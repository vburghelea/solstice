## Issues found

### 1) Category: Config

**Location:** `src/lib/env.client.ts:19-23` and `src/tenant/tenant-env.ts:1-6`
**Issue:** `env.client.ts` references `import.meta.env` at module evaluation time (`runtimeEnv: import.meta.env`, `skipValidation: !!import.meta.env[...]`). But `src/tenant/tenant-env.ts` imports `env.client` at top-level (`import { env as clientEnv } from "~/lib/env.client";`). In non-Vite runtimes (SST cron jobs, Lambda workers, Node scripts), `import.meta.env` can be `undefined`, causing a hard crash just by importing tenant resolution code.
**Impact:** Server-side processes (cron/queue workers) can fail to start. Tenant resolution and feature gating become unavailable, which can cascade into “everything breaks” behavior (routes not loading, server functions throwing on import).
**Fix:** Make client env access browser/Vite-only.

- Option A (clean): split into `tenant-env.client.ts` and `tenant-env.server.ts` so server never imports `env.client.ts`.
- Option B (minimal): in `env.client.ts`, defensively define `runtimeEnv`:

  ```ts
  const runtimeEnv =
    typeof import.meta !== "undefined" && "env" in import.meta
      ? (import.meta as any).env
      : {};
  ```

  Then use `runtimeEnv` for both `runtimeEnv:` and `skipValidation:`; and in `tenant-env.ts` move the `env.client` import inside `getClientTenantKey()` via dynamic import.

---

### 2) Category: Security

**Location:** `src/routes/__root.tsx:56-66`
**Issue:** Root route reads `active_org_id` from the cookie header and blindly injects it into router context without validating it against the authenticated user’s accessible organizations.
**Impact:** A user can set/modify `active_org_id` (or reuse a stale value) and the app will treat it as “selected”. Even if server functions are correctly enforcing org access, this still:

- creates a bypass of the “select org” UX guard,
- risks cross-org data exposure if any server endpoint is missing an org-access check,
- causes confusing failures (pages load but show errors/empty data).
  **Fix:** Validate server-side before placing `activeOrganizationId` into context:
- Add a server guard (ideal: a shared `resolveOrgContext()` / `requireOrgContext()` helper) that:
  1. reads cookie,
  2. checks membership/access,
  3. returns `{ activeOrganizationId, organizationRole }` or null.

- If invalid, return `null` and (if possible) clear the cookie via the mutation/response middleware.

---

### 3) Category: Routing

**Location:** `src/routes/dashboard/sin.tsx:5-13`
**Issue:** `/dashboard/sin` route guard only checks that `context.activeOrganizationId` is _present_, not that it’s _valid for the current user_.
**Impact:** Cross-org selection bypass (and potential cross-org access if any server function misses org checks). Also makes it easy to get stuck in broken states where the org id exists but the user no longer has access.
**Fix:** In `beforeLoad`, validate the org id and role:

- Call a server function that confirms access to `context.activeOrganizationId` (or returns the “best” org if the cookie is invalid).
- If invalid/unset, redirect to `/dashboard/select-org` and include a safe redirect target.

---

### 4) Category: Security

**Location:** `src/components/ui/app-sidebar.tsx:41-60` and `src/features/organizations/org-context.tsx:27-37`
**Issue:** Logout does not clear the persisted org context (`localStorage.active_org_id`), and the OrgContextProvider persists org selection in localStorage.
**Impact:** On shared devices (or test accounts), user B can inherit user A’s last-selected org context. Even if server access checks prevent data leakage, it’s still a privacy leak (org names/selection state) and can lead to confusing redirects/UI state.
**Fix:** On logout:

- Clear localStorage key:

  ```ts
  window.localStorage.removeItem("active_org_id");
  ```

- Also clear server-side cookie (best: call `setActiveOrganization({ organizationId: null })` before `auth.signOut()` or clear it in the signout response hook).
- Consider removing org-related react-query caches on logout (see next issue).

---

### 5) Category: Security

**Location:** `src/features/organizations/org-context.tsx:40-44`
**Issue:** `listAccessibleOrganizations` query cache key is not scoped to the user (`queryKey: ["organizations", "accessible"]`), and query is enabled purely by `sin_portal` feature flag—not by authentication presence.
**Impact:** React Query can reuse cached accessible-org lists between different authenticated users in the same browser session (org names/ids leakage), and unauthenticated pages could still try to fetch accessible orgs (401 noise, error toasts, wasted requests).
**Fix:**

- Include user id in the query key and gate by user:

  ```ts
  const { user } = useRouteContext({ strict: false }) as { user?: { id?: string } } | undefined;

  useQuery({
    queryKey: ["organizations", "accessible", user?.id],
    enabled: isSinPortalEnabled && Boolean(user?.id),
    ...
  })
  ```

- On logout, remove org queries:

  ```ts
  queryClient.removeQueries({ queryKey: ["organizations"] });
  ```

  (or clear the full cache on signout if that’s acceptable).

---

### 6) Category: Routing

**Location:** `src/features/organizations/org-context.tsx:22-26`
**Issue:** OrgContextProvider initializes state from route context once (`useState(initialOrgId)`) but never syncs when `context.activeOrganizationId` changes.
**Impact:** Router context and OrgContextProvider state can diverge:

- after login/logout,
- after cookie changes,
- after router invalidations.
  This can cause nav gating and “selected org” UI to show one org while route guards use another, leading to inconsistent behavior.
  **Fix:** Sync state when route-context org id changes:

```ts
useEffect(() => {
  setActiveOrganizationId(initialOrgId);
}, [initialOrgId]);
```

(If you want to avoid clobbering a “pending” selection, track whether the user has made a local change and only sync when appropriate.)

---

### 7) Category: UX

**Location:** `src/features/organizations/components/org-switcher.tsx:37-40` and `src/routes/dashboard/select-org.tsx:23-28`
**Issue:** Potential race between setting org context and navigating. `OrgSwitcher` calls `setActiveOrganizationId(newOrgId)` then immediately `onSuccess(newOrgId)`, which in `select-org.tsx` immediately navigates. Root route reads org id from `localStorage`, but the localStorage write happens in a `useEffect` in `OrgContextProvider`, which may not have run yet.
**Impact:** Intermittent redirect loops: user selects an org, gets navigated to `/dashboard/sin`, but guard still sees no active org and sends them back to `/dashboard/select-org`.
**Fix:** Write localStorage synchronously before navigating (or invalidate router context):

- In `OrgSwitcher` onSuccess:

  ```ts
  if (typeof window !== "undefined") {
    if (newOrgId) localStorage.setItem("active_org_id", newOrgId);
    else localStorage.removeItem("active_org_id");
  }
  setActiveOrganizationId(newOrgId);
  onSuccess?.(newOrgId);
  ```

- Or in `SelectOrgPage.handleOrgSelected`, do the localStorage set before `navigate()`.
- Alternatively, call `router.invalidate()` after setting org so root beforeLoad recomputes with the updated value.

---

### 8) Category: Security

**Location:** `src/routes/dashboard/select-org.tsx:6-9` and `src/routes/dashboard/select-org.tsx:23-28`
**Issue:** `redirect` search param is accepted as any string and used as a navigation target (`navigate({ to: destination })`) without validation/sanitization.
**Impact:** Open-redirect style behavior inside the app routing layer (and at minimum broken navigation). An attacker can send a link to `/dashboard/select-org?redirect=...` that navigates somewhere unexpected after org selection.
**Fix:** Restrict `redirect` to safe internal paths:

- Validate with zod refine:

  ```ts
  const searchSchema = z.object({
    redirect: z
      .string()
      .optional()
      .refine((v) => !v || v.startsWith("/dashboard"), "Invalid redirect"),
  });
  ```

- Prefer passing a structured `{ to, search }` instead of a raw string, or at least normalize to pathname+search (no protocol, no `//`).

---

### 9) Category: UX

**Location:** `src/routes/dashboard/sin/index.tsx:23-53` and `src/routes/dashboard/admin/sin/index.tsx:14-87`
**Issue:** The SIN Portal home and SIN Admin overview pages render cards/links unconditionally. They don’t filter by per-module feature flags (or org role for analytics).
**Impact:** If you ever disable `sin_forms`, `sin_imports`, etc. for a tenant or environment, users will see “dead” cards that lead to `/dashboard/forbidden`. Same for admin modules.
**Fix:** Build these card lists from the same nav/feature-gate system you already have:

- Create arrays like:

  ```ts
  const cards = [
    { feature: "sin_reporting", to: "/dashboard/sin/reporting", ... },
    ...
  ].filter(card => isFeatureEnabled(card.feature))
  ```

- For analytics, also filter by org role (same rules as sidebar).

---

If you want, I can also give you a “tightened” reference flow (cookie → server validation → route context → OrgContextProvider) that eliminates localStorage as a source of truth and makes org selection fully deterministic.
