## Key Questions — What the current code actually does

### 1) Is MFA properly enforced for admin roles?

**Partially, but not end-to-end.** There _is_ a server-side check (`requireAdmin`) that blocks admins when `user.mfaRequired === true` and `user.twoFactorEnabled === false`. However, in the provided subset I do **not** see the piece that reliably sets `mfaRequired=true` for global admin users (and your SIN seed scripts don’t set it either). Also, the **route-level admin guard** (`requireGlobalAdmin`) checks role membership but **does not** check MFA.

Net: MFA enforcement depends on a flag that is not obviously being set, and route access doesn’t enforce it.

### 2) Is step-up authentication working for sensitive actions?

**The building blocks exist, but the server check is unreliable and I can’t see it being applied to sensitive endpoints in this subset.**

- Server guard exists: `requireRecentAuth()` in `src/lib/auth/guards/step-up.ts`.
- Client prompt exists: `StepUpProvider` + dialog in `src/features/auth/step-up.tsx`.
- But `requireRecentAuth()` **can fail open** (or fail in odd ways) depending on the session object shape and missing timestamps.

### 3) Are auth guards properly protecting routes?

- You have standard route guards (`requireAuth`, `requireAuthAndProfile`, `requireRole`, `requireGlobalAdmin`).
- You also have server function middleware (`authMiddleware`) enforcing session and lockouts.
- Main concerns are: **admin+MFA enforcement is not consistent across route/server**, and **org context trust assumptions** could be tightened.

### 4) Do E2E tests cover critical SIN flows?

**No — the current E2E set is tenant gating + “admin vs non-admin” only.** No MFA, step-up, exports, DSAR, role changes, org switching, etc.

### 5) Are seed scripts creating proper test data?

They create a good org hierarchy, roles, users, and sample submissions — but:

- They’re **dangerously destructive** if pointed at the wrong DB.
- They have an **exit-code bug** that can hide failures.
- They don’t seed **admin MFA required/enrolled states**, which undercuts your S-001 requirements and any MFA-related E2E coverage.

---

## Issues Found

### 1) Step-up auth can fail open if timestamps can’t be extracted

**Category:** Auth
**Severity:** High
**Location:** `src/lib/auth/guards/step-up.ts:~8-110`
**Issue:** `requireRecentAuth()` only enforces the re-auth window if it can extract a usable `authenticatedAt`. If timestamp extraction fails (`authenticatedAt === null`) and the user is **not** MFA-enabled, the function does **not** require re-auth.
**Security Impact:** Sensitive operations protected by `requireRecentAuth()` can be executed without step-up if the session object doesn’t expose timestamps in the expected shape (or if caller passes the wrong object). This is a direct step-up bypass risk.
**Fix:** Fail closed when auth time is unknown. For example:

- If `authenticatedAt` is missing/unparseable, **throw** `forbidden("Re-authentication required for this action")`.
- Also update extraction to handle Better Auth’s likely nested shape (e.g. `session.session.createdAt`) and/or pass only `session.session` into `requireRecentAuth()`.

---

### 2) Step-up timestamp extraction likely doesn’t match the actual session object shape

**Category:** Auth
**Severity:** High
**Location:** `src/lib/auth/guards/step-up.ts:~12-70`
**Issue:** `extractSessionTimes(session)` checks keys like `"createdAt"` and `"iat"` at the _top level_ of the passed object. But in your codebase you commonly treat Better Auth’s return as `{ user, session }`. If callers pass the whole object, timestamps are probably under `session.session.createdAt`, not `session.createdAt`.
**Security Impact:**

- For non-MFA users: step-up can silently fail open (see Issue #1).
- For MFA users: step-up could become unusable (always requiring re-auth) or inconsistent, depending on what fields happen to exist.
  **Fix:** Make `extractSessionTimes` understand nested shapes:
- Check `session.session?.createdAt` / `session.session?.iat` and `session.session?.lastMfaVerifiedAt`, etc.
- Or change the API: accept `{ session: SessionRow }` and pass exactly that.

---

### 3) MFA re-verification logic is too permissive when MFA timestamp is missing

**Category:** MFA
**Severity:** Medium
**Location:** `src/lib/auth/guards/step-up.ts:~80-110`
**Issue:** For `record.twoFactorEnabled === true`, you only enforce MFA freshness if `lastMfaVerifiedAt` exists. If it’s missing but `authenticatedAt` exists, the check passes.
**Security Impact:** If MFA verification time isn’t present (common if the session object doesn’t store it), sensitive operations may not require MFA re-verification even though MFA is enabled and policy says step-up must include MFA.
**Fix:** For MFA-enabled users, require **explicit** evidence of recent MFA verification. If missing, require re-auth / re-verify:

- `if (record.twoFactorEnabled && !lastMfaVerifiedAt) throw forbidden("MFA re-verification required for this action");`

---

### 4) Admin session max-age (4h) and true idle timeout (30m) aren’t implemented

**Category:** Auth
**Severity:** Medium
**Location:** `src/lib/auth/server-helpers.ts:~60-95`
**Issue:** You set `expiresIn: 8 hours` globally. There is no admin-specific 4-hour max age. Also `updateAge: 30 minutes` is not necessarily an idle timeout; it’s typically a session refresh/write frequency, not a “log out after inactivity” guarantee.
**Security Impact:** Admin sessions may live longer than required; idle sessions may remain valid longer than policy intends. This is a real risk if devices are left unattended.
**Fix:**

- Implement **admin TTL**: on each request (middleware), if user is global admin and session age > 4h, force re-login.
- Implement **idle timeout**: store `lastActivityAt` (session metadata or separate table) and invalidate when idle > 30m. Enforce server-side.

---

### 5) Admin MFA enforcement is not consistently applied (route vs server vs seeds)

**Category:** MFA
**Severity:** High
**Location:**

- `src/lib/auth/utils/admin-check.ts:~25-60`
- `src/lib/auth/middleware/role-guard.ts:~45-60`
- `scripts/seed-sin-data.ts:~120-220`
- `scripts/seed-global-admins.ts:~150-260`
  **Issue:**
- `requireAdmin()` blocks admins only when `mfaRequired` is set, but I don’t see code here that reliably sets `mfaRequired=true` when global admin roles are assigned.
- `requireGlobalAdmin()` checks role membership only; it doesn’t enforce MFA.
- Seeds create admin users/roles but don’t set MFA-required/enrolled state.
  **Security Impact:** Admin users may be able to access admin routes and perform admin actions without MFA if `mfaRequired` isn’t consistently set/enforced. This violates S-001 and `security-controls.md` expectations.
  **Fix:**
- On global admin role assignment (server-side), **set `user.mfaRequired=true`** and audit it.
- Add an explicit guard for admin routes/actions: require both **admin role + MFA enabled**.
- Update seed scripts to create at least one “admin with MFA enabled” and one “admin with MFA required but not enrolled” to test enforcement.

---

### 6) `markMfaEnrolled` can be called without verifying MFA state

**Category:** MFA
**Severity:** Medium
**Location:** `src/features/auth/mfa/mfa.mutations.ts:~1-45`
**Issue:** `markMfaEnrolled()` sets `mfaEnrolledAt` and logs `AUTH.MFA_ENROLL` based only on “has session”. It does **not** confirm that Better Auth 2FA has actually been enabled/verified. A client could call this endpoint directly.
**Security Impact:** Users can falsify MFA enrollment timestamps and audit entries, potentially bypassing any UI logic that treats `mfaEnrolledAt` as truth. Audit log integrity is weakened.
**Fix:** Before setting `mfaEnrolledAt` / logging:

- Verify `twoFactorEnabled === true` from DB **or**
- Check Better Auth 2FA state (e.g., query twoFactor table / auth API if available) and only then mark enrolled.

---

### 7) Step-up UI supports TOTP only, no backup code path

**Category:** MFA
**Severity:** Medium
**Location:** `src/features/auth/step-up.tsx:~150-260`
**Issue:** In the step-up modal, MFA step only calls `auth.twoFactor.verifyTotp`. There’s no backup code option, even though backup codes exist in login and enrollment flows.
**Security Impact:** Users who rely on backup codes (lost device) can’t complete step-up for sensitive actions, which can block DSAR/export/admin operations. Operational risk and potential support escalation.
**Fix:** Add an MFA method toggle (TOTP vs backup) similar to the login 2FA screen.

---

### 8) `authMiddleware` trusts org role from context without re-validating

**Category:** Auth
**Severity:** Medium
**Location:** `src/lib/auth/middleware/auth-guard.ts:~55-95`
**Issue:** If `contextOrgId === requestedOrgId` and `contextOrgRole` exists, you accept it without re-resolving `resolveOrganizationAccess`. This is likely intended as an optimization, but it creates a trust boundary that can be hard to reason about (especially if any middleware can populate those context fields).
**Security Impact:** If a client-controllable path ever injects `organizationRole` into context, org access could be spoofed. Even if that’s not currently possible, this is fragile.
**Fix:** Always resolve org access on the server using `user.id + requestedOrgId`, or at minimum validate that the context fields came from `orgContextMiddleware` (and never from client input).

---

### 9) Inconsistent session freshness behavior across code paths

**Category:** Auth
**Severity:** Low
**Location:**

- `src/lib/auth/guards/org-context.ts:~1-30`
- `src/features/auth/auth.queries.ts:~10-40`
  **Issue:** Some `auth.api.getSession` calls do not pass `disableCookieCache: true` while `authMiddleware` explicitly does.
  **Security Impact:** Potential inconsistent session reads (especially given your comment about cookie cache issues). Can cause confusing “logged in vs not” states and inconsistent org resolution.
  **Fix:** Standardize session retrieval:
- Add a helper like `getFreshSession({ headers })` that always disables cookie cache until the upstream issue is resolved, and use it everywhere.

---

### 10) Seed script is destructive with no “safe to run” guard

**Category:** Seeds
**Severity:** High
**Location:** `scripts/seed-sin-data.ts:~70-120`
**Issue:** The script deletes from many tables without scoping to “test data only” and without an explicit environment safety check. It will happily run against whatever `DATABASE_URL` points to.
**Security Impact:** Accidental execution against a non-test database could wipe production/real data. That’s a catastrophic operational/security incident.
**Fix:** Add hard safety rails:

- Require `E2E_DATABASE_URL` (don’t fall back to `DATABASE_URL`) **or** require a `--force` flag.
- Refuse to run when `NODE_ENV === "production"`.
- Optionally verify DB name/host contains `e2e`/`test`.

---

### 11) Seed script always exits with success (even on failure)

**Category:** Seeds
**Severity:** Medium
**Location:** `scripts/seed-sin-data.ts:~500-540`
**Issue:** `process.exit(0)` is called in the `finally` block of `seed()`, so the process exits 0 even when an error is thrown. The `.catch()` below becomes effectively useless.
**Security Impact:** CI and developers may believe seeding succeeded when it partially failed, leading to misleading test results and broken environments.
**Fix:** Remove `process.exit(0)` from `finally`. Instead:

- Return cleanly on success.
- In the outer `.catch`, set `process.exit(1)` (or `process.exitCode = 1`).

---

### 12) Seeded sessions violate stated session policy and may conflict with Better Auth expectations

**Category:** Seeds
**Severity:** Medium
**Location:** `scripts/seed-sin-data.ts:~170-220`
**Issue:** You insert session rows with `expiresAt` set to 30 days and a predictable plaintext token. This diverges from the documented policy (8h max, admins 4h), and may not match Better Auth’s token hashing/format expectations.
**Security Impact:**

- Tests can pass without exercising real session expiration rules.
- Predictable session tokens are dangerous if used outside a strictly isolated test DB.
  **Fix:** Prefer not seeding sessions at all. Let Playwright log in through the auth flow. If you must seed:
- Align expiry with policy.
- Ensure token format/hashing matches Better Auth’s schema expectations.

---

### 13) Step-up prompting relies on string matching error messages

**Category:** Auth
**Severity:** Low
**Location:** `src/features/auth/step-up.tsx:~20-45`
**Issue:** `getStepUpErrorMessage()` detects step-up requirements by substring matching specific phrases.
**Security Impact:** Mostly reliability/UX: message changes can silently break the prompt and lead to confusing failures.
**Fix:** Use structured errors:

- Throw an error with a stable code (e.g., `APIError("REAUTH_REQUIRED")`) and check `error.code`.
- Or return a typed payload `{ code: "REAUTH_REQUIRED" }` from server functions.

---

### 14) `requireAdmin` throws generic `Error` instead of typed server errors

**Category:** Auth
**Severity:** Low
**Location:** `src/lib/auth/utils/admin-check.ts:~25-65`
**Issue:** `requireAdmin()` throws plain `Error("Unauthorized...")` and `Error("Multi-factor authentication required")` rather than using your `unauthorized()` / `forbidden()` helpers.
**Security Impact:** Incorrect HTTP status codes and inconsistent error handling can leak implementation details and break client step-up handling patterns.
**Fix:** Throw standardized errors with correct status:

- `throw unauthorized("Admin access required")`
- `throw forbidden("Multi-factor authentication required")`

---

## Test Coverage Gaps

These are the critical SIN security flows that are not covered by the current E2E tests (`sin-admin-access` / `sin-portal-access`):

1. **Admin MFA required**
   - Admin user with global admin role + `mfaRequired=true` + `twoFactorEnabled=false` should be blocked from admin actions/routes.
   - Admin user with MFA enabled should proceed.

2. **MFA enrollment flow**
   - Enable 2FA → QR display → verify TOTP → backup codes regeneration.
   - Negative paths: wrong password, invalid TOTP, backup code reuse.

3. **Login with MFA challenge**
   - Email/password login triggers 2FA challenge (`twoFactorRedirect`).
   - Verify TOTP success/failure + backup code success/failure.

4. **Step-up for sensitive actions**
   - For each: **export**, **role change**, **DSAR** (per `security-controls.md`), assert:
     - Action fails without step-up.
     - Step-up modal appears, re-auth works, action succeeds.
     - MFA-enabled account requires MFA re-verification (and backup code path if you support it).

5. **Org scoping + tenant gating defense in depth**
   - Ensure API endpoints for SIN features can’t be called by QC tenant even if URL guessed (not just UI redirect).

6. **Account lockout**
   - Repeated login failures lock account; locked account cannot access server functions even if session exists.

7. **Seed consistency tests**
   - A smoke test that seeded roles/users exist and have expected permissions, org memberships, and (critically) MFA-required states for admins.

---

## Auth Hardening Recommendations

1. **Make admin MFA enforcement deterministic**
   - On global admin role assignment: set `user.mfaRequired=true` in the same transaction, and audit it.
   - Add a reconciliation job/migration: “any user with global admin role must have mfaRequired=true”.

2. **Fix step-up to fail closed and be schema-correct**
   - Require timestamps; if missing → require re-auth.
   - Normalize the session object you pass into `requireRecentAuth` (or make it handle nested shapes).
   - Store explicit `lastStepUpAt` / `lastMfaVerifiedAt` in a reliable place (session metadata or DB) instead of guessing from “createdAt”.

3. **Implement the session policy from `security-controls.md`**
   - Enforce **admin max age 4h** server-side.
   - Implement a real **idle timeout 30m** server-side (not just updateAge).

4. **Don’t rely on client-side security events**
   - `recordSecurityEvent()` calls in the login UI are helpful but bypassable. Ensure the server auth handler also records:
     - login_success/login_fail
     - mfa_success/mfa_fail
     - lockout events

5. **Harden seed scripts**
   - Require explicit “test DB only” checks and remove unconditional `process.exit(0)` in `finally`.
   - Prefer seeding **users/orgs/data only**, not sessions.

6. **Use structured error codes for security UX**
   - Replace step-up “string match” with stable error codes to avoid silent breakage.

If you want, I can also propose a concrete patch plan for `requireRecentAuth()` (fail-closed + nested-session support + MFA timestamp rules) and a minimal Playwright MFA harness strategy (e.g., using a known TOTP secret for seeded users so tests can generate valid codes deterministically).
