This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: e2e/utils/auth.ts, e2e/auth.setup.ts, e2e/tests/unauthenticated/auth-flow.unauth.spec.ts, e2e/tests/authenticated/profile-edit.auth.spec.ts, e2e/tests/authenticated/membership.auth.spec.ts, e2e/tests/authenticated/teams-create-no-conflict.auth.spec.ts, src/features/auth/components/login.tsx, src/features/auth/components/signup.tsx, playwright.config.ts
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
e2e/
  tests/
    authenticated/
      membership.auth.spec.ts
      profile-edit.auth.spec.ts
      teams-create-no-conflict.auth.spec.ts
    unauthenticated/
      auth-flow.unauth.spec.ts
  utils/
    auth.ts
  auth.setup.ts
src/
  features/
    auth/
      components/
        login.tsx
        signup.tsx
playwright.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="e2e/tests/authenticated/teams-create-no-conflict.auth.spec.ts">
import { expect, test } from "@playwright/test";
import { clearAuthState, gotoWithAuth } from "../../utils/auth";

test.describe("Team Creation Without Conflict", () => {
  test.beforeEach(async ({ page }) => {
    await clearAuthState(page);
    
    // Login with team-join user who is not on any team (can be used for creation)
    await gotoWithAuth(page, "/dashboard/teams/create", {
      email: "team-join@example.com",
      password: "testpassword123",
    });
  });

  test("should successfully create a team without database conflicts", async ({ page }) => {
    // Fill in the form
    await page.getByLabel("Team Name").fill("E2E No Conflict Team");
    await page.getByLabel("URL Slug").fill("e2e-no-conflict-team");
    await page
      .getByLabel("Description")
      .fill("This is a test team created by a user with no existing team membership");
    await page.getByLabel("City").fill("Berlin");

    // Select country from combobox
    await page.getByLabel("Country").click();
    await page.getByRole("option", { name: "Germany" }).click();

    await page.getByLabel("Founded Year").fill("2024");
    await page.getByLabel("Website").fill("https://no-conflict.example.com");
    
    // Set colors - color inputs need special handling
    await page.evaluate(() => {
      const primaryColor = document.querySelector('input[name="primaryColor"]') as HTMLInputElement;
      const secondaryColor = document.querySelector('input[name="secondaryColor"]') as HTMLInputElement;
      if (primaryColor) primaryColor.value = "#FF5733";
      if (secondaryColor) secondaryColor.value = "#33FF57";
    });

    // Submit the form
    await page.getByRole("button", { name: "Create Team" }).click();

    // Should redirect to team detail page without database errors
    await expect(page).toHaveURL(/\/dashboard\/teams\/[a-z0-9]+/, { timeout: 10000 });

    // Verify the team was created (would see team details)
    await expect(page.getByText("E2E No Conflict Team")).toBeVisible();
    
    // Verify no database error message
    await expect(page.getByText("Failed query")).not.toBeVisible();
  });
});
</file>

<file path="e2e/tests/authenticated/profile-edit.auth.spec.ts">
import { expect, test } from "@playwright/test";
import { clearAuthState, gotoWithAuth } from "../../utils/auth";

test.describe("Profile Edit", () => {
  test.beforeEach(async ({ page }) => {
    await clearAuthState(page);
    await gotoWithAuth(page, "/dashboard/profile", {
      email: "profile-edit@example.com",
      password: "testpassword123",
    });
  });

  test("should display current profile information", async ({ page }) => {
    // Already on profile page from beforeEach
    
    // Check page title
    await expect(page.getByRole("heading", { name: "My Profile" })).toBeVisible({ timeout: 10000 });

    // Check basic information card
    await expect(page.getByText("Basic Information")).toBeVisible();
    await expect(page.getByText("Email", { exact: true })).toBeVisible();
    await expect(page.getByText("profile-edit@example.com")).toBeVisible();
  });

  test("should toggle edit mode", async ({ page }) => {
    // Click edit button
    await page.getByRole("button", { name: /Edit Profile/i }).click();

    // Check that save and cancel buttons appear
    await expect(page.getByRole("button", { name: /Save Changes/i })).toBeVisible();
    await expect(page.getByRole("button", { name: /Cancel/i })).toBeVisible();

    // Check that input fields are visible - use more specific selectors
    await expect(page.getByRole("textbox", { name: "Phone Number" })).toBeVisible();
    await expect(page.getByLabel("Gender")).toBeVisible();
    await expect(page.getByLabel("Pronouns")).toBeVisible();
  });

  test("should cancel editing", async ({ page }) => {
    // Enter edit mode
    await page.getByRole("button", { name: /Edit Profile/i }).click();
    
    // Wait for edit mode to be fully activated
    await expect(page.getByRole("button", { name: /Save Changes/i })).toBeVisible();

    // Make some changes
    await page.getByRole("textbox", { name: "Phone Number" }).fill("+1 (555) 123-4567");

    // Cancel editing
    await page.getByRole("button", { name: /Cancel/i }).click();

    // Wait for the form to reset and edit mode to exit
    // The Cancel button should disappear first
    await expect(page.getByRole("button", { name: /Cancel/i })).not.toBeVisible({ timeout: 10000 });
    
    // Then the edit button should be visible again
    await expect(page.getByRole("button", { name: /Edit Profile/i })).toBeVisible({ timeout: 10000 });
    
    // Check that changes were not saved - the new phone number should not be visible
    await expect(page.getByText("+1 (555) 123-4567")).not.toBeVisible();
  });

  test("should save profile changes", async ({ page }) => {
    // Enter edit mode
    await page.getByRole("button", { name: /Edit Profile/i }).click();
    
    // Wait for edit mode to be fully activated
    await expect(page.getByRole("button", { name: /Save Changes/i })).toBeVisible();

    // Fill in some fields
    await page.getByRole("textbox", { name: "Phone Number" }).fill("+1 (555) 987-6543");
    await page.getByLabel("Pronouns").fill("they/them");

    // Select gender
    await page.getByLabel("Gender").click();
    await page.getByRole("option", { name: "Non-binary" }).click();

    // Save changes
    await page.getByRole("button", { name: /Save Changes/i }).click();

    // Wait for success toast
    await expect(page.getByText("Profile updated successfully")).toBeVisible({ timeout: 10000 });

    // Wait for edit mode to exit - Save Changes button should disappear
    await expect(page.getByRole("button", { name: /Save Changes/i })).not.toBeVisible({ timeout: 10000 });
    
    // Check that edit button is back (this waits for the UI to update)
    await expect(page.getByRole("button", { name: /Edit Profile/i })).toBeVisible({ timeout: 10000 });
    
    // Check that changes are displayed
    await expect(page.getByText("+1 (555) 987-6543")).toBeVisible();
    await expect(page.getByText("they/them")).toBeVisible();
    await expect(page.getByText("non-binary")).toBeVisible();
  });

  test("should update privacy settings", async ({ page }) => {
    // Enter edit mode
    await page.getByRole("button", { name: /Edit Profile/i }).click();
    
    // Wait for edit mode to be fully activated
    await expect(page.getByRole("button", { name: /Save Changes/i })).toBeVisible();

    // Update privacy settings
    await page.getByLabel("Show my email address to team members").check();
    await page.getByLabel("Show my phone number to team members").check();

    // Save changes
    await page.getByRole("button", { name: /Save Changes/i }).click();

    // Wait for success toast
    await expect(page.getByText("Profile updated successfully")).toBeVisible({ timeout: 10000 });

    // Wait for edit mode to exit - Save Changes button should disappear
    await expect(page.getByRole("button", { name: /Save Changes/i })).not.toBeVisible({ timeout: 10000 });
    
    // Check that edit mode is exited
    await expect(page.getByRole("button", { name: /Edit Profile/i })).toBeVisible({ timeout: 10000 });
    
    // Check that privacy settings are displayed correctly
    await expect(page.getByText("Email visibility:")).toBeVisible();
    await expect(page.getByText("Visible to team members")).toBeVisible();
    await expect(page.getByText("Phone visibility:")).toBeVisible();
  });
});
</file>

<file path="e2e/utils/auth.ts">
import { expect, Page } from "@playwright/test";

/** Clears every trace of a previous session (cookies *and* storage). */
export async function clearAuthState(page: Page) {
  await page.context().clearCookies();
  await page.addInitScript(() => {
    localStorage.clear();
    sessionStorage.clear();
  });
}

/** UI login that waits for the form to be *ready* before clicking. */
export async function uiLogin(
  page: Page,
  email: string,
  password: string,
  redirect = "/dashboard",
) {
  await page.goto(`/auth/login?redirect=${redirect}`);
  
  // Wait for page to be fully loaded
  await page.waitForLoadState("domcontentloaded");
  
  // Wait for email field to be visible and enabled
  const emailField = page.getByLabel("Email");
  await expect(emailField).toBeVisible({ timeout: 10_000 });
  await expect(emailField).toBeEnabled({ timeout: 10_000 });
  
  // Click and fill email field
  await emailField.click();
  await emailField.fill(email);
  
  // Wait for password field to be enabled
  const passwordField = page.getByLabel("Password");
  await expect(passwordField).toBeEnabled({ timeout: 10_000 });
  
  // Click and fill password field
  await passwordField.click();
  await passwordField.fill(password);
  
  // Ensure button is enabled before clicking
  const btn = page.getByRole("button", { name: "Login", exact: true });
  await expect(btn).toBeEnabled({ timeout: 10_000 });
  await btn.click();
  
  // Wait for navigation with increased timeout
  await page.waitForURL(redirect, { timeout: 30_000 });
}

export async function login(page: Page, email: string, password: string) {
  await page.goto("/auth/login");
  await page.getByLabel("Email").fill(email);
  await page.getByLabel("Password").fill(password);
  const loginBtn = page.getByRole("button", { name: "Login", exact: true });
  await expect(loginBtn).toBeEnabled({ timeout: 5_000 });
  await loginBtn.click();

  // Wait for navigation to complete
  await page.waitForURL("/dashboard");
}

export async function signup(page: Page, name: string, email: string, password: string) {
  await page.goto("/auth/signup");
  await page.getByLabel("Name").fill(name);
  await page.getByLabel("Email").fill(email);
  await page.getByLabel("Password", { exact: true }).fill(password);
  await page.getByLabel("Confirm Password").fill(password);
  const signupBtn = page.getByRole("button", { name: "Sign up", exact: true });
  await expect(signupBtn).toBeEnabled({ timeout: 5_000 });
  await signupBtn.click();

  // Wait for navigation to complete
  await page.waitForURL("/onboarding");
}

export async function logout(page: Page) {
  // Use the sidebar logout button which is always visible
  const logoutButton = page.getByRole("button", { name: "Logout" });
  await logoutButton.waitFor({ state: "visible", timeout: 10_000 });
  await logoutButton.click();

  // Wait for redirection to the login page
  await page.waitForURL(/\/auth\/login/, { timeout: 15_000 });
}

/** 
 * Convenience helper: navigate to a path with authentication.
 * If redirected to login, automatically logs in and continues to the target path.
 */
export async function gotoWithAuth(
  page: Page,
  path: string,
  {
    email = process.env["E2E_TEST_EMAIL"]!,
    password = process.env["E2E_TEST_PASSWORD"]!,
    expectRedirect = true,
  } = {},
) {
  // First try to navigate directly
  await page.goto(path, { waitUntil: "domcontentloaded" });
  
  // If we ended up on login page, authenticate
  if (expectRedirect && page.url().includes("/auth/login")) {
    await uiLogin(page, email, password, path);
    // After login, we should be on the target path
    await expect(page).toHaveURL(path, { timeout: 30_000 });
  } else {
    // If no login was needed, wait for the page to be ready
    await page.waitForTimeout(1000); // Small delay to ensure page is ready
  }
}
</file>

<file path="e2e/tests/authenticated/membership.auth.spec.ts">
import { expect, test } from "@playwright/test";
import { clearAuthState, gotoWithAuth } from "../../utils/auth";
import { ANNUAL_MEMBERSHIP_NAME, ANNUAL_MEMBERSHIP_PRICE } from "../../helpers/constants";

test.describe("Membership Purchase Flow (Authenticated)", () => {
  test.beforeEach(async ({ page }) => {
    await clearAuthState(page);
    await gotoWithAuth(page, "/dashboard/membership", {
      email: "membership-purchase@example.com",
      password: "testpassword123",
    });
  });
  
  test("should display membership page with available memberships", async ({ page }) => {
    // Already on membership page from beforeEach

    // Check page title and description with extended timeout
    await expect(
      page.getByRole("heading", { name: "Membership", exact: true }),
    ).toBeVisible({ timeout: 10000 });
    await expect(
      page.getByText("Join Roundup Games and access exclusive member benefits"),
    ).toBeVisible();

    // Check current status section
    await expect(page.getByText("Current Status", { exact: true })).toBeVisible({ timeout: 10000 });

    // User may or may not have a membership - check both cases
    const hasActiveMembership = await page
      .getByText("Active Membership")
      .isVisible()
      .catch(() => false);

    if (!hasActiveMembership) {
      await expect(page.getByText("No Active Membership")).toBeVisible();
      await expect(
        page.getByText("Join today to participate in events and access member benefits"),
      ).toBeVisible();
    } else {
      await expect(page.getByText("Active Membership")).toBeVisible();
      await expect(page.getByText(/Expires:/)).toBeVisible();
    }

    // Check available memberships section
    await expect(
      page.getByRole("heading", { name: "Available Memberships" }),
    ).toBeVisible();

    // Check for the Annual Player Membership card with dynamic values
    // Use first() to avoid strict mode violations when text appears multiple times
    await expect(page.getByText(ANNUAL_MEMBERSHIP_NAME).first()).toBeVisible();
    await expect(page.getByText(ANNUAL_MEMBERSHIP_PRICE)).toBeVisible();
    await expect(
      page.getByText(
        "Full access to all Roundup Games events and programs for the 2025 season",
      ),
    ).toBeVisible();
    // Button text depends on membership status
    const button = page.getByRole("button", { name: /Purchase|Renew|Current Plan/ });
    await expect(button).toBeVisible();
    const buttonText = await button.textContent();
    expect(["Purchase", "Renew", "Current Plan"]).toContain(buttonText);
  });

  test("should show loading state when fetching membership data", async ({ page }) => {
    test.skip(process.env["CI"] === "true", "Spinner timings are flaky on CI");
    
    // Slow down the network to see loading states
    await page.route("**/api/**", async (route) => {
      await new Promise((resolve) => setTimeout(resolve, 100));
      await route.continue();
    });

    await page.goto("/dashboard/membership");

    // Should show loading spinner initially
    await expect(page.locator(".animate-spin")).toBeVisible();

    // Wait for content to load
    await expect(
      page.getByRole("heading", { name: "Available Memberships" }),
    ).toBeVisible({
      timeout: 10000,
    });
  });

  test("should handle membership button click", async ({ page }) => {
    // Already on membership page from beforeEach

    // Wait for memberships to load
    await expect(
      page.getByRole("heading", { name: "Available Memberships" }),
    ).toBeVisible();

    // Find the membership purchase/renew button specifically
    // Use exact button names to avoid matching other buttons like "Logout"
    const purchaseButton = page.getByRole("button", { name: "Purchase" });
    const renewButton = page.getByRole("button", { name: "Renew" });
    const currentPlanButton = page.getByRole("button", { name: "Current Plan" });
    
    // One of these buttons should be visible
    const button = purchaseButton.or(renewButton).or(currentPlanButton);
    await expect(button).toBeVisible();

    const buttonText = await button.textContent();

    if (buttonText === "Purchase" || buttonText === "Renew") {
      // Only test checkout flow if button is clickable
      await expect(button).toBeEnabled();

      // Click the button
      await button.click();

      // The mock payment service should redirect back to membership page with mock checkout params
      await page.waitForURL((url) => url.toString().includes("mock_checkout=true"), {
        timeout: 10000,
      });

      // Verify we're on the mock checkout page
      expect(page.url()).toContain("/dashboard/membership");
      expect(page.url()).toContain("mock_checkout=true");
      expect(page.url()).toContain("session=");
      expect(page.url()).toContain("type=");
      expect(page.url()).toContain("amount=");
    } else if (buttonText === "Current Plan") {
      // Button should be disabled for current plan
      await expect(button).toBeDisabled();
    }
  });

  test("should handle payment confirmation callback", async ({ page }) => {
    // Already on membership page from beforeEach

    // Wait for memberships to load
    await expect(
      page.getByRole("heading", { name: "Available Memberships" }),
    ).toBeVisible();

    // Find a purchase button (user might not have membership yet)
    const purchaseButton = page.getByRole("button", { name: "Purchase" }).first();
    const buttonExists = await purchaseButton.isVisible().catch(() => false);

    if (buttonExists) {
      // Click purchase to start mock checkout
      await purchaseButton.click();

      // Wait for mock checkout redirect
      await page.waitForURL((url) => url.toString().includes("mock_checkout=true"));

      // Mock checkout automatically processes the payment
      // Wait for the success message
      await expect(page.getByText("Membership purchased successfully!")).toBeVisible({
        timeout: 10000,
      });
    } else {
      // User already has membership, check the status instead
      await expect(page.getByText("Active Membership")).toBeVisible();
    }
  });

  test("should show active membership status correctly", async ({ page }) => {
    // Already on membership page from beforeEach

    // Check current status section
    await expect(page.getByText("Current Status", { exact: true })).toBeVisible();

    // Check if user has active membership
    const hasActiveMembership = await page
      .getByText("Active Membership")
      .isVisible()
      .catch(() => false);

    if (hasActiveMembership) {
      // User has active membership
      await expect(page.getByText("Active Membership")).toBeVisible();
      await expect(page.getByText(/Annual Player Membership/).first()).toBeVisible();
      await expect(page.getByText(/Expires:/)).toBeVisible();
      await expect(page.getByText(/Days Remaining:/)).toBeVisible();

      // Button should be disabled for current plan
      const button = page.getByRole("button", { name: /Current Plan|Renew/ });
      
      await expect(button).toBeVisible();
      const buttonText = await button.textContent();
      if (buttonText === "Current Plan") {
        await expect(button).toBeDisabled();
      } else if (buttonText === "Renew") {
        await expect(button).toBeEnabled();
      }
    } else {
      // User doesn't have membership
      await expect(page.getByText("No Active Membership")).toBeVisible();

      const purchaseButton = page
        .locator(':has-text("Annual Player Membership 2025")')
        .first()
        .getByRole("button", { name: "Purchase" });
      await expect(purchaseButton).toBeEnabled();
    }
  });

  test("should handle network errors gracefully", async ({ page }) => {
    // Block API calls to simulate network error
    await page.route("**/createCheckoutSession*", (route) => {
      route.abort("failed");
    });

    // Already on membership page from beforeEach

    // Wait for memberships to load
    await expect(
      page.getByRole("heading", { name: "Available Memberships" }),
    ).toBeVisible();

    // Find the membership purchase/renew button specifically
    const purchaseButton = page.getByRole("button", { name: "Purchase" });
    const renewButton = page.getByRole("button", { name: "Renew" });
    const currentPlanButton = page.getByRole("button", { name: "Current Plan" });
    
    // Check which button is visible
    const button = purchaseButton.or(renewButton);
    const hasClickableButton = await button.isVisible().catch(() => false);
    
    if (!hasClickableButton) {
      // User already has membership - skip test
      test.skip();
      return;
    }
    
    const buttonText = await button.textContent();

    // Only test if button is clickable
    if (buttonText === "Purchase" || buttonText === "Renew") {
      await button.click();

      // Should show error message
      await expect(
        page.getByText(/failed to create checkout session|error|problem/i),
      ).toBeVisible({
        timeout: 10000,
      });
    } else {
      // Skip test if user already has this membership
      test.skip();
    }
  });

  test("should navigate from dashboard quick action", async ({ page }) => {
    await page.goto("/dashboard");

    // Look for either "Get Membership" or "Renew Now" link
    const membershipLink = page.getByRole("link", { name: /Get Membership|Renew Now/ });
    await expect(membershipLink).toBeVisible();
    await membershipLink.click();

    // Should navigate to membership page
    await expect(page).toHaveURL("/dashboard/membership");
    await expect(
      page.getByRole("heading", { name: "Membership", exact: true }),
    ).toBeVisible();
  });

  test("should maintain membership selection after navigation", async ({ page }) => {
    // Already on membership page from beforeEach

    // Wait for page to load
    await expect(
      page.getByRole("heading", { name: "Available Memberships" }),
    ).toBeVisible();

    // Navigate away - use exact match to avoid ambiguity
    await page.getByRole("link", { name: "Dashboard", exact: true }).click();
    await expect(page).toHaveURL("/dashboard");

    // Navigate back using either link text
    const membershipLink = page.getByRole("link", { name: /Get Membership|Renew Now/ });
    await membershipLink.click();

    // Wait for navigation to complete
    await expect(page).toHaveURL("/dashboard/membership");

    // Membership options should still be visible
    await expect(
      page.getByRole("heading", { name: "Available Memberships" }),
    ).toBeVisible();
    
    // Verify membership card is visible (wait for it to appear)
    await expect(
      page.locator(`:has-text("${ANNUAL_MEMBERSHIP_NAME}")`).first(),
    ).toBeVisible({ timeout: 10000 });
  });

  test("should handle rapid button clicks", async ({ page }) => {
    // Already on membership page from beforeEach

    // Wait for memberships to load
    await expect(
      page.getByRole("heading", { name: "Available Memberships" }),
    ).toBeVisible();

    // Find the membership purchase/renew button specifically
    const purchaseButton = page.getByRole("button", { name: "Purchase" });
    const renewButton = page.getByRole("button", { name: "Renew" });
    
    // Check which button is visible
    const button = purchaseButton.or(renewButton);
    const hasClickableButton = await button.isVisible().catch(() => false);
    
    if (!hasClickableButton) {
      // User already has membership - skip test
      test.skip();
      return;
    }
    
    const buttonText = await button.textContent();

    if (buttonText === "Purchase" || buttonText === "Renew") {
      // Rapidly click the button multiple times
      await button.click();
      await button.click();
      await button.click();

      // Should only trigger one checkout session
      // Wait for redirect to mock checkout
      await page.waitForURL((url) => url.toString().includes("mock_checkout=true"), {
        timeout: 10000,
      });

      // Verify we're on the mock checkout page (only one redirect should occur)
      expect(page.url()).toContain("/dashboard/membership");
      expect(page.url()).toContain("mock_checkout=true");
    } else {
      // Skip test if user already has current plan
      test.skip();
    }
  });
});
</file>

<file path="e2e/tests/unauthenticated/auth-flow.unauth.spec.ts">
import { expect, test } from "@playwright/test";
import { clearAuthState, uiLogin } from "../../utils/auth";

test.describe("Authentication Flow (Unauthenticated)", () => {
  test.beforeEach(async ({ page }) => {
    // Ensure we're not authenticated
    await clearAuthState(page);
  });

  test("should complete successful login flow", async ({ page }) => {
    // Use the uiLogin helper which handles all the login flow
    await uiLogin(page, process.env["E2E_TEST_EMAIL"]!, process.env["E2E_TEST_PASSWORD"]!);
    
    // Verify user is logged in - check for welcome message
    await expect(page.getByRole("heading", { name: /Welcome back/ })).toBeVisible({ timeout: 10_000 });

    // Verify sidebar navigation is present (complementary role)
    const sidebar = page.getByRole("complementary");
    await expect(sidebar).toBeVisible();
    
    // Check for specific sidebar links with exact matching to avoid strict mode violations
    // The sidebar has both "Roundup Games Dashboard" and "Dashboard" links
    await expect(sidebar.getByRole("link", { name: "Dashboard", exact: true })).toBeVisible();
    await expect(sidebar.getByRole("link", { name: "Profile", exact: true })).toBeVisible();
  });

  test("should complete successful signup flow for new user", async ({ page }) => {
    await page.goto("/auth/signup");

    // Wait for the page to be ready
    await page.waitForLoadState("domcontentloaded");

    // Generate unique email for this test
    const timestamp = Date.now();
    const testEmail = `test+${timestamp}@example.com`;

    // Wait for form fields to be ready
    const nameField = page.getByLabel("Name");
    await expect(nameField).toBeVisible({ timeout: 10_000 });
    await expect(nameField).toBeEnabled({ timeout: 10_000 });

    // Fill signup form
    await nameField.fill("New Test User");
    await page.getByLabel("Email").fill(testEmail);
    
    // Fill password field
    const passwordField = page.getByLabel("Password", { exact: true });
    await passwordField.fill("testpassword123");
    
    // Wait for password validation to complete
    await page.waitForTimeout(200);
    
    // Now fill confirm password - it will validate against the password field
    const confirmField = page.getByLabel("Confirm Password");
    await confirmField.fill("testpassword123");
    
    // Wait for confirm password validation
    await page.waitForTimeout(200);

    // Submit signup
    const signupBtn = page.getByRole("button", { name: "Sign up", exact: true });
    await expect(signupBtn).toBeEnabled({ timeout: 10_000 });
    await signupBtn.click();

    // Should redirect to onboarding for new users to complete their profile
    await page.waitForURL("/onboarding", { timeout: 30_000 });

    // Verify we're on the onboarding page
    await expect(
      page.getByRole("heading", { name: /Complete Your Profile/ }),
    ).toBeVisible({ timeout: 10_000 });

    // Clean up: Note - in a real test suite, we'd have a cleanup step
    // to remove test users created during tests
  });

  test("should handle OAuth login buttons", async ({ page }) => {
    await page.goto("/auth/login");

    // Check that OAuth buttons are present and clickable
    const googleLoginButton = page.getByRole("button", { name: "Login with Google" });
    await expect(googleLoginButton).toBeVisible();
    await expect(googleLoginButton).toBeEnabled();

    // Note: We can't test the actual OAuth flow in E2E tests
    // as it involves external services
  });

  test("should persist redirect after login", async ({ page }) => {
    // Try to access a protected page
    await page.goto("/dashboard/profile");

    // Should redirect to login with redirect parameter
    await expect(page).toHaveURL(/\/auth\/login/);
    await expect(page).toHaveURL(/redirect=/);

    // Use uiLogin helper to login - it will respect the redirect parameter
    await uiLogin(
      page, 
      process.env["E2E_TEST_EMAIL"]!, 
      process.env["E2E_TEST_PASSWORD"]!, 
      "/dashboard/profile"
    );

    // Should be on the profile page now
    await expect(page).toHaveURL("/dashboard/profile");
  });
});
</file>

<file path="e2e/auth.setup.ts">
import { expect, test as setup } from "@playwright/test";
import { dirname, join } from "path";
import { fileURLToPath } from "url";
import { clearAuthState, uiLogin } from "./utils/auth";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const authFile = join(__dirname, ".auth/user.json");

setup("authenticate", async ({ page }) => {
  // Clear any existing auth state first
  await clearAuthState(page);

  // Use the uiLogin helper to perform login
  await uiLogin(page, process.env["E2E_TEST_EMAIL"]!, process.env["E2E_TEST_PASSWORD"]!);

  // Verify we're logged in by checking for the welcome message
  await expect(page.getByRole("heading", { name: /Welcome back/ })).toBeVisible({
    timeout: 10_000,
  });

  // Save authentication state
  await page.context().storageState({ path: authFile });
});
</file>

<file path="playwright.config.ts">
import { defineConfig, devices } from "@playwright/test";
import dotenv from "dotenv";
import { dirname, resolve } from "path";
import { fileURLToPath } from "url";

// Get __dirname equivalent in ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

/**
 * Read environment variables from file.
 * https://github.com/motdotla/dotenv
 */
dotenv.config({ path: resolve(__dirname, ".env.e2e") });

/**
 * See https://playwright.dev/docs/test-configuration.
 */
export default defineConfig({
  testDir: "./e2e",
  /* Run tests in files in parallel */
  fullyParallel: true,
  /* Fail the build on CI if you accidentally left test.only in the source code. */
  forbidOnly: !!process.env["CI"],
  /* Retry on CI only */
  retries: process.env["CI"] ? 2 : 0,
  /* Opt out of parallel tests on CI. */
  workers: process.env["CI_REMOTE_DB"] ? 1 : undefined,
  /* Reporter to use. See https://playwright.dev/docs/test-reporters */
  reporter: "html",
  /* Shared settings for all the projects below. See https://playwright.dev/docs/api/class-testoptions. */
  use: {
    /* Base URL to use in actions like `await page.goto('/')`. */
    baseURL: process.env["VITE_BASE_URL"] || "http://localhost:5173",

    /* Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer */
    trace: "on-first-retry",

    /* Take screenshot on failure */
    screenshot: "only-on-failure",
    
    /* Global timeout settings for better stability */
    navigationTimeout: 15000,
    actionTimeout: 10000,
  },

  /* Configure projects for major browsers */
  projects: [
    // Setup project for authentication
    { name: "setup", testMatch: /.*\.setup\.ts/ },

    // Unauthenticated tests - run without auth state
    {
      name: "chromium-unauthenticated",
      use: {
        ...devices["Desktop Chrome"],
      },
      testMatch: /.*\.(unauth)\.spec\.ts/,
    },

    // Shared-state project: only tests that explicitly want the Test User
    {
      name: "chromium-shared-auth",
      use: {
        ...devices["Desktop Chrome"],
        storageState: "e2e/.auth/user.json",
      },
      dependencies: ["setup"],
      testMatch: /.*\.shared\.spec\.ts/,
    },

    // Per-suite project: runs every other authenticated spec without storageState
    {
      name: "chromium-auth",
      use: { ...devices["Desktop Chrome"] },
      testMatch: /.*\.(auth|dashboard|profile|teams)\.spec\.ts/,
    },

    // Firefox unauthenticated
    {
      name: "firefox-unauthenticated",
      use: {
        ...devices["Desktop Firefox"],
        launchOptions: { slowMo: 100 }, // tiny delay prevents spurious abort
      },
      testMatch: /.*\.(unauth)\.spec\.ts/,
    },

    // Firefox shared auth
    {
      name: "firefox-shared-auth",
      use: {
        ...devices["Desktop Firefox"],
        launchOptions: { slowMo: 100 }, // tiny delay prevents spurious abort
        storageState: "e2e/.auth/user.json",
      },
      dependencies: ["setup"],
      testMatch: /.*\.shared\.spec\.ts/,
    },

    // Firefox authenticated (no shared state)
    {
      name: "firefox-auth",
      use: {
        ...devices["Desktop Firefox"],
        launchOptions: { slowMo: 100 },
      },
      testMatch: /.*\.(auth|dashboard|profile|teams)\.spec\.ts/,
    },
  ],

  /* Run your local dev server before starting the tests */
  webServer: {
    command: "pnpm dev",
    url: "http://localhost:5173",
    reuseExistingServer: !process.env["CI"],
    timeout: 120 * 1000,
  },
});
</file>

<file path="src/features/auth/components/signup.tsx">
import { useQueryClient } from "@tanstack/react-query";
import { useNavigate, useRouter } from "@tanstack/react-router";
import { useState } from "react";
import { FormSubmitButton } from "~/components/form-fields/FormSubmitButton";
import { ValidatedInput } from "~/components/form-fields/ValidatedInput";
import { Button } from "~/components/ui/button";
import { GoogleIcon, LogoIcon } from "~/components/ui/icons";
import { SafeLink as Link } from "~/components/ui/SafeLink";
import { auth } from "~/lib/auth-client";
import { useAppForm } from "~/lib/hooks/useAppForm";
import { signupFormFields } from "../auth.schemas";

export default function SignupForm() {
  const queryClient = useQueryClient();
  const navigate = useNavigate();
  const router = useRouter();
  const redirectUrl = "/dashboard"; // Default redirect after signup

  const [isLoading, setIsLoading] = useState(false);
  const [errorMessage, setErrorMessage] = useState("");

  const form = useAppForm({
    defaultValues: {
      name: "",
      email: "",
      password: "",
      confirmPassword: "",
    },
    onSubmit: async ({ value }) => {
      setIsLoading(true);
      setErrorMessage("");

      try {
        const result = await auth.signUp.email({
          name: value.name,
          email: value.email,
          password: value.password,
          callbackURL: redirectUrl,
        });

        if (result?.error) {
          throw new Error(result.error.message || "Signup failed");
        }

        // Success path
        await queryClient.invalidateQueries({ queryKey: ["user"] });
        await router.invalidate();
        await navigate({ to: redirectUrl });
      } catch (error) {
        // Error handling
        setErrorMessage((error as Error)?.message || "Signup failed");
        // Keep form values but reset submitting state by resetting with current values
        form.reset({
          name: value.name,
          email: value.email,
          password: value.password,
          confirmPassword: value.confirmPassword,
        });
      } finally {
        // Always reset loading state
        setIsLoading(false);
      }
    },
  });

  return (
    <div className="flex flex-col gap-6">
      <form
        onSubmit={async (e) => {
          e.preventDefault();
          e.stopPropagation();
          await form.handleSubmit();
        }}
      >
        <div className="flex flex-col gap-6">
          <div className="flex flex-col items-center gap-2">
            <a href="#" className="flex flex-col items-center gap-2 font-medium">
              <div className="flex h-8 w-8 items-center justify-center rounded-md">
                <LogoIcon className="size-6" />
              </div>
              <span className="sr-only">Roundup Games</span>
            </a>
            <h1 className="text-xl font-bold">Sign up for Roundup Games</h1>
          </div>
          <div className="flex flex-col gap-5">
            <form.Field
              name="name"
              validators={{
                onChange: signupFormFields.name,
              }}
            >
              {(field) => (
                <ValidatedInput
                  field={field}
                  label="Name"
                  type="text"
                  placeholder="John Doe"
                  autoComplete="name"
                  autoFocus
                />
              )}
            </form.Field>
            <form.Field
              name="email"
              validators={{
                onChange: signupFormFields.email,
              }}
            >
              {(field) => (
                <ValidatedInput
                  field={field}
                  label="Email"
                  type="email"
                  placeholder="hello@example.com"
                  autoComplete="email"
                />
              )}
            </form.Field>
            <form.Field
              name="password"
              validators={{
                onChange: signupFormFields.password,
              }}
            >
              {(field) => (
                <ValidatedInput
                  field={field}
                  label="Password"
                  type="password"
                  placeholder="Password"
                  autoComplete="new-password"
                />
              )}
            </form.Field>
            <form.Field
              name="confirmPassword"
              validators={{
                onChangeListenTo: ["password"],
                onChange: ({ value, fieldApi }) => {
                  if (value !== fieldApi.form.getFieldValue("password")) {
                    return "Passwords do not match";
                  }
                  return undefined;
                },
              }}
            >
              {(field) => (
                <ValidatedInput
                  field={field}
                  label="Confirm Password"
                  type="password"
                  placeholder="Confirm Password"
                  autoComplete="new-password"
                />
              )}
            </form.Field>
            <FormSubmitButton
              isSubmitting={form.state.isSubmitting || isLoading}
              className="mt-2 w-full"
              size="lg"
              loadingText="Signing up..."
            >
              Sign up
            </FormSubmitButton>
          </div>
          {errorMessage && (
            <span className="text-destructive text-center text-sm">{errorMessage}</span>
          )}
          <div className="after:border-border relative text-center text-sm after:absolute after:inset-0 after:top-1/2 after:z-0 after:flex after:items-center after:border-t">
            <span className="bg-background text-muted-foreground relative z-10 px-2">
              Or
            </span>
          </div>
          <Button
            variant="outline"
            className="w-full"
            type="button"
            disabled={isLoading || form.state.isSubmitting}
            onClick={() =>
              auth.signInWithOAuth(
                {
                  provider: "google",
                  callbackURL: redirectUrl,
                },
                {
                  onRequest: () => {
                    setIsLoading(true);
                    setErrorMessage("");
                  },
                  // eslint-disable-next-line @typescript-eslint/no-explicit-any
                  onError: (ctx: any) => {
                    setIsLoading(false);
                    setErrorMessage(ctx.error?.message || "OAuth signup failed");
                  },
                },
              )
            }
          >
            <GoogleIcon />
            Sign up with Google
          </Button>
        </div>
      </form>

      <div className="text-center text-sm">
        Already have an account?{" "}
        <Link to="/auth/login" className="underline underline-offset-4">
          Login
        </Link>
      </div>
    </div>
  );
}
</file>

<file path="src/features/auth/components/login.tsx">
import { useQueryClient } from "@tanstack/react-query";
import { useNavigate, useRouter } from "@tanstack/react-router";
import { useState } from "react";
import { z } from "zod";
import { FormSubmitButton } from "~/components/form-fields/FormSubmitButton";
import { ValidatedInput } from "~/components/form-fields/ValidatedInput";
import { Button } from "~/components/ui/button";
import { GoogleIcon, LogoIcon } from "~/components/ui/icons";
import { SafeLink as Link } from "~/components/ui/SafeLink";
import { auth } from "~/lib/auth-client";
import { useAppForm } from "~/lib/hooks/useAppForm";
import { loginFormSchema } from "../auth.schemas";

export default function LoginForm() {
  const queryClient = useQueryClient();
  const navigate = useNavigate();
  const router = useRouter();
  
  // Get redirect parameter from URL, default to dashboard
  const searchParams = new URLSearchParams(window.location.search);
  const redirectUrl = searchParams.get("redirect") || "/dashboard";

  const [isLoading, setIsLoading] = useState(false);
  const [errorMessage, setErrorMessage] = useState("");

  const form = useAppForm({
    defaultValues: {
      email: "",
      password: "",
    },
    onSubmit: async ({ value }) => {
      setIsLoading(true);
      setErrorMessage("");

      try {
        const result = await auth.signIn.email(value);

        if (result?.error) {
          throw new Error(result.error.message || "Invalid email or password");
        }

        // Success path
        await queryClient.invalidateQueries({ queryKey: ["user"] });
        await router.invalidate();
        await navigate({ to: redirectUrl });
      } catch (error) {
        // Error handling
        setErrorMessage((error as Error)?.message || "Invalid email or password");
        // Keep form values but reset submitting state by resetting with current values
        form.reset(value);
      } finally {
        // Always reset loading state
        setIsLoading(false);
      }
    },
  });

  return (
    <div className="flex flex-col gap-6">
      <form
        onSubmit={async (e) => {
          e.preventDefault();
          e.stopPropagation();
          await form.handleSubmit();
        }}
      >
        <div className="flex flex-col gap-6">
          <div className="flex flex-col items-center gap-2">
            <a href="#" className="flex flex-col items-center gap-2 font-medium">
              <div className="flex h-8 w-8 items-center justify-center rounded-md">
                <LogoIcon className="size-6" />
              </div>
              <span className="sr-only">Roundup Games</span>
            </a>
            <h1 className="text-xl font-bold">Welcome back to Roundup Games</h1>
          </div>
          <div className="flex flex-col gap-5">
            <form.Field
              name="email"
              validators={{
                onChange: ({ value }) => {
                  try {
                    loginFormSchema.shape.email.parse(value);
                    return undefined;
                  } catch (error) {
                    if (error instanceof z.ZodError) {
                      return error.errors?.[0]?.message || "Invalid email";
                    }
                    return "Invalid email";
                  }
                },
              }}
            >
              {(field) => (
                <ValidatedInput
                  field={field}
                  label="Email"
                  type="email"
                  placeholder="hello@example.com"
                  autoComplete="email"
                  autoFocus
                />
              )}
            </form.Field>
            <form.Field
              name="password"
              validators={{
                onChange: ({ value }) => {
                  try {
                    loginFormSchema.shape.password.parse(value);
                    return undefined;
                  } catch (error) {
                    if (error instanceof z.ZodError) {
                      return error.errors?.[0]?.message || "Password is required";
                    }
                    return "Password is required";
                  }
                },
              }}
            >
              {(field) => (
                <ValidatedInput
                  field={field}
                  label="Password"
                  type="password"
                  placeholder="Password"
                  autoComplete="current-password"
                />
              )}
            </form.Field>
            <FormSubmitButton
              isSubmitting={form.state.isSubmitting || isLoading}
              className="mt-2 w-full"
              size="lg"
              loadingText="Logging in..."
            >
              Login
            </FormSubmitButton>
          </div>
          {errorMessage && (
            <span className="text-destructive text-center text-sm">{errorMessage}</span>
          )}
          <div className="after:border-border relative text-center text-sm after:absolute after:inset-0 after:top-1/2 after:z-0 after:flex after:items-center after:border-t">
            <span className="bg-background text-muted-foreground relative z-10 px-2">
              Or
            </span>
          </div>
          <Button
            variant="outline"
            className="w-full"
            type="button"
            disabled={isLoading || form.state.isSubmitting}
            onClick={() =>
              auth.signInWithOAuth(
                {
                  provider: "google",
                  callbackURL: redirectUrl,
                },
                {
                  onRequest: () => {
                    setIsLoading(true);
                    setErrorMessage("");
                  },
                  // eslint-disable-next-line @typescript-eslint/no-explicit-any
                  onError: (ctx: any) => {
                    setIsLoading(false);
                    setErrorMessage(ctx.error?.message || "OAuth login failed");
                  },
                },
              )
            }
          >
            <GoogleIcon />
            Login with Google
          </Button>
        </div>
      </form>

      <div className="text-center text-sm">
        Don&apos;t have an account?{" "}
        <Link to="/auth/signup" className="underline underline-offset-4">
          Sign up
        </Link>
      </div>
    </div>
  );
}
</file>

</files>
