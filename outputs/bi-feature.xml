This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/features/bi/**/*.ts, src/features/bi/**/*.tsx, src/db/schema/bi.schema.ts, src/routes/dashboard/sin/analytics.tsx, src/routes/dashboard/admin/sin/analytics.tsx
- Files matching these patterns are excluded: **/__fixtures__/**, **/docs/**, **/__tests__/**, **/*.test.ts
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  db/
    schema/
      bi.schema.ts
  features/
    bi/
      components/
        charts/
          BarChart.tsx
          ChartContainer.tsx
          KpiCard.tsx
          LineChart.tsx
          PieChart.tsx
          pivot-chart.ts
        dashboard/
          AddWidgetModal.tsx
          dashboard-utils.ts
          DashboardCanvas.tsx
          DashboardExportDialog.tsx
          DashboardFilters.tsx
          DashboardShareDialog.tsx
          DashboardWidget.tsx
          WidgetToolbar.tsx
        filters/
          DateFilter.tsx
          EnumFilter.tsx
          FilterBuilder.tsx
          FilterGroup.tsx
          NumericFilter.tsx
        pivot-builder/
          DropZone.tsx
          FieldPalette.tsx
          FilterPanel.tsx
          MeasureConfig.tsx
          PivotBuilder.tsx
          PivotPreview.tsx
        pivot-table/
          PivotHeader.tsx
          PivotRow.tsx
          PivotTable.tsx
          TotalsRow.tsx
        sql-workbench/
          QueryHistory.tsx
          ResultsTable.tsx
          SqlEditor.tsx
          SqlWorkbench.tsx
      engine/
        aggregations.ts
        filters.ts
        index.ts
        pivot-aggregator.ts
        query-builder.ts
        sorting.ts
        sql-parser.ts
        sql-rewriter.ts
      governance/
        audit-logger.ts
        export-controls.ts
        field-acl.ts
        index.ts
        org-scoping.ts
        pii-masking.ts
        query-audit.ts
        query-guardrails.ts
      hooks/
        use-dashboard.ts
      semantic/
        calculated-fields.ts
        datasets.config.ts
        field-metadata.ts
        index.ts
        metrics.config.ts
      bi.data.ts
      bi.mutations.ts
      bi.queries.ts
      bi.schemas.ts
      bi.sql-executor.ts
      bi.types.ts
      bi.utils.ts
      index.ts
  routes/
    dashboard/
      admin/
        sin/
          analytics.tsx
      sin/
        analytics.tsx
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/db/schema/bi.schema.ts">
import {
  boolean,
  integer,
  jsonb,
  pgEnum,
  pgTable,
  text,
  timestamp,
  uuid,
} from "drizzle-orm/pg-core";
import type {
  ChartConfig,
  DashboardLayout,
  DatasetField as DatasetFieldConfig,
  DatasetJoin,
  FilterConfig,
  FormatOptions,
  PivotConfig,
  SqlConfig,
  WidgetConfig,
} from "~/features/bi/bi.types";
import { user } from "./auth.schema";
import { organizations } from "./organizations.schema";

export const chartTypeEnum = pgEnum("bi_chart_type", [
  "table",
  "bar",
  "line",
  "area",
  "pie",
  "donut",
  "heatmap",
  "scatter",
  "kpi",
]);

export const widgetTypeEnum = pgEnum("bi_widget_type", [
  "chart",
  "pivot",
  "kpi",
  "text",
  "filter",
]);

export const biDatasets = pgTable("bi_datasets", {
  id: uuid("id").primaryKey().defaultRandom(),
  organizationId: uuid("organization_id").references(() => organizations.id),
  name: text("name").notNull(),
  description: text("description"),
  baseTable: text("base_table").notNull(),
  joins: jsonb("joins").$type<DatasetJoin[]>(),
  fields: jsonb("fields").$type<DatasetFieldConfig[]>().notNull(),
  isPublic: boolean("is_public").notNull().default(false),
  allowedRoles: jsonb("allowed_roles").$type<string[]>().default([]),
  createdBy: text("created_by").references(() => user.id),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true })
    .notNull()
    .defaultNow()
    .$onUpdate(() => new Date()),
});

export const biMetrics = pgTable("bi_metrics", {
  id: uuid("id").primaryKey().defaultRandom(),
  organizationId: uuid("organization_id").references(() => organizations.id),
  datasetId: uuid("dataset_id").references(() => biDatasets.id),
  name: text("name").notNull(),
  description: text("description"),
  expression: text("expression").notNull(),
  aggregation: text("aggregation"),
  formatType: text("format_type").notNull().default("number"),
  formatOptions: jsonb("format_options").$type<FormatOptions>(),
  createdBy: text("created_by").references(() => user.id),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true })
    .notNull()
    .defaultNow()
    .$onUpdate(() => new Date()),
});

export const biReports = pgTable("bi_reports", {
  id: uuid("id").primaryKey().defaultRandom(),
  organizationId: uuid("organization_id").references(() => organizations.id),
  datasetId: uuid("dataset_id").references(() => biDatasets.id),
  name: text("name").notNull(),
  description: text("description"),
  reportType: text("report_type").notNull().default("pivot"),
  pivotConfig: jsonb("pivot_config").$type<PivotConfig>(),
  sqlConfig: jsonb("sql_config").$type<SqlConfig>(),
  chartType: chartTypeEnum("chart_type"),
  chartConfig: jsonb("chart_config").$type<ChartConfig>(),
  filters: jsonb("filters").$type<FilterConfig[]>().default([]),
  ownerId: text("owner_id")
    .notNull()
    .references(() => user.id),
  sharedWith: jsonb("shared_with").$type<string[]>().default([]),
  isOrgWide: boolean("is_org_wide").notNull().default(false),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true })
    .notNull()
    .defaultNow()
    .$onUpdate(() => new Date()),
});

export const biDashboards = pgTable("bi_dashboards", {
  id: uuid("id").primaryKey().defaultRandom(),
  organizationId: uuid("organization_id").references(() => organizations.id),
  name: text("name").notNull(),
  description: text("description"),
  layout: jsonb("layout").$type<DashboardLayout>().notNull(),
  globalFilters: jsonb("global_filters").$type<FilterConfig[]>().default([]),
  ownerId: text("owner_id")
    .notNull()
    .references(() => user.id),
  sharedWith: jsonb("shared_with").$type<string[]>().default([]),
  isOrgWide: boolean("is_org_wide").notNull().default(false),
  isPublished: boolean("is_published").notNull().default(false),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true })
    .notNull()
    .defaultNow()
    .$onUpdate(() => new Date()),
});

export const biDashboardWidgets = pgTable("bi_dashboard_widgets", {
  id: uuid("id").primaryKey().defaultRandom(),
  dashboardId: uuid("dashboard_id")
    .notNull()
    .references(() => biDashboards.id, { onDelete: "cascade" }),
  widgetType: widgetTypeEnum("widget_type").notNull(),
  reportId: uuid("report_id").references(() => biReports.id),
  x: integer("x").notNull().default(0),
  y: integer("y").notNull().default(0),
  w: integer("w").notNull().default(4),
  h: integer("h").notNull().default(3),
  config: jsonb("config").$type<WidgetConfig>(),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true })
    .notNull()
    .defaultNow()
    .$onUpdate(() => new Date()),
});

export const biQueryLog = pgTable("bi_query_log", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: text("user_id")
    .notNull()
    .references(() => user.id),
  organizationId: uuid("organization_id").references(() => organizations.id),
  queryType: text("query_type").notNull(),
  queryHash: text("query_hash").notNull(),
  datasetId: uuid("dataset_id").references(() => biDatasets.id),
  sqlQuery: text("sql_query"),
  parameters: jsonb("parameters").$type<Record<string, unknown>>(),
  pivotConfig: jsonb("pivot_config").$type<PivotConfig>(),
  rowsReturned: integer("rows_returned"),
  executionTimeMs: integer("execution_time_ms"),
  previousLogId: uuid("previous_log_id"),
  checksum: text("checksum"),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
});
</file>

<file path="src/features/bi/components/charts/BarChart.tsx">
import { ChartContainer } from "./ChartContainer";

export function BarChart({ option }: { option: unknown }) {
  return <ChartContainer option={option} />;
}
</file>

<file path="src/features/bi/components/charts/ChartContainer.tsx">
import { useEffect, useState, type CSSProperties, type ComponentType } from "react";
import { Loader2 } from "lucide-react";

export function ChartContainer({
  option,
  style,
}: {
  option: unknown;
  style?: CSSProperties;
}) {
  type ChartComponentProps = { option: unknown; style: CSSProperties };
  const [ChartComponent, setChartComponent] = useState<
    ComponentType<ChartComponentProps> | null
  >(null);

  useEffect(() => {
    let active = true;
    import("echarts-for-react")
      .then((mod) => {
        if (active) {
          setChartComponent(
            () => mod.default as ComponentType<ChartComponentProps>,
          );
        }
      })
      .catch(() => {
        if (active) setChartComponent(null);
      });
    return () => {
      active = false;
    };
  }, []);

  if (!ChartComponent) {
    return (
      <div className="flex h-64 items-center justify-center rounded-md border border-dashed">
        <div className="flex items-center gap-2 text-muted-foreground text-sm">
          <Loader2 className="h-4 w-4 animate-spin" />
          Loading chart...
        </div>
      </div>
    );
  }

  return <ChartComponent option={option} style={style ?? { height: 320 }} />;
}
</file>

<file path="src/features/bi/components/charts/KpiCard.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";

export function KpiCard({
  title,
  value,
  subtitle,
}: {
  title: string;
  value: string | number;
  subtitle?: string;
}) {
  return (
    <Card>
      <CardHeader className="pb-2">
        <CardTitle className="text-sm font-medium text-muted-foreground">
          {title}
        </CardTitle>
      </CardHeader>
      <CardContent>
        <div className="text-2xl font-semibold">{value}</div>
        {subtitle ? (
          <p className="text-muted-foreground mt-1 text-xs">{subtitle}</p>
        ) : null}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/bi/components/charts/LineChart.tsx">
import { ChartContainer } from "./ChartContainer";

export function LineChart({ option }: { option: unknown }) {
  return <ChartContainer option={option} />;
}
</file>

<file path="src/features/bi/components/charts/PieChart.tsx">
import { ChartContainer } from "./ChartContainer";

export function PieChart({ option }: { option: unknown }) {
  return <ChartContainer option={option} />;
}
</file>

<file path="src/features/bi/components/charts/pivot-chart.ts">
import type { ChartType, PivotResult } from "../../bi.schemas";

const joinLabel = (values: Record<string, string>, fallback: string) => {
  const entries = Object.entries(values);
  if (entries.length === 0) return fallback;
  return entries.map(([field, value]) => `${field}: ${value || "-"}`).join(" / ");
};

const sumValues = (values: Array<number | null>) =>
  values.reduce<number>((acc, value) => acc + (value ?? 0), 0);

export const buildPivotChartOptions = (
  pivot: PivotResult,
  chartType: ChartType,
  measureKey: string,
) => {
  const rowLabels = pivot.rows.map((row) =>
    joinLabel(row.values, pivot.rowFields.length === 0 ? "Total" : ""),
  );
  const columnLabels = pivot.columnKeys.map((column) => column.label);

  const matrix = pivot.rows.map((row) =>
    pivot.columnKeys.map((column) => row.cells[column.key]?.[measureKey] ?? 0),
  );

  if (chartType === "pie" || chartType === "donut") {
    return {
      tooltip: { trigger: "item" },
      series: [
        {
          type: "pie",
          radius: chartType === "donut" ? ["40%", "70%"] : "65%",
          data: rowLabels.map((label, index) => ({
            name: label || "Total",
            value: sumValues(matrix[index] ?? []),
          })),
        },
      ],
    };
  }

  if (chartType === "heatmap") {
    const data: Array<[number, number, number]> = [];
    matrix.forEach((row, rowIndex) => {
      row.forEach((value, colIndex) => {
        data.push([colIndex, rowIndex, value ?? 0]);
      });
    });

    return {
      tooltip: { position: "top" },
      grid: { height: "70%", top: "10%" },
      xAxis: { type: "category", data: columnLabels },
      yAxis: { type: "category", data: rowLabels },
      visualMap: {
        min: 0,
        max: Math.max(...data.map((item) => item[2]), 1),
        calculable: true,
        orient: "horizontal",
        left: "center",
        bottom: "2%",
      },
      series: [
        {
          type: "heatmap",
          data,
          emphasis: {
            itemStyle: { shadowBlur: 6, shadowColor: "rgba(0,0,0,0.3)" },
          },
        },
      ],
    };
  }

  if (chartType === "scatter") {
    const data = rowLabels.map((label, index) => {
      const value = sumValues(matrix[index] ?? []);
      return [index, value, label];
    });

    return {
      tooltip: {
        trigger: "item",
        formatter: (params: { value: [number, number, string] }) =>
          `${params.value[2]}: ${params.value[1]}`,
      },
      xAxis: { type: "category", data: rowLabels },
      yAxis: { type: "value" },
      series: [
        {
          type: "scatter",
          data: data.map((point) => [point[0], point[1]]),
        },
      ],
    };
  }

  if (chartType === "bar" || chartType === "line" || chartType === "area") {
    const series = columnLabels.map((label, index) => ({
      name: label,
      type: chartType === "area" ? "line" : chartType,
      areaStyle: chartType === "area" ? {} : undefined,
      data: matrix.map((row) => row[index] ?? 0),
    }));

    return {
      tooltip: { trigger: "axis" },
      legend: { data: columnLabels },
      xAxis: { type: "category", data: rowLabels },
      yAxis: { type: "value" },
      series,
    };
  }

  return null;
};
</file>

<file path="src/features/bi/components/dashboard/AddWidgetModal.tsx">
import { useEffect, useState } from "react";
import { toast } from "sonner";
import { Button } from "~/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "~/components/ui/dialog";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";
import { Textarea } from "~/components/ui/textarea";
import type { ChartType, PivotQuery, WidgetType } from "../../bi.schemas";
import type { WidgetConfig } from "../../bi.types";

const widgetOptions: Array<{ value: WidgetType; label: string }> = [
  { value: "chart", label: "Chart" },
  { value: "pivot", label: "Pivot" },
  { value: "kpi", label: "KPI" },
  { value: "text", label: "Text" },
];

const chartOptions: Array<{ value: ChartType; label: string }> = [
  { value: "bar", label: "Bar" },
  { value: "line", label: "Line" },
  { value: "area", label: "Area" },
  { value: "pie", label: "Pie" },
  { value: "donut", label: "Donut" },
  { value: "heatmap", label: "Heatmap" },
  { value: "scatter", label: "Scatter" },
  { value: "kpi", label: "KPI" },
];

export function AddWidgetModal({
  open,
  onOpenChange,
  datasets,
  widgetsCount,
  onAdd,
}: {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  datasets: Array<{ id: string; name: string }>;
  widgetsCount: number;
  onAdd: (params: {
    widgetType: WidgetType;
    title: string;
    position: { x: number; y: number; w: number; h: number };
    query?: PivotQuery;
    config?: WidgetConfig;
  }) => void;
}) {
  const [widgetType, setWidgetType] = useState<WidgetType>("chart");
  const [title, setTitle] = useState("");
  const [datasetId, setDatasetId] = useState("");
  const [chartType, setChartType] = useState<ChartType>("bar");
  const [textContent, setTextContent] = useState("");

  useEffect(() => {
    if (!datasetId && datasets.length > 0) {
      setDatasetId(datasets[0]?.id ?? "");
    }
  }, [datasetId, datasets]);

  const reset = () => {
    setWidgetType("chart");
    setTitle("");
    setTextContent("");
    setChartType("bar");
  };

  const handleAdd = () => {
    if (!title.trim()) {
      toast.error("Widget title is required.");
      return;
    }

    const basePosition = {
      x: 0,
      y: widgetsCount * 4,
      w: widgetType === "kpi" ? 3 : 4,
      h: widgetType === "text" ? 3 : 4,
    };

    let query: PivotQuery | undefined;
    const config: WidgetConfig = { title };

    if (widgetType !== "text") {
      if (!datasetId) {
        toast.error("Select a dataset for this widget.");
        return;
      }
      const nextQuery: PivotQuery = {
        datasetId,
        rows: [],
        columns: [],
        measures: [{ field: null, aggregation: "count" }],
        filters: [],
        limit: 1000,
      };
      query = nextQuery;
      config.query = nextQuery;
    }

    if (widgetType === "chart") {
      config.chartType = chartType;
    }

    if (widgetType === "text") {
      config.textContent = textContent;
    }

    const payload = {
      widgetType,
      title,
      position: basePosition,
      ...(query ? { query } : {}),
      config,
    };

    onAdd(payload);
    reset();
    onOpenChange(false);
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Add widget</DialogTitle>
        </DialogHeader>

        <div className="space-y-4">
          <div className="space-y-1">
            <Label>Widget type</Label>
            <Select
              value={widgetType}
              onValueChange={(value) => setWidgetType(value as WidgetType)}
            >
              <SelectTrigger>
                <SelectValue placeholder="Select widget type" />
              </SelectTrigger>
              <SelectContent>
                {widgetOptions.map((option) => (
                  <SelectItem key={option.value} value={option.value}>
                    {option.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          <div className="space-y-1">
            <Label>Title</Label>
            <Input value={title} onChange={(event) => setTitle(event.target.value)} />
          </div>

          {widgetType !== "text" ? (
            <div className="space-y-1">
              <Label>Dataset</Label>
              <Select value={datasetId} onValueChange={setDatasetId}>
                <SelectTrigger>
                  <SelectValue placeholder="Select dataset" />
                </SelectTrigger>
                <SelectContent>
                  {datasets.map((dataset) => (
                    <SelectItem key={dataset.id} value={dataset.id}>
                      {dataset.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          ) : null}

          {widgetType === "chart" ? (
            <div className="space-y-1">
              <Label>Chart type</Label>
              <Select
                value={chartType}
                onValueChange={(value) => setChartType(value as ChartType)}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Select chart" />
                </SelectTrigger>
                <SelectContent>
                  {chartOptions.map((option) => (
                    <SelectItem key={option.value} value={option.value}>
                      {option.label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          ) : null}

          {widgetType === "text" ? (
            <div className="space-y-1">
              <Label>Text</Label>
              <Textarea
                rows={4}
                value={textContent}
                onChange={(event) => setTextContent(event.target.value)}
              />
            </div>
          ) : null}
        </div>

        <DialogFooter>
          <Button type="button" variant="outline" onClick={() => onOpenChange(false)}>
            Cancel
          </Button>
          <Button type="button" onClick={handleAdd}>
            Add widget
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/features/bi/components/dashboard/dashboard-utils.ts">
import type { FilterConfig, PivotQuery } from "~/features/bi/bi.schemas";
import { getDataset } from "~/features/bi/semantic";

export const mergeDashboardFilters = (
  query: PivotQuery | null | undefined,
  globalFilters: FilterConfig[],
): PivotQuery | null => {
  if (!query) return null;

  const baseFilters = query.filters ?? [];
  if (globalFilters.length === 0) {
    return { ...query, filters: baseFilters };
  }

  const dataset = getDataset(query.datasetId);
  if (!dataset) {
    return { ...query, filters: baseFilters };
  }

  const allowedFields = new Set(dataset.fields.map((field) => field.id));
  const applicableFilters = globalFilters.filter((filter) =>
    allowedFields.has(filter.field),
  );

  return { ...query, filters: [...baseFilters, ...applicableFilters] };
};
</file>

<file path="src/features/bi/components/dashboard/DashboardCanvas.tsx">
import "react-grid-layout/css/styles.css";
import "react-resizable/css/styles.css";
import ReactGridLayout, {
  WidthProvider,
  type Layout,
  type LegacyReactGridLayoutProps,
} from "react-grid-layout/legacy";
import { DashboardWidget } from "./DashboardWidget";
import type { FilterConfig, WidgetType } from "../../bi.schemas";
import type { WidgetConfig } from "../../bi.types";

const GridLayout = WidthProvider(ReactGridLayout);

type WidgetPosition = {
  x: number;
  y: number;
  w: number;
  h: number;
};

export function DashboardCanvas({
  layout,
  widgets,
  globalFilters = [],
  editable,
  onPositionChange,
  onRemoveWidget,
}: {
  layout: {
    columns: number;
    rowHeight: number;
    compactType: "vertical" | "horizontal" | null;
  };
  widgets: Array<{
    id: string;
    widgetType: WidgetType;
    x: number;
    y: number;
    w: number;
    h: number;
    config?: WidgetConfig | null;
  }>;
  globalFilters?: FilterConfig[];
  editable: boolean;
  onPositionChange: (widgetId: string, position: WidgetPosition) => void;
  onRemoveWidget: (widgetId: string) => void;
}) {
  const gridLayout: Layout = widgets.map((widget) => ({
    i: widget.id,
    x: widget.x,
    y: widget.y,
    w: widget.w,
    h: widget.h,
    minW: 2,
    minH: 2,
  }));

  const handleLayoutChange: LegacyReactGridLayoutProps["onDragStop"] = (
    _layout,
    _oldItem,
    newItem,
  ) => {
    if (!editable) return;
    if (!newItem) return;
    onPositionChange(newItem.i, {
      x: newItem.x,
      y: newItem.y,
      w: newItem.w,
      h: newItem.h,
    });
  };

  const handleResizeStop: LegacyReactGridLayoutProps["onResizeStop"] = (
    _layout,
    _oldItem,
    newItem,
  ) => {
    if (!editable) return;
    if (!newItem) return;
    onPositionChange(newItem.i, {
      x: newItem.x,
      y: newItem.y,
      w: newItem.w,
      h: newItem.h,
    });
  };

  return (
    <GridLayout
      key={editable ? "dashboard-edit" : "dashboard-view"}
      className="layout"
      cols={layout.columns}
      rowHeight={layout.rowHeight}
      compactType={layout.compactType}
      isDraggable={editable}
      isResizable={editable}
      layout={gridLayout}
      onDragStop={handleLayoutChange}
      onResizeStop={handleResizeStop}
      margin={[16, 16]}
      containerPadding={[0, 0]}
    >
      {widgets.map((widget) => (
        <div
          key={widget.id}
          data-grid={{ x: widget.x, y: widget.y, w: widget.w, h: widget.h }}
        >
          {[
            <DashboardWidget
              key={`widget-${widget.id}`}
              widget={widget}
              globalFilters={globalFilters}
              editable={editable}
              onRemove={() => onRemoveWidget(widget.id)}
            />,
          ]}
        </div>
      ))}
    </GridLayout>
  );
}
</file>

<file path="src/features/bi/components/dashboard/DashboardExportDialog.tsx">
import { useEffect, useMemo, useState } from "react";
import { useMutation } from "@tanstack/react-query";
import { toast } from "sonner";
import { Button } from "~/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "~/components/ui/dialog";
import { Label } from "~/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";
import { getStepUpErrorMessage, useStepUpPrompt } from "~/features/auth/step-up";
import { exportPivotResults } from "~/features/bi/bi.mutations";
import type { FilterConfig, PivotQuery } from "~/features/bi/bi.schemas";
import { mergeDashboardFilters } from "~/features/bi/components/dashboard/dashboard-utils";

type ExportFormat = "csv" | "xlsx" | "json";

export type ExportableWidget = {
  id: string;
  title: string;
  query?: PivotQuery | null;
};

export function DashboardExportDialog({
  open,
  onOpenChange,
  widgets,
  globalFilters,
}: {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  widgets: ExportableWidget[];
  globalFilters: FilterConfig[];
}) {
  const { requestStepUp } = useStepUpPrompt();
  const exportableWidgets = useMemo(
    () => widgets.filter((widget) => widget.query),
    [widgets],
  );
  const [selectedWidgetId, setSelectedWidgetId] = useState("");
  const [format, setFormat] = useState<ExportFormat>("csv");

  useEffect(() => {
    if (!open) return;
    setSelectedWidgetId(exportableWidgets[0]?.id ?? "");
    setFormat("csv");
  }, [open, exportableWidgets]);

  const selectedWidget = useMemo(
    () => exportableWidgets.find((widget) => widget.id === selectedWidgetId) ?? null,
    [exportableWidgets, selectedWidgetId],
  );

  const mergedQuery = useMemo(
    () => mergeDashboardFilters(selectedWidget?.query ?? null, globalFilters),
    [selectedWidget, globalFilters],
  );

  const exportMutation = useMutation({
    mutationFn: async () => {
      if (!mergedQuery) {
        throw new Error("Select a widget to export.");
      }
      return exportPivotResults({
        data: {
          pivotQuery: mergedQuery,
          format,
        },
      });
    },
    onSuccess: (result) => {
      if (!result?.data) {
        toast.error("No export data returned.");
        return;
      }

      const encoding = result.encoding ?? "utf-8";
      const blobData =
        encoding === "base64"
          ? Uint8Array.from(atob(result.data), (char) => char.charCodeAt(0))
          : result.data;
      const blob = new Blob([blobData], {
        type: result.mimeType ?? "text/csv",
      });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = result.fileName ?? "dashboard-export.csv";
      link.click();
      URL.revokeObjectURL(url);
      onOpenChange(false);
    },
    onError: (error) => {
      const message = getStepUpErrorMessage(error);
      if (message) {
        requestStepUp(message);
        return;
      }
      toast.error(error instanceof Error ? error.message : "Dashboard export failed.");
    },
  });

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Export dashboard data</DialogTitle>
          <DialogDescription>
            Download data for a specific widget on this dashboard.
          </DialogDescription>
        </DialogHeader>

        {exportableWidgets.length === 0 ? (
          <p className="text-muted-foreground text-sm">
            Add a chart, pivot, or KPI widget to export data.
          </p>
        ) : (
          <div className="space-y-4">
            <div className="space-y-2">
              <Label>Widget</Label>
              <Select value={selectedWidgetId} onValueChange={setSelectedWidgetId}>
                <SelectTrigger>
                  <SelectValue placeholder="Select widget" />
                </SelectTrigger>
                <SelectContent>
                  {exportableWidgets.map((widget) => (
                    <SelectItem key={widget.id} value={widget.id}>
                      {widget.title}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            <div className="space-y-2">
              <Label>Format</Label>
              <Select
                value={format}
                onValueChange={(value) => setFormat(value as ExportFormat)}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Select format" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="csv">CSV</SelectItem>
                  <SelectItem value="xlsx">Excel</SelectItem>
                  <SelectItem value="json">JSON</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
        )}

        <DialogFooter>
          <Button variant="outline" onClick={() => onOpenChange(false)}>
            Cancel
          </Button>
          <Button
            onClick={() => exportMutation.mutate()}
            disabled={!mergedQuery || exportMutation.isPending}
          >
            Export data
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/features/bi/components/dashboard/DashboardFilters.tsx">
import type { FilterConfig } from "../../bi.schemas";
import type { DatasetField } from "../../bi.types";
import { FilterBuilder } from "../filters/FilterBuilder";

const renderFilterLabel = (filter: FilterConfig) => {
  const value = Array.isArray(filter.value)
    ? filter.value.join(", ")
    : filter.value ?? "";
  return `${filter.field} ${filter.operator} ${value}`.trim();
};

export function DashboardFilters({
  fields,
  filters,
  editable,
  onChange,
}: {
  fields?: DatasetField[];
  filters: FilterConfig[];
  editable?: boolean;
  onChange?: (next: FilterConfig[]) => void;
}) {
  if (editable && fields && onChange) {
    return <FilterBuilder fields={fields} filters={filters} onChange={onChange} />;
  }

  if (filters.length === 0) {
    return (
      <div className="text-muted-foreground text-xs">No global filters applied.</div>
    );
  }

  return (
    <div className="flex flex-wrap gap-2 text-xs">
      {filters.map((filter, index) => (
        <span
          key={`${filter.field}-${index}`}
          className="rounded-full border bg-muted px-2 py-1"
        >
          {renderFilterLabel(filter)}
        </span>
      ))}
    </div>
  );
}
</file>

<file path="src/features/bi/components/dashboard/DashboardShareDialog.tsx">
import { Button } from "~/components/ui/button";
import { Checkbox } from "~/components/ui/checkbox";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "~/components/ui/dialog";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";

type DashboardShareDialogProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  sharedWith: string;
  isOrgWide: boolean;
  onSharedWithChange: (value: string) => void;
  onOrgWideChange: (value: boolean) => void;
  onSave: () => void;
  isSaving?: boolean;
};

export function DashboardShareDialog({
  open,
  onOpenChange,
  sharedWith,
  isOrgWide,
  onSharedWithChange,
  onOrgWideChange,
  onSave,
  isSaving = false,
}: DashboardShareDialogProps) {
  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Share dashboard</DialogTitle>
          <DialogDescription>
            Control who can access this dashboard.
          </DialogDescription>
        </DialogHeader>
        <div className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="dashboard-share-users">Share with users</Label>
            <Input
              id="dashboard-share-users"
              placeholder="user-id-1, user-id-2"
              value={sharedWith}
              onChange={(event) => onSharedWithChange(event.target.value)}
            />
            <p className="text-muted-foreground text-xs">
              Provide user IDs separated by commas.
            </p>
          </div>
          <div className="flex items-start gap-2">
            <Checkbox
              id="dashboard-share-org"
              checked={isOrgWide}
              onCheckedChange={(value) => onOrgWideChange(Boolean(value))}
            />
            <Label htmlFor="dashboard-share-org" className="text-sm">
              Share with entire organization
            </Label>
          </div>
        </div>
        <DialogFooter>
          <Button variant="outline" onClick={() => onOpenChange(false)}>
            Cancel
          </Button>
          <Button onClick={onSave} disabled={isSaving}>
            Save sharing settings
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/features/bi/components/dashboard/DashboardWidget.tsx">
import { useMemo } from "react";
import { useQuery } from "@tanstack/react-query";
import type {
  ChartType,
  FilterConfig,
  PivotQuery,
  PivotResult,
} from "~/features/bi/bi.schemas";
import type { WidgetConfig } from "~/features/bi/bi.types";
import { executePivotQuery } from "~/features/bi/bi.queries";
import { buildPivotChartOptions } from "~/features/bi/components/charts/pivot-chart";
import { ChartContainer } from "~/features/bi/components/charts/ChartContainer";
import { KpiCard } from "~/features/bi/components/charts/KpiCard";
import { PivotTable } from "~/features/bi/components/pivot-table/PivotTable";
import { mergeDashboardFilters } from "~/features/bi/components/dashboard/dashboard-utils";
import { WidgetToolbar } from "~/features/bi/components/dashboard/WidgetToolbar";

const sumMeasure = (pivot: PivotResult, measureKey: string) => {
  const values = pivot.rows.flatMap((row) =>
    pivot.columnKeys.map((column) => row.cells[column.key]?.[measureKey] ?? null),
  );
  const hasValue = values.some((value) => typeof value === "number");
  if (!hasValue) return null;
  return values.reduce<number>((acc, value) => acc + (value ?? 0), 0);
};

export function DashboardWidget({
  widget,
  globalFilters = [],
  onRemove,
  editable = false,
}: {
  widget: {
    id: string;
    widgetType: string;
    config?: WidgetConfig | null;
  };
  globalFilters?: FilterConfig[];
  onRemove?: () => void;
  editable?: boolean;
}) {
  const config = (widget.config ?? {}) as WidgetConfig;
  const query = config.query;

  const mergedQuery = useMemo(
    () => mergeDashboardFilters(query ?? null, globalFilters),
    [query, globalFilters],
  );

  const queryKey = useMemo(() => {
    return [
      "bi-widget",
      widget.id,
      mergedQuery ? JSON.stringify(mergedQuery) : "none",
    ];
  }, [widget.id, mergedQuery]);

  const pivotQuery = useQuery({
    queryKey,
    queryFn: () =>
      mergedQuery
        ? executePivotQuery({ data: { ...mergedQuery } })
        : Promise.resolve(null),
    enabled:
      Boolean(mergedQuery) &&
      !editable &&
      (widget.widgetType === "chart" ||
        widget.widgetType === "pivot" ||
        widget.widgetType === "kpi"),
  });

  const pivot = pivotQuery.data?.pivot ?? null;

  const measureKey = pivot?.measures?.[0]?.key ?? "";
  const chartType = config.chartType ?? "bar";
  const chartOptions =
    pivot && measureKey ? buildPivotChartOptions(pivot, chartType, measureKey) : null;

  return (
    <div
      className="flex h-full flex-col overflow-hidden rounded-md border bg-background"
      data-testid="dashboard-widget"
    >
      <WidgetToolbar
        title={config.title ?? "Widget"}
        {...(editable && onRemove ? { onRemove } : {})}
      />
      <div className="flex-1 overflow-auto p-3">
        {widget.widgetType === "text" ? (
          <p className="text-sm whitespace-pre-wrap">
            {config.textContent ?? "No content"}
          </p>
        ) : widget.widgetType === "kpi" ? (
          pivot ? (
            <KpiCard
              title={config.title ?? "KPI"}
              value={sumMeasure(pivot, measureKey) ?? "-"}
              {...(config.subtitle ? { subtitle: config.subtitle } : {})}
            />
          ) : (
            <p className="text-muted-foreground text-sm">No data</p>
          )
        ) : widget.widgetType === "pivot" ? (
          pivot ? (
            <PivotTable pivot={pivot} />
          ) : (
            <p className="text-muted-foreground text-sm">No data</p>
          )
        ) : widget.widgetType === "chart" ? (
          editable ? (
            <p className="text-muted-foreground text-sm">
              Chart preview disabled while editing.
            </p>
          ) : chartOptions ? (
            <ChartContainer option={chartOptions} />
          ) : (
            <p className="text-muted-foreground text-sm">No data</p>
          )
        ) : (
          <p className="text-muted-foreground text-sm">Unsupported widget</p>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/features/bi/components/dashboard/WidgetToolbar.tsx">
import { Button } from "~/components/ui/button";
import { Trash2 } from "lucide-react";

export function WidgetToolbar({
  title,
  onRemove,
}: {
  title?: string;
  onRemove?: () => void;
}) {
  return (
    <div className="flex items-center justify-between gap-2 border-b px-3 py-2">
      <span className="text-sm font-medium">{title ?? "Widget"}</span>
      {onRemove ? (
        <Button type="button" variant="ghost" size="icon" onClick={onRemove}>
          <Trash2 className="h-4 w-4" />
        </Button>
      ) : null}
    </div>
  );
}
</file>

<file path="src/features/bi/components/filters/DateFilter.tsx">
import { Input } from "~/components/ui/input";
import type { FilterOperator, FilterValue } from "../../bi.schemas";

export function DateFilter({
  operator,
  value,
  onChange,
}: {
  operator: FilterOperator;
  value: FilterValue | undefined;
  onChange: (next: FilterValue | undefined) => void;
}) {
  if (operator === "between") {
    const range = Array.isArray(value) ? value : ["", ""];
    return (
      <div className="flex items-center gap-2">
        <Input
          type="date"
          value={String(range[0] ?? "")}
          onChange={(event) => onChange([event.target.value, range[1] ?? ""])}
        />
        <span className="text-muted-foreground text-xs">to</span>
        <Input
          type="date"
          value={String(range[1] ?? "")}
          onChange={(event) => onChange([range[0] ?? "", event.target.value])}
        />
      </div>
    );
  }

  return (
    <Input
      type="date"
      value={typeof value === "string" ? value : ""}
      onChange={(event) => onChange(event.target.value)}
    />
  );
}
</file>

<file path="src/features/bi/components/filters/EnumFilter.tsx">
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";
import { Input } from "~/components/ui/input";
import type { FilterOperator, FilterValue } from "../../bi.schemas";

const parseList = (value: string) =>
  value
    .split(",")
    .map((entry) => entry.trim())
    .filter(Boolean);

export function EnumFilter({
  operator,
  value,
  enumValues,
  onChange,
}: {
  operator: FilterOperator;
  value: FilterValue | undefined;
  enumValues?: Array<{ value: string; label: string }>;
  onChange: (next: FilterValue | undefined) => void;
}) {
  if (operator === "in" || operator === "not_in") {
    return (
      <Input
        placeholder="Comma-separated values"
        value={Array.isArray(value) ? value.join(", ") : ""}
        onChange={(event) => onChange(parseList(event.target.value))}
      />
    );
  }

  if (enumValues && enumValues.length > 0) {
    return (
      <Select
        value={typeof value === "string" ? value : ""}
        onValueChange={(next) => onChange(next)}
      >
        <SelectTrigger>
          <SelectValue placeholder="Select value" />
        </SelectTrigger>
        <SelectContent>
          {enumValues.map((entry) => (
            <SelectItem key={entry.value} value={entry.value}>
              {entry.label}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    );
  }

  return (
    <Input
      placeholder="Value"
      value={typeof value === "string" ? value : ""}
      onChange={(event) => onChange(event.target.value)}
    />
  );
}
</file>

<file path="src/features/bi/components/filters/FilterBuilder.tsx">
import { useMemo } from "react";
import { Plus, X } from "lucide-react";
import { Button } from "~/components/ui/button";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";
import type { DatasetConfig, DatasetField } from "../../bi.types";
import type { FilterConfig, FilterOperator } from "../../bi.schemas";
import { buildAllowedFilters } from "../../bi.utils";
import { DateFilter } from "./DateFilter";
import { EnumFilter } from "./EnumFilter";
import { FilterGroup } from "./FilterGroup";
import { NumericFilter } from "./NumericFilter";

const operatorLabels: Record<FilterOperator, string> = {
  eq: "Equals",
  neq: "Not equals",
  gt: ">",
  gte: ">=",
  lt: "<",
  lte: "<=",
  in: "In",
  not_in: "Not in",
  between: "Between",
  contains: "Contains",
  starts_with: "Starts with",
  ends_with: "Ends with",
  is_null: "Is null",
  is_not_null: "Is not null",
};

const buildDatasetStub = (fields: DatasetField[]): DatasetConfig => ({
  id: "filters",
  name: "Filters",
  baseTable: "filters",
  fields,
});

const getDefaultOperator = (operators: FilterOperator[]) => operators[0] ?? "eq";

const isNullOperator = (operator: FilterOperator) =>
  operator === "is_null" || operator === "is_not_null";

const parseList = (value: string) =>
  value
    .split(",")
    .map((entry) => entry.trim())
    .filter(Boolean);

export function FilterBuilder({
  fields,
  filters,
  onChange,
}: {
  fields: DatasetField[];
  filters: FilterConfig[];
  onChange: (next: FilterConfig[]) => void;
}) {
  const filterableFields = fields.filter((field) => field.allowFilter);
  const allowedFilters = useMemo(
    () => buildAllowedFilters(buildDatasetStub(filterableFields)),
    [filterableFields],
  );

  const updateFilter = (index: number, patch: Partial<FilterConfig>) => {
    onChange(filters.map((filter, idx) => (idx === index ? { ...filter, ...patch } : filter)));
  };

  const handleAddFilter = () => {
    const firstField = filterableFields[0];
    if (!firstField) return;
    const operators = allowedFilters[firstField.id]?.operators ?? [];
    onChange([
      ...filters,
      {
        field: firstField.id,
        operator: getDefaultOperator(operators),
        value: "",
      },
    ]);
  };

  const handleRemove = (index: number) => {
    onChange(filters.filter((_, idx) => idx !== index));
  };

  return (
    <FilterGroup title="Filters">
      {filters.length === 0 ? (
        <p className="text-muted-foreground text-xs">No filters applied.</p>
      ) : null}
      {filters.map((filter, index) => {
        const field = filterableFields.find((item) => item.id === filter.field);
        const operators = field ? allowedFilters[field.id]?.operators ?? [] : [];

        return (
          <div key={`${filter.field}-${index}`} className="grid gap-2 md:grid-cols-[2fr_1fr_2fr_auto]">
            <div className="space-y-1">
              <Label className="text-xs">Field</Label>
              <Select
                value={filter.field}
                onValueChange={(value) => {
                  const nextField = filterableFields.find((item) => item.id === value);
                  if (!nextField) return;
                  const nextOperators = allowedFilters[nextField.id]?.operators ?? [];
                  updateFilter(index, {
                    field: value,
                    operator: getDefaultOperator(nextOperators),
                    value: "",
                  });
                }}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Select field" />
                </SelectTrigger>
                <SelectContent>
                  {filterableFields.map((field) => (
                    <SelectItem key={field.id} value={field.id}>
                      {field.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-1">
              <Label className="text-xs">Operator</Label>
              <Select
                value={filter.operator}
                onValueChange={(value) => {
                  const operator = value as FilterOperator;
                  updateFilter(index, {
                    operator,
                    value: isNullOperator(operator) ? undefined : filter.value,
                  });
                }}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Operator" />
                </SelectTrigger>
                <SelectContent>
                  {operators.map((operator) => (
                    <SelectItem key={operator} value={operator}>
                      {operatorLabels[operator] ?? operator}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-1">
              <Label className="text-xs">Value</Label>
              {field && !isNullOperator(filter.operator) ? (
                field.dataType === "number" ? (
                  <NumericFilter
                    operator={filter.operator}
                    value={filter.value}
                    onChange={(next) => updateFilter(index, { value: next })}
                  />
                ) : field.dataType === "datetime" || field.dataType === "date" ? (
                  <DateFilter
                    operator={filter.operator}
                    value={filter.value}
                    onChange={(next) => updateFilter(index, { value: next })}
                  />
                ) : field.dataType === "enum" ? (
                  <EnumFilter
                    operator={filter.operator}
                    value={filter.value}
                    enumValues={field.enumValues ?? []}
                    onChange={(next) => updateFilter(index, { value: next })}
                  />
                ) : field.dataType === "boolean" ? (
                  <Select
                    value={typeof filter.value === "boolean" ? String(filter.value) : ""}
                    onValueChange={(next) => updateFilter(index, { value: next === "true" })}
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="Select" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="true">True</SelectItem>
                      <SelectItem value="false">False</SelectItem>
                    </SelectContent>
                  </Select>
                ) : filter.operator === "in" || filter.operator === "not_in" ? (
                  <Input
                    placeholder="Comma-separated values"
                    value={Array.isArray(filter.value) ? filter.value.join(", ") : ""}
                    onChange={(event) =>
                      updateFilter(index, { value: parseList(event.target.value) })
                    }
                  />
                ) : (
                  <Input
                    placeholder="Value"
                    value={typeof filter.value === "string" ? filter.value : ""}
                    onChange={(event) => updateFilter(index, { value: event.target.value })}
                  />
                )
              ) : (
                <div className="text-muted-foreground text-xs">No value required</div>
              )}
            </div>

            <div className="flex items-end">
              <Button
                type="button"
                variant="ghost"
                size="icon"
                onClick={() => handleRemove(index)}
              >
                <X className="h-4 w-4" />
              </Button>
            </div>
          </div>
        );
      })}
      <Button type="button" variant="outline" size="sm" onClick={handleAddFilter}>
        <Plus className="mr-2 h-4 w-4" />
        Add filter
      </Button>
    </FilterGroup>
  );
}
</file>

<file path="src/features/bi/components/filters/FilterGroup.tsx">
import type { ReactNode } from "react";
import { Label } from "~/components/ui/label";

export function FilterGroup({ title, children }: { title: string; children: ReactNode }) {
  return (
    <div className="space-y-2 rounded-md border bg-muted/20 p-3">
      <Label className="text-xs uppercase tracking-wide text-muted-foreground">
        {title}
      </Label>
      <div className="space-y-2">{children}</div>
    </div>
  );
}
</file>

<file path="src/features/bi/components/filters/NumericFilter.tsx">
import { Input } from "~/components/ui/input";
import type { FilterOperator, FilterValue } from "../../bi.schemas";

const toNumberValue = (value: FilterValue | undefined) => {
  if (typeof value === "number") return String(value);
  if (typeof value === "string") return value;
  return "";
};

export function NumericFilter({
  operator,
  value,
  onChange,
}: {
  operator: FilterOperator;
  value: FilterValue | undefined;
  onChange: (next: FilterValue | undefined) => void;
}) {
  if (operator === "between") {
    const range = Array.isArray(value) ? value : ["", ""];
    return (
      <div className="flex items-center gap-2">
        <Input
          type="number"
          value={toNumberValue(range[0] as FilterValue)}
          onChange={(event) => onChange([event.target.value, range[1] ?? ""])}
        />
        <span className="text-muted-foreground text-xs">to</span>
        <Input
          type="number"
          value={toNumberValue(range[1] as FilterValue)}
          onChange={(event) => onChange([range[0] ?? "", event.target.value])}
        />
      </div>
    );
  }

  if (operator === "in" || operator === "not_in") {
    return (
      <Input
        placeholder="Comma-separated values"
        value={Array.isArray(value) ? value.join(", ") : ""}
        onChange={(event) =>
          onChange(
            event.target.value
              .split(",")
              .map((entry) => entry.trim())
              .filter(Boolean),
          )
        }
      />
    );
  }

  return (
    <Input
      type="number"
      value={toNumberValue(value)}
      onChange={(event) => onChange(event.target.value)}
    />
  );
}
</file>

<file path="src/features/bi/components/pivot-builder/DropZone.tsx">
import { useDroppable } from "@dnd-kit/core";
import { SortableContext, verticalListSortingStrategy } from "@dnd-kit/sortable";
import { Label } from "~/components/ui/label";

export function DropZone({
  id,
  label,
  items,
  renderItem,
}: {
  id: string;
  label: string;
  items: string[];
  renderItem: (item: string) => React.ReactNode;
}) {
  const { setNodeRef, isOver } = useDroppable({ id });

  return (
    <div className="space-y-2">
      <Label>{label}</Label>
      <div
        ref={setNodeRef}
        className={`rounded-md border p-2 ${isOver ? "bg-muted/40" : "bg-muted/20"}`}
        data-testid={`${id}-dropzone`}
      >
        <SortableContext items={items} strategy={verticalListSortingStrategy}>
          <div className="space-y-2">
            {items.length === 0 ? (
              <p className="text-muted-foreground text-xs">Drop fields here</p>
            ) : (
              items.map((item) => <div key={item}>{renderItem(item)}</div>)
            )}
          </div>
        </SortableContext>
      </div>
    </div>
  );
}
</file>

<file path="src/features/bi/components/pivot-builder/FieldPalette.tsx">
import type { DatasetField } from "../../bi.types";
import { DropZone } from "./DropZone";

export function FieldPalette({
  availableFields,
  fieldsById,
  renderItem,
}: {
  availableFields: string[];
  fieldsById: Map<string, DatasetField>;
  renderItem: (fieldId: string, label: string) => React.ReactNode;
}) {
  return (
    <DropZone
      id="available"
      label="Available fields"
      items={availableFields}
      renderItem={(item) => renderItem(item, fieldsById.get(item)?.name ?? item)}
    />
  );
}
</file>

<file path="src/features/bi/components/pivot-builder/FilterPanel.tsx">
import type { DatasetField } from "../../bi.types";
import type { FilterConfig } from "../../bi.schemas";
import { FilterBuilder } from "../filters/FilterBuilder";

export function FilterPanel({
  fields,
  filters,
  onChange,
}: {
  fields: DatasetField[];
  filters: FilterConfig[];
  onChange: (next: FilterConfig[]) => void;
}) {
  return <FilterBuilder fields={fields} filters={filters} onChange={onChange} />;
}
</file>

<file path="src/features/bi/components/pivot-builder/MeasureConfig.tsx">
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";
import { Button } from "~/components/ui/button";
import { Trash2 } from "lucide-react";
import type { AggregationType } from "../../bi.schemas";

const aggregationLabels: Record<AggregationType, string> = {
  count: "Count",
  sum: "Sum",
  avg: "Average",
  min: "Min",
  max: "Max",
  count_distinct: "Count distinct",
  median: "Median",
  stddev: "Std dev",
  variance: "Variance",
};

export function MeasureConfig({
  aggregation,
  options,
  onChange,
  onRemove,
}: {
  aggregation: AggregationType;
  options: AggregationType[];
  onChange: (next: AggregationType) => void;
  onRemove?: () => void;
}) {
  return (
    <div className="flex items-center gap-2">
      <Select value={aggregation} onValueChange={(value) => onChange(value as AggregationType)}>
        <SelectTrigger className="h-7 w-36">
          <SelectValue />
        </SelectTrigger>
        <SelectContent>
          {options.map((option) => (
            <SelectItem key={option} value={option}>
              {aggregationLabels[option] ?? option}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
      {onRemove ? (
        <Button type="button" variant="ghost" size="icon" onClick={onRemove}>
          <Trash2 className="h-4 w-4" />
        </Button>
      ) : null}
    </div>
  );
}
</file>

<file path="src/features/bi/components/pivot-builder/PivotBuilder.tsx">
import {
  DndContext,
  PointerSensor,
  closestCenter,
  useSensor,
  useSensors,
  type DragEndEvent,
} from "@dnd-kit/core";
import { arrayMove, useSortable } from "@dnd-kit/sortable";
import { CSS } from "@dnd-kit/utilities";
import { useMutation, useQuery } from "@tanstack/react-query";
import { useEffect, useMemo, useState } from "react";
import { toast } from "sonner";
import { Badge } from "~/components/ui/badge";
import { Button } from "~/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";
import { Checkbox } from "~/components/ui/checkbox";
import { Label } from "~/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";
import { getStepUpErrorMessage, useStepUpPrompt } from "~/features/auth/step-up";
import { useOrgContext } from "~/features/organizations/org-context";
import type { AggregationType, ChartType, FilterConfig, PivotResult } from "../..";
import type { DatasetField } from "../../bi.types";
import { exportPivotResults } from "../../bi.mutations";
import { executePivotQuery, getAvailableDatasets, getDatasetFields } from "../../bi.queries";
import { DropZone } from "./DropZone";
import { FieldPalette } from "./FieldPalette";
import { FilterPanel } from "./FilterPanel";
import { MeasureConfig } from "./MeasureConfig";
import { PivotPreview } from "./PivotPreview";

const chartOptions: Array<{ value: ChartType; label: string }> = [
  { value: "table", label: "Table" },
  { value: "bar", label: "Bar" },
  { value: "line", label: "Line" },
  { value: "area", label: "Area" },
  { value: "pie", label: "Pie" },
  { value: "donut", label: "Donut" },
  { value: "heatmap", label: "Heatmap" },
  { value: "scatter", label: "Scatter" },
  { value: "kpi", label: "KPI" },
];

const baseAggregations: AggregationType[] = [
  "count",
  "sum",
  "avg",
  "min",
  "max",
  "count_distinct",
  "median",
  "stddev",
  "variance",
];

const nonNumericAggregations: AggregationType[] = ["count", "count_distinct"];

const aggregationOptionsForField = (
  field: DatasetField | undefined,
): AggregationType[] => {
  if (!field) return baseAggregations;
  if (field.dataType === "number") return baseAggregations;
  return nonNumericAggregations;
};

function SortableField({
  id,
  label,
  children,
}: {
  id: string;
  label: string;
  children?: React.ReactNode;
}) {
  const { attributes, listeners, setNodeRef, transform, transition, isDragging } =
    useSortable({ id });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
  } as React.CSSProperties;

  return (
    <div
      ref={setNodeRef}
      style={style}
      className="flex items-center justify-between gap-2 rounded-md border bg-background px-3 py-2 text-sm"
      data-testid={`field-${id}`}
    >
      <span {...attributes} {...listeners} className="cursor-grab text-xs font-medium">
        {label}
      </span>
      {children}
    </div>
  );
}

export function PivotBuilder() {
  const { activeOrganizationId } = useOrgContext();
  const { requestStepUp } = useStepUpPrompt();
  const [datasetId, setDatasetId] = useState<string>("");
  const [rows, setRows] = useState<string[]>([]);
  const [columns, setColumns] = useState<string[]>([]);
  const [measures, setMeasures] = useState<
    Array<{ field: string; aggregation: AggregationType }>
  >([]);
  const [filters, setFilters] = useState<FilterConfig[]>([]);
  const [chartType, setChartType] = useState<ChartType>("table");
  const [pivotResult, setPivotResult] = useState<PivotResult | null>(null);
  const [selectedMeasureKey, setSelectedMeasureKey] = useState<string>("");
  const [showRowTotals, setShowRowTotals] = useState(true);
  const [showColumnTotals, setShowColumnTotals] = useState(true);
  const [showGrandTotal, setShowGrandTotal] = useState(true);

  const sensors = useSensors(useSensor(PointerSensor));

  const datasetsQuery = useQuery({
    queryKey: ["bi-datasets"],
    queryFn: () => getAvailableDatasets(),
  });

  const fieldsQuery = useQuery({
    queryKey: ["bi-fields", datasetId],
    queryFn: () =>
      datasetId ? getDatasetFields({ data: { datasetId } }) : Promise.resolve(null),
    enabled: Boolean(datasetId),
  });

  const datasets = datasetsQuery.data?.datasets ?? [];
  const fields = (fieldsQuery.data?.fields ?? []) as DatasetField[];
  const fieldsById = useMemo(
    () => new Map(fields.map((field) => [field.id, field])),
    [fields],
  );

  const usedFields = new Set([
    ...rows,
    ...columns,
    ...measures.map((item) => item.field),
  ]);

  const availableFields = fields
    .filter((field) => !usedFields.has(field.id))
    .map((field) => field.id);

  useEffect(() => {
    if (!datasetId && datasets.length > 0) {
      setDatasetId(datasets[0]?.id ?? "");
    }
  }, [datasetId, datasets]);

  useEffect(() => {
    setRows([]);
    setColumns([]);
    setMeasures([]);
    setFilters([]);
    setPivotResult(null);
    setSelectedMeasureKey("");
  }, [datasetId]);

  const runMutation = useMutation({
    mutationFn: async () => {
      if (!datasetId) {
        throw new Error("Select a dataset to run a query.");
      }
      if (measures.length === 0) {
        throw new Error("Add at least one measure.");
      }

      return executePivotQuery({
        data: {
          datasetId,
          organizationId: activeOrganizationId ?? undefined,
          rows,
          columns,
          measures,
          filters,
        },
      });
    },
    onSuccess: (result) => {
      const pivot = result?.pivot ?? null;
      setPivotResult(pivot);
      if (pivot?.measures?.length) {
        setSelectedMeasureKey((prev) =>
          pivot.measures.some((measure) => measure.key === prev)
            ? prev
            : (pivot.measures[0]?.key ?? ""),
        );
      } else {
        setSelectedMeasureKey("");
      }
      toast.success("Pivot updated.");
    },
    onError: (error) => {
      toast.error(error instanceof Error ? error.message : "Failed to run pivot.");
    },
  });

  const exportMutation = useMutation({
    mutationFn: async (format: "csv" | "xlsx" | "json") => {
      if (!datasetId) {
        throw new Error("Select a dataset to export.");
      }
      if (measures.length === 0) {
        throw new Error("Add at least one measure before exporting.");
      }

      return exportPivotResults({
        data: {
          pivotQuery: {
            datasetId,
            organizationId: activeOrganizationId ?? undefined,
            rows,
            columns,
            measures,
            filters,
          },
          format,
        },
      });
    },
    onSuccess: (result) => {
      if (!result?.data) return;
      const encoding = result.encoding ?? "utf-8";
      const blobData =
        encoding === "base64"
          ? Uint8Array.from(atob(result.data), (char) => char.charCodeAt(0))
          : result.data;
      const blob = new Blob([blobData], {
        type: result.mimeType ?? "text/csv",
      });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = result.fileName ?? "pivot-export.csv";
      link.click();
      URL.revokeObjectURL(url);
    },
    onError: (error) => {
      const message = getStepUpErrorMessage(error);
      if (message) {
        requestStepUp(message);
        return;
      }
      toast.error(error instanceof Error ? error.message : "Pivot export failed.");
    },
  });

  const findContainer = (id: string) => {
    if (rows.includes(id)) return "rows";
    if (columns.includes(id)) return "columns";
    if (measures.some((item) => item.field === id)) return "measures";
    if (availableFields.includes(id)) return "available";
    return null;
  };

  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event;
    if (!over) return;

    const activeId = String(active.id);
    const overId = String(over.id);
    const activeContainer = findContainer(activeId);
    const overContainer =
      overId === "rows" ||
      overId === "columns" ||
      overId === "measures" ||
      overId === "available"
        ? overId
        : findContainer(overId);

    if (!activeContainer || !overContainer) return;

    if (activeContainer === overContainer) {
      if (activeContainer === "rows") {
        const oldIndex = rows.indexOf(activeId);
        const newIndex = rows.indexOf(overId);
        if (oldIndex !== -1 && newIndex !== -1 && oldIndex !== newIndex) {
          setRows(arrayMove(rows, oldIndex, newIndex));
        }
      }
      if (activeContainer === "columns") {
        const oldIndex = columns.indexOf(activeId);
        const newIndex = columns.indexOf(overId);
        if (oldIndex !== -1 && newIndex !== -1 && oldIndex !== newIndex) {
          setColumns(arrayMove(columns, oldIndex, newIndex));
        }
      }
      if (activeContainer === "measures") {
        const items = measures.map((item) => item.field);
        const oldIndex = items.indexOf(activeId);
        const newIndex = items.indexOf(overId);
        if (oldIndex !== -1 && newIndex !== -1 && oldIndex !== newIndex) {
          const ordered = arrayMove(items, oldIndex, newIndex);
          setMeasures(
            ordered.map((field) => measures.find((item) => item.field === field)!),
          );
        }
      }
      return;
    }

    const removeFrom = (container: string) => {
      if (container === "rows") setRows(rows.filter((item) => item !== activeId));
      if (container === "columns")
        setColumns(columns.filter((item) => item !== activeId));
      if (container === "measures") {
        setMeasures(measures.filter((item) => item.field !== activeId));
      }
    };

    const addTo = (container: string) => {
      const field = fieldsById.get(activeId);

      if (container === "rows") {
        if (!field?.allowGroupBy) {
          toast.error("This field cannot be used as a row.");
          return;
        }
        if (!rows.includes(activeId)) {
          setRows([...rows, activeId]);
        }
      }
      if (container === "columns") {
        if (!field?.allowGroupBy) {
          toast.error("This field cannot be used as a column.");
          return;
        }
        if (!columns.includes(activeId)) {
          setColumns([...columns, activeId]);
        }
      }
      if (container === "measures") {
        if (!field?.allowAggregate) {
          toast.error("This field cannot be used as a measure.");
          return;
        }
        if (!measures.some((item) => item.field === activeId)) {
          setMeasures([
            ...measures,
            {
              field: activeId,
              aggregation: field.defaultAggregation ?? "count",
            },
          ]);
        }
      }
    };

    if (overContainer === "available") {
      removeFrom(activeContainer);
      return;
    }

    removeFrom(activeContainer);
    addTo(overContainer);
  };

  const updateMeasure = (field: string, aggregation: AggregationType) => {
    setMeasures((prev) =>
      prev.map((item) => (item.field === field ? { ...item, aggregation } : item)),
    );
  };

  const removeMeasure = (field: string) => {
    setMeasures((prev) => prev.filter((item) => item.field !== field));
  };

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Pivot builder</CardTitle>
        </CardHeader>
        <CardContent className="space-y-6">
          <div className="grid gap-4 md:grid-cols-2">
            <div className="space-y-2">
              <Label>Dataset</Label>
              <Select value={datasetId} onValueChange={setDatasetId}>
                <SelectTrigger>
                  <SelectValue placeholder="Select dataset" />
                </SelectTrigger>
                <SelectContent>
                  {datasets.map((dataset) => (
                    <SelectItem key={dataset.id} value={dataset.id}>
                      {dataset.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <p className="text-muted-foreground text-xs">
                {datasets.find((dataset) => dataset.id === datasetId)?.description ??
                  "Select a dataset to begin."}
              </p>
            </div>
            <div className="space-y-2">
              <Label>Chart type</Label>
              <Select
                value={chartType}
                onValueChange={(value) => setChartType(value as ChartType)}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Select chart" />
                </SelectTrigger>
                <SelectContent>
                  {chartOptions.map((option) => (
                    <SelectItem key={option.value} value={option.value}>
                      {option.label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          </div>

          <FilterPanel fields={fields} filters={filters} onChange={setFilters} />

          <DndContext
            sensors={sensors}
            collisionDetection={closestCenter}
            onDragEnd={handleDragEnd}
          >
            <div className="grid gap-4 lg:grid-cols-4">
              <FieldPalette
                availableFields={availableFields}
                fieldsById={fieldsById}
                renderItem={(item, label) => (
                  <SortableField id={item} label={label} />
                )}
              />
              <DropZone
                id="rows"
                label="Rows"
                items={rows}
                renderItem={(item) => (
                  <SortableField id={item} label={fieldsById.get(item)?.name ?? item} />
                )}
              />
              <DropZone
                id="columns"
                label="Columns"
                items={columns}
                renderItem={(item) => (
                  <SortableField id={item} label={fieldsById.get(item)?.name ?? item} />
                )}
              />
              <DropZone
                id="measures"
                label="Measures"
                items={measures.map((item) => item.field)}
                renderItem={(item) => {
                  const measure = measures.find((entry) => entry.field === item);
                  const field = fieldsById.get(item);
                  return (
                    <SortableField id={item} label={field?.name ?? item}>
                      <MeasureConfig
                        aggregation={measure?.aggregation ?? "count"}
                        options={aggregationOptionsForField(field)}
                        onChange={(next) => updateMeasure(item, next)}
                        onRemove={() => removeMeasure(item)}
                      />
                    </SortableField>
                  );
                }}
              />
            </div>
          </DndContext>

          <div className="flex flex-wrap items-center gap-3">
            <Button size="sm" onClick={() => runMutation.mutate()}>
              Run query
            </Button>
            <Button
              size="sm"
              variant="outline"
              onClick={() => exportMutation.mutate("csv")}
            >
              Export CSV
            </Button>
            <Button
              size="sm"
              variant="outline"
              onClick={() => exportMutation.mutate("xlsx")}
            >
              Export Excel
            </Button>
            <Button
              size="sm"
              variant="outline"
              onClick={() => exportMutation.mutate("json")}
            >
              Export JSON
            </Button>
            <Badge variant="secondary">{activeOrganizationId ?? "No org"}</Badge>
          </div>

          <div className="flex flex-wrap items-center gap-4">
            <div className="flex items-center gap-2">
              <Checkbox
                id="rowTotals"
                checked={showRowTotals}
                onCheckedChange={(value) => setShowRowTotals(Boolean(value))}
              />
              <Label htmlFor="rowTotals" className="text-xs">
                Row totals
              </Label>
            </div>
            <div className="flex items-center gap-2">
              <Checkbox
                id="columnTotals"
                checked={showColumnTotals}
                onCheckedChange={(value) => setShowColumnTotals(Boolean(value))}
              />
              <Label htmlFor="columnTotals" className="text-xs">
                Column totals
              </Label>
            </div>
            <div className="flex items-center gap-2">
              <Checkbox
                id="grandTotal"
                checked={showGrandTotal}
                onCheckedChange={(value) => setShowGrandTotal(Boolean(value))}
              />
              <Label htmlFor="grandTotal" className="text-xs">
                Grand total
              </Label>
            </div>
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Preview</CardTitle>
        </CardHeader>
        <CardContent>
          <PivotPreview
            pivot={pivotResult}
            chartType={chartType}
            selectedMeasureKey={selectedMeasureKey}
            onMeasureChange={setSelectedMeasureKey}
            showRowTotals={showRowTotals}
            showColumnTotals={showColumnTotals}
            showGrandTotal={showGrandTotal}
          />
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/features/bi/components/pivot-builder/PivotPreview.tsx">
import { useMemo } from "react";
import type { ChartType, PivotResult } from "../../bi.schemas";
import { buildPivotChartOptions } from "../charts/pivot-chart";
import { ChartContainer } from "../charts/ChartContainer";
import { KpiCard } from "../charts/KpiCard";
import { PivotTable } from "../pivot-table/PivotTable";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";

const sumMeasure = (pivot: PivotResult, measureKey: string) => {
  const values = pivot.rows.flatMap((row) =>
    pivot.columnKeys.map((column) => row.cells[column.key]?.[measureKey] ?? null),
  );
  const hasValue = values.some((value) => typeof value === "number");
  if (!hasValue) return null;
  return values.reduce<number>((acc, value) => acc + (value ?? 0), 0);
};

export function PivotPreview({
  pivot,
  chartType,
  selectedMeasureKey,
  onMeasureChange,
  showRowTotals,
  showColumnTotals,
  showGrandTotal,
}: {
  pivot: PivotResult | null;
  chartType: ChartType;
  selectedMeasureKey: string;
  onMeasureChange: (key: string) => void;
  showRowTotals: boolean;
  showColumnTotals: boolean;
  showGrandTotal: boolean;
}) {
  const chartOption = useMemo(() => {
    if (!pivot || !selectedMeasureKey) return null;
    return buildPivotChartOptions(pivot, chartType, selectedMeasureKey);
  }, [pivot, chartType, selectedMeasureKey]);

  if (!pivot) {
    return (
      <div className="rounded-md border border-dashed p-8 text-center text-muted-foreground">
        Run a query to preview results.
      </div>
    );
  }

  const showMeasureSelector = pivot.measures.length > 1 && chartType !== "table";

  return (
    <div className="space-y-3">
      {showMeasureSelector ? (
        <Select value={selectedMeasureKey} onValueChange={onMeasureChange}>
          <SelectTrigger className="w-64">
            <SelectValue placeholder="Select measure" />
          </SelectTrigger>
          <SelectContent>
            {pivot.measures.map((measure) => (
              <SelectItem key={measure.key} value={measure.key}>
                {measure.label}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      ) : null}

      {chartType === "table" ? (
        <PivotTable
          pivot={pivot}
          showRowTotals={showRowTotals}
          showColumnTotals={showColumnTotals}
          showGrandTotal={showGrandTotal}
        />
      ) : chartType === "kpi" ? (
        <KpiCard
          title={pivot.measures.find((measure) => measure.key === selectedMeasureKey)?.label ?? "KPI"}
          value={sumMeasure(pivot, selectedMeasureKey) ?? "-"}
        />
      ) : chartOption ? (
        <ChartContainer option={chartOption} />
      ) : (
        <div className="rounded-md border border-dashed p-8 text-center text-muted-foreground">
          Select a chart type to preview results.
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/features/bi/components/pivot-table/PivotHeader.tsx">
import type { PivotResult } from "../../bi.schemas";
import { TableHead, TableRow } from "~/components/ui/table";

export function PivotHeader({
  rowFields,
  columnKeys,
  measures,
  showRowTotals,
}: {
  rowFields: PivotResult["rowFields"];
  columnKeys: PivotResult["columnKeys"];
  measures: PivotResult["measures"];
  showRowTotals: boolean;
}) {
  const hasMultipleMeasures = measures.length > 1;

  return (
    <>
      <TableRow>
        {rowFields.map((field) => (
          <TableHead key={field} rowSpan={hasMultipleMeasures ? 2 : 1}>
            {field}
          </TableHead>
        ))}
        {columnKeys.map((column) => (
          <TableHead key={column.key} colSpan={measures.length}>
            {column.label}
          </TableHead>
        ))}
        {showRowTotals ? (
          <TableHead colSpan={measures.length}>Total</TableHead>
        ) : null}
      </TableRow>
      {hasMultipleMeasures ? (
        <TableRow>
          {columnKeys.map((column) =>
            measures.map((measure) => (
              <TableHead key={`${column.key}:${measure.key}`}>
                {measure.label}
              </TableHead>
            )),
          )}
          {showRowTotals
            ? measures.map((measure) => (
                <TableHead key={`total:${measure.key}`}>{measure.label}</TableHead>
              ))
            : null}
        </TableRow>
      ) : null}
    </>
  );
}
</file>

<file path="src/features/bi/components/pivot-table/PivotRow.tsx">
import type { PivotResult } from "../../bi.schemas";
import { TableCell, TableRow } from "~/components/ui/table";

export function PivotRow({
  row,
  rowFields,
  columnKeys,
  measures,
  rowTotals,
  showRowTotals,
}: {
  row: PivotResult["rows"][number];
  rowFields: PivotResult["rowFields"];
  columnKeys: PivotResult["columnKeys"];
  measures: PivotResult["measures"];
  rowTotals: Record<string, number | null>;
  showRowTotals: boolean;
}) {
  return (
    <TableRow>
      {rowFields.map((field) => (
        <TableCell key={`${row.key}:${field}`}>{row.values[field] ?? ""}</TableCell>
      ))}
      {columnKeys.map((column) =>
        measures.map((measure) => (
          <TableCell key={`${row.key}:${column.key}:${measure.key}`}>
            {row.cells[column.key]?.[measure.key] ?? ""}
          </TableCell>
        )),
      )}
      {showRowTotals
        ? measures.map((measure) => (
            <TableCell key={`${row.key}:total:${measure.key}`}>
              {rowTotals[measure.key] ?? ""}
            </TableCell>
          ))
        : null}
    </TableRow>
  );
}
</file>

<file path="src/features/bi/components/pivot-table/PivotTable.tsx">
import type { PivotResult } from "../../bi.schemas";
import {
  Table,
  TableBody,
  TableHeader,
} from "~/components/ui/table";
import { PivotHeader } from "./PivotHeader";
import { PivotRow } from "./PivotRow";
import { TotalsRow } from "./TotalsRow";

const sumValues = (values: Array<number | null>) => {
  const hasValue = values.some((value) => typeof value === "number");
  if (!hasValue) return null;
  return values.reduce<number>((acc, value) => acc + (value ?? 0), 0);
};

export function PivotTable({
  pivot,
  showRowTotals = true,
  showColumnTotals = true,
  showGrandTotal = true,
}: {
  pivot: PivotResult;
  showRowTotals?: boolean;
  showColumnTotals?: boolean;
  showGrandTotal?: boolean;
}) {
  const rowTotals = pivot.rows.map((row) => {
    const totals: Record<string, number | null> = {};
    for (const measure of pivot.measures) {
      const values = pivot.columnKeys.map(
        (column) => row.cells[column.key]?.[measure.key] ?? null,
      );
      totals[measure.key] = sumValues(values);
    }
    return totals;
  });

  const columnTotals = pivot.columnKeys.map((column) => {
    const totals: Record<string, number | null> = {};
    for (const measure of pivot.measures) {
      const values = pivot.rows.map(
        (row) => row.cells[column.key]?.[measure.key] ?? null,
      );
      totals[measure.key] = sumValues(values);
    }
    return totals;
  });

  const grandTotals: Record<string, number | null> = {};
  for (const measure of pivot.measures) {
    const values = pivot.rows.flatMap((row) =>
      pivot.columnKeys.map((column) => row.cells[column.key]?.[measure.key] ?? null),
    );
    grandTotals[measure.key] = sumValues(values);
  }

  return (
    <div className="overflow-x-auto" data-testid="pivot-table">
      <Table>
        <TableHeader>
          <PivotHeader
            rowFields={pivot.rowFields}
            columnKeys={pivot.columnKeys}
            measures={pivot.measures}
            showRowTotals={showRowTotals}
          />
        </TableHeader>
        <TableBody>
          {pivot.rows.map((row, index) => (
            <PivotRow
              key={row.key}
              row={row}
              rowFields={pivot.rowFields}
              columnKeys={pivot.columnKeys}
              measures={pivot.measures}
              rowTotals={rowTotals[index] ?? {}}
              showRowTotals={showRowTotals}
            />
          ))}
          {showColumnTotals ? (
            <TotalsRow
              label="Total"
              rowFields={pivot.rowFields}
              columnKeys={pivot.columnKeys}
              measures={pivot.measures}
              columnTotals={columnTotals}
              grandTotals={grandTotals}
              showRowTotals={showRowTotals}
              showGrandTotal={showGrandTotal}
            />
          ) : null}
        </TableBody>
      </Table>
    </div>
  );
}
</file>

<file path="src/features/bi/components/pivot-table/TotalsRow.tsx">
import type { PivotResult } from "../../bi.schemas";
import { TableCell, TableRow } from "~/components/ui/table";

export function TotalsRow({
  label,
  rowFields,
  columnKeys,
  measures,
  columnTotals,
  grandTotals,
  showRowTotals,
  showGrandTotal,
}: {
  label: string;
  rowFields: PivotResult["rowFields"];
  columnKeys: PivotResult["columnKeys"];
  measures: PivotResult["measures"];
  columnTotals: Array<Record<string, number | null>>;
  grandTotals: Record<string, number | null>;
  showRowTotals: boolean;
  showGrandTotal: boolean;
}) {
  return (
    <TableRow>
      {rowFields.map((field, index) => (
        <TableCell
          key={`${label}:${field}`}
          className={index === 0 ? "font-medium" : ""}
        >
          {index === 0 ? label : ""}
        </TableCell>
      ))}
      {columnKeys.map((column, columnIndex) =>
        measures.map((measure) => (
          <TableCell
            key={`${label}:${column.key}:${measure.key}`}
            className="font-medium"
          >
            {columnTotals[columnIndex]?.[measure.key] ?? ""}
          </TableCell>
        )),
      )}
      {showRowTotals && showGrandTotal
        ? measures.map((measure) => (
            <TableCell
              key={`${label}:grand:${measure.key}`}
              className="font-semibold"
            >
              {grandTotals[measure.key] ?? ""}
            </TableCell>
          ))
        : showRowTotals
          ? measures.map((measure) => (
              <TableCell key={`${label}:grand:${measure.key}`} />
            ))
          : null}
    </TableRow>
  );
}
</file>

<file path="src/features/bi/components/sql-workbench/QueryHistory.tsx">
import { Button } from "~/components/ui/button";

export type QueryHistoryEntry = {
  id: string;
  sql: string;
  datasetId: string;
  organizationId: string | null;
  createdAt: string;
};

export function QueryHistory({
  history,
  datasetLabels,
  onSelect,
}: {
  history: QueryHistoryEntry[];
  datasetLabels: Map<string, string>;
  onSelect: (entry: QueryHistoryEntry) => void;
}) {
  if (history.length === 0) {
    return <p className="text-muted-foreground text-xs">No queries yet.</p>;
  }

  return (
    <div className="space-y-2">
      {history.map((entry) => (
        <Button
          key={entry.id}
          variant="ghost"
          className="w-full justify-start text-left text-xs"
          onClick={() => onSelect(entry)}
        >
          <div className="flex w-full flex-col gap-1">
            <div className="flex items-center justify-between text-[11px] text-muted-foreground">
              <span>{datasetLabels.get(entry.datasetId) ?? entry.datasetId}</span>
              <span>{new Date(entry.createdAt).toLocaleString()}</span>
            </div>
            <span className="text-xs font-medium">
              {entry.sql.slice(0, 140)}
            </span>
          </div>
        </Button>
      ))}
    </div>
  );
}
</file>

<file path="src/features/bi/components/sql-workbench/ResultsTable.tsx">
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "~/components/ui/table";
import type { JsonRecord } from "~/shared/lib/json";

export function ResultsTable({ rows }: { rows: JsonRecord[] }) {
  if (rows.length === 0) {
    return (
      <div className="rounded-md border border-dashed p-6 text-center text-xs text-muted-foreground">
        No rows returned.
      </div>
    );
  }

  const columns = Array.from(
    rows.reduce((acc, row) => {
      Object.keys(row).forEach((key) => acc.add(key));
      return acc;
    }, new Set<string>()),
  );

  return (
    <Table>
      <TableHeader>
        <TableRow>
          {columns.map((column) => (
            <TableHead key={column}>{column}</TableHead>
          ))}
        </TableRow>
      </TableHeader>
      <TableBody>
        {rows.map((row, rowIndex) => (
          <TableRow key={rowIndex}>
            {columns.map((column) => (
              <TableCell key={`${rowIndex}-${column}`}>
                {row[column] !== null && row[column] !== undefined
                  ? String(row[column])
                  : ""}
              </TableCell>
            ))}
          </TableRow>
        ))}
      </TableBody>
    </Table>
  );
}
</file>

<file path="src/features/bi/components/sql-workbench/SqlEditor.tsx">
import { useEffect, useMemo, useState, type ComponentType } from "react";
import { EditorView } from "@codemirror/view";
import { PostgreSQL, sql, type SQLNamespace } from "@codemirror/lang-sql";
import type { ReactCodeMirrorProps } from "@uiw/react-codemirror";
import { Textarea } from "~/components/ui/textarea";

export function SqlEditor({
  value,
  onChange,
  schema,
  defaultTable,
}: {
  value: string;
  onChange: (next: string) => void;
  schema?: SQLNamespace;
  defaultTable?: string;
}) {
  const [CodeMirror, setCodeMirror] = useState<
    ComponentType<ReactCodeMirrorProps> | null
  >(null);

  useEffect(() => {
    let active = true;
    import("@uiw/react-codemirror")
      .then((mod) => {
        if (active) {
          setCodeMirror(() => mod.default as ComponentType<ReactCodeMirrorProps>);
        }
      })
      .catch(() => {
        if (active) setCodeMirror(null);
      });
    return () => {
      active = false;
    };
  }, []);

  const extensions = useMemo(
    () => [
      sql({
        dialect: PostgreSQL,
        ...(schema ? { schema } : {}),
        ...(defaultTable ? { defaultTable } : {}),
      }),
      EditorView.lineWrapping,
    ],
    [schema, defaultTable],
  );

  if (!CodeMirror) {
    return (
      <Textarea
        rows={10}
        className="font-mono text-sm"
        placeholder="SELECT * FROM organizations WHERE id = {{organization_id}}"
        value={value}
        onChange={(event) => onChange(event.target.value)}
      />
    );
  }

  return (
    <div className="rounded-md border">
      <CodeMirror
        value={value}
        minHeight="240px"
        theme="light"
        placeholder="SELECT * FROM organizations WHERE id = {{organization_id}}"
        extensions={extensions}
        onChange={(next) => onChange(next)}
        basicSetup={{
          lineNumbers: true,
          highlightActiveLine: true,
          highlightActiveLineGutter: true,
        }}
      />
    </div>
  );
}
</file>

<file path="src/features/bi/components/sql-workbench/SqlWorkbench.tsx">
import { useEffect, useMemo, useState } from "react";
import { useMutation, useQuery } from "@tanstack/react-query";
import { toast } from "sonner";
import { Button } from "~/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";
import {
  executeSqlQuery,
  getAvailableDatasets,
  getDatasetFields,
} from "~/features/bi/bi.queries";
import type { DatasetField } from "~/features/bi/bi.types";
import {
  QueryHistory,
  type QueryHistoryEntry,
} from "~/features/bi/components/sql-workbench/QueryHistory";
import { ResultsTable } from "~/features/bi/components/sql-workbench/ResultsTable";
import { SqlEditor } from "~/features/bi/components/sql-workbench/SqlEditor";
import { useOrgContext } from "~/features/organizations/org-context";
import { useLocalStorage } from "~/shared/hooks/useLocalStorage";
import type { JsonRecord } from "~/shared/lib/json";

const PARAM_REGEX = /\{\{([a-zA-Z_][\w]*)\}\}/g;
const HISTORY_LIMIT = 10;

const extractParams = (sqlText: string) => {
  const params = new Set<string>();
  let match: RegExpExecArray | null = null;
  while ((match = PARAM_REGEX.exec(sqlText)) !== null) {
    params.add(match[1]);
  }
  return Array.from(params);
};

export function SqlWorkbench() {
  const { activeOrganizationId } = useOrgContext();
  const [sqlText, setSqlText] = useState("");
  const [datasetId, setDatasetId] = useState("");
  const [paramValues, setParamValues] = useState<Record<string, string>>({});
  const [history, setHistory] = useLocalStorage<QueryHistoryEntry[]>(
    "bi.sql.history",
    [],
  );
  const [rows, setRows] = useState<JsonRecord[]>([]);

  const datasetsQuery = useQuery({
    queryKey: ["bi-datasets"],
    queryFn: () => getAvailableDatasets(),
  });

  const datasets = datasetsQuery.data?.datasets ?? [];
  const datasetLabels = useMemo(
    () => new Map(datasets.map((dataset) => [dataset.id, dataset.name])),
    [datasets],
  );

  useEffect(() => {
    if (!datasetId && datasets.length > 0) {
      setDatasetId(datasets[0]?.id ?? "");
    }
  }, [datasetId, datasets]);

  const fieldsQuery = useQuery({
    queryKey: ["bi-fields", datasetId],
    queryFn: () =>
      datasetId ? getDatasetFields({ data: { datasetId } }) : Promise.resolve(null),
    enabled: Boolean(datasetId),
  });

  const fields = (fieldsQuery.data?.fields ?? []) as DatasetField[];
  const columnNames = useMemo(() => {
    const set = new Set<string>();
    fields.forEach((field) => {
      if (field.sourceColumn) {
        set.add(field.sourceColumn.toLowerCase());
      }
    });
    return Array.from(set);
  }, [fields]);

  const sqlSchema = useMemo(() => {
    if (!datasetId || columnNames.length === 0) return undefined;
    const viewName = `bi_v_${datasetId}`;
    return {
      [datasetId]: columnNames,
      [viewName]: columnNames,
    };
  }, [datasetId, columnNames]);

  const paramNames = useMemo(() => extractParams(sqlText), [sqlText]);

  useEffect(() => {
    setParamValues((prev) => {
      const next: Record<string, string> = { ...prev };
      for (const name of paramNames) {
        if (!(name in next)) next[name] = "";
      }
      Object.keys(next).forEach((key) => {
        if (!paramNames.includes(key)) delete next[key];
      });
      return next;
    });
  }, [paramNames]);

  const visibleHistory = useMemo(
    () =>
      history.filter(
        (entry) => entry.organizationId === (activeOrganizationId ?? null),
      ),
    [history, activeOrganizationId],
  );

  const queryMutation = useMutation({
    mutationFn: async () => {
      if (!sqlText.trim()) {
        throw new Error("SQL query is required.");
      }
      if (!datasetId) {
        throw new Error("Select a dataset to run SQL queries.");
      }

      const data = {
        sql: sqlText,
        parameters: paramValues,
        datasetId,
      };

      return executeSqlQuery({ data });
    },
    onSuccess: (result) => {
      setRows(result?.rows ?? []);
      const entry: QueryHistoryEntry = {
        id: crypto.randomUUID(),
        sql: sqlText,
        datasetId,
        organizationId: activeOrganizationId ?? null,
        createdAt: new Date().toISOString(),
      };
      setHistory((prev) => {
        const currentOrg = activeOrganizationId ?? null;
        const otherEntries = prev.filter(
          (item) => item.organizationId !== currentOrg,
        );
        const currentEntries = prev.filter(
          (item) =>
            item.organizationId === currentOrg &&
            !(item.sql === entry.sql && item.datasetId === entry.datasetId),
        );
        return [...[entry, ...currentEntries].slice(0, HISTORY_LIMIT), ...otherEntries];
      });
      toast.success("Query executed.");
    },
    onError: (error) => {
      toast.error(error instanceof Error ? error.message : "SQL execution failed.");
    },
  });

  return (
    <div className="grid gap-6 lg:grid-cols-[2fr_1fr]">
      <div className="space-y-4">
        <Card>
          <CardHeader>
            <CardTitle>SQL editor</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="space-y-2">
              <Label>Dataset</Label>
              <Select value={datasetId} onValueChange={setDatasetId}>
                <SelectTrigger>
                  <SelectValue placeholder="Select dataset" />
                </SelectTrigger>
                <SelectContent>
                  {datasets.map((dataset) => (
                    <SelectItem key={dataset.id} value={dataset.id}>
                      {dataset.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            <SqlEditor
              value={sqlText}
              onChange={setSqlText}
              {...(sqlSchema ? { schema: sqlSchema } : {})}
              {...(datasetId ? { defaultTable: datasetId } : {})}
            />

            {paramNames.length > 0 ? (
              <div className="grid gap-3 md:grid-cols-2">
                {paramNames.map((name) => (
                  <div key={name} className="space-y-1">
                    <Label>{name}</Label>
                    <Input
                      value={paramValues[name] ?? ""}
                      onChange={(event) =>
                        setParamValues((prev) => ({
                          ...prev,
                          [name]: event.target.value,
                        }))
                      }
                    />
                  </div>
                ))}
              </div>
            ) : null}

            <Button onClick={() => queryMutation.mutate()} disabled={queryMutation.isPending}>
              Run query
            </Button>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Results</CardTitle>
          </CardHeader>
          <CardContent>
            <ResultsTable rows={rows} />
          </CardContent>
        </Card>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Query history</CardTitle>
        </CardHeader>
        <CardContent>
          <QueryHistory
            history={visibleHistory}
            datasetLabels={datasetLabels}
            onSelect={(entry) => {
              setSqlText(entry.sql);
              setDatasetId(entry.datasetId);
            }}
          />
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/features/bi/engine/query-builder.ts">
import type { DatasetConfig, DatasetField } from "../bi.types";

export type QueryColumn = {
  fieldId: string;
  sourceColumn: string;
  sourceTable: string;
};

export type DatasetQueryPlan = {
  baseTable: string;
  joins: DatasetConfig["joins"];
  columns: QueryColumn[];
};

const resolveField = (fieldId: string, fields: DatasetField[]) => {
  const field = fields.find((entry) => entry.id === fieldId);
  if (!field) {
    throw new Error(`Unknown field '${fieldId}'`);
  }
  return field;
};

export const buildDatasetQueryPlan = (
  dataset: DatasetConfig,
  selectedFields: string[],
): DatasetQueryPlan => {
  const columns = selectedFields.map((fieldId) => {
    const field = resolveField(fieldId, dataset.fields);
    return {
      fieldId: field.id,
      sourceColumn: field.sourceColumn,
      sourceTable: field.sourceTable ?? dataset.baseTable,
    };
  });

  return {
    baseTable: dataset.baseTable,
    joins: dataset.joins ?? [],
    columns,
  };
};
</file>

<file path="src/features/bi/engine/sorting.ts">
import type { DatasetConfig } from "../bi.types";

export type SortDirection = "asc" | "desc";

export type SortConfig = {
  field: string;
  direction: SortDirection;
};

export const buildAllowedSortFields = (dataset: DatasetConfig) =>
  new Set(dataset.fields.filter((field) => field.allowSort).map((field) => field.id));

export const normalizeSort = (
  sort: SortConfig | null | undefined,
  allowedFields: Set<string>,
): SortConfig | null => {
  if (!sort) return null;
  if (!allowedFields.has(sort.field)) {
    throw new Error(`Sort field '${sort.field}' is not allowed`);
  }
  return {
    field: sort.field,
    direction: sort.direction ?? "asc",
  };
};
</file>

<file path="src/features/bi/engine/sql-parser.ts">
import {
  astVisitor,
  parse,
  type Statement,
  type WithStatement,
  type WithRecursiveStatement,
} from "pgsql-ast-parser";

export type SqlParameter = { name: string; position: number };

export type ParsedQuery = {
  isValid: boolean;
  errors: string[];
  tables: string[];
  columns: string[];
  parameters: SqlParameter[];
  tableAliases: Record<string, string | null>;
  cteNames: string[];
  selectAliases: string[];
  sanitizedSql?: string;
};

const PLACEHOLDER_PREFIX = "__bi_param__";
const PLACEHOLDER_PATTERN = /\{\{([a-zA-Z_][\w]*)\}\}/g;

export const normalizeSqlPlaceholders = (sqlText: string) => {
  const parameters: SqlParameter[] = [];
  const sanitizedSql = sqlText.replace(PLACEHOLDER_PATTERN, (_, name, index) => {
    parameters.push({ name, position: index });
    return `'${PLACEHOLDER_PREFIX}${name}__'`;
  });

  return { sanitizedSql, parameters };
};

export const restoreSqlPlaceholders = (sqlText: string) => {
  const pattern = new RegExp(`'${PLACEHOLDER_PREFIX}([a-zA-Z_][\\w]*)__'`, "g");
  return sqlText.replace(pattern, (_, name) => `{{${name}}}`);
};

const isSelectStatement = (statement: Statement): boolean => {
  switch (statement.type) {
    case "select":
      return true;
    case "union":
    case "union all":
      return isSelectStatement(statement.left) && isSelectStatement(statement.right);
    case "with": {
      const withStatement = statement as WithStatement;
      return (
        isSelectStatement(withStatement.in) &&
        withStatement.bind.every((binding) => isSelectStatement(binding.statement))
      );
    }
    case "with recursive": {
      const withStatement = statement as WithRecursiveStatement;
      return isSelectStatement(withStatement.in) && isSelectStatement(withStatement.bind);
    }
    default:
      return false;
  }
};

const normalizeTableName = (name?: string | null, schema?: string | null) => {
  if (!name) return null;
  if (schema) return `${schema}.${name}`;
  return name;
};

const collectCteNames = (statement: Statement) => {
  const names = new Set<string>();
  const visit = (stmt: Statement) => {
    switch (stmt.type) {
      case "with": {
        const withStatement = stmt as WithStatement;
        withStatement.bind.forEach((binding) => {
          names.add(binding.alias.name.toLowerCase());
          if (binding.statement && typeof binding.statement === "object") {
            visit(binding.statement as Statement);
          }
        });
        if (withStatement.in && typeof withStatement.in === "object") {
          visit(withStatement.in as Statement);
        }
        break;
      }
      case "with recursive": {
        const withStatement = stmt as WithRecursiveStatement;
        names.add(withStatement.alias.name.toLowerCase());
        if (withStatement.bind) {
          visit(withStatement.bind as Statement);
        }
        if (withStatement.in && typeof withStatement.in === "object") {
          visit(withStatement.in as Statement);
        }
        break;
      }
      case "union":
      case "union all":
        visit(stmt.left);
        visit(stmt.right);
        break;
      default:
        break;
    }
  };

  visit(statement);
  return names;
};

export function parseAndValidateSql(sqlText: string): ParsedQuery {
  const { sanitizedSql, parameters } = normalizeSqlPlaceholders(sqlText);

  const result: ParsedQuery = {
    isValid: true,
    errors: [],
    tables: [],
    columns: [],
    parameters,
    tableAliases: {},
    cteNames: [],
    selectAliases: [],
    sanitizedSql,
  };

  let statements: Statement[] = [];

  try {
    statements = parse(sanitizedSql);
  } catch (error) {
    result.isValid = false;
    result.errors.push(
      `SQL parse error: ${error instanceof Error ? error.message : String(error)}`,
    );
    return result;
  }

  if (statements.length !== 1) {
    result.isValid = false;
    result.errors.push("SQL must contain a single SELECT statement");
    return result;
  }

  const statement = statements[0];
  if (!statement || !isSelectStatement(statement)) {
    result.isValid = false;
    result.errors.push("Only SELECT statements are allowed");
    return result;
  }

  const tables = new Set<string>();
  const columns = new Set<string>();
  const tableAliases = new Map<string, string | null>();
  const selectAliases = new Set<string>();
  const cteNames = collectCteNames(statement);

  const visitor = astVisitor((v) => ({
    fromTable: (from) => {
      const table = normalizeTableName(from.name.name, from.name.schema ?? null);
      const normalizedTable = table?.toLowerCase() ?? null;
      if (from.name.alias) {
        tableAliases.set(
          from.name.alias.toLowerCase(),
          cteNames.has(normalizedTable ?? "") ? null : normalizedTable,
        );
      }
      if (normalizedTable && !cteNames.has(normalizedTable)) {
        tables.add(normalizedTable);
      }
      v.super().fromTable(from);
    },
    fromCall: (from) => {
      const name = normalizeTableName(
        from.function.name,
        from.function.schema ?? null,
      );
      if (name) {
        tables.add(name.toLowerCase());
      }
      const alias = from.alias?.name;
      if (alias) {
        tableAliases.set(alias.toLowerCase(), name ? name.toLowerCase() : null);
      }
      v.super().fromCall(from);
    },
    fromStatement: (from) => {
      if (from.alias) {
        tableAliases.set(from.alias.toLowerCase(), null);
      }
      v.super().fromStatement(from);
    },
    selectionColumn: (column) => {
      if (column.alias?.name) {
        selectAliases.add(column.alias.name.toLowerCase());
      }
      v.super().selectionColumn(column);
    },
    ref: (ref) => {
      const table = normalizeTableName(ref.table?.name ?? null, ref.table?.schema ?? null);
      if (table) {
        columns.add(`${table.toLowerCase()}.${ref.name}`);
      } else {
        columns.add(String(ref.name));
      }
      v.super().ref(ref);
    },
  }));

  visitor.statement(statement);

  result.tables = Array.from(tables);
  result.columns = Array.from(columns);
  result.tableAliases = Object.fromEntries(tableAliases);
  result.cteNames = Array.from(cteNames);
  result.selectAliases = Array.from(selectAliases);

  return result;
}

export function validateAgainstDataset(
  parsed: ParsedQuery,
  allowedTables: Set<string>,
  allowedColumns: Map<string, Set<string>>,
): string[] {
  const errors: string[] = [];
  const normalizedTables = new Set(Array.from(allowedTables).map((t) => t.toLowerCase()));
  const normalizedColumns = new Map(
    Array.from(allowedColumns.entries()).map(([table, cols]) => [
      table.toLowerCase(),
      new Set(Array.from(cols).map((col) => col.toLowerCase())),
    ]),
  );
  const cteNames = new Set(parsed.cteNames.map((name) => name.toLowerCase()));
  const selectAliases = new Set(
    parsed.selectAliases.map((name) => name.toLowerCase()),
  );
  const tableAliases = new Map(
    Object.entries(parsed.tableAliases).map(([alias, table]) => [
      alias.toLowerCase(),
      table ? table.toLowerCase() : null,
    ]),
  );

  for (const table of parsed.tables) {
    if (!normalizedTables.has(table.toLowerCase())) {
      errors.push(`Table "${table}" is not in the allowed dataset`);
    }
  }

  for (const column of parsed.columns) {
    if (column === "*") continue;

    const [table, col] = column.includes(".")
      ? column.split(".")
      : [null, column];

    if (!table) {
      if (col === "*") continue;
      const normalizedColumn = col.toLowerCase();
      if (selectAliases.has(normalizedColumn)) continue;
      const isAllowed = Array.from(normalizedColumns.values()).some((cols) =>
        cols.has(normalizedColumn),
      );
      if (!isAllowed) {
        errors.push(`Column "${column}" is not accessible`);
      }
      continue;
    }

    if (col === "*") {
      continue;
    }

    const normalizedTable = table.toLowerCase();
    if (cteNames.has(normalizedTable)) {
      continue;
    }

    const resolvedTable =
      tableAliases.has(normalizedTable)
        ? tableAliases.get(normalizedTable)
        : normalizedTable;

    if (!resolvedTable) {
      continue;
    }

    const cols = normalizedColumns.get(resolvedTable);
    if (!cols) {
      errors.push(`Column "${column}" is not accessible`);
      continue;
    }

    const normalizedColumn = col.toLowerCase();
    if (!cols.has(normalizedColumn) && !cols.has("*")) {
      errors.push(`Column "${column}" is not accessible`);
    }
  }

  return errors;
}
</file>

<file path="src/features/bi/engine/sql-rewriter.ts">
import {
  assignChanged,
  astMapper,
  parse,
  toSql,
  type FromTable,
  type Statement,
} from "pgsql-ast-parser";
import { normalizeSqlPlaceholders, restoreSqlPlaceholders } from "./sql-parser";

export type SqlRewriteResult = {
  sql: string;
  rewritten: boolean;
};

const buildTableMap = (tableMap: Record<string, string>) =>
  new Map(
    Object.entries(tableMap).map(([key, value]) => [key.toLowerCase(), value]),
  );

const rewriteFromTable = (
  from: FromTable,
  map: Map<string, string>,
): FromTable => {
  const tableName = from.name.name;
  const mapped = map.get(tableName.toLowerCase());

  if (!mapped) {
    return from;
  }

  const alias = from.name.alias ?? tableName;
  const nextName = assignChanged(from.name, {
    name: mapped,
    alias,
  });

  return assignChanged(from, { name: nextName });
};

export function rewriteSqlTables(
  sqlText: string,
  tableMap: Record<string, string>,
): SqlRewriteResult {
  const { sanitizedSql } = normalizeSqlPlaceholders(sqlText);
  const statements = parse(sanitizedSql);

  const [statement] = statements;
  if (statements.length !== 1 || !statement) {
    return { sql: sqlText, rewritten: false };
  }

  const map = buildTableMap(tableMap);
  let touched = false;

  const mapper = astMapper((m) => ({
    fromTable: (from) => {
      const next = rewriteFromTable(from, map);
      if (next !== from) {
        touched = true;
      }
      return m.super().fromTable(next);
    },
  }));

  const rewritten = mapper.statement(statement as Statement);
  if (!rewritten) {
    return { sql: sqlText, rewritten: false };
  }
  const rewrittenSql = toSql.statement(rewritten);

  return {
    sql: restoreSqlPlaceholders(rewrittenSql),
    rewritten: touched,
  };
}
</file>

<file path="src/features/bi/governance/export-controls.ts">
import type { QueryContext } from "../bi.types";

const exportPermissions = new Set(["analytics.export", "analytics.admin", "*"]);

export const assertExportAllowed = (context: QueryContext) => {
  const hasPermission = Array.from(context.permissions).some((permission) =>
    exportPermissions.has(permission),
  );

  if (!hasPermission) {
    throw new Error("Analytics export permission required");
  }

  if (!context.hasRecentAuth) {
    throw new Error("Step-up authentication required for export");
  }
};
</file>

<file path="src/features/bi/governance/pii-masking.ts">
/**
 * PII masking utilities for BI outputs.
 */

export { maskPiiFields, queryIncludesPii } from "./field-acl";
</file>

<file path="src/features/bi/governance/query-audit.ts">
/**
 * Query audit helpers for SQL workbench.
 */

export {
  computeChecksum,
  computeQueryHash,
  logExport,
  logQuery,
  verifyAuditChain,
  type LogQueryParams,
  type QueryType,
} from "./audit-logger";
</file>

<file path="src/features/bi/governance/query-guardrails.ts">
/**
 * SQL Workbench Guardrails
 *
 * Enforces query limits (timeout, row limits, cost, concurrency) for SQL workbench.
 */

export const QUERY_GUARDRAILS = {
  statementTimeoutMs: 30000,
  maxRowsUi: 10000,
  maxRowsExport: 100000,
  maxEstimatedCost: 100000,
  maxConcurrentPerUser: 2,
  maxConcurrentPerOrg: 5,
} as const;

const inflightByUser = new Map<string, number>();
const inflightByOrg = new Map<string, number>();

const bump = (map: Map<string, number>, key: string) => {
  const next = (map.get(key) ?? 0) + 1;
  map.set(key, next);
  return next;
};

const drop = (map: Map<string, number>, key: string) => {
  const next = (map.get(key) ?? 1) - 1;
  if (next <= 0) {
    map.delete(key);
  } else {
    map.set(key, next);
  }
};

export const acquireConcurrencySlot = (
  userId: string,
  organizationId: string | null,
): (() => void) => {
  const userCount = bump(inflightByUser, userId);
  if (userCount > QUERY_GUARDRAILS.maxConcurrentPerUser) {
    drop(inflightByUser, userId);
    throw new Error("Too many concurrent SQL queries for this user");
  }

  if (organizationId) {
    const orgCount = bump(inflightByOrg, organizationId);
    if (orgCount > QUERY_GUARDRAILS.maxConcurrentPerOrg) {
      drop(inflightByUser, userId);
      drop(inflightByOrg, organizationId);
      throw new Error("Too many concurrent SQL queries for this organization");
    }
  }

  return () => {
    drop(inflightByUser, userId);
    if (organizationId) {
      drop(inflightByOrg, organizationId);
    }
  };
};

export const stripTrailingSemicolons = (sqlText: string) =>
  sqlText.replace(/;\s*$/, "");

export const buildLimitedQuery = (sqlText: string, maxRows: number) =>
  `SELECT * FROM (${stripTrailingSemicolons(sqlText)}) AS bi_limit_subquery LIMIT ${maxRows}`;

const escapeLiteral = (value: string) => `'${value.replace(/'/g, "''")}'`;

export const inlineParameters = (
  sqlText: string,
  parameters: Record<string, unknown>,
): string => {
  return sqlText.replace(/\{\{([a-zA-Z_][\w]*)\}\}/g, (_, name) => {
    if (!(name in parameters)) {
      throw new Error(`Missing SQL parameter: ${name}`);
    }

    const value = parameters[name];
    if (value === null || value === undefined) return "NULL";
    if (typeof value === "number" && Number.isFinite(value)) return value.toString();
    if (typeof value === "boolean") return value ? "TRUE" : "FALSE";
    if (value instanceof Date) return escapeLiteral(value.toISOString());
    if (Array.isArray(value)) {
      return `ARRAY[${value.map((entry) => inlineParameters("{{value}}", { value: entry })).join(", ")}]`;
    }
    return escapeLiteral(String(value));
  });
};
</file>

<file path="src/features/bi/hooks/use-dashboard.ts">
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import {
  addWidget,
  createDashboard,
  deleteDashboard,
  removeWidget,
  updateDashboard,
  updateWidget,
} from "../bi.mutations";
import { getDashboard, getDashboards } from "../bi.queries";

export const useDashboards = () => {
  return useQuery({
    queryKey: ["bi-dashboards"],
    queryFn: () => getDashboards(),
  });
};

export const useDashboard = (dashboardId: string) => {
  const queryClient = useQueryClient();

  const dashboardQuery = useQuery({
    queryKey: ["bi-dashboard", dashboardId],
    queryFn: () => getDashboard({ data: { dashboardId } }),
    enabled: Boolean(dashboardId),
  });

  const invalidate = async () => {
    await queryClient.invalidateQueries({ queryKey: ["bi-dashboard", dashboardId] });
    await queryClient.invalidateQueries({ queryKey: ["bi-dashboards"] });
  };

  const updateDashboardMutation = useMutation({
    mutationFn: updateDashboard,
    onSuccess: invalidate,
  });

  const addWidgetMutation = useMutation({
    mutationFn: addWidget,
    onSuccess: invalidate,
  });

  const updateWidgetMutation = useMutation({
    mutationFn: updateWidget,
    onSuccess: invalidate,
  });

  const removeWidgetMutation = useMutation({
    mutationFn: removeWidget,
    onSuccess: invalidate,
  });

  const deleteDashboardMutation = useMutation({
    mutationFn: deleteDashboard,
    onSuccess: invalidate,
  });

  return {
    dashboard: dashboardQuery.data,
    widgets: dashboardQuery.data?.widgets ?? [],
    isLoading: dashboardQuery.isLoading,
    refresh: dashboardQuery.refetch,
    updateDashboard: updateDashboardMutation,
    addWidget: addWidgetMutation,
    updateWidget: updateWidgetMutation,
    removeWidget: removeWidgetMutation,
    deleteDashboard: deleteDashboardMutation,
  };
};

export const useCreateDashboard = () => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: createDashboard,
    onSuccess: () => queryClient.invalidateQueries({ queryKey: ["bi-dashboards"] }),
  });
};
</file>

<file path="src/features/bi/semantic/calculated-fields.ts">
/**
 * Calculated fields for the BI semantic layer.
 */

export interface CalculatedField {
  id: string;
  name: string;
  datasetId: string;
  expression: string;
  description?: string;
}

export const CALCULATED_FIELDS: CalculatedField[] = [];

export function getCalculatedField(id: string): CalculatedField | undefined {
  return CALCULATED_FIELDS.find((field) => field.id === id);
}

export function getCalculatedFieldsForDataset(datasetId: string): CalculatedField[] {
  return CALCULATED_FIELDS.filter((field) => field.datasetId === datasetId);
}

export function registerCalculatedField(field: CalculatedField): void {
  CALCULATED_FIELDS.push(field);
}
</file>

<file path="src/features/bi/semantic/field-metadata.ts">
/**
 * Field metadata helpers
 */

import type { DatasetField } from "../bi.types";
import { DATASETS } from "./datasets.config";

export function getDatasetFields(datasetId: string): DatasetField[] {
  return DATASETS[datasetId]?.fields ?? [];
}

export function getFieldById(
  datasetId: string,
  fieldId: string,
): DatasetField | undefined {
  return getDatasetFields(datasetId).find((field) => field.id === fieldId);
}
</file>

<file path="src/features/bi/semantic/metrics.config.ts">
/**
 * Metric definitions for the BI semantic layer.
 */

import type { AggregationType } from "../bi.schemas";
import type { FormatOptions } from "../bi.types";

export interface MetricDefinition {
  id: string;
  name: string;
  description?: string;
  datasetId: string;
  expression: string;
  aggregation?: AggregationType;
  formatType?: "text" | "number" | "currency" | "percent" | "date" | "datetime";
  formatOptions?: FormatOptions;
}

export const METRICS: MetricDefinition[] = [];

export function getMetric(id: string): MetricDefinition | undefined {
  return METRICS.find((metric) => metric.id === id);
}

export function getMetricsForDataset(datasetId: string): MetricDefinition[] {
  return METRICS.filter((metric) => metric.datasetId === datasetId);
}

export function registerMetric(metric: MetricDefinition): void {
  METRICS.push(metric);
}
</file>

<file path="src/features/bi/bi.data.ts">
import type { FormDefinition } from "~/features/forms/forms.schemas";
import { maskPiiFields } from "./governance";

export type QueryFilter = { field: string; operator: string; value: unknown };

export const shapeRows = (rows: Array<Record<string, unknown>>, columns: string[]) =>
  rows.map((row) => {
    const next: Record<string, unknown> = {};
    for (const column of columns) {
      next[column] = row[column];
    }
    return next;
  });

export const redactFormSubmissionPayloads = async (params: {
  rows: Array<Record<string, unknown>>;
  canViewSensitiveFields: boolean;
}) => {
  if (params.canViewSensitiveFields) return params.rows;
  const { getDb } = await import("~/db/server-helpers");
  const { formVersions } = await import("~/db/schema");
  const { inArray } = await import("drizzle-orm");

  const versionIds = Array.from(
    new Set(
      params.rows
        .map((row) => row["formVersionId"])
        .filter(
          (value): value is string => typeof value === "string" && value.length > 0,
        ),
    ),
  );

  if (versionIds.length === 0) return params.rows;

  const db = await getDb();
  const versions = await db
    .select({
      id: formVersions.id,
      definition: formVersions.definition,
    })
    .from(formVersions)
    .where(inArray(formVersions.id, versionIds));

  const definitionById = new Map<string, FormDefinition>();
  for (const version of versions) {
    if (version.definition) {
      definitionById.set(version.id, version.definition as FormDefinition);
    }
  }

  return params.rows.map((row) => {
    const payload = row["payload"];
    if (!payload || typeof payload !== "object" || Array.isArray(payload)) {
      return row;
    }

    const definition = definitionById.get(String(row["formVersionId"])) ?? null;
    if (!definition) {
      return { ...row, payload: "[REDACTED]" };
    }

    const fieldsByKey = new Map(definition.fields.map((field) => [field.key, field]));
    const redacted: Record<string, unknown> = {};

    for (const [key, value] of Object.entries(payload)) {
      const field = fieldsByKey.get(key);
      const classification = field?.dataClassification ?? "none";
      const isPii = classification !== "none";

      if (isPii || !field) {
        redacted[key] = "[REDACTED]";
      } else {
        redacted[key] = value;
      }
    }

    return { ...row, payload: redacted };
  });
};

export const loadDatasetData = async (params: {
  datasetId: string;
  columns: string[];
  filters: QueryFilter[];
  fieldsToMask: string[];
}) => {
  const { datasetId } = params;
  const { getDb } = await import("~/db/server-helpers");
  const {
    and,
    asc,
    between,
    eq,
    gt,
    gte,
    ilike,
    inArray,
    isNull,
    lt,
    lte,
    ne,
    not,
  } = await import("drizzle-orm");
  const {
    events,
    formSubmissions,
    organizations,
    reportingSubmissions,
  } = await import("~/db/schema");

  const db = await getDb();

  const buildConditions = (
    columns: Record<string, unknown>,
    filters: QueryFilter[],
  ) => {
    const conditions = [] as Array<ReturnType<typeof eq>>;

    for (const filter of filters) {
      const column = columns[filter.field];
      if (!column) continue;

      switch (filter.operator) {
        case "eq":
          conditions.push(eq(column as never, filter.value as never));
          break;
        case "neq":
          conditions.push(ne(column as never, filter.value as never));
          break;
        case "gt":
          conditions.push(gt(column as never, filter.value as never));
          break;
        case "gte":
          conditions.push(gte(column as never, filter.value as never));
          break;
        case "lt":
          conditions.push(lt(column as never, filter.value as never));
          break;
        case "lte":
          conditions.push(lte(column as never, filter.value as never));
          break;
        case "in":
          conditions.push(inArray(column as never, filter.value as never[]));
          break;
        case "not_in":
          conditions.push(not(inArray(column as never, filter.value as never[])));
          break;
        case "between": {
          const [start, end] = filter.value as [unknown, unknown];
          conditions.push(between(column as never, start as never, end as never));
          break;
        }
        case "contains":
          conditions.push(ilike(column as never, `%${filter.value}%`));
          break;
        case "starts_with":
          conditions.push(ilike(column as never, `${filter.value}%`));
          break;
        case "ends_with":
          conditions.push(ilike(column as never, `%${filter.value}`));
          break;
        case "is_null":
          conditions.push(isNull(column as never));
          break;
        case "is_not_null":
          conditions.push(not(isNull(column as never)));
          break;
        default:
          break;
      }
    }

    return conditions.length ? and(...conditions) : undefined;
  };

  const buildOrderBy = (columns: Record<string, unknown>) => {
    const sortField = params.columns[0];
    if (!sortField || !columns[sortField]) return undefined;
    return asc(columns[sortField] as never);
  };

  if (datasetId === "organizations") {
    const columnMap = {
      id: organizations.id,
      name: organizations.name,
      slug: organizations.slug,
      type: organizations.type,
      parentOrgId: organizations.parentOrgId,
      status: organizations.status,
      createdAt: organizations.createdAt,
      updatedAt: organizations.updatedAt,
    } as const;

    const selection = Object.fromEntries(
      params.columns.map((column) => [
        column,
        columnMap[column as keyof typeof columnMap],
      ]),
    );

    const baseQuery = db
      .select(selection)
      .from(organizations)
      .where(buildConditions(columnMap, params.filters));

    const orderBy = buildOrderBy(columnMap);
    const rows = orderBy ? await baseQuery.orderBy(orderBy) : await baseQuery;

    const masked = rows.map((row) => maskPiiFields(row, params.fieldsToMask));

    return shapeRows(masked as Array<Record<string, unknown>>, params.columns);
  }

  if (datasetId === "reporting_submissions") {
    const columnMap = {
      id: reportingSubmissions.id,
      taskId: reportingSubmissions.taskId,
      organizationId: reportingSubmissions.organizationId,
      formSubmissionId: reportingSubmissions.formSubmissionId,
      status: reportingSubmissions.status,
      submittedAt: reportingSubmissions.submittedAt,
      submittedBy: reportingSubmissions.submittedBy,
      reviewedAt: reportingSubmissions.reviewedAt,
      reviewedBy: reportingSubmissions.reviewedBy,
      reviewNotes: reportingSubmissions.reviewNotes,
      createdAt: reportingSubmissions.createdAt,
      updatedAt: reportingSubmissions.updatedAt,
    } as const;

    const selection = Object.fromEntries(
      params.columns.map((column) => [
        column,
        columnMap[column as keyof typeof columnMap],
      ]),
    );

    const baseQuery = db
      .select(selection)
      .from(reportingSubmissions)
      .where(buildConditions(columnMap, params.filters));

    const orderBy = buildOrderBy(columnMap);
    const rows = orderBy ? await baseQuery.orderBy(orderBy) : await baseQuery;

    const masked = rows.map((row) => maskPiiFields(row, params.fieldsToMask));

    return shapeRows(masked as Array<Record<string, unknown>>, params.columns);
  }

  if (datasetId === "form_submissions") {
    const columnMap = {
      id: formSubmissions.id,
      formId: formSubmissions.formId,
      formVersionId: formSubmissions.formVersionId,
      organizationId: formSubmissions.organizationId,
      importJobId: formSubmissions.importJobId,
      submitterId: formSubmissions.submitterId,
      status: formSubmissions.status,
      payload: formSubmissions.payload,
      completenessScore: formSubmissions.completenessScore,
      missingFields: formSubmissions.missingFields,
      validationErrors: formSubmissions.validationErrors,
      submittedAt: formSubmissions.submittedAt,
      reviewedBy: formSubmissions.reviewedBy,
      reviewedAt: formSubmissions.reviewedAt,
      reviewNotes: formSubmissions.reviewNotes,
      createdAt: formSubmissions.createdAt,
      updatedAt: formSubmissions.updatedAt,
    } as const;

    const shouldIncludePayload = params.columns.includes("payload");
    const queryColumns = [...params.columns];
    if (shouldIncludePayload && !queryColumns.includes("formVersionId")) {
      queryColumns.push("formVersionId");
    }

    const selection = Object.fromEntries(
      queryColumns.map((column) => [
        column,
        columnMap[column as keyof typeof columnMap],
      ]),
    );

    const baseQuery = db
      .select(selection)
      .from(formSubmissions)
      .where(buildConditions(columnMap, params.filters));

    const orderBy = buildOrderBy(columnMap);
    const rows = orderBy ? await baseQuery.orderBy(orderBy) : await baseQuery;

    const maskFields = params.fieldsToMask.filter((field) => field !== "payload");
    let masked = rows.map((row) => maskPiiFields(row, maskFields));

    if (shouldIncludePayload) {
      masked = await redactFormSubmissionPayloads({
        rows: masked as Array<Record<string, unknown>>,
        canViewSensitiveFields: params.fieldsToMask.length === 0,
      });
    }

    return shapeRows(masked as Array<Record<string, unknown>>, params.columns);
  }

  if (datasetId === "events") {
    const columnMap = {
      id: events.id,
      name: events.name,
      type: events.type,
      status: events.status,
      startDate: events.startDate,
      endDate: events.endDate,
      createdAt: events.createdAt,
    } as const;

    const selection = Object.fromEntries(
      params.columns.map((column) => [
        column,
        columnMap[column as keyof typeof columnMap],
      ]),
    );

    const baseQuery = db
      .select(selection)
      .from(events)
      .where(buildConditions(columnMap, params.filters));

    const orderBy = buildOrderBy(columnMap);
    const rows = orderBy ? await baseQuery.orderBy(orderBy) : await baseQuery;

    const masked = rows.map((row) => maskPiiFields(row, params.fieldsToMask));

    return shapeRows(masked as Array<Record<string, unknown>>, params.columns);
  }

  return [];
};
</file>

<file path="src/features/bi/bi.sql-executor.ts">
import { sql, type SQLChunk } from "drizzle-orm";
import type { DatasetConfig } from "./bi.types";
import type { QueryContext } from "./bi.types";
import type { JsonRecord, JsonValue } from "~/shared/lib/json";
import { parseAndValidateSql, validateAgainstDataset } from "./engine/sql-parser";
import { rewriteSqlTables } from "./engine/sql-rewriter";
import {
  QUERY_GUARDRAILS,
  acquireConcurrencySlot,
  buildLimitedQuery,
  inlineParameters,
  stripTrailingSemicolons,
} from "./governance/query-guardrails";
import { DATASETS, getDataset } from "./semantic";

const PLACEHOLDER_PATTERN = /\{\{([a-zA-Z_][\w]*)\}\}/g;

const escapeSqlString = (value: string) => `'${value.replaceAll("'", "''")}'`;

const formatSettingValue = (value: string | number | boolean) => {
  if (typeof value === "number") {
    return Number.isFinite(value) ? String(value) : "0";
  }
  if (typeof value === "boolean") {
    return value ? "true" : "false";
  }
  return escapeSqlString(value);
};

export type SqlExecutionResult = {
  rows: JsonRecord[];
  truncated: boolean;
  executionTimeMs: number;
  rowCount: number;
  sql: string;
};

const getViewName = (datasetId: string) => `bi_v_${datasetId}`;

const buildTableMapping = (datasets: DatasetConfig[]) => {
  const map: Record<string, string> = {};
  for (const dataset of datasets) {
    map[dataset.baseTable] = getViewName(dataset.id);
    map[dataset.id] = getViewName(dataset.id);
  }
  return map;
};

const buildAllowedTables = (datasets: DatasetConfig[]) =>
  new Set(datasets.map((dataset) => getViewName(dataset.id)));

const buildAllowedColumns = (datasets: DatasetConfig[]) => {
  const allowed = new Map<string, Set<string>>();
  for (const dataset of datasets) {
    const viewName = getViewName(dataset.id);
    const columns = new Set<string>();
    for (const field of dataset.fields) {
      if (field.piiClassification && field.piiClassification !== "none") continue;
      columns.add(field.sourceColumn.toLowerCase());
    }
    allowed.set(viewName, columns);
  }
  return allowed;
};

const buildParameterizedSql = (
  sqlText: string,
  parameters: Record<string, unknown>,
) => {
  let lastIndex = 0;
  const chunks: SQLChunk[] = [];
  let match: RegExpExecArray | null = null;

  while ((match = PLACEHOLDER_PATTERN.exec(sqlText)) !== null) {
    const before = sqlText.slice(lastIndex, match.index);
    if (before) {
      chunks.push(sql.raw(before));
    }
    const name = match[1];
    if (!(name in parameters)) {
      throw new Error(`Missing SQL parameter: ${name}`);
    }
    chunks.push(sql.param(parameters[name]));
    lastIndex = match.index + match[0].length;
  }

  const tail = sqlText.slice(lastIndex);
  if (tail) {
    chunks.push(sql.raw(tail));
  }

  return sql.join(chunks);
};

const extractPlanCost = (explainResult: Array<Record<string, unknown>>) => {
  if (!explainResult.length) return null;
  const planEntry = explainResult[0] as Record<string, unknown>;
  const planValue = planEntry["QUERY PLAN"] ?? planEntry["QUERY_PLAN"];
  const plan = Array.isArray(planValue) ? planValue[0] : planValue;
  if (!plan || typeof plan !== "object") return null;
  const planDetails = (plan as Record<string, unknown>)["Plan"] as
    | Record<string, unknown>
    | undefined;
  const totalCost = planDetails?.["Total Cost"];
  return typeof totalCost === "number" ? totalCost : null;
};

const normalizeSqlValue = (value: unknown): JsonValue => {
  if (value === null || value === undefined) return null;
  if (value instanceof Date) return value.toISOString();
  if (typeof value === "bigint") return value.toString();
  if (Array.isArray(value)) return value.map((entry) => normalizeSqlValue(entry));
  if (typeof value === "object") {
    const nested: JsonRecord = {};
    for (const [key, entry] of Object.entries(value)) {
      nested[key] = normalizeSqlValue(entry);
    }
    return nested;
  }
  if (typeof value === "number" || typeof value === "string" || typeof value === "boolean") {
    return value;
  }
  return String(value);
};

const normalizeSqlRow = (row: Record<string, unknown>): JsonRecord => {
  const normalized: JsonRecord = {};
  for (const [key, value] of Object.entries(row)) {
    normalized[key] = normalizeSqlValue(value);
  }
  return normalized;
};

export const executeSqlWorkbenchQuery = async (params: {
  sqlText: string;
  parameters?: Record<string, unknown>;
  datasetId?: string;
  context: QueryContext;
  maxRows?: number;
}): Promise<SqlExecutionResult> => {
  const { sqlText, datasetId, context } = params;
  const parameters = params.parameters ?? {};
  const maxRows = params.maxRows ?? QUERY_GUARDRAILS.maxRowsUi;

  const release = acquireConcurrencySlot(context.userId, context.organizationId);
  const startedAt = Date.now();

  try {
    const parsed = parseAndValidateSql(sqlText);
    if (!parsed.isValid) {
      throw new Error(parsed.errors.join(" "));
    }

    const selectedDatasets = (
      datasetId ? [getDataset(datasetId)] : Object.values(DATASETS)
    ).filter((dataset): dataset is DatasetConfig => Boolean(dataset));

    if (selectedDatasets.length === 0) {
      throw new Error("No datasets available for SQL workbench");
    }

    const tableMapping = buildTableMapping(selectedDatasets);
    const rewritten = rewriteSqlTables(stripTrailingSemicolons(sqlText), tableMapping);

    const rewrittenParsed = parseAndValidateSql(rewritten.sql);
    if (!rewrittenParsed.isValid) {
      throw new Error(rewrittenParsed.errors.join(" "));
    }

    const allowedTables = buildAllowedTables(selectedDatasets);
    const allowedColumns = buildAllowedColumns(selectedDatasets);
    const validationErrors = validateAgainstDataset(
      rewrittenParsed,
      allowedTables,
      allowedColumns,
    );

    if (validationErrors.length > 0) {
      throw new Error(validationErrors.join(" "));
    }

    const limitedSqlText = buildLimitedQuery(rewritten.sql, maxRows);
    const query = buildParameterizedSql(limitedSqlText, parameters);

    const { getDb } = await import("~/db/server-helpers");
    const db = await getDb();

    const result = await db.transaction(async (tx) => {
      await tx.execute(sql.raw("SET LOCAL ROLE bi_readonly"));
      await tx.execute(
        sql.raw(
          `SET LOCAL app.org_id = ${formatSettingValue(
            context.organizationId ?? "",
          )}`,
        ),
      );
      await tx.execute(
        sql.raw(
          `SET LOCAL app.is_global_admin = ${formatSettingValue(
            String(context.isGlobalAdmin),
          )}`,
        ),
      );
      await tx.execute(
        sql.raw(
          `SET LOCAL statement_timeout = ${formatSettingValue(
            QUERY_GUARDRAILS.statementTimeoutMs,
          )}`,
        ),
      );

      const explainSql = inlineParameters(limitedSqlText, parameters);
      const explainRows = await tx.execute<Record<string, unknown>>(
        sql.raw(`EXPLAIN (FORMAT JSON) ${explainSql}`),
      );
      const planCost = extractPlanCost(explainRows);
      if (
        typeof planCost === "number" &&
        planCost > QUERY_GUARDRAILS.maxEstimatedCost
      ) {
        throw new Error("SQL query exceeds cost limits");
      }

      return tx.execute<Record<string, unknown>>(query);
    });

    const rows = Array.isArray(result) ? result : [];
    const normalizedRows = rows.map((row) => normalizeSqlRow(row));
    const executionTimeMs = Date.now() - startedAt;

    const { logQuery } = await import("./governance");
    const logParams = {
      context,
      queryType: "sql" as const,
      sqlQuery: rewritten.sql,
      parameters,
      rowsReturned: normalizedRows.length,
      executionTimeMs,
      ...(datasetId ? { datasetId } : {}),
    };

    await logQuery(logParams);

    return {
      rows: normalizedRows,
      truncated: normalizedRows.length >= maxRows,
      executionTimeMs,
      rowCount: normalizedRows.length,
      sql: rewritten.sql,
    };
  } finally {
    release();
  }
};
</file>

<file path="src/features/bi/bi.utils.ts">
import type { FilterConfig, PivotMeasure } from "./bi.schemas";
import type { DatasetConfig } from "./bi.types";
import type { PivotMeasureMeta } from "./engine/pivot-aggregator";
import {
  normalizeFilter,
  type AllowedFilterConfig,
  type FilterType,
  type NormalizedFilter,
} from "./engine/filters";

const operatorsByType: Record<FilterType, AllowedFilterConfig["operators"]> = {
  string: [
    "eq",
    "neq",
    "in",
    "not_in",
    "contains",
    "starts_with",
    "ends_with",
    "is_null",
    "is_not_null",
  ],
  enum: ["eq", "neq", "in", "not_in", "is_null", "is_not_null"],
  uuid: ["eq", "neq", "in", "not_in", "is_null", "is_not_null"],
  number: [
    "eq",
    "neq",
    "gt",
    "gte",
    "lt",
    "lte",
    "between",
    "in",
    "not_in",
    "is_null",
    "is_not_null",
  ],
  date: [
    "eq",
    "gt",
    "gte",
    "lt",
    "lte",
    "between",
    "is_null",
    "is_not_null",
  ],
  boolean: ["eq", "neq", "is_null", "is_not_null"],
};

const mapFilterType = (dataType: DatasetConfig["fields"][number]["dataType"]):
  | FilterType
  | null => {
  switch (dataType) {
    case "datetime":
    case "date":
      return "date";
    case "number":
      return "number";
    case "boolean":
      return "boolean";
    case "enum":
      return "enum";
    case "uuid":
      return "uuid";
    case "string":
      return "string";
    default:
      return null;
  }
};

export const buildAllowedFilters = (
  dataset: DatasetConfig,
): Record<string, AllowedFilterConfig> => {
  return dataset.fields.reduce<Record<string, AllowedFilterConfig>>((acc, field) => {
    if (!field.allowFilter) return acc;
    const type = mapFilterType(field.dataType);
    if (!type) return acc;
    acc[field.id] = {
      type,
      operators: operatorsByType[type],
    };
    return acc;
  }, {});
};

export type NormalizedPivotConfig = {
  rowFields: string[];
  columnFields: string[];
  measures: PivotMeasureMeta[];
  selectedFields: string[];
  filters: NormalizedFilter[];
};

export type NormalizationResult =
  | { ok: true; value: NormalizedPivotConfig }
  | { ok: false; errors: string[] };

export const normalizePivotConfig = (params: {
  dataset: DatasetConfig;
  rows?: string[] | undefined;
  columns?: string[] | undefined;
  measures: PivotMeasure[];
  filters: FilterConfig[];
}): NormalizationResult => {
  const errors: string[] = [];
  const rowFields = Array.from(new Set(params.rows ?? []));
  const columnFields = Array.from(new Set(params.columns ?? []));

  const fieldById = new Map(params.dataset.fields.map((field) => [field.id, field]));

  for (const field of rowFields) {
    const definition = fieldById.get(field);
    if (!definition) {
      errors.push(`Row field '${field}' is not in dataset '${params.dataset.id}'`);
      continue;
    }
    if (!definition.allowGroupBy) {
      errors.push(`Row field '${field}' does not support grouping`);
    }
  }

  for (const field of columnFields) {
    const definition = fieldById.get(field);
    if (!definition) {
      errors.push(`Column field '${field}' is not in dataset '${params.dataset.id}'`);
      continue;
    }
    if (!definition.allowGroupBy) {
      errors.push(`Column field '${field}' does not support grouping`);
    }
  }

  const measures: PivotMeasureMeta[] = params.measures.map((measure) => {
    if (measure.aggregation !== "count" && !measure.field) {
      errors.push("Measures require a field for non-count aggregations.");
    }

    if (measure.field) {
      const definition = fieldById.get(measure.field);
      if (!definition) {
        errors.push(`Measure field '${measure.field}' is not in dataset`);
      } else if (!definition.allowAggregate) {
        errors.push(`Measure field '${measure.field}' does not allow aggregation`);
      }
    }

    const field = measure.field ?? null;
    const key = `${measure.aggregation}:${field ?? "count"}`;
    const label =
      measure.aggregation === "count"
        ? "Count"
        : `${measure.aggregation.toUpperCase()}(${field ?? "-"})`;
    return {
      field,
      aggregation: measure.aggregation,
      key,
      label: measure.label ?? label,
    };
  });

  const measureFields = measures
    .map((measure) => measure.field)
    .filter((field): field is string => Boolean(field));

  const selectedFields = Array.from(
    new Set([...rowFields, ...columnFields, ...measureFields]),
  );

  if (selectedFields.length === 0) {
    const fallback = params.dataset.fields[0]?.id;
    if (fallback) {
      selectedFields.push(fallback);
    } else {
      errors.push("No fields available for pivot query.");
    }
  }

  const allowedFilters = buildAllowedFilters(params.dataset);
  const normalizedFilters: NormalizedFilter[] = [];

  for (const filter of params.filters) {
    try {
      normalizedFilters.push(normalizeFilter(filter, allowedFilters));
    } catch (error) {
      errors.push(error instanceof Error ? error.message : "Invalid filter");
    }
  }

  if (errors.length > 0) {
    return { ok: false, errors };
  }

  return {
    ok: true,
    value: {
      rowFields,
      columnFields,
      measures,
      selectedFields,
      filters: normalizedFilters,
    },
  };
};
</file>

<file path="src/features/bi/engine/aggregations.ts">
/**
 * Aggregation Functions
 *
 * Pure aggregation implementations for pivot computations.
 * Designed for TDD with property-based testing.
 *
 * @see src/features/bi/docs/GUIDE-bi-testing.md
 */

import type { AggregationType } from "../bi.schemas";

export type AggregatorFn = (values: number[]) => number | null;

export const count: AggregatorFn = (values) => values.length;
export const sum: AggregatorFn = (values) => values.reduce((acc, val) => acc + val, 0);
export const avg: AggregatorFn = (values) =>
  values.length > 0
    ? values.reduce((acc, val) => acc + val, 0) / values.length
    : null;
export const min: AggregatorFn = (values) =>
  values.length > 0 ? Math.min(...values) : null;
export const max: AggregatorFn = (values) =>
  values.length > 0 ? Math.max(...values) : null;

export const aggregators: Record<
  Exclude<AggregationType, "count_distinct" | "median" | "stddev" | "variance">,
  AggregatorFn
> = {
  count,
  sum,
  avg,
  min,
  max,
};

export const countDistinct: AggregatorFn = (values) => new Set(values).size;
export const median: AggregatorFn = (values) => {
  if (values.length === 0) return null;
  const sorted = [...values].sort((a, b) => a - b);
  const mid = Math.floor(sorted.length / 2);
  return sorted.length % 2 !== 0
    ? sorted[mid]
    : (sorted[mid - 1] + sorted[mid]) / 2;
};
export const stddev: AggregatorFn = (values) => {
  if (values.length < 2) return null;
  const mean = values.reduce((acc, val) => acc + val, 0) / values.length;
  const squaredDiffs = values.map((value) => (value - mean) ** 2);
  return Math.sqrt(squaredDiffs.reduce((acc, val) => acc + val, 0) / values.length);
};
export const variance: AggregatorFn = (values) => {
  if (values.length < 2) return null;
  const mean = values.reduce((acc, val) => acc + val, 0) / values.length;
  const squaredDiffs = values.map((value) => (value - mean) ** 2);
  return squaredDiffs.reduce((acc, val) => acc + val, 0) / values.length;
};

export const aggregatorsPhase2: Record<
  "count_distinct" | "median" | "stddev" | "variance",
  AggregatorFn
> = {
  count_distinct: countDistinct,
  median,
  stddev,
  variance,
};

const allAggregators: Record<AggregationType, AggregatorFn> = {
  ...aggregators,
  ...aggregatorsPhase2,
};

export function executeAggregation(type: AggregationType, values: number[]): number | null {
  const aggregator = allAggregators[type];
  if (!aggregator) {
    throw new Error(`Unknown aggregation type: ${type}`);
  }
  return aggregator(values);
}
</file>

<file path="src/features/bi/engine/filters.ts">
/**
 * Filter Engine
 *
 * Normalization + client-side matching helpers for BI filters.
 */

import type { FilterConfig, FilterOperator, FilterValue } from "../bi.schemas";

export type FilterType = "string" | "number" | "date" | "enum" | "uuid" | "boolean";

export type NormalizedFilter = {
  field: string;
  operator: FilterOperator;
  value: unknown;
};

export type AllowedFilterConfig = {
  operators: FilterOperator[];
  type: FilterType;
};

const coerceBoolean = (value: unknown): boolean => {
  if (typeof value === "boolean") return value;
  if (value === "true") return true;
  if (value === "false") return false;
  throw new Error("Value must be a boolean");
};

const coerceNumber = (value: unknown): number => {
  const parsed = typeof value === "number" ? value : Number(value);
  if (!Number.isFinite(parsed)) {
    throw new Error("Value must be a number");
  }
  return parsed;
};

const coerceDate = (value: unknown): Date => {
  const date = value instanceof Date ? value : new Date(String(value));
  if (Number.isNaN(date.getTime())) {
    throw new Error("Value must be a valid date");
  }
  return date;
};

const coerceString = (value: unknown): string => {
  if (typeof value === "string" && value.trim()) return value;
  throw new Error("Value must be a non-empty string");
};

const coerceValue = (value: unknown, type: FilterType) => {
  switch (type) {
    case "number":
      return coerceNumber(value);
    case "boolean":
      return coerceBoolean(value);
    case "date":
      return coerceDate(value);
    case "string":
    case "enum":
    case "uuid":
      return coerceString(value);
    default:
      return value;
  }
};

const coerceFilterValue = (
  rawValue: unknown,
  type: FilterType,
  operator: FilterOperator,
): unknown => {
  if (operator === "is_null" || operator === "is_not_null") {
    return null;
  }

  if (operator === "in" || operator === "not_in") {
    if (!Array.isArray(rawValue) || rawValue.length === 0) {
      throw new Error("Value must be a non-empty array");
    }
    return rawValue.map((value) => coerceValue(value, type));
  }

  if (operator === "between") {
    if (!Array.isArray(rawValue) || rawValue.length !== 2) {
      throw new Error("Value must be a [start, end] array");
    }
    return rawValue.map((value) => coerceValue(value, type));
  }

  if (Array.isArray(rawValue)) {
    throw new Error("Value must be a single value");
  }

  return coerceValue(rawValue, type);
};

export function normalizeFilter(
  filter: FilterConfig,
  allowedFilters: Record<string, AllowedFilterConfig>,
): NormalizedFilter {
  const config = allowedFilters[filter.field];
  if (!config) {
    throw new Error(`Field '${filter.field}' is not allowed`);
  }

  if (!config.operators.includes(filter.operator)) {
    throw new Error(`Operator '${filter.operator}' not allowed for '${filter.field}'`);
  }

  return {
    field: filter.field,
    operator: filter.operator,
    value: coerceFilterValue(filter.value, config.type, filter.operator),
  };
}

export function validateFilter(
  filter: FilterConfig,
  allowedFilters: Record<string, AllowedFilterConfig>,
): { valid: boolean; errors: string[] } {
  const errors: string[] = [];
  const config = allowedFilters[filter.field];
  if (!config) {
    return { valid: false, errors: [`Field '${filter.field}' is not allowed`] };
  }

  if (!config.operators.includes(filter.operator)) {
    errors.push(`Operator '${filter.operator}' not allowed for field '${filter.field}'`);
  }

  try {
    coerceFilterValue(filter.value, config.type, filter.operator);
  } catch (error) {
    errors.push(error instanceof Error ? error.message : "Invalid filter value");
  }

  return { valid: errors.length === 0, errors };
}

const toComparable = (value: unknown): string | number | null => {
  if (value === null || value === undefined) return null;
  if (value instanceof Date) return value.getTime();
  if (typeof value === "number") return value;
  if (typeof value === "string") {
    const date = new Date(value);
    if (!Number.isNaN(date.getTime())) return date.getTime();
    return value;
  }
  return null;
};

/**
 * Apply a single filter to a value
 */
export function matchesFilter(
  value: unknown,
  operator: FilterOperator,
  filterValue: FilterValue | undefined,
): boolean {
  if (operator === "is_null") return value === null || value === undefined;
  if (operator === "is_not_null") return value !== null && value !== undefined;

  if (value === null || value === undefined) {
    if (operator === "eq" && filterValue === null) return true;
    if (operator === "neq" && filterValue !== null) return true;
    return false;
  }

  switch (operator) {
    case "eq":
      return value === filterValue;
    case "neq":
      return value !== filterValue;
    case "gt": {
      const left = toComparable(value);
      const right = toComparable(filterValue);
      return left !== null && right !== null ? left > right : false;
    }
    case "gte": {
      const left = toComparable(value);
      const right = toComparable(filterValue);
      return left !== null && right !== null ? left >= right : false;
    }
    case "lt": {
      const left = toComparable(value);
      const right = toComparable(filterValue);
      return left !== null && right !== null ? left < right : false;
    }
    case "lte": {
      const left = toComparable(value);
      const right = toComparable(filterValue);
      return left !== null && right !== null ? left <= right : false;
    }
    case "in":
      return Array.isArray(filterValue)
        ? filterValue.includes(value as string | number | boolean | null)
        : false;
    case "not_in":
      return Array.isArray(filterValue)
        ? !filterValue.includes(value as string | number | boolean | null)
        : false;
    case "between": {
      if (Array.isArray(filterValue) && filterValue.length === 2) {
        const [minVal, maxVal] = filterValue;
        const left = toComparable(value);
        const min = toComparable(minVal);
        const max = toComparable(maxVal);
        return left !== null && min !== null && max !== null
          ? left >= min && left <= max
          : false;
      }
      return false;
    }
    case "contains":
      return typeof value === "string" && typeof filterValue === "string"
        ? value.includes(filterValue)
        : false;
    case "starts_with":
      return typeof value === "string" && typeof filterValue === "string"
        ? value.startsWith(filterValue)
        : false;
    case "ends_with":
      return typeof value === "string" && typeof filterValue === "string"
        ? value.endsWith(filterValue)
        : false;
    default: {
      const _exhaustiveCheck: never = operator;
      throw new Error(`Unknown operator: ${_exhaustiveCheck}`);
    }
  }
}

/**
 * Check if a row matches all filters (AND logic)
 */
export function matchesAllFilters(
  row: Record<string, unknown>,
  filters: FilterConfig[],
): boolean {
  return filters.every((filter) =>
    matchesFilter(row[filter.field], filter.operator, filter.value),
  );
}

/**
 * Apply filters to a dataset
 */
export function applyFilters(
  data: Record<string, unknown>[],
  filters: FilterConfig[],
): Record<string, unknown>[] {
  if (filters.length === 0) return data;
  return data.filter((row) => matchesAllFilters(row, filters));
}

export function isNull(value: unknown): boolean {
  return value === null || value === undefined;
}

export function isNotNull(value: unknown): boolean {
  return value !== null && value !== undefined;
}
</file>

<file path="src/features/bi/engine/index.ts">
/**
 * BI Engine - Internal API
 *
 * Core computation engine for pivot tables and queries.
 */

export {
  buildPivotResult,
  groupByDimensions,
  parseDimensionKey,
  type PivotConfig,
  type PivotMeasureMeta,
} from "./pivot-aggregator";

export {
  aggregators,
  aggregatorsPhase2,
  avg,
  count,
  countDistinct,
  executeAggregation,
  max,
  median,
  min,
  stddev,
  sum,
  variance,
} from "./aggregations";

export {
  applyFilters,
  isNotNull,
  isNull,
  matchesAllFilters,
  matchesFilter,
  normalizeFilter,
  validateFilter,
  type AllowedFilterConfig,
  type FilterType,
  type NormalizedFilter,
} from "./filters";

export {
  normalizeSqlPlaceholders,
  parseAndValidateSql,
  restoreSqlPlaceholders,
  validateAgainstDataset,
  type ParsedQuery,
  type SqlParameter,
} from "./sql-parser";

export { rewriteSqlTables, type SqlRewriteResult } from "./sql-rewriter";

export { buildDatasetQueryPlan, type DatasetQueryPlan } from "./query-builder";

export {
  buildAllowedSortFields,
  normalizeSort,
  type SortConfig,
  type SortDirection,
} from "./sorting";
</file>

<file path="src/features/bi/engine/pivot-aggregator.ts">
/**
 * Pivot Aggregator Engine
 *
 * Core pivot table computation engine extracted from reports.mutations.ts.
 *
 * @see src/features/bi/docs/PLAN-bi-implementation.md
 * @see src/features/bi/docs/GUIDE-bi-testing.md
 */

import type { AggregationType, PivotResult } from "../bi.schemas";
import { executeAggregation } from "./aggregations";

export type PivotMeasureMeta = {
  field: string | null;
  aggregation: AggregationType;
  key: string;
  label: string;
};

export type PivotConfig = {
  rowFields: string[];
  columnFields: string[];
  measures: PivotMeasureMeta[];
};

type MeasureBucket = {
  count: number;
  values: number[];
  distinct: Set<string>;
};

const toPivotKey = (fields: string[], row: Record<string, unknown>) => {
  if (fields.length === 0) return "__total__";
  return fields.map((field) => String(row[field] ?? "")).join("||");
};

const toPivotValues = (fields: string[], row: Record<string, unknown>) => {
  const values: Record<string, string> = {};
  for (const field of fields) {
    const value = row[field];
    if (value === null || value === undefined) {
      values[field] = "";
    } else if (typeof value === "string") {
      values[field] = value;
    } else if (typeof value === "number" || typeof value === "boolean") {
      values[field] = String(value);
    } else {
      values[field] = JSON.stringify(value);
    }
  }
  return values;
};

const toNumber = (value: unknown): number | null => {
  if (typeof value === "number") return Number.isFinite(value) ? value : null;
  if (typeof value === "string" && value.trim()) {
    const parsed = Number(value);
    return Number.isFinite(parsed) ? parsed : null;
  }
  return null;
};

/**
 * Build pivot result from raw data
 *
 * @param rows - Raw data rows (already org-scoped and filtered)
 * @param config - Pivot config with fields and measures
 */
export function buildPivotResult(
  rows: Array<Record<string, unknown>>,
  config: PivotConfig,
): PivotResult {
  const columnKeyMap = new Map<string, Record<string, string>>();
  const rowMap = new Map<
    string,
    {
      values: Record<string, string>;
      cells: Record<string, Record<string, MeasureBucket>>;
    }
  >();

  for (const row of rows) {
    const rowKey = toPivotKey(config.rowFields, row);
    const columnKey = toPivotKey(config.columnFields, row);
    const columnValues = toPivotValues(config.columnFields, row);

    if (!columnKeyMap.has(columnKey)) {
      columnKeyMap.set(columnKey, columnValues);
    }

    const rowEntry = rowMap.get(rowKey) ?? {
      values: toPivotValues(config.rowFields, row),
      cells: {},
    };

    if (!rowEntry.cells[columnKey]) {
      rowEntry.cells[columnKey] = {};
    }

    for (const measure of config.measures) {
      if (!rowEntry.cells[columnKey][measure.key]) {
        rowEntry.cells[columnKey][measure.key] = {
          count: 0,
          values: [],
          distinct: new Set<string>(),
        };
      }

      const bucket = rowEntry.cells[columnKey][measure.key];

      if (measure.aggregation === "count") {
        bucket.count += 1;
        continue;
      }

      const field = measure.field;
      if (!field) continue;
      const rawValue = row[field];

      if (measure.aggregation === "count_distinct") {
        if (rawValue !== null && rawValue !== undefined) {
          bucket.distinct.add(String(rawValue));
        }
        continue;
      }

      const numeric = toNumber(rawValue);
      if (numeric === null) continue;
      bucket.values.push(numeric);
    }

    rowMap.set(rowKey, rowEntry);
  }

  const columnKeys = Array.from(columnKeyMap.entries()).map(([key, values]) => {
    const label =
      Object.keys(values).length === 0
        ? "Total"
        : Object.entries(values)
            .map(([field, value]) => `${field}: ${value || "-"}`)
            .join(" / ");
    return { key, label, values };
  });

  const outputRows = Array.from(rowMap.entries()).map(([key, rowEntry]) => {
    const cells: Record<string, Record<string, number | null>> = {};
    for (const columnKey of columnKeys) {
      const aggregate = rowEntry.cells[columnKey.key] ?? {};
      cells[columnKey.key] = {};
      for (const measure of config.measures) {
        const bucket = aggregate[measure.key];
        if (!bucket) {
          cells[columnKey.key][measure.key] = null;
          continue;
        }

        if (measure.aggregation === "count") {
          cells[columnKey.key][measure.key] = bucket.count;
          continue;
        }

        if (measure.aggregation === "count_distinct") {
          cells[columnKey.key][measure.key] = bucket.distinct.size;
          continue;
        }

        const value = executeAggregation(measure.aggregation, bucket.values);
        if (measure.aggregation === "avg") {
          cells[columnKey.key][measure.key] =
            value !== null ? Number(value.toFixed(2)) : null;
          continue;
        }

        cells[columnKey.key][measure.key] = value;
      }
    }

    return { key, values: rowEntry.values, cells };
  });

  return {
    rowFields: config.rowFields,
    columnFields: config.columnFields,
    measures: config.measures,
    columnKeys,
    rows: outputRows,
  };
}

/**
 * Group data by dimension values
 *
 * @internal
 */
export function groupByDimensions(
  data: Record<string, unknown>[],
  dimensions: string[],
): Map<string, Record<string, unknown>[]> {
  const groups = new Map<string, Record<string, unknown>[]>();

  for (const row of data) {
    const key =
      dimensions.length === 0
        ? "__total__"
        : dimensions.map((dimension) => String(row[dimension] ?? "")).join("|");
    const existing = groups.get(key) ?? [];
    existing.push(row);
    groups.set(key, existing);
  }

  return groups;
}

/**
 * Extract dimension values from group key
 *
 * @internal
 */
export function parseDimensionKey(
  key: string,
  dimensions: string[],
): Record<string, string> {
  const values = key.split("|");
  const result: Record<string, string> = {};
  dimensions.forEach((dimension, index) => {
    result[dimension] = values[index] ?? "";
  });
  return result;
}
</file>

<file path="src/features/bi/governance/audit-logger.ts">
/**
 * BI Audit Logger
 *
 * Logs BI queries and exports to the bi_query_log table.
 * Maintains its own tamper-evident chain.
 *
 * @see src/features/bi/docs/SPEC-bi-platform.md
 */

import type { PivotQuery } from "../bi.schemas";
import type { BiQueryLogEntry, QueryContext } from "../bi.types";

export type QueryType = "pivot" | "sql" | "export";

export interface LogQueryParams {
  context: QueryContext;
  queryType: QueryType;
  datasetId?: string;
  pivotQuery?: PivotQuery;
  sqlQuery?: string;
  parameters?: Record<string, unknown> | null;
  rowsReturned: number;
  executionTimeMs: number;
}

export async function computeQueryHash(query: PivotQuery | string): Promise<string> {
  const queryString = typeof query === "string" ? query : JSON.stringify(query);
  const encoder = new TextEncoder();
  const data = encoder.encode(queryString);

  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
}

export async function computeChecksum(
  logEntry: Omit<BiQueryLogEntry, "checksum">,
  previousChecksum: string | null,
  secret: string,
): Promise<string> {
  const payload = JSON.stringify({
    id: logEntry.id,
    userId: logEntry.userId,
    organizationId: logEntry.organizationId,
    queryType: logEntry.queryType,
    queryHash: logEntry.queryHash,
    rowsReturned: logEntry.rowsReturned,
    executionTimeMs: logEntry.executionTimeMs,
    previousLogId: logEntry.previousLogId,
    createdAt: logEntry.createdAt.toISOString(),
    previousChecksum: previousChecksum ?? "",
  });

  const encoder = new TextEncoder();
  const keyData = encoder.encode(secret);
  const messageData = encoder.encode(payload);

  const cryptoKey = await crypto.subtle.importKey(
    "raw",
    keyData,
    { name: "HMAC", hash: "SHA-256" },
    false,
    ["sign"],
  );

  const signature = await crypto.subtle.sign("HMAC", cryptoKey, messageData);
  const hashArray = Array.from(new Uint8Array(signature));
  return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
}

export async function logQuery(params: LogQueryParams): Promise<string> {
  const {
    context,
    queryType,
    datasetId,
    pivotQuery,
    sqlQuery,
    parameters,
    rowsReturned,
    executionTimeMs,
  } = params;
  const normalizedDatasetId =
    datasetId && /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(datasetId)
      ? datasetId
      : null;

  const { getDb } = await import("~/db/server-helpers");
  const { biQueryLog } = await import("~/db/schema");
  const { desc, eq, isNull } = await import("drizzle-orm");
  const { getAuthSecret } = await import("~/lib/env.server");

  const db = await getDb();

  const [previous] = await db
    .select({ id: biQueryLog.id, checksum: biQueryLog.checksum })
    .from(biQueryLog)
    .where(
      context.organizationId
        ? eq(biQueryLog.organizationId, context.organizationId)
        : isNull(biQueryLog.organizationId),
    )
    .orderBy(desc(biQueryLog.createdAt), desc(biQueryLog.id))
    .limit(1);

  const id = crypto.randomUUID();
  const queryHash = await computeQueryHash(
    sqlQuery ?? pivotQuery ?? `${queryType}:${datasetId ?? "unknown"}`,
  );

  const entry: Omit<BiQueryLogEntry, "checksum"> = {
    id,
    userId: context.userId,
    organizationId: context.organizationId ?? null,
    queryType,
    queryHash,
    datasetId: normalizedDatasetId,
    sqlQuery: sqlQuery ?? null,
    parameters: parameters ?? null,
    pivotConfig: pivotQuery
      ? {
          rows: pivotQuery.rows,
          columns: pivotQuery.columns,
          measures: pivotQuery.measures.map((measure) => ({
            field: measure.field ?? null,
            aggregation: measure.aggregation,
            ...(measure.label ? { label: measure.label } : {}),
          })),
        }
      : null,
    rowsReturned,
    executionTimeMs,
    previousLogId: previous?.id ?? null,
    createdAt: new Date(),
  };

  const checksum = await computeChecksum(entry, previous?.checksum ?? null, getAuthSecret());

  await db.insert(biQueryLog).values({
    ...entry,
    checksum,
  });

  return id;
}

export async function logExport(
  params: LogQueryParams & {
    format: "csv" | "xlsx" | "json";
    includesPii: boolean;
    stepUpAuthUsed: boolean;
  },
): Promise<string> {
  return logQuery({
    ...params,
    queryType: "export",
  });
}

export async function verifyAuditChain(
  organizationId: string,
  startDate: Date,
  endDate: Date,
): Promise<{
  valid: boolean;
  entriesChecked: number;
  firstBrokenEntry: string | null;
}> {
  const { getDb } = await import("~/db/server-helpers");
  const { biQueryLog } = await import("~/db/schema");
  const { and, asc, between, eq } = await import("drizzle-orm");
  const { getAuthSecret } = await import("~/lib/env.server");

  const db = await getDb();
  const rows = await db
    .select()
    .from(biQueryLog)
    .where(
      and(
        eq(biQueryLog.organizationId, organizationId),
        between(biQueryLog.createdAt, startDate, endDate),
      ),
    )
    .orderBy(asc(biQueryLog.createdAt), asc(biQueryLog.id));

  let previousChecksum: string | null = null;
  let entriesChecked = 0;

  for (const row of rows) {
    const expected = await computeChecksum(
      {
        id: row.id,
        userId: row.userId,
        organizationId: row.organizationId ?? null,
        queryType: row.queryType as QueryType,
        queryHash: row.queryHash,
        datasetId: row.datasetId ?? null,
        sqlQuery: row.sqlQuery ?? null,
        parameters: row.parameters ?? null,
        pivotConfig: row.pivotConfig ?? null,
        rowsReturned: row.rowsReturned ?? 0,
        executionTimeMs: row.executionTimeMs ?? 0,
        previousLogId: row.previousLogId ?? null,
        createdAt: row.createdAt,
      },
      previousChecksum,
      getAuthSecret(),
    );

    entriesChecked += 1;
    if (row.checksum !== expected) {
      return { valid: false, entriesChecked, firstBrokenEntry: row.id };
    }
    previousChecksum = row.checksum ?? null;
  }

  return { valid: true, entriesChecked, firstBrokenEntry: null };
}
</file>

<file path="src/features/bi/governance/field-acl.ts">
/**
 * Field-Level Access Control
 *
 * Enforces field-level permissions for BI queries based on user permissions.
 * Masks PII fields for non-privileged users.
 *
 * @see src/features/bi/docs/SPEC-bi-platform.md (Governance Model)
 */

import type { DatasetField, QueryContext } from "../bi.types";

export const PII_PERMISSIONS = ["*", "pii.read", "pii:read", "data.pii.read"];

export function canViewSensitiveFields(permissions: Set<string>): boolean {
  return PII_PERMISSIONS.some((permission) => permissions.has(permission));
}

const hasPermission = (permissions: Set<string>, required?: string): boolean => {
  if (!required) return true;
  return permissions.has(required) || permissions.has("*");
};

export interface FieldAccessResult {
  canAccess: boolean;
  isPii: boolean;
  shouldMask: boolean;
  reason: string;
}

export function checkFieldAccess(
  field: DatasetField,
  context: QueryContext,
  isExport: boolean = false,
): FieldAccessResult {
  const hasRequiredPermission = hasPermission(
    context.permissions,
    field.requiredPermission,
  );

  if (!hasRequiredPermission) {
    return {
      canAccess: false,
      isPii: field.piiClassification !== undefined && field.piiClassification !== "none",
      shouldMask: false,
      reason: `Missing permission ${field.requiredPermission ?? ""}`,
    };
  }

  const isPii = field.piiClassification !== undefined && field.piiClassification !== "none";
  const canViewPii = context.isGlobalAdmin || canViewSensitiveFields(context.permissions);

  if (isPii && (!canViewPii || (isExport && !context.hasRecentAuth))) {
    return {
      canAccess: true,
      isPii: true,
      shouldMask: true,
      reason: "PII field masked",
    };
  }

  return {
    canAccess: true,
    isPii,
    shouldMask: false,
    reason: "Field access granted",
  };
}

export function filterAccessibleFields(
  fields: DatasetField[],
  context: QueryContext,
): DatasetField[] {
  return fields.filter((field) => checkFieldAccess(field, context).canAccess);
}

export function getFieldsToMask(
  fields: DatasetField[],
  context: QueryContext,
  isExport: boolean = false,
): string[] {
  return fields
    .filter((field) => checkFieldAccess(field, context, isExport).shouldMask)
    .map((field) => field.id);
}

export function maskPiiFields(
  row: Record<string, unknown>,
  fieldsToMask: string[],
): Record<string, unknown> {
  if (fieldsToMask.length === 0) return row;

  const maskedRow = { ...row };
  for (const field of fieldsToMask) {
    if (field in maskedRow) {
      maskedRow[field] = "***";
    }
  }
  return maskedRow;
}

export function queryIncludesPii(
  requestedFields: string[],
  datasetFields: DatasetField[],
): boolean {
  const fieldMap = new Map(datasetFields.map((field) => [field.id, field]));
  return requestedFields.some((fieldId) => {
    const field = fieldMap.get(fieldId);
    return field?.piiClassification !== undefined && field.piiClassification !== "none";
  });
}
</file>

<file path="src/features/bi/governance/index.ts">
/**
 * Governance Layer - Public API
 *
 * Access control, org scoping, and audit logging for BI.
 */

export {
  applyOrgScopingFilter,
  buildOrgScopingClause,
  determineOrgScoping,
  type OrgScopingResult,
} from "./org-scoping";

export {
  checkFieldAccess,
  filterAccessibleFields,
  getFieldsToMask,
  maskPiiFields,
  queryIncludesPii,
  type FieldAccessResult,
} from "./field-acl";

export {
  computeChecksum,
  computeQueryHash,
  logExport,
  logQuery,
  verifyAuditChain,
  type LogQueryParams,
  type QueryType,
} from "./audit-logger";

export {
  QUERY_GUARDRAILS,
  acquireConcurrencySlot,
  buildLimitedQuery,
  inlineParameters,
  stripTrailingSemicolons,
} from "./query-guardrails";

export { assertExportAllowed } from "./export-controls";
</file>

<file path="src/features/bi/governance/org-scoping.ts">
/**
 * Organization Scoping
 *
 * Enforces organization-level data isolation for BI queries.
 *
 * @see src/features/bi/docs/SPEC-bi-platform.md (Governance Model)
 */

import type { DatasetConfig, QueryContext } from "../bi.types";

export interface OrgScopingResult {
  shouldScope: boolean;
  scopeOrgId: string | null;
  scopeColumn: string | null;
  reason: string;
}

export function determineOrgScoping(
  context: QueryContext,
  dataset: DatasetConfig,
): OrgScopingResult {
  if (context.isGlobalAdmin) {
    return {
      shouldScope: false,
      scopeOrgId: null,
      scopeColumn: null,
      reason: "Global admin - org scoping bypassed",
    };
  }

  if (!dataset.requiresOrgScope) {
    return {
      shouldScope: false,
      scopeOrgId: null,
      scopeColumn: null,
      reason: `Dataset '${dataset.id}' does not require org scoping`,
    };
  }

  if (!dataset.orgScopeColumn) {
    return {
      shouldScope: true,
      scopeOrgId: context.organizationId,
      scopeColumn: "organizationId",
      reason: `Dataset '${dataset.id}' missing orgScopeColumn - using default`,
    };
  }

  return {
    shouldScope: true,
    scopeOrgId: context.organizationId,
    scopeColumn: dataset.orgScopeColumn,
    reason: `Scoped to org ${context.organizationId}`,
  };
}

export function applyOrgScopingFilter(
  data: Record<string, unknown>[],
  scoping: OrgScopingResult,
): Record<string, unknown>[] {
  if (!scoping.shouldScope || !scoping.scopeOrgId || !scoping.scopeColumn) {
    return data;
  }

  return data.filter((row) => row[scoping.scopeColumn!] === scoping.scopeOrgId);
}

export function buildOrgScopingClause(scoping: OrgScopingResult): string | null {
  if (!scoping.shouldScope || !scoping.scopeOrgId || !scoping.scopeColumn) {
    return null;
  }

  return `${scoping.scopeColumn} = :orgId`;
}
</file>

<file path="src/features/bi/semantic/datasets.config.ts">
/**
 * Dataset Configuration
 *
 * Defines available datasets for BI queries. Each dataset maps to a database
 * table/view and specifies which fields are queryable, their types, and access rules.
 *
 * @see src/features/bi/docs/SPEC-bi-platform.md
 */

import type { DatasetConfig, DatasetField } from "../bi.types";

const organizationFields: DatasetField[] = [
  {
    id: "id",
    name: "ID",
    sourceColumn: "id",
    dataType: "uuid",
    allowGroupBy: true,
    allowFilter: true,
    allowSort: true,
  },
  {
    id: "name",
    name: "Name",
    sourceColumn: "name",
    dataType: "string",
    allowGroupBy: true,
    allowFilter: true,
    allowSort: true,
  },
  {
    id: "slug",
    name: "Slug",
    sourceColumn: "slug",
    dataType: "string",
    allowGroupBy: true,
    allowFilter: true,
    allowSort: true,
  },
  {
    id: "type",
    name: "Type",
    sourceColumn: "type",
    dataType: "enum",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "parentOrgId",
    name: "Parent Organization",
    sourceColumn: "parent_org_id",
    dataType: "uuid",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "status",
    name: "Status",
    sourceColumn: "status",
    dataType: "enum",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "createdAt",
    name: "Created",
    sourceColumn: "created_at",
    dataType: "datetime",
    allowGroupBy: true,
    allowFilter: true,
    allowSort: true,
  },
  {
    id: "updatedAt",
    name: "Updated",
    sourceColumn: "updated_at",
    dataType: "datetime",
    allowGroupBy: true,
    allowFilter: true,
    allowSort: true,
  },
];

const reportingSubmissionFields: DatasetField[] = [
  {
    id: "id",
    name: "Submission ID",
    sourceColumn: "id",
    dataType: "uuid",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "taskId",
    name: "Task ID",
    sourceColumn: "task_id",
    dataType: "uuid",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "organizationId",
    name: "Organization ID",
    sourceColumn: "organization_id",
    dataType: "uuid",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "formSubmissionId",
    name: "Form Submission ID",
    sourceColumn: "form_submission_id",
    dataType: "uuid",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "status",
    name: "Status",
    sourceColumn: "status",
    dataType: "enum",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "submittedAt",
    name: "Submitted",
    sourceColumn: "submitted_at",
    dataType: "datetime",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "submittedBy",
    name: "Submitted By",
    sourceColumn: "submitted_by",
    dataType: "string",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "reviewedAt",
    name: "Reviewed",
    sourceColumn: "reviewed_at",
    dataType: "datetime",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "reviewedBy",
    name: "Reviewed By",
    sourceColumn: "reviewed_by",
    dataType: "string",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "reviewNotes",
    name: "Review Notes",
    sourceColumn: "review_notes",
    dataType: "string",
    allowGroupBy: false,
    allowFilter: true,
  },
  {
    id: "createdAt",
    name: "Created",
    sourceColumn: "created_at",
    dataType: "datetime",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "updatedAt",
    name: "Updated",
    sourceColumn: "updated_at",
    dataType: "datetime",
    allowGroupBy: true,
    allowFilter: true,
  },
];

const formSubmissionFields: DatasetField[] = [
  {
    id: "id",
    name: "Submission ID",
    sourceColumn: "id",
    dataType: "uuid",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "formId",
    name: "Form ID",
    sourceColumn: "form_id",
    dataType: "uuid",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "formVersionId",
    name: "Form Version ID",
    sourceColumn: "form_version_id",
    dataType: "uuid",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "organizationId",
    name: "Organization ID",
    sourceColumn: "organization_id",
    dataType: "uuid",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "importJobId",
    name: "Import Job ID",
    sourceColumn: "import_job_id",
    dataType: "uuid",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "submitterId",
    name: "Submitter ID",
    sourceColumn: "submitter_id",
    dataType: "string",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "status",
    name: "Status",
    sourceColumn: "status",
    dataType: "enum",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "payload",
    name: "Payload",
    sourceColumn: "payload",
    dataType: "json",
    piiClassification: "sensitive",
    allowGroupBy: false,
    allowFilter: false,
  },
  {
    id: "completenessScore",
    name: "Completeness",
    sourceColumn: "completeness_score",
    dataType: "number",
    allowGroupBy: true,
    allowFilter: true,
    allowAggregate: true,
    defaultAggregation: "avg",
  },
  {
    id: "missingFields",
    name: "Missing Fields",
    sourceColumn: "missing_fields",
    dataType: "json",
    allowGroupBy: false,
    allowFilter: false,
  },
  {
    id: "validationErrors",
    name: "Validation Errors",
    sourceColumn: "validation_errors",
    dataType: "json",
    allowGroupBy: false,
    allowFilter: false,
  },
  {
    id: "submittedAt",
    name: "Submitted",
    sourceColumn: "submitted_at",
    dataType: "datetime",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "reviewedBy",
    name: "Reviewed By",
    sourceColumn: "reviewed_by",
    dataType: "string",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "reviewedAt",
    name: "Reviewed",
    sourceColumn: "reviewed_at",
    dataType: "datetime",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "reviewNotes",
    name: "Review Notes",
    sourceColumn: "review_notes",
    dataType: "string",
    allowGroupBy: false,
    allowFilter: true,
  },
  {
    id: "createdAt",
    name: "Created",
    sourceColumn: "created_at",
    dataType: "datetime",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "updatedAt",
    name: "Updated",
    sourceColumn: "updated_at",
    dataType: "datetime",
    allowGroupBy: true,
    allowFilter: true,
  },
];

const eventFields: DatasetField[] = [
  {
    id: "id",
    name: "Event ID",
    sourceColumn: "id",
    dataType: "uuid",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "name",
    name: "Event Name",
    sourceColumn: "name",
    dataType: "string",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "type",
    name: "Type",
    sourceColumn: "type",
    dataType: "enum",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "status",
    name: "Status",
    sourceColumn: "status",
    dataType: "enum",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "startDate",
    name: "Start Date",
    sourceColumn: "start_date",
    dataType: "date",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "endDate",
    name: "End Date",
    sourceColumn: "end_date",
    dataType: "date",
    allowGroupBy: true,
    allowFilter: true,
  },
  {
    id: "createdAt",
    name: "Created",
    sourceColumn: "created_at",
    dataType: "datetime",
    allowGroupBy: true,
    allowFilter: true,
  },
];

const measureFields = (fields: DatasetField[]) =>
  fields.map((field) => ({
    ...field,
    allowAggregate:
      field.allowAggregate ?? (field.dataType !== "json" && field.dataType !== "boolean"),
    defaultAggregation:
      field.defaultAggregation ?? (field.dataType === "number" ? "sum" : "count"),
  }));

export const DATASETS: Record<string, DatasetConfig> = {
  organizations: {
    id: "organizations",
    name: "Organizations",
    description: "Organization hierarchy and metadata",
    baseTable: "organizations",
    fields: measureFields(organizationFields),
    requiresOrgScope: true,
    orgScopeColumn: "id",
  },
  reporting_submissions: {
    id: "reporting_submissions",
    name: "Reporting Submissions",
    description: "Submission status and review metadata",
    baseTable: "reporting_submissions",
    fields: measureFields(reportingSubmissionFields),
    requiresOrgScope: true,
    orgScopeColumn: "organizationId",
  },
  form_submissions: {
    id: "form_submissions",
    name: "Form Submissions",
    description: "Form submission records",
    baseTable: "form_submissions",
    fields: measureFields(formSubmissionFields),
    requiresOrgScope: true,
    orgScopeColumn: "organizationId",
  },
  events: {
    id: "events",
    name: "Events",
    description: "Event schedule metadata",
    baseTable: "events",
    fields: measureFields(eventFields),
    requiresOrgScope: false,
  },
};

export function getDataset(datasetId: string): DatasetConfig | undefined {
  return DATASETS[datasetId];
}

export function getDatasetIds(): string[] {
  return Object.keys(DATASETS);
}

export function hasDataset(datasetId: string): boolean {
  return datasetId in DATASETS;
}
</file>

<file path="src/features/bi/semantic/index.ts">
/**
 * Semantic Layer - Public API
 *
 * Dataset and metric configurations for the BI module.
 */

export {
  DATASETS,
  getDataset,
  getDatasetIds,
  hasDataset,
} from "./datasets.config";

export { getDatasetFields, getFieldById } from "./field-metadata";

export {
  METRICS,
  getMetric,
  getMetricsForDataset,
  registerMetric,
  type MetricDefinition,
} from "./metrics.config";

export {
  CALCULATED_FIELDS,
  getCalculatedField,
  getCalculatedFieldsForDataset,
  registerCalculatedField,
  type CalculatedField,
} from "./calculated-fields";
</file>

<file path="src/features/bi/bi.mutations.ts">
/**
 * BI Module Mutations (Server Functions)
 */

import { createServerFn } from "@tanstack/react-start";
import { z } from "zod";
import type { OrganizationRole } from "~/lib/auth/guards/org-guard";
import { getAuthMiddleware, requireUser } from "~/lib/server/auth";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import type { FilterConfig } from "./bi.schemas";
import { exportRequestSchema, filterSchema, pivotQuerySchema } from "./bi.schemas";
import type { QueryContext } from "./bi.types";
import { normalizePivotConfig } from "./bi.utils";
import { loadDatasetData } from "./bi.data";
import { buildPivotResult } from "./engine/pivot-aggregator";
import {
  filterAccessibleFields,
  getFieldsToMask,
  queryIncludesPii,
} from "./governance";
import { getDataset } from "./semantic";
import type { JsonRecord, JsonValue } from "~/shared/lib/json";

const ANALYTICS_ROLES: OrganizationRole[] = ["owner", "admin", "reporter"];

const extractPermissionSet = (
  roleAssignments: Array<{ role?: { permissions?: Record<string, boolean> } }>,
) => {
  const permissions = new Set<string>();
  for (const assignment of roleAssignments) {
    const perms = assignment.role?.permissions ?? {};
    for (const [key, value] of Object.entries(perms)) {
      if (value) permissions.add(key);
    }
  }
  return permissions;
};

const serializeFilterValue = (value: unknown): JsonValue => {
  if (value instanceof Date) return value.toISOString();
  if (Array.isArray(value)) return value.map((entry) => serializeFilterValue(entry));
  if (
    typeof value === "string" ||
    typeof value === "number" ||
    typeof value === "boolean" ||
    value === null ||
    value === undefined
  ) {
    return value;
  }
  if (typeof value === "object") {
    const result: Record<string, JsonValue> = {};
    for (const [k, v] of Object.entries(value as Record<string, unknown>)) {
      result[k] = serializeFilterValue(v);
    }
    return result;
  }
  return null;
};

const serializeFilters = (filters: Array<{ field: string; operator: string; value: unknown }>) => {
  const serialized: JsonRecord = {};
  for (const filter of filters) {
    serialized[filter.field] = {
      operator: filter.operator,
      value: serializeFilterValue(filter.value),
    };
  }
  return serialized;
};

const ensureOrgScope = (
  params: {
    datasetOrgField?: string;
    datasetRequiresOrg: boolean | undefined;
    isGlobalAdmin: boolean;
    contextOrganizationId: string | null;
    requestOrganizationId?: string | null;
    filters: FilterConfig[];
  },
): { scopedOrganizationId: string | null } => {
  if (params.isGlobalAdmin) {
    return {
      scopedOrganizationId:
        params.requestOrganizationId ?? params.contextOrganizationId ?? null,
    };
  }

  if (!params.datasetRequiresOrg) {
    return { scopedOrganizationId: null };
  }

  if (!params.contextOrganizationId) {
    throw new Error("Organization context required");
  }

  if (
    params.requestOrganizationId &&
    params.requestOrganizationId !== params.contextOrganizationId
  ) {
    throw new Error("Organization context mismatch");
  }

  const orgField = params.datasetOrgField ?? "organizationId";
  const orgFilter = params.filters.find((filter) => filter.field === orgField);
  if (orgFilter) {
    const filterValues =
      orgFilter.operator === "in" && Array.isArray(orgFilter.value)
        ? orgFilter.value
        : [orgFilter.value];
    const invalid = filterValues.some(
      (value) => value !== params.contextOrganizationId,
    );
    if (invalid) {
      throw new Error("Organization context mismatch");
    }
  }

  return { scopedOrganizationId: params.contextOrganizationId };
};

const hasAnalyticsPermission = (permissions: Set<string>, permission: string) =>
  permissions.has(permission) || permissions.has("analytics.admin") || permissions.has("*");

const ensureDashboardOwner = async (dashboardId: string, userId: string) => {
  const { getDb } = await import("~/db/server-helpers");
  const { biDashboards } = await import("~/db/schema");
  const { eq } = await import("drizzle-orm");
  const { badRequest, forbidden } = await import("~/lib/server/errors");
  const { PermissionService } = await import("~/features/roles/permission.service");

  const db = await getDb();
  const [dashboard] = await db
    .select()
    .from(biDashboards)
    .where(eq(biDashboards.id, dashboardId))
    .limit(1);

  if (!dashboard) {
    throw badRequest("Dashboard not found");
  }

  const isGlobalAdmin = await PermissionService.isGlobalAdmin(userId);
  if (!isGlobalAdmin && dashboard.ownerId !== userId) {
    throw forbidden("Dashboard access denied");
  }

  return dashboard;
};

// =============================================================================
// Export Mutations
// =============================================================================

export const exportPivotResults = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(exportRequestSchema.parse)
  .handler(async ({ data, context }) => {
    await assertFeatureEnabled("sin_analytics");
    const user = requireUser(context);
    const { badRequest, forbidden } = await import("~/lib/server/errors");

    if (!data.pivotQuery) {
      throw badRequest("pivotQuery is required for export");
    }

    const { getCurrentSession, requireRecentAuth } = await import(
      "~/lib/auth/guards/step-up"
    );
    const session = await getCurrentSession();
    await requireRecentAuth(user.id, session);

    const dataset = getDataset(data.pivotQuery.datasetId);
    if (!dataset) {
      throw badRequest(`Unknown dataset: ${data.pivotQuery.datasetId}`);
    }

    const { PermissionService } = await import("~/features/roles/permission.service");
    const isGlobalAdmin = await PermissionService.isGlobalAdmin(user.id);
    const roleAssignments = await PermissionService.getUserRoles(user.id);
    const permissions = extractPermissionSet(roleAssignments);

    if (!hasAnalyticsPermission(permissions, "analytics.export")) {
      throw forbidden("Analytics export permission required");
    }

    const contextOrganizationId =
      (context as { organizationId?: string | null } | undefined)?.organizationId ??
      null;

    let orgRole: OrganizationRole | null = null;
    if (contextOrganizationId && !isGlobalAdmin && dataset.requiresOrgScope) {
      const { requireOrganizationAccess } = await import(
        "~/lib/auth/guards/org-guard"
      );
      const access = await requireOrganizationAccess(
        { userId: user.id, organizationId: contextOrganizationId },
        { roles: ANALYTICS_ROLES },
      );
      orgRole = access.role as OrganizationRole;
    }

    let scopedOrganizationId: string | null = null;
    try {
      scopedOrganizationId =
        ensureOrgScope({
          datasetOrgField: dataset.orgScopeColumn ?? "organizationId",
          datasetRequiresOrg: dataset.requiresOrgScope,
          isGlobalAdmin,
          contextOrganizationId,
          requestOrganizationId: data.pivotQuery.organizationId ?? null,
          filters: data.pivotQuery.filters,
        }).scopedOrganizationId ?? null;
    } catch (error) {
      throw forbidden(error instanceof Error ? error.message : "Org scoping failed");
    }

    const queryContext: QueryContext = {
      userId: user.id,
      organizationId: scopedOrganizationId,
      orgRole,
      isGlobalAdmin,
      permissions,
      hasRecentAuth: true,
      timestamp: new Date(),
    };

    const normalized = normalizePivotConfig({
      dataset,
      rows: data.pivotQuery.rows,
      columns: data.pivotQuery.columns,
      measures: data.pivotQuery.measures,
      filters: data.pivotQuery.filters,
    });

    if (!normalized.ok) {
      throw badRequest(normalized.errors.join(" "));
    }

    const accessibleFields = filterAccessibleFields(dataset.fields, queryContext);
    const accessibleIds = new Set(accessibleFields.map((field) => field.id));
    const requestedFields = new Set([
      ...normalized.value.rowFields,
      ...normalized.value.columnFields,
      ...normalized.value.measures
        .map((measure) => measure.field)
        .filter((field): field is string => Boolean(field)),
    ]);

    const forbiddenFields = Array.from(requestedFields).filter(
      (field) => !accessibleIds.has(field),
    );

    if (forbiddenFields.length > 0) {
      throw forbidden(`Field access denied: ${forbiddenFields.join(", ")}`);
    }

    const orgScopeFilters = normalized.value.filters;
    if (dataset.requiresOrgScope && scopedOrganizationId) {
      const scopeField = dataset.orgScopeColumn ?? "organizationId";
      orgScopeFilters.push({
        field: scopeField,
        operator: "eq",
        value: scopedOrganizationId,
      });
    }

    const fieldsToMask = getFieldsToMask(accessibleFields, queryContext, true);

    const rows = await loadDatasetData({
      datasetId: dataset.id,
      columns: normalized.value.selectedFields,
      filters: orgScopeFilters,
      fieldsToMask,
    });

    const pivot = buildPivotResult(rows, {
      rowFields: normalized.value.rowFields,
      columnFields: normalized.value.columnFields,
      measures: normalized.value.measures,
    });

    const columnLabels = [
      ...pivot.rowFields,
      ...pivot.columnKeys.flatMap((columnKey) =>
        pivot.measures.map((measure) => `${columnKey.label}  ${measure.label}`),
      ),
    ];

    const exportRows = pivot.rows.map((row) => {
      const record: Record<string, unknown> = {};
      for (const field of pivot.rowFields) {
        record[field] = row.values[field] ?? "";
      }
      for (const columnKey of pivot.columnKeys) {
        for (const measure of pivot.measures) {
          const header = `${columnKey.label}  ${measure.label}`;
          record[header] = row.cells[columnKey.key]?.[measure.key] ?? null;
        }
      }
      return record;
    });

    let exportPayload = "";
    let fileName = "pivot-export.csv";
    let mimeType = "text/csv";
    let encoding: "base64" | "utf-8" = "utf-8";

    if (data.format === "xlsx") {
      const module = await import("xlsx");
      const XLSX = "default" in module ? module.default : module;
      const worksheet = XLSX.utils.json_to_sheet(exportRows, { header: columnLabels });
      const workbook = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(workbook, worksheet, "Pivot");
      exportPayload = XLSX.write(workbook, { type: "base64", bookType: "xlsx" });
      fileName = "pivot-export.xlsx";
      mimeType =
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
      encoding = "base64";
    } else if (data.format === "json") {
      exportPayload = JSON.stringify(exportRows, null, 2);
      fileName = "pivot-export.json";
      mimeType = "application/json";
    } else {
      const { toCsv } = await import("~/shared/lib/csv");
      exportPayload = toCsv(exportRows);
    }

    const { getDb } = await import("~/db/server-helpers");
    const { exportHistory } = await import("~/db/schema");
    const db = await getDb();

    await db.insert(exportHistory).values({
      userId: user.id,
      organizationId: scopedOrganizationId,
      reportId: null,
      exportType: data.format,
      dataSource: dataset.id,
      filtersUsed: serializeFilters(orgScopeFilters),
      rowCount: exportRows.length,
      fileKey: null,
    });

    const { logExport } = await import("./governance");
    await logExport({
      context: queryContext,
      queryType: "export",
      datasetId: dataset.id,
      pivotQuery: data.pivotQuery,
      rowsReturned: exportRows.length,
      executionTimeMs: 0,
      format: data.format,
      includesPii: queryIncludesPii(Array.from(requestedFields), dataset.fields),
      stepUpAuthUsed: true,
    });

    return {
      data: exportPayload,
      fileName,
      mimeType,
      encoding,
    };
  });

// =============================================================================
// Dashboard Mutations
// =============================================================================

const createDashboardSchema = z.object({
  name: z.string().min(1).max(100),
  description: z.string().max(500).optional(),
});

export const createDashboard = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(createDashboardSchema.parse)
  .handler(async ({ data, context }) => {
    await assertFeatureEnabled("sin_analytics");
    const user = requireUser(context);
    const { forbidden } = await import("~/lib/server/errors");

    const contextOrganizationId =
      (context as { organizationId?: string | null } | undefined)?.organizationId ??
      null;

    const { PermissionService } = await import("~/features/roles/permission.service");
    const roleAssignments = await PermissionService.getUserRoles(user.id);
    const permissions = extractPermissionSet(roleAssignments);

    if (!hasAnalyticsPermission(permissions, "analytics.author")) {
      throw forbidden("Analytics author permission required");
    }

    if (!contextOrganizationId) {
      throw forbidden("Organization context required");
    }

    const { getDb } = await import("~/db/server-helpers");
    const { biDashboards } = await import("~/db/schema");

    const db = await getDb();
    const [dashboard] = await db
      .insert(biDashboards)
      .values({
        organizationId: contextOrganizationId,
        name: data.name,
        description: data.description ?? null,
        layout: { columns: 12, rowHeight: 32, compactType: "vertical" },
        globalFilters: [],
        ownerId: user.id,
        sharedWith: [],
        isOrgWide: false,
        isPublished: false,
      })
      .returning();

    return {
      dashboardId: dashboard?.id ?? null,
    };
  });

const updateDashboardSchema = z.object({
  dashboardId: z.string().uuid(),
  name: z.string().min(1).max(100).optional(),
  description: z.string().max(500).optional(),
  isOrgWide: z.boolean().optional(),
  isPublished: z.boolean().optional(),
  sharedWith: z.array(z.string()).optional(),
  layout: z
    .object({
      columns: z.number().int().positive(),
      rowHeight: z.number().int().positive(),
      compactType: z.enum(["vertical", "horizontal"]).nullable(),
    })
    .optional(),
  globalFilters: z.array(filterSchema).optional(),
});

export const updateDashboard = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(updateDashboardSchema.parse)
  .handler(async ({ data, context }) => {
    await assertFeatureEnabled("sin_analytics");
    const user = requireUser(context);
    const { getDb } = await import("~/db/server-helpers");
    const { biDashboards } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");
    const { forbidden } = await import("~/lib/server/errors");

    const db = await getDb();
    const [existing] = await db
      .select()
      .from(biDashboards)
      .where(eq(biDashboards.id, data.dashboardId))
      .limit(1);

    if (!existing) return { success: false as const };

    const { PermissionService } = await import("~/features/roles/permission.service");
    const isGlobalAdmin = await PermissionService.isGlobalAdmin(user.id);
    const roleAssignments = await PermissionService.getUserRoles(user.id);
    const permissions = extractPermissionSet(roleAssignments);

    if (!isGlobalAdmin && existing.ownerId !== user.id) {
      throw forbidden("Dashboard access denied");
    }

    if (data.isOrgWide && !hasAnalyticsPermission(permissions, "analytics.share")) {
      throw forbidden("Analytics share permission required");
    }

    const [updated] = await db
      .update(biDashboards)
      .set({
        name: data.name ?? existing.name,
        description: data.description ?? existing.description,
        isOrgWide: data.isOrgWide ?? existing.isOrgWide,
        isPublished: data.isPublished ?? existing.isPublished,
        sharedWith: data.sharedWith ?? existing.sharedWith,
        layout: data.layout ?? existing.layout,
        globalFilters: data.globalFilters ?? existing.globalFilters,
      })
      .where(eq(biDashboards.id, data.dashboardId))
      .returning();

    return {
      success: Boolean(updated),
    };
  });

const deleteDashboardSchema = z.object({
  dashboardId: z.string().uuid(),
});

export const deleteDashboard = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(deleteDashboardSchema.parse)
  .handler(async ({ data, context }) => {
    await assertFeatureEnabled("sin_analytics");
    const user = requireUser(context);
    const { getDb } = await import("~/db/server-helpers");
    const { biDashboards } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    await ensureDashboardOwner(data.dashboardId, user.id);
    await db.delete(biDashboards).where(eq(biDashboards.id, data.dashboardId));

    return { success: true as const };
  });

// =============================================================================
// Widget Mutations
// =============================================================================

const addWidgetSchema = z.object({
  dashboardId: z.string().uuid(),
  widgetType: z.enum(["chart", "pivot", "kpi", "text", "filter"]),
  title: z.string().min(1).max(100),
  position: z.object({
    x: z.number().int().nonnegative(),
    y: z.number().int().nonnegative(),
    w: z.number().int().positive(),
    h: z.number().int().positive(),
  }),
  query: pivotQuerySchema.optional(),
  config: z.record(z.string(), z.unknown()).optional(),
});

export const addWidget = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(addWidgetSchema.parse)
  .handler(async ({ data, context }) => {
    await assertFeatureEnabled("sin_analytics");
    const user = requireUser(context);
    await ensureDashboardOwner(data.dashboardId, user.id);
    const { getDb } = await import("~/db/server-helpers");
    const { biDashboardWidgets } = await import("~/db/schema");

    const db = await getDb();
    const [widget] = await db
      .insert(biDashboardWidgets)
      .values({
        dashboardId: data.dashboardId,
        widgetType: data.widgetType,
        reportId: null,
        x: data.position.x,
        y: data.position.y,
        w: data.position.w,
        h: data.position.h,
        config: {
          title: data.title,
          ...(data.query ? { query: data.query } : {}),
          ...(data.config ?? {}),
        },
      })
      .returning();

    return {
      widgetId: widget?.id ?? null,
    };
  });

const updateWidgetSchema = z.object({
  dashboardId: z.string().uuid(),
  widgetId: z.string().uuid(),
  title: z.string().min(1).max(100).optional(),
  position: z
    .object({
      x: z.number().int().nonnegative(),
      y: z.number().int().nonnegative(),
      w: z.number().int().positive(),
      h: z.number().int().positive(),
    })
    .optional(),
  query: pivotQuerySchema.optional(),
  config: z.record(z.string(), z.unknown()).optional(),
});

export const updateWidget = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(updateWidgetSchema.parse)
  .handler(async ({ data, context }) => {
    await assertFeatureEnabled("sin_analytics");
    const user = requireUser(context);
    await ensureDashboardOwner(data.dashboardId, user.id);
    const { getDb } = await import("~/db/server-helpers");
    const { biDashboardWidgets } = await import("~/db/schema");
    const { eq, and } = await import("drizzle-orm");

    const db = await getDb();
    const [existing] = await db
      .select()
      .from(biDashboardWidgets)
      .where(
        and(
          eq(biDashboardWidgets.id, data.widgetId),
          eq(biDashboardWidgets.dashboardId, data.dashboardId),
        ),
      )
      .limit(1);

    if (!existing) return { success: false as const };

    const nextConfig = {
      ...(existing.config ?? {}),
      ...(data.config ?? {}),
      ...(data.title ? { title: data.title } : {}),
      ...(data.query ? { query: data.query } : {}),
    };

    const [updated] = await db
      .update(biDashboardWidgets)
      .set({
        x: data.position?.x ?? existing.x,
        y: data.position?.y ?? existing.y,
        w: data.position?.w ?? existing.w,
        h: data.position?.h ?? existing.h,
        config: nextConfig,
      })
      .where(
        and(
          eq(biDashboardWidgets.id, data.widgetId),
          eq(biDashboardWidgets.dashboardId, data.dashboardId),
        ),
      )
      .returning();

    return { success: Boolean(updated) };
  });

const removeWidgetSchema = z.object({
  dashboardId: z.string().uuid(),
  widgetId: z.string().uuid(),
});

export const removeWidget = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(removeWidgetSchema.parse)
  .handler(async ({ data, context }) => {
    await assertFeatureEnabled("sin_analytics");
    const user = requireUser(context);
    await ensureDashboardOwner(data.dashboardId, user.id);
    const { getDb } = await import("~/db/server-helpers");
    const { biDashboardWidgets } = await import("~/db/schema");
    const { and, eq } = await import("drizzle-orm");

    const db = await getDb();
    await db
      .delete(biDashboardWidgets)
      .where(
        and(
          eq(biDashboardWidgets.id, data.widgetId),
          eq(biDashboardWidgets.dashboardId, data.dashboardId),
        ),
      );

    return { success: true as const };
  });
</file>

<file path="src/features/bi/bi.queries.ts">
/**
 * BI Module Queries (Server Functions)
 */

import { createServerFn } from "@tanstack/react-start";
import { z } from "zod";
import type { OrganizationRole } from "~/lib/auth/guards/org-guard";
import { getAuthMiddleware, requireUser } from "~/lib/server/auth";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import { pivotQuerySchema, sqlQuerySchema } from "./bi.schemas";
import type { FilterConfig } from "./bi.schemas";
import type { QueryContext } from "./bi.types";
import { normalizePivotConfig } from "./bi.utils";
import { loadDatasetData } from "./bi.data";
import { buildPivotResult } from "./engine/pivot-aggregator";
import { filterAccessibleFields, getFieldsToMask } from "./governance";
import { DATASETS, getDataset } from "./semantic";

const ANALYTICS_ROLES: OrganizationRole[] = ["owner", "admin", "reporter"];

const extractPermissionSet = (
  roleAssignments: Array<{ role?: { permissions?: Record<string, boolean> } }>,
) => {
  const permissions = new Set<string>();
  for (const assignment of roleAssignments) {
    const perms = assignment.role?.permissions ?? {};
    for (const [key, value] of Object.entries(perms)) {
      if (value) permissions.add(key);
    }
  }
  return permissions;
};

const hasAnalyticsPermission = (permissions: Set<string>, permission: string) =>
  permissions.has(permission) || permissions.has("analytics.admin") || permissions.has("*");

const ensureOrgScope = (
  params: {
    datasetOrgField?: string;
    datasetRequiresOrg: boolean | undefined;
    isGlobalAdmin: boolean;
    contextOrganizationId: string | null;
    requestOrganizationId?: string | null;
    filters: FilterConfig[];
  },
): { scopedOrganizationId: string | null } => {
  if (params.isGlobalAdmin) {
    return {
      scopedOrganizationId:
        params.requestOrganizationId ?? params.contextOrganizationId ?? null,
    };
  }

  if (!params.datasetRequiresOrg) {
    return { scopedOrganizationId: null };
  }

  if (!params.contextOrganizationId) {
    throw new Error("Organization context required");
  }

  if (
    params.requestOrganizationId &&
    params.requestOrganizationId !== params.contextOrganizationId
  ) {
    throw new Error("Organization context mismatch");
  }

  const orgField = params.datasetOrgField ?? "organizationId";
  const orgFilter = params.filters.find((filter) => filter.field === orgField);
  if (orgFilter) {
    const filterValues =
      orgFilter.operator === "in" && Array.isArray(orgFilter.value)
        ? orgFilter.value
        : [orgFilter.value];
    const invalid = filterValues.some(
      (value) => value !== params.contextOrganizationId,
    );
    if (invalid) {
      throw new Error("Organization context mismatch");
    }
  }

  return { scopedOrganizationId: params.contextOrganizationId };
};


export const getAvailableDatasets = createServerFn({ method: "GET" })
  .middleware(getAuthMiddleware())
  .handler(async ({ context }) => {
    await assertFeatureEnabled("sin_analytics");
    const user = requireUser(context);
    const { PermissionService } = await import("~/features/roles/permission.service");
    const isGlobalAdmin = await PermissionService.isGlobalAdmin(user.id);
    const roleAssignments = await PermissionService.getUserRoles(user.id);
    const permissions = extractPermissionSet(roleAssignments);

    const contextOrganizationId =
      (context as { organizationId?: string | null } | undefined)?.organizationId ??
      null;

    let orgRole: OrganizationRole | null = null;
    if (contextOrganizationId && !isGlobalAdmin) {
      const { requireOrganizationAccess } = await import(
        "~/lib/auth/guards/org-guard"
      );
      const access = await requireOrganizationAccess(
        { userId: user.id, organizationId: contextOrganizationId },
        { roles: ANALYTICS_ROLES },
      );
      orgRole = access.role as OrganizationRole;
    }

    const datasets = Object.values(DATASETS);

    const visible = datasets.filter((dataset) => {
      if (isGlobalAdmin) return true;
      if (!dataset.allowedRoles || dataset.allowedRoles.length === 0) return true;
      if (!orgRole) return false;
      return dataset.allowedRoles.includes(orgRole);
    });

    return {
      datasets: visible.map((dataset) => ({
        id: dataset.id,
        name: dataset.name,
        description: dataset.description ?? "",
        fieldCount: dataset.fields.length,
        canExport: permissions.has("analytics.export") || permissions.has("*"),
      })),
    };
  });

export const getDatasetFields = createServerFn({ method: "GET" })
  .middleware(getAuthMiddleware())
  .inputValidator(z.object({ datasetId: z.string().min(1) }).parse)
  .handler(async ({ data, context }) => {
    await assertFeatureEnabled("sin_analytics");
    const user = requireUser(context);
    const dataset = getDataset(data.datasetId);

    const { badRequest } = await import("~/lib/server/errors");
    if (!dataset) {
      throw badRequest(`Unknown dataset: ${data.datasetId}`);
    }

    const { PermissionService } = await import("~/features/roles/permission.service");
    const isGlobalAdmin = await PermissionService.isGlobalAdmin(user.id);
    const roleAssignments = await PermissionService.getUserRoles(user.id);
    const permissions = extractPermissionSet(roleAssignments);

    const contextOrganizationId =
      (context as { organizationId?: string | null } | undefined)?.organizationId ??
      null;

    let orgRole: OrganizationRole | null = null;
    if (contextOrganizationId && !isGlobalAdmin) {
      const { requireOrganizationAccess } = await import(
        "~/lib/auth/guards/org-guard"
      );
      const access = await requireOrganizationAccess(
        { userId: user.id, organizationId: contextOrganizationId },
        { roles: ANALYTICS_ROLES },
      );
      orgRole = access.role as OrganizationRole;
    }

    const queryContext: QueryContext = {
      userId: user.id,
      organizationId: contextOrganizationId,
      orgRole,
      isGlobalAdmin,
      permissions,
      hasRecentAuth: false,
      timestamp: new Date(),
    };

    const fields = filterAccessibleFields(dataset.fields, queryContext);

    return {
      datasetId: data.datasetId,
      fields: fields.map((field) => ({
        ...field,
        allowGroupBy: field.allowGroupBy ?? false,
        allowAggregate: field.allowAggregate ?? false,
        allowFilter: field.allowFilter ?? false,
        allowSort: field.allowSort ?? false,
        defaultAggregation: field.defaultAggregation ?? null,
      })),
    };
  });

export const executePivotQuery = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(pivotQuerySchema.parse)
  .handler(async ({ data, context }) => {
    await assertFeatureEnabled("sin_analytics");
    const user = requireUser(context);
    const dataset = getDataset(data.datasetId);
    const { badRequest, forbidden } = await import("~/lib/server/errors");

    if (!dataset) {
      throw badRequest(`Unknown dataset: ${data.datasetId}`);
    }

    const { PermissionService } = await import("~/features/roles/permission.service");
    const isGlobalAdmin = await PermissionService.isGlobalAdmin(user.id);
    const roleAssignments = await PermissionService.getUserRoles(user.id);
    const permissions = extractPermissionSet(roleAssignments);

    const contextOrganizationId =
      (context as { organizationId?: string | null } | undefined)?.organizationId ??
      null;

    let orgRole: OrganizationRole | null = null;
    if (contextOrganizationId && !isGlobalAdmin && dataset.requiresOrgScope) {
      const { requireOrganizationAccess } = await import(
        "~/lib/auth/guards/org-guard"
      );
      const access = await requireOrganizationAccess(
        { userId: user.id, organizationId: contextOrganizationId },
        { roles: ANALYTICS_ROLES },
      );
      orgRole = access.role as OrganizationRole;
    }

    let scopedOrganizationId: string | null = null;
    try {
      scopedOrganizationId =
        ensureOrgScope({
          datasetOrgField: dataset.orgScopeColumn ?? "organizationId",
          datasetRequiresOrg: dataset.requiresOrgScope,
          isGlobalAdmin,
          contextOrganizationId,
          requestOrganizationId: data.organizationId ?? null,
          filters: data.filters,
        }).scopedOrganizationId ?? null;
    } catch (error) {
      throw forbidden(error instanceof Error ? error.message : "Org scoping failed");
    }

    const queryContext: QueryContext = {
      userId: user.id,
      organizationId: scopedOrganizationId,
      orgRole,
      isGlobalAdmin,
      permissions,
      hasRecentAuth: false,
      timestamp: new Date(),
    };

    const normalized = normalizePivotConfig({
      dataset,
      rows: data.rows,
      columns: data.columns,
      measures: data.measures,
      filters: data.filters,
    });

    if (!normalized.ok) {
      throw badRequest(normalized.errors.join(" "));
    }

    const accessibleFields = filterAccessibleFields(dataset.fields, queryContext);
    const accessibleIds = new Set(accessibleFields.map((field) => field.id));
    const requestedFields = new Set([
      ...normalized.value.rowFields,
      ...normalized.value.columnFields,
      ...normalized.value.measures
        .map((measure) => measure.field)
        .filter((field): field is string => Boolean(field)),
    ]);

    const forbiddenFields = Array.from(requestedFields).filter(
      (field) => !accessibleIds.has(field),
    );

    if (forbiddenFields.length > 0) {
      throw forbidden(`Field access denied: ${forbiddenFields.join(", ")}`);
    }

    const orgScopeFilters = normalized.value.filters;

    if (dataset.requiresOrgScope && scopedOrganizationId) {
      const scopeField = dataset.orgScopeColumn ?? "organizationId";
      orgScopeFilters.push({
        field: scopeField,
        operator: "eq",
        value: scopedOrganizationId,
      });
    }

    const fieldsToMask = getFieldsToMask(accessibleFields, queryContext);

    const rows = await loadDatasetData({
      datasetId: dataset.id,
      columns: normalized.value.selectedFields,
      filters: orgScopeFilters,
      fieldsToMask,
    });

    const pivot = buildPivotResult(rows, {
      rowFields: normalized.value.rowFields,
      columnFields: normalized.value.columnFields,
      measures: normalized.value.measures,
    });

    const { logQuery } = await import("./governance");
    await logQuery({
      context: queryContext,
      queryType: "pivot",
      datasetId: dataset.id,
      pivotQuery: data,
      rowsReturned: rows.length,
      executionTimeMs: 0,
    });

    return {
      pivot,
      rowCount: rows.length,
    };
  });

export const getDashboards = createServerFn({ method: "GET" })
  .middleware(getAuthMiddleware())
  .handler(async ({ context }) => {
    await assertFeatureEnabled("sin_analytics");
    const user = requireUser(context);
    const { getDb } = await import("~/db/server-helpers");
    const { biDashboards } = await import("~/db/schema");
    const { and, eq, isNull, or, sql } = await import("drizzle-orm");
    const { PermissionService } = await import("~/features/roles/permission.service");

    const db = await getDb();
    const isGlobalAdmin = await PermissionService.isGlobalAdmin(user.id);
    const contextOrganizationId =
      (context as { organizationId?: string | null } | undefined)?.organizationId ??
      null;

    if (isGlobalAdmin) {
      return {
        dashboards: await db.select().from(biDashboards),
      };
    }

    if (!contextOrganizationId) {
      return { dashboards: [] };
    }

    const personalCondition = and(
      isNull(biDashboards.organizationId),
      eq(biDashboards.ownerId, user.id),
    );

    const sharedWithCondition = sql`${biDashboards.sharedWith} @> ${JSON.stringify([
      user.id,
    ])}::jsonb`;

    const orgScopedCondition = and(
      eq(biDashboards.organizationId, contextOrganizationId),
      or(
        eq(biDashboards.ownerId, user.id),
        sharedWithCondition,
        eq(biDashboards.isOrgWide, true),
      ),
    );

    return {
      dashboards: await db
        .select()
        .from(biDashboards)
        .where(or(personalCondition, orgScopedCondition)),
    };
  });

export const getDashboard = createServerFn({ method: "GET" })
  .middleware(getAuthMiddleware())
  .inputValidator(z.object({ dashboardId: z.string().uuid() }).parse)
  .handler(async ({ data, context }) => {
    await assertFeatureEnabled("sin_analytics");
    const user = requireUser(context);
    const { getDb } = await import("~/db/server-helpers");
    const { biDashboards, biDashboardWidgets } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");
    const { PermissionService } = await import("~/features/roles/permission.service");

    const db = await getDb();
    const isGlobalAdmin = await PermissionService.isGlobalAdmin(user.id);
    const [dashboard] = await db
      .select()
      .from(biDashboards)
      .where(eq(biDashboards.id, data.dashboardId))
      .limit(1);

    if (!dashboard) return null;

    if (!isGlobalAdmin) {
      const contextOrganizationId =
        (context as { organizationId?: string | null } | undefined)?.organizationId ??
        null;

      const canAccess =
        dashboard.ownerId === user.id ||
        dashboard.isOrgWide ||
        (dashboard.sharedWith ?? []).includes(user.id) ||
        (contextOrganizationId && dashboard.organizationId === contextOrganizationId);

      if (!canAccess) return null;
    }

    const widgets = await db
      .select()
      .from(biDashboardWidgets)
      .where(eq(biDashboardWidgets.dashboardId, dashboard.id));

    return {
      ...dashboard,
      widgets,
    };
  });

export const executeSqlQuery = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(sqlQuerySchema.parse)
  .handler(async ({ data, context }) => {
    await assertFeatureEnabled("sin_analytics_sql_workbench");
    const user = requireUser(context);
    const { forbidden } = await import("~/lib/server/errors");
    const { PermissionService } = await import("~/features/roles/permission.service");

    const isGlobalAdmin = await PermissionService.isGlobalAdmin(user.id);
    const roleAssignments = await PermissionService.getUserRoles(user.id);
    const permissions = extractPermissionSet(roleAssignments);

    if (!hasAnalyticsPermission(permissions, "analytics.sql")) {
      throw forbidden("Analytics SQL permission required");
    }

    const contextOrganizationId =
      (context as { organizationId?: string | null } | undefined)?.organizationId ??
      null;

    let orgRole: OrganizationRole | null = null;
    if (contextOrganizationId && !isGlobalAdmin) {
      const { requireOrganizationAccess } = await import(
        "~/lib/auth/guards/org-guard"
      );
      const access = await requireOrganizationAccess(
        { userId: user.id, organizationId: contextOrganizationId },
        { roles: ANALYTICS_ROLES },
      );
      orgRole = access.role as OrganizationRole;
    }

    const queryContext: QueryContext = {
      userId: user.id,
      organizationId: contextOrganizationId,
      orgRole,
      isGlobalAdmin,
      permissions,
      hasRecentAuth: false,
      timestamp: new Date(),
    };

    const { executeSqlWorkbenchQuery } = await import("./bi.sql-executor");
    const sqlParams = {
      sqlText: data.sql,
      parameters: data.parameters ?? {},
      context: queryContext,
      ...(data.datasetId ? { datasetId: data.datasetId } : {}),
    };

    return executeSqlWorkbenchQuery(sqlParams);
  });
</file>

<file path="src/features/bi/bi.schemas.ts">
/**
 * BI Module Schemas
 *
 * Contract-first Zod schemas for BI operations, datasets, and query configs.
 *
 * @see src/features/bi/docs/SPEC-bi-platform.md
 */

import { z } from "zod";

// =============================================================================
// Operators + Aggregations
// =============================================================================

export const filterOperatorSchema = z.enum([
  "eq",
  "neq",
  "gt",
  "gte",
  "lt",
  "lte",
  "in",
  "between",
  "not_in",
  "contains",
  "starts_with",
  "ends_with",
  "is_null",
  "is_not_null",
]);

export type FilterOperator = z.infer<typeof filterOperatorSchema>;

export const aggregationTypeSchema = z.enum([
  "count",
  "sum",
  "avg",
  "min",
  "max",
  "count_distinct",
  "median",
  "stddev",
  "variance",
]);

export type AggregationType = z.infer<typeof aggregationTypeSchema>;

export const chartTypeSchema = z.enum([
  "table",
  "bar",
  "line",
  "area",
  "pie",
  "donut",
  "heatmap",
  "scatter",
  "kpi",
]);

export type ChartType = z.infer<typeof chartTypeSchema>;

export const widgetTypeSchema = z.enum(["chart", "pivot", "kpi", "text", "filter"]);

export type WidgetType = z.infer<typeof widgetTypeSchema>;

// =============================================================================
// Filters
// =============================================================================

const filterPrimitiveSchema = z.union([z.string(), z.number(), z.boolean(), z.null()]);

export const filterValueSchema = z.union([
  filterPrimitiveSchema,
  z.array(filterPrimitiveSchema),
]);

export type FilterValue = z.infer<typeof filterValueSchema>;

export const filterSchema = z.object({
  field: z.string().min(1),
  operator: filterOperatorSchema,
  value: filterValueSchema.optional(),
  label: z.string().optional(),
});

export type FilterConfig = z.infer<typeof filterSchema>;

// =============================================================================
// Dataset Definitions
// =============================================================================

export const datasetJoinSchema = z.object({
  table: z.string().min(1),
  type: z.enum(["inner", "left", "right"]),
  on: z.object({
    left: z.string().min(1),
    right: z.string().min(1),
  }),
});

export type DatasetJoin = z.infer<typeof datasetJoinSchema>;

export const formatOptionsSchema = z.object({
  decimals: z.number().int().min(0).optional(),
  prefix: z.string().optional(),
  suffix: z.string().optional(),
  thousandsSeparator: z.string().optional(),
  dateFormat: z.string().optional(),
  currency: z.string().optional(),
});

export type FormatOptions = z.infer<typeof formatOptionsSchema>;

export const datasetFieldSchema = z.object({
  id: z.string().min(1),
  name: z.string().min(1),
  description: z.string().optional(),
  sourceColumn: z.string().min(1),
  sourceTable: z.string().optional(),
  dataType: z.enum([
    "string",
    "number",
    "date",
    "datetime",
    "boolean",
    "enum",
    "json",
    "uuid",
  ]),
  piiClassification: z.enum(["none", "personal", "sensitive", "restricted"]).optional(),
  requiredPermission: z.string().optional(),
  formatType: z
    .enum(["text", "number", "currency", "percent", "date", "datetime"])
    .optional(),
  formatOptions: formatOptionsSchema.optional(),
  allowFilter: z.boolean().optional(),
  allowSort: z.boolean().optional(),
  allowGroupBy: z.boolean().optional(),
  allowAggregate: z.boolean().optional(),
  defaultAggregation: aggregationTypeSchema.optional(),
  enumValues: z
    .array(
      z.object({
        value: z.string(),
        label: z.string(),
      }),
    )
    .optional(),
});

export type DatasetField = z.infer<typeof datasetFieldSchema>;

export const datasetDefinitionSchema = z.object({
  id: z.string().min(1),
  name: z.string().min(1),
  description: z.string().optional(),
  baseTable: z.string().min(1),
  joins: z.array(datasetJoinSchema).optional(),
  fields: z.array(datasetFieldSchema),
  isPublic: z.boolean().optional(),
  allowedRoles: z.array(z.string()).optional(),
});

export type DatasetDefinition = z.infer<typeof datasetDefinitionSchema>;

// =============================================================================
// Pivot Config + Queries
// =============================================================================

export const pivotMeasureSchema = z.object({
  field: z.string().min(1).nullable().optional(),
  aggregation: aggregationTypeSchema,
  label: z.string().optional(),
});

export type PivotMeasure = z.infer<typeof pivotMeasureSchema>;

export const pivotQuerySchema = z.object({
  datasetId: z.string().min(1),
  organizationId: z.string().uuid().optional(),
  rows: z.array(z.string()).default([]),
  columns: z.array(z.string()).default([]),
  measures: z.array(pivotMeasureSchema).min(1),
  filters: z.array(filterSchema).default([]),
  limit: z.number().int().min(1).max(10000).default(1000),
});

export type PivotQuery = z.infer<typeof pivotQuerySchema>;

// =============================================================================
// Pivot Results
// =============================================================================

export const pivotMeasureMetaSchema = z.object({
  field: z.string().nullable(),
  aggregation: aggregationTypeSchema,
  key: z.string().min(1),
  label: z.string().min(1),
});

export type PivotMeasureMeta = z.infer<typeof pivotMeasureMetaSchema>;

export const pivotColumnKeySchema = z.object({
  key: z.string().min(1),
  label: z.string().min(1),
  values: z.record(z.string(), z.string()),
});

export const pivotRowSchema = z.object({
  key: z.string().min(1),
  values: z.record(z.string(), z.string()),
  cells: z.record(z.string(), z.record(z.string(), z.number().nullable())),
});

export const pivotResultSchema = z.object({
  rowFields: z.array(z.string()),
  columnFields: z.array(z.string()),
  measures: z.array(pivotMeasureMetaSchema),
  columnKeys: z.array(pivotColumnKeySchema),
  rows: z.array(pivotRowSchema),
});

export type PivotResult = z.infer<typeof pivotResultSchema>;

// =============================================================================
// Exports
// =============================================================================

export const exportFormatSchema = z.enum(["csv", "xlsx", "json"]);

export type ExportFormat = z.infer<typeof exportFormatSchema>;

export const exportRequestSchema = z.object({
  queryId: z.string().uuid().optional(),
  pivotQuery: pivotQuerySchema.optional(),
  format: exportFormatSchema,
  includeHeaders: z.boolean().default(true),
});

export type ExportRequest = z.infer<typeof exportRequestSchema>;

// =============================================================================
// SQL Workbench
// =============================================================================

export const sqlQuerySchema = z.object({
  sql: z.string().min(1),
  parameters: z.record(z.string(), z.unknown()).optional(),
  datasetId: z.string().min(1).optional(),
});

export type SqlQueryRequest = z.infer<typeof sqlQuerySchema>;
</file>

<file path="src/features/bi/bi.types.ts">
/**
 * BI Module Types
 *
 * TypeScript types for BI operations, datasets, and governance.
 *
 * @see src/features/bi/docs/SPEC-bi-platform.md
 */

import type { OrganizationRole } from "~/lib/auth/guards/org-guard";
import type {
  AggregationType,
  ChartType,
  DatasetDefinition,
  ExportFormat,
  FilterConfig,
  FilterOperator,
  PivotMeasure,
  PivotQuery,
  PivotResult,
  WidgetType,
} from "./bi.schemas";

export type {
  AggregationType,
  ChartType,
  DatasetDefinition,
  ExportFormat,
  FilterConfig,
  FilterOperator,
  PivotMeasure,
  PivotQuery,
  PivotResult,
  WidgetType,
};

// =============================================================================
// Dataset Types
// =============================================================================

export interface DatasetJoin {
  table: string;
  type: "inner" | "left" | "right";
  on: { left: string; right: string };
}

export interface FormatOptions {
  decimals?: number;
  prefix?: string;
  suffix?: string;
  thousandsSeparator?: string;
  dateFormat?: string;
  currency?: string;
}

export interface DatasetField {
  id: string;
  name: string;
  description?: string;
  sourceColumn: string;
  sourceTable?: string;
  dataType:
    | "string"
    | "number"
    | "date"
    | "datetime"
    | "boolean"
    | "enum"
    | "json"
    | "uuid";
  piiClassification?: "none" | "personal" | "sensitive" | "restricted";
  requiredPermission?: string;
  formatType?: "text" | "number" | "currency" | "percent" | "date" | "datetime";
  formatOptions?: FormatOptions;
  allowFilter?: boolean;
  allowSort?: boolean;
  allowGroupBy?: boolean;
  allowAggregate?: boolean;
  defaultAggregation?: AggregationType;
  enumValues?: Array<{ value: string; label: string }>;
}

export interface DatasetConfig {
  id: string;
  name: string;
  description?: string;
  baseTable: string;
  joins?: DatasetJoin[];
  fields: DatasetField[];
  isPublic?: boolean;
  allowedRoles?: string[];
  requiresOrgScope?: boolean;
  orgScopeColumn?: string;
}

// =============================================================================
// Query Config Types
// =============================================================================

export interface PivotConfig {
  rows: string[];
  columns: string[];
  measures: Array<{
    field: string | null;
    aggregation: AggregationType;
    label?: string;
    format?: FormatOptions;
  }>;
  showRowTotals?: boolean;
  showColumnTotals?: boolean;
  showGrandTotal?: boolean;
}

export interface SqlConfig {
  query: string;
  parameters: Array<{
    name: string;
    type: "string" | "number" | "date" | "uuid";
    defaultValue?: unknown;
    required?: boolean;
  }>;
}

export interface ChartConfig {
  xAxis?: string;
  yAxis?: string | string[];
  series?: string;
  colorBy?: string;
  options?: Record<string, unknown>;
}

// =============================================================================
// Dashboard Types
// =============================================================================

export interface DashboardLayout {
  columns: number;
  rowHeight: number;
  compactType: "vertical" | "horizontal" | null;
}

export interface WidgetConfig {
  title?: string;
  subtitle?: string;
  chartType?: ChartType;
  query?: PivotQuery;
  kpiField?: string;
  kpiAggregation?: AggregationType;
  kpiFormat?: FormatOptions;
  textContent?: string;
  textFormat?: "plain" | "markdown";
  filterField?: string;
  filterType?: "select" | "date_range" | "search";
}

export interface DashboardWidgetPosition {
  x: number;
  y: number;
  w: number;
  h: number;
}

export interface DashboardWidget {
  id: string;
  dashboardId: string;
  widgetType: WidgetType;
  reportId?: string | null;
  position: DashboardWidgetPosition;
  config?: WidgetConfig | null;
  createdAt: Date;
  updatedAt: Date;
}

export interface Dashboard {
  id: string;
  organizationId: string | null;
  name: string;
  description: string | null;
  layout: DashboardLayout;
  globalFilters: FilterConfig[];
  ownerId: string;
  sharedWith: string[];
  isOrgWide: boolean;
  isPublished: boolean;
  createdAt: Date;
  updatedAt: Date;
}

// =============================================================================
// Query Execution + Governance Types
// =============================================================================

export interface QueryContext {
  userId: string;
  organizationId: string | null;
  orgRole: OrganizationRole | null;
  isGlobalAdmin: boolean;
  permissions: Set<string>;
  hasRecentAuth: boolean;
  timestamp: Date;
}

export interface QueryExecutionResult<T> {
  data: T;
  executionTimeMs: number;
  truncated: boolean;
  totalRows: number;
  queryHash: string;
}

export interface BiQueryLogEntry {
  id: string;
  userId: string;
  organizationId: string | null;
  queryType: "pivot" | "sql" | "export";
  queryHash: string;
  datasetId: string | null;
  sqlQuery: string | null;
  parameters: Record<string, unknown> | null;
  pivotConfig: PivotConfig | null;
  rowsReturned: number | null;
  executionTimeMs: number | null;
  previousLogId: string | null;
  checksum: string | null;
  createdAt: Date;
}
</file>

<file path="src/features/bi/index.ts">
/**
 * BI Module - Public API
 */

// =============================================================================
// Schemas (contract-first types)
// =============================================================================

export {
  aggregationTypeSchema,
  chartTypeSchema,
  datasetDefinitionSchema,
  datasetFieldSchema,
  datasetJoinSchema,
  exportFormatSchema,
  exportRequestSchema,
  filterOperatorSchema,
  filterSchema,
  filterValueSchema,
  formatOptionsSchema,
  pivotMeasureMetaSchema,
  pivotMeasureSchema,
  pivotQuerySchema,
  pivotResultSchema,
  sqlQuerySchema,
  widgetTypeSchema,
} from "./bi.schemas";

export type {
  AggregationType,
  ChartType,
  DatasetDefinition,
  DatasetField,
  DatasetJoin,
  ExportFormat,
  ExportRequest,
  FilterConfig,
  FilterOperator,
  FilterValue,
  FormatOptions,
  PivotMeasure,
  PivotMeasureMeta,
  PivotQuery,
  PivotResult,
  SqlQueryRequest,
  WidgetType,
} from "./bi.schemas";

// =============================================================================
// Types (complex/internal types)
// =============================================================================

export type {
  BiQueryLogEntry,
  ChartConfig,
  Dashboard,
  DashboardLayout,
  DashboardWidget as DashboardWidgetType,
  DashboardWidgetPosition,
  DatasetConfig,
  DatasetField as DatasetFieldConfig,
  QueryContext,
  QueryExecutionResult,
  SqlConfig,
  WidgetConfig,
} from "./bi.types";

// =============================================================================
// Server Functions - Queries
// =============================================================================

export {
  executePivotQuery,
  getAvailableDatasets,
  getDashboard,
  getDashboards,
  getDatasetFields,
  executeSqlQuery,
} from "./bi.queries";

// =============================================================================
// Server Functions - Mutations
// =============================================================================

export {
  addWidget,
  createDashboard,
  deleteDashboard,
  exportPivotResults,
  removeWidget,
  updateDashboard,
  updateWidget,
} from "./bi.mutations";

// =============================================================================
// Engine (internal - exported for testing)
// =============================================================================

export {
  aggregators,
  aggregatorsPhase2,
  applyFilters,
  buildPivotResult,
  executeAggregation,
} from "./engine";

// =============================================================================
// Hooks + UI Components
// =============================================================================

export { useCreateDashboard, useDashboard, useDashboards } from "./hooks/use-dashboard";

export { PivotBuilder } from "./components/pivot-builder/PivotBuilder";
export { SqlWorkbench } from "./components/sql-workbench/SqlWorkbench";
export { DashboardCanvas } from "./components/dashboard/DashboardCanvas";
export { DashboardWidget } from "./components/dashboard/DashboardWidget";
export { AddWidgetModal } from "./components/dashboard/AddWidgetModal";
</file>

<file path="src/routes/dashboard/admin/sin/analytics.tsx">
import { createFileRoute, redirect } from "@tanstack/react-router";
import { requireFeatureInRoute } from "~/tenant/feature-gates";

export const Route = createFileRoute("/dashboard/admin/sin/analytics")({
  beforeLoad: () => {
    requireFeatureInRoute("sin_admin_analytics");
    throw redirect({ to: "/dashboard/analytics/explore" });
  },
});
</file>

<file path="src/routes/dashboard/sin/analytics.tsx">
import { createFileRoute, redirect } from "@tanstack/react-router";
import { requireFeatureInRoute } from "~/tenant/feature-gates";

export const Route = createFileRoute("/dashboard/sin/analytics")({
  beforeLoad: () => {
    requireFeatureInRoute("sin_analytics");
    throw redirect({ to: "/dashboard/analytics/explore" });
  },
});
</file>

</files>
