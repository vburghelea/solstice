This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/lib/auth/**/*.ts, src/lib/security/**/*.ts, src/lib/pacer/**/*.ts, src/lib/env.server.ts, src/features/auth/**/*.ts, src/features/auth/**/*.tsx, src/features/roles/**/*.ts, src/features/roles/**/*.tsx, src/features/membership/**/*.ts, src/features/membership/**/*.tsx, src/db/schema/**/*.ts, src/db/connections.ts, src/routes/api/auth/**/*.ts, src/routes/auth/**/*.tsx, src/routes/dashboard/route.tsx, src/routes/__root.tsx, netlify/edge-functions/**/*.ts, repomix-bundles/REQUIREMENTS-BUNDLE-1.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
netlify/
  edge-functions/
    security-headers.ts
repomix-bundles/
  REQUIREMENTS-BUNDLE-1.md
src/
  db/
    schema/
      auth.schema.ts
      events.schema.ts
      index.ts
      membership.schema.ts
      roles.schema.ts
      teams.schema.ts
    connections.ts
  features/
    auth/
      __tests__/
        login-with-router.test.tsx
        login.test.tsx
        signup-with-router.test.tsx
      components/
        login.tsx
        signup.tsx
      hooks/
        useAuth.ts
        useAuthForm.ts
      auth.queries.ts
      auth.schemas.ts
      index.ts
    membership/
      __tests__/
        membership.finalize.integration.test.ts
        membership.schemas.test.ts
        membership.validation.test.ts
        square.webhook.test.ts
      components/
        admin-memberships-report.tsx
      hooks/
        usePaymentReturn.ts
      index.ts
      membership.admin-queries.ts
      membership.db-types.ts
      membership.finalize.ts
      membership.mutations.ts
      membership.queries.ts
      membership.schemas.ts
      membership.types.ts
    roles/
      __tests__/
        permission.service.test.ts
      components/
        __tests__/
          role-management-dashboard.test.tsx
        role-management-dashboard.tsx
      permission.server.ts
      permission.service.ts
      roles.mutations.ts
      roles.queries.ts
      roles.types.ts
  lib/
    auth/
      guards/
        route-guards.ts
      middleware/
        __tests__/
          auth-guard.test.ts
        auth-guard.ts
        role-guard.ts
      utils/
        admin-check.ts
      index.ts
      server-helpers.ts
      types.ts
    pacer/
      hooks.ts
      index.ts
      rate-limit-config.ts
    security/
      utils/
        password-validator.ts
      config.ts
      index.ts
      password-config.ts
    env.server.ts
  routes/
    api/
      auth/
        $action/
          $provider.ts
        $.ts
    auth/
      login.tsx
      route.tsx
      signup.tsx
    dashboard/
      route.tsx
    __root.tsx
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="repomix-bundles/REQUIREMENTS-BUNDLE-1.md">
# Bundle 1: Security, Auth & Access Control

> **Your Task:** Implement or enhance the 6 requirements below for the viaSport Strength in Numbers (SIN) system.

---

## Requirements You Must Address

### SEC-AGG-001: Authentication & Access Control
**Description:** The system shall enforce multi-factor authentication, support secure password recovery, restrict access based on user roles and affiliations, and allow organizational leaders to manage user admission.

**Acceptance Criteria:** Users log in securely; only authorized individuals gain access based on role and affiliation.

**Current Status:** 75% complete
- Better Auth with email/password + OAuth (GitHub, Google)
- Password validation with strength requirements
- Role-based guards exist

**Gaps to Implement:**
- [ ] Add TOTP/SMS multi-factor authentication
- [ ] Organizational leader user admission management
- [ ] Affiliation-based access restrictions

---

### SEC-AGG-002: Monitoring & Threat Detection
**Description:** The system shall detect and flag suspicious activities such as unusual login patterns or behavior anomalies and automatically lock accounts where appropriate.

**Acceptance Criteria:** Security anomalies are flagged, logged, and result in appropriate account safeguards.

**Current Status:** 30% complete
- Rate limiting via Pacer exists
- No anomaly detection

**Gaps to Implement:**
- [ ] Track login patterns (location, time, device)
- [ ] Detect unusual behavior (failed attempts, rapid requests)
- [ ] Auto-lock accounts after suspicious activity
- [ ] Alert administrators of security events

---

### SEC-AGG-003: Privacy & Regulatory Compliance
**Description:** The system shall comply with relevant data protection laws (e.g., PIPEDA) to ensure secure handling, storage, and access to personal information.

**Acceptance Criteria:** All sensitive data is encrypted and stored securely.

**Current Status:** 50% complete
- HTTPS enforced
- Secure cookies with HttpOnly, SameSite
- Database connections encrypted

**Gaps to Implement:**
- [ ] Privacy consent collection and management
- [ ] Data retention policy enforcement
- [ ] Right to erasure (data deletion) workflow
- [ ] Privacy policy acceptance tracking

---

### SEC-AGG-004: Audit Trail & Data Lineage
**Description:** The system shall maintain an immutable audit log of user actions, data changes, authentication events, and administrative configurations, supporting forensic review and regulatory reporting.

**Acceptance Criteria:** Auditors can filter logs by user or record ID and export results; tamper-evident hashing verifies integrity of log entries.

**Current Status:** 25% complete
- `createdAt`/`updatedAt` timestamps exist on records
- No comprehensive audit log table

**Gaps to Implement:**
- [ ] Create `audit_logs` table with immutable entries
- [ ] Log all authentication events (login, logout, failed attempts)
- [ ] Log data changes (create, update, delete) with before/after
- [ ] Log administrative actions (role changes, user management)
- [ ] Add filtering/export for audit logs
- [ ] Implement tamper-evident hashing

---

### DM-AGG-003: Data Governance & Access Control
**Description:** The system shall enforce role-based access to data and provide administrators with secure database access, along with data cataloging and indexing capabilities for discoverability.

**Acceptance Criteria:** Users can only access data based on permission.

**Current Status:** 70% complete
- Role-based access control exists
- Team-based permissions implemented
- Membership tiers with different access levels

**Gaps to Implement:**
- [ ] Field-level access control (hide sensitive fields by role)
- [ ] Data cataloging/indexing for discoverability
- [ ] Admin database access portal (read-only queries)

---

### UI-AGG-001: User Access & Account Control
**Description:** The system shall support secure login/logout (MFA), individual and organizational account registration, account recovery, and system administrator account management with role-based access.

**Acceptance Criteria:** Users and system admin can perform account-related tasks securely.

**Current Status:** 85% complete
- Full auth flow (login, signup, logout)
- OAuth providers (GitHub, Google)
- Profile management
- Role-based admin access

**Gaps to Implement:**
- [ ] MFA enrollment UI
- [ ] Organizational account registration (team signup flow)
- [ ] Enhanced account recovery (security questions, backup codes)

---

## Context: viaSport SIN Project

viaSport BC is replacing legacy systems (BC Activity Reporter and BC Sport Information System) with a modern, secure, scalable platform for B.C. amateur sport data management.

**Key Context:**
- Historical data: 20+ million rows
- Compliance required: PIPA/PIPEDA, SOC II / ISO 27001
- Users: Sport organizations, administrators, provincial staff
</file>

<file path="src/db/schema/auth.schema.ts">
import { boolean, integer, pgTable, text, timestamp } from "drizzle-orm/pg-core";

export const user = pgTable("user", {
  id: text("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  emailVerified: boolean("email_verified")
    .$defaultFn(() => false)
    .notNull(),
  image: text("image"),
  createdAt: timestamp("created_at")
    .$defaultFn(() => /* @__PURE__ */ new Date())
    .notNull(),
  updatedAt: timestamp("updated_at")
    .$defaultFn(() => /* @__PURE__ */ new Date())
    .notNull(),
  // Profile completion tracking
  profileComplete: boolean("profile_complete")
    .$defaultFn(() => false)
    .notNull(),

  // Required profile fields
  dateOfBirth: timestamp("date_of_birth"),
  emergencyContact: text("emergency_contact"), // JSON string

  // Optional profile fields
  gender: text("gender"),
  pronouns: text("pronouns"),
  phone: text("phone"),

  // Privacy and preferences
  privacySettings: text("privacy_settings"), // JSON string

  // Audit and versioning
  profileVersion: integer("profile_version")
    .$defaultFn(() => 1)
    .notNull(),
  profileUpdatedAt: timestamp("profile_updated_at").$defaultFn(() => new Date()),
});

export const session = pgTable("session", {
  id: text("id").primaryKey(),
  expiresAt: timestamp("expires_at").notNull(),
  token: text("token").notNull().unique(),
  createdAt: timestamp("created_at").notNull(),
  updatedAt: timestamp("updated_at").notNull(),
  ipAddress: text("ip_address"),
  userAgent: text("user_agent"),
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
});

export const account = pgTable("account", {
  id: text("id").primaryKey(),
  accountId: text("account_id").notNull(),
  providerId: text("provider_id").notNull(),
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  accessToken: text("access_token"),
  refreshToken: text("refresh_token"),
  idToken: text("id_token"),
  accessTokenExpiresAt: timestamp("access_token_expires_at"),
  refreshTokenExpiresAt: timestamp("refresh_token_expires_at"),
  scope: text("scope"),
  password: text("password"),
  createdAt: timestamp("created_at").notNull(),
  updatedAt: timestamp("updated_at").notNull(),
});

export const verification = pgTable("verification", {
  id: text("id").primaryKey(),
  identifier: text("identifier").notNull(),
  value: text("value").notNull(),
  expiresAt: timestamp("expires_at").notNull(),
  createdAt: timestamp("created_at").$defaultFn(() => /* @__PURE__ */ new Date()),
  updatedAt: timestamp("updated_at").$defaultFn(() => /* @__PURE__ */ new Date()),
});
</file>

<file path="src/features/membership/index.ts">
// Export queries
export {
  getMembershipType,
  getUserMembershipStatus,
  listMembershipTypes,
} from "./membership.queries";

// Export mutations
export { confirmMembershipPurchase, createCheckoutSession } from "./membership.mutations";

// Export types
export type {
  CheckoutSessionResult,
  MembershipOperationResult,
  MembershipPurchaseInput,
  MembershipStatus,
  UserMembership,
} from "./membership.types";
</file>

<file path="src/lib/security/utils/password-validator.ts">
import { PASSWORD_CONFIG } from "../password-config";

interface PasswordValidationResult {
  isValid: boolean;
  errors: string[];
}

/**
 * Validates a password against security requirements
 * Works in both client and server environments
 */
export function validatePassword(password: string): PasswordValidationResult {
  const errors: string[] = [];
  const config = PASSWORD_CONFIG;

  // Check minimum length
  if (password.length < config.minLength) {
    errors.push(`Password must be at least ${config.minLength} characters long`);
  }

  // Check uppercase requirement
  if (config.requireUppercase && !/[A-Z]/.test(password)) {
    errors.push("Password must contain at least one uppercase letter");
  }

  // Check lowercase requirement
  if (config.requireLowercase && !/[a-z]/.test(password)) {
    errors.push("Password must contain at least one lowercase letter");
  }

  // Check numbers requirement
  if (config.requireNumbers && !/\d/.test(password)) {
    errors.push("Password must contain at least one number");
  }

  // Check special characters requirement
  if (config.requireSpecialChars && !/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
    errors.push("Password must contain at least one special character");
  }

  return {
    isValid: errors.length === 0,
    errors,
  };
}

/**
 * Generates a password strength score (0-5)
 */
export function getPasswordStrength(password: string): number {
  let strength = 0;

  // Length bonuses
  if (password.length >= 8) strength++;
  if (password.length >= 12) strength++;
  if (password.length >= 16) strength++;

  // Complexity bonuses
  if (/[a-z]/.test(password) && /[A-Z]/.test(password)) strength++;
  if (/\d/.test(password)) strength++;
  if (/[!@#$%^&*(),.?":{}|<>]/.test(password)) strength++;

  // Cap at 5
  return Math.min(strength, 5);
}

/**
 * Get a human-readable password strength label
 */
export function getPasswordStrengthLabel(strength: number): string {
  switch (strength) {
    case 0:
    case 1:
      return "Very Weak";
    case 2:
      return "Weak";
    case 3:
      return "Fair";
    case 4:
      return "Strong";
    case 5:
      return "Very Strong";
    default:
      return "Unknown";
  }
}
</file>

<file path="src/lib/security/password-config.ts">
/**
 * Password configuration constants
 * Shared between client and server - no environment dependencies
 */

export const PASSWORD_CONFIG = {
  minLength: 8,
  requireUppercase: true,
  requireLowercase: true,
  requireNumbers: true,
  requireSpecialChars: true,
} as const;

// Export type for use in other modules
export type PasswordConfig = typeof PASSWORD_CONFIG;
</file>

<file path="src/routes/auth/signup.tsx">
import { createFileRoute } from "@tanstack/react-router";
import SignupForm from "~/features/auth/components/signup";

export const Route = createFileRoute("/auth/signup")({
  component: SignupForm,
});
</file>

<file path="src/db/schema/index.ts">
export * from "./auth.schema";
export * from "./events.schema";
export * from "./membership.schema";
export * from "./roles.schema";
export * from "./teams.schema";
</file>

<file path="src/features/auth/__tests__/login-with-router.test.tsx">
import userEvent from "@testing-library/user-event";
import { beforeEach, describe, expect, it, vi } from "vitest";
import { auth } from "~/lib/auth-client";
import { renderWithRouter, screen, waitFor } from "~/tests/utils";
import LoginForm from "../components/login";

// Mock auth client
vi.mock("~/lib/auth-client", () => ({
  auth: {
    signIn: {
      email: vi.fn(),
    },
    signInWithOAuth: vi.fn(),
  },
}));

describe("LoginForm with TanStack Router", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("renders login form in router context", async () => {
    await renderWithRouter(<LoginForm />);

    expect(screen.getByLabelText("Email")).toBeInTheDocument();
    expect(screen.getByLabelText("Password")).toBeInTheDocument();
    expect(screen.getByRole("button", { name: "Login" })).toBeInTheDocument();
  });

  it("handles navigation with router context", async () => {
    const user = userEvent.setup();

    // Mock successful login
    vi.mocked(auth.signIn.email).mockImplementation((data, handlers) => {
      handlers?.onSuccess?.({ data: { user: {}, session: {} } } as Parameters<
        NonNullable<typeof handlers.onSuccess>
      >[0]);
      return Promise.resolve({ data: { user: {}, session: {} }, error: null });
    });

    const { router } = await renderWithRouter(<LoginForm />);

    // Fill and submit form
    await user.type(screen.getByLabelText("Email"), "test@example.com");
    await user.type(screen.getByLabelText("Password"), "password123");
    await user.click(screen.getByRole("button", { name: "Login" }));

    await waitFor(() => {
      expect(auth.signIn.email).toHaveBeenCalled();
    });

    // In a real router test, we would check navigation
    // But since LoginForm uses router hooks that we need to mock,
    // we'll verify the router exists
    expect(router).toBeDefined();
  });

  it("renders with custom user context", async () => {
    const customUser = {
      id: "custom-user",
      name: "Custom User",
      email: "custom@example.com",
      emailVerified: true,
      image: null,
      createdAt: new Date(),
      updatedAt: new Date(),
      profileComplete: true,
      dateOfBirth: new Date("1990-01-01"),
      phone: "+1234567890",
      gender: "male" as const,
      pronouns: "he/him",
      emergencyContact: JSON.stringify({
        name: "Emergency Contact",
        phone: "+0987654321",
        relationship: "spouse",
      }),
      privacySettings: JSON.stringify({
        showEmail: false,
        showPhone: false,
        showDateOfBirth: false,
      }),
      profileVersion: 1,
      profileUpdatedAt: new Date(),
    };

    await renderWithRouter(<LoginForm />, { user: customUser });

    // Component should still render
    expect(screen.getByLabelText("Email")).toBeInTheDocument();
  });

  it("has access to query client", async () => {
    const { queryClient } = await renderWithRouter(<LoginForm />);

    expect(queryClient).toBeDefined();
    expect(queryClient?.getDefaultOptions()).toBeDefined();
  });
});
</file>

<file path="src/features/auth/hooks/useAuth.ts">
import { useRouteContext } from "@tanstack/react-router";
import type { User } from "better-auth";

/**
 * Hook to access authentication state from route context
 *
 * @example
 * const { user, isAuthenticated } = useAuth();
 *
 * if (isAuthenticated) {
 *   // User is logged in
 * }
 */
export function useAuth() {
  const context = useRouteContext({ from: "__root__" });
  const user = context.user as User | null;

  return {
    user,
    isAuthenticated: !!user,
  };
}

/**
 * Hook that requires authentication and returns the user
 * Should only be used in components that are already protected by route guards
 *
 * @example
 * const user = useAuthenticatedUser(); // Will never be null
 */
export function useAuthenticatedUser(): User {
  const { user } = useAuth();

  if (!user) {
    throw new Error(
      "useAuthenticatedUser must be used within an authenticated route. " +
        "Make sure the route has proper auth guards in place.",
    );
  }

  return user;
}
</file>

<file path="src/features/membership/__tests__/membership.finalize.integration.test.ts">
import { beforeEach, describe, expect, it, vi } from "vitest";
import type { MembershipDbClient } from "../membership.finalize";
import { finalizeMembershipForSession } from "../membership.finalize";

/**
 * Integration tests for membership finalization logic.
 * These tests verify the business logic of membership creation
 * including idempotency and transaction handling.
 */
describe("Membership Finalization Integration", () => {
  // Mock database client that simulates real transaction behavior
  let mockTx: ReturnType<typeof createMockTransaction>;
  let mockDb: MembershipDbClient;

  function createMockTransaction() {
    const membershipsTable: Array<{
      id: string;
      userId: string;
      membershipTypeId: string;
      paymentId: string;
      startDate: string;
      endDate: string;
      status: string;
      paymentProvider: string;
      metadata: Record<string, unknown>;
    }> = [];

    const sessionsTable: Array<{
      id: string;
      status: string;
      squarePaymentId: string | null;
      squareOrderId: string | null;
      metadata: Record<string, unknown>;
      updatedAt: Date;
    }> = [];

    return {
      membershipsTable,
      sessionsTable,
      select: vi.fn().mockReturnThis(),
      from: vi.fn().mockReturnThis(),
      where: vi.fn().mockImplementation(() => ({
        limit: vi.fn().mockImplementation(() => {
          // Return existing membership if payment ID matches
          const existingMembership = membershipsTable.find((m) => m.paymentId);
          return Promise.resolve(existingMembership ? [existingMembership] : []);
        }),
      })),
      insert: vi.fn().mockImplementation(() => ({
        values: vi.fn().mockImplementation((values) => {
          const newMembership = {
            id: `membership-${Date.now()}`,
            ...values,
          };
          membershipsTable.push(newMembership);
          return {
            returning: vi.fn().mockResolvedValue([newMembership]),
          };
        }),
      })),
      update: vi.fn().mockImplementation(() => ({
        set: vi.fn().mockImplementation((values) => ({
          where: vi.fn().mockImplementation(() => {
            sessionsTable.push({
              id: "session-1",
              ...values,
            });
            return Promise.resolve();
          }),
        })),
      })),
    };
  }

  beforeEach(() => {
    vi.clearAllMocks();
    mockTx = createMockTransaction();
    mockDb = {
      transaction: vi.fn().mockImplementation(async (callback) => {
        return callback(mockTx);
      }),
    } as unknown as MembershipDbClient;
  });

  describe("New Membership Creation", () => {
    it("creates a new membership when none exists for payment", async () => {
      const paymentSession = {
        id: "session-123",
        userId: "user-456",
        membershipTypeId: "type-789",
        squareCheckoutId: "checkout-1",
        squarePaymentId: null,
        squareOrderId: "order-1",
        squarePaymentLinkUrl: "https://square.link/test-payment",
        amountCents: 4500,
        currency: "CAD",
        status: "pending" as const,
        metadata: {},
        expiresAt: null,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const membershipType = {
        id: "type-789",
        name: "Annual Player Membership",
        description: null,
        priceCents: 4500,
        durationMonths: 12,
        status: "active" as const,
        metadata: {},
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const result = await finalizeMembershipForSession({
        db: mockDb,
        paymentSession,
        membershipType,
        paymentId: "pay-123",
        orderId: "order-1",
        sessionId: "session-123",
        now: new Date("2025-01-15"),
      });

      expect(result.wasCreated).toBe(true);
      expect(result.membership).toMatchObject({
        userId: "user-456",
        membershipTypeId: "type-789",
        paymentId: "pay-123",
        status: "active",
        paymentProvider: "square",
      });
    });

    it("calculates correct end date based on membership duration", async () => {
      const now = new Date("2025-01-15");
      const paymentSession = {
        id: "session-123",
        userId: "user-456",
        membershipTypeId: "type-789",
        squareCheckoutId: "checkout-1",
        squarePaymentId: null,
        squareOrderId: null,
        squarePaymentLinkUrl: "https://square.link/test-payment",
        amountCents: 4500,
        currency: "CAD",
        status: "pending" as const,
        metadata: {},
        expiresAt: null,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const membershipType = {
        id: "type-789",
        name: "Annual Player Membership",
        description: null,
        priceCents: 4500,
        durationMonths: 12, // 12 months
        status: "active" as const,
        metadata: {},
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const result = await finalizeMembershipForSession({
        db: mockDb,
        paymentSession,
        membershipType,
        paymentId: "pay-123",
        sessionId: "session-123",
        now,
      });

      // End date should be 12 months from start
      expect(result.membership.startDate).toBe("2025-01-15");
      expect(result.membership.endDate).toBe("2026-01-15");
    });
  });

  describe("Idempotency", () => {
    it("returns existing membership when payment already processed", async () => {
      // Pre-populate with existing membership
      const existingMembership = {
        id: "existing-membership-1",
        userId: "user-456",
        membershipTypeId: "type-789",
        paymentId: "pay-123",
        startDate: "2025-01-01",
        endDate: "2026-01-01",
        status: "active",
        paymentProvider: "square",
        metadata: {},
      };

      // Override the mock to return existing membership
      const mockTxWithExisting = {
        ...mockTx,
        select: vi.fn().mockReturnThis(),
        from: vi.fn().mockReturnThis(),
        where: vi.fn().mockImplementation(() => ({
          limit: vi.fn().mockResolvedValue([existingMembership]),
        })),
        update: vi.fn().mockImplementation(() => ({
          set: vi.fn().mockImplementation(() => ({
            where: vi.fn().mockResolvedValue(undefined),
          })),
        })),
      };

      const mockDbWithExisting = {
        transaction: vi.fn().mockImplementation(async (callback) => {
          return callback(mockTxWithExisting);
        }),
      } as unknown as MembershipDbClient;

      const paymentSession = {
        id: "session-123",
        userId: "user-456",
        membershipTypeId: "type-789",
        squareCheckoutId: "checkout-1",
        squarePaymentId: null,
        squareOrderId: null,
        squarePaymentLinkUrl: "https://square.link/test-payment",
        amountCents: 4500,
        currency: "CAD",
        status: "pending" as const,
        metadata: {},
        expiresAt: null,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const membershipType = {
        id: "type-789",
        name: "Annual Player Membership",
        description: null,
        priceCents: 4500,
        durationMonths: 12,
        status: "active" as const,
        metadata: {},
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const result = await finalizeMembershipForSession({
        db: mockDbWithExisting,
        paymentSession,
        membershipType,
        paymentId: "pay-123",
        sessionId: "session-123",
        now: new Date("2025-01-15"),
      });

      expect(result.wasCreated).toBe(false);
      expect(result.membership.id).toBe("existing-membership-1");
    });
  });

  describe("Metadata Handling", () => {
    it("preserves existing session metadata when finalizing", async () => {
      const existingMetadata = {
        referralCode: "FRIEND2025",
        utmSource: "email",
      };

      const paymentSession = {
        id: "session-123",
        userId: "user-456",
        membershipTypeId: "type-789",
        squareCheckoutId: "checkout-1",
        squarePaymentId: null,
        squareOrderId: null,
        squarePaymentLinkUrl: "https://square.link/test-payment",
        amountCents: 4500,
        currency: "CAD",
        status: "pending" as const,
        metadata: existingMetadata,
        expiresAt: null,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const membershipType = {
        id: "type-789",
        name: "Annual Player Membership",
        description: null,
        priceCents: 4500,
        durationMonths: 12,
        status: "active" as const,
        metadata: {},
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const result = await finalizeMembershipForSession({
        db: mockDb,
        paymentSession,
        membershipType,
        paymentId: "pay-123",
        orderId: "order-1",
        sessionId: "session-123",
        now: new Date("2025-01-15"),
      });

      expect(result.membership.metadata).toMatchObject({
        referralCode: "FRIEND2025",
        utmSource: "email",
        sessionId: "session-123",
        squareTransactionId: "pay-123",
        squareOrderId: "order-1",
      });
    });
  });
});
</file>

<file path="src/features/membership/__tests__/membership.schemas.test.ts">
import { describe, expect, it } from "vitest";
import {
  cancelMembershipSchema,
  confirmMembershipPurchaseSchema,
  getMembershipTypeSchema,
  purchaseMembershipSchema,
} from "../membership.schemas";

describe("Membership Schemas", () => {
  describe("getMembershipTypeSchema", () => {
    it("validates valid membership type ID", () => {
      const validInput = {
        membershipTypeId: "membership-123",
      };

      const result = getMembershipTypeSchema.safeParse(validInput);
      expect(result.success).toBe(true);
    });

    it("fails without membership type ID", () => {
      const invalidInput = {};

      const result = getMembershipTypeSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });

    it("fails with non-string membership type ID", () => {
      const invalidInput = {
        membershipTypeId: 123,
      };

      const result = getMembershipTypeSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });
  });

  describe("purchaseMembershipSchema", () => {
    it("validates valid purchase input", () => {
      const validInput = {
        membershipTypeId: "membership-123",
        autoRenew: true,
      };

      const result = purchaseMembershipSchema.safeParse(validInput);
      expect(result.success).toBe(true);
      expect(result.data?.autoRenew).toBe(true);
    });

    it("validates purchase input without autoRenew (defaults to false)", () => {
      const validInput = {
        membershipTypeId: "membership-123",
      };

      const result = purchaseMembershipSchema.safeParse(validInput);
      expect(result.success).toBe(true);
      expect(result.data?.autoRenew).toBe(false);
    });

    it("fails without membership type ID", () => {
      const invalidInput = {
        autoRenew: true,
      };

      const result = purchaseMembershipSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });

    it("fails with invalid autoRenew type", () => {
      const invalidInput = {
        membershipTypeId: "membership-123",
        autoRenew: "yes", // Should be boolean
      };

      const result = purchaseMembershipSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });
  });

  describe("cancelMembershipSchema", () => {
    it("validates valid cancellation with all fields", () => {
      const validInput = {
        membershipId: "membership-123",
        reason: "Moving to another country",
        immediate: true,
      };

      const result = cancelMembershipSchema.safeParse(validInput);
      expect(result.success).toBe(true);
      expect(result.data?.reason).toBe("Moving to another country");
      expect(result.data?.immediate).toBe(true);
    });

    it("validates cancellation without optional fields", () => {
      const validInput = {
        membershipId: "membership-123",
      };

      const result = cancelMembershipSchema.safeParse(validInput);
      expect(result.success).toBe(true);
      expect(result.data?.reason).toBeUndefined();
      expect(result.data?.immediate).toBe(false);
    });

    it("validates cancellation with only reason", () => {
      const validInput = {
        membershipId: "membership-123",
        reason: "No longer playing",
      };

      const result = cancelMembershipSchema.safeParse(validInput);
      expect(result.success).toBe(true);
      expect(result.data?.reason).toBe("No longer playing");
      expect(result.data?.immediate).toBe(false);
    });

    it("fails without membership ID", () => {
      const invalidInput = {
        reason: "No longer playing",
        immediate: true,
      };

      const result = cancelMembershipSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });

    it("accepts empty string as reason", () => {
      const validInput = {
        membershipId: "membership-123",
        reason: "",
        immediate: false,
      };

      const result = cancelMembershipSchema.safeParse(validInput);
      expect(result.success).toBe(true);
      expect(result.data?.reason).toBe("");
    });
  });

  describe("confirmMembershipPurchaseSchema", () => {
    it("validates valid confirmation with all fields", () => {
      const validInput = {
        membershipTypeId: "membership-123",
        sessionId: "session-456",
        paymentId: "payment-789",
      };

      const result = confirmMembershipPurchaseSchema.safeParse(validInput);
      expect(result.success).toBe(true);
      expect(result.data?.paymentId).toBe("payment-789");
    });

    it("validates confirmation without optional payment ID", () => {
      const validInput = {
        membershipTypeId: "membership-123",
        sessionId: "session-456",
      };

      const result = confirmMembershipPurchaseSchema.safeParse(validInput);
      expect(result.success).toBe(true);
      expect(result.data?.paymentId).toBeUndefined();
    });

    it("fails without membership type ID", () => {
      const invalidInput = {
        sessionId: "session-456",
        paymentId: "payment-789",
      };

      const result = confirmMembershipPurchaseSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });

    it("fails without session ID", () => {
      const invalidInput = {
        membershipTypeId: "membership-123",
        paymentId: "payment-789",
      };

      const result = confirmMembershipPurchaseSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });

    it("fails with non-string IDs", () => {
      const invalidInput = {
        membershipTypeId: 123,
        sessionId: 456,
        paymentId: 789,
      };

      const result = confirmMembershipPurchaseSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });
  });
});
</file>

<file path="src/features/membership/__tests__/membership.validation.test.ts">
import { describe, expect, it } from "vitest";
import {
  confirmMembershipPurchaseSchema,
  purchaseMembershipSchema,
} from "../membership.schemas";

describe("Membership Server Function Validation", () => {
  describe("createCheckoutSession validation", () => {
    it("validates membership purchase input correctly", () => {
      // The actual server function uses omit({ autoRenew: true })
      const schema = purchaseMembershipSchema.omit({ autoRenew: true });

      const validInput = {
        data: {
          membershipTypeId: "membership-123",
        },
      };

      const result = schema.safeParse(validInput.data);
      expect(result.success).toBe(true);
    });

    it("fails without membership type ID", () => {
      const schema = purchaseMembershipSchema.omit({ autoRenew: true });

      const invalidInput = {
        data: {},
      };

      const result = schema.safeParse(invalidInput.data);
      expect(result.success).toBe(false);
    });
  });

  describe("confirmMembershipPurchase validation", () => {
    it("validates confirmation input correctly", () => {
      const validInput = {
        data: {
          membershipTypeId: "membership-123",
          sessionId: "session-456",
          paymentId: "payment-789",
        },
      };

      const result = confirmMembershipPurchaseSchema.safeParse(validInput.data);
      expect(result.success).toBe(true);
    });

    it("validates without optional payment ID", () => {
      const validInput = {
        data: {
          membershipTypeId: "membership-123",
          sessionId: "session-456",
        },
      };

      const result = confirmMembershipPurchaseSchema.safeParse(validInput.data);
      expect(result.success).toBe(true);
    });

    it("fails without required fields", () => {
      const invalidInput = {
        data: {
          membershipTypeId: "membership-123",
          // Missing sessionId
        },
      };

      const result = confirmMembershipPurchaseSchema.safeParse(invalidInput.data);
      expect(result.success).toBe(false);
    });
  });

  describe("Membership Types", () => {
    it("validates membership type structure", () => {
      // This is more of a type check than a runtime validation
      const membershipType = {
        id: "annual-player-2025",
        name: "Annual Player Membership 2025",
        description: "Full player membership for 2025 season",
        priceCents: 4500,
        currency: "CAD",
        durationMonths: 12,
        benefits: [
          "Tournament participation",
          "League play",
          "Insurance coverage",
          "Voting rights",
        ],
        status: "active" as const,
        maxPurchases: 1,
        validFrom: new Date("2025-01-01"),
        validUntil: new Date("2025-12-31"),
      };

      expect(membershipType).toMatchObject({
        id: expect.any(String),
        name: expect.any(String),
        priceCents: expect.any(Number),
        durationMonths: expect.any(Number),
        status: expect.stringMatching(/active|inactive|archived/),
      });
    });
  });

  describe("Membership Record", () => {
    it("validates membership record structure", () => {
      const membership = {
        id: "membership-123",
        userId: "user-456",
        membershipTypeId: "annual-player-2025",
        startDate: "2025-01-01",
        endDate: "2025-12-31",
        status: "active" as const,
        paymentProvider: "square" as const,
        paymentId: "payment-789",
        autoRenew: false,
        metadata: {
          sessionId: "session-123",
          purchasedAt: new Date().toISOString(),
        },
      };

      expect(membership).toMatchObject({
        id: expect.any(String),
        userId: expect.any(String),
        membershipTypeId: expect.any(String),
        startDate: expect.stringMatching(/^\d{4}-\d{2}-\d{2}$/),
        endDate: expect.stringMatching(/^\d{4}-\d{2}-\d{2}$/),
        status: expect.stringMatching(/active|expired|cancelled/),
        paymentProvider: expect.stringMatching(/square|etransfer|cash|other/),
      });
    });
  });
});
</file>

<file path="src/features/membership/components/admin-memberships-report.tsx">
import { useQuery } from "@tanstack/react-query";
import { type ColumnDef } from "@tanstack/react-table";
import { useState } from "react";
import { DataTable } from "~/components/ui/data-table";
import { exportToCSV, formatCurrency, formatDate } from "~/lib/utils/csv-export";
import { getAllMemberships, type MembershipReportRow } from "../membership.admin-queries";

const columns: ColumnDef<MembershipReportRow>[] = [
  {
    accessorKey: "userName",
    header: "User Name",
  },
  {
    accessorKey: "userEmail",
    header: "Email",
  },
  {
    accessorKey: "membershipType",
    header: "Membership Type",
  },
  {
    accessorKey: "startDate",
    header: "Start Date",
    cell: ({ row }) => formatDate(row.getValue("startDate")),
  },
  {
    accessorKey: "endDate",
    header: "End Date",
    cell: ({ row }) => formatDate(row.getValue("endDate")),
  },
  {
    accessorKey: "status",
    header: "Status",
    cell: ({ row }) => {
      const status = row.getValue("status") as string;
      return (
        <span
          className={`inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-medium ${
            status === "active"
              ? "bg-green-100 text-green-800"
              : status === "expired"
                ? "bg-gray-100 text-gray-800"
                : "bg-red-100 text-red-800"
          }`}
        >
          {status}
        </span>
      );
    },
  },
  {
    accessorKey: "priceCents",
    header: "Price",
    cell: ({ row }) => formatCurrency(row.getValue("priceCents")),
  },
  {
    accessorKey: "paymentId",
    header: "Payment ID",
    cell: ({ row }) => row.getValue("paymentId") || "-",
  },
  {
    accessorKey: "createdAt",
    header: "Created At",
    cell: ({ row }) => formatDate(row.getValue("createdAt")),
  },
];

export function AdminMembershipsReport() {
  const [statusFilter, setStatusFilter] = useState<
    "all" | "active" | "expired" | "cancelled"
  >("all");

  const { data, isLoading, error } = useQuery({
    queryKey: ["admin-memberships", statusFilter],
    queryFn: async () => {
      const result = await getAllMemberships({ data: { status: statusFilter } });
      return result;
    },
  });

  const handleExport = () => {
    if (data?.data) {
      const exportData = data.data.map((row) => ({
        "User Name": row.userName,
        Email: row.userEmail,
        "Membership Type": row.membershipType,
        "Start Date": formatDate(row.startDate),
        "End Date": formatDate(row.endDate),
        Status: row.status,
        Price: formatCurrency(row.priceCents),
        "Payment ID": row.paymentId || "-",
        "Created At": formatDate(row.createdAt),
      }));

      const filename = `memberships-report-${new Date().toISOString().split("T")[0]}.csv`;
      exportToCSV(exportData, filename);
    }
  };

  if (isLoading) {
    return (
      <div className="flex h-64 items-center justify-center">
        <div className="text-muted-foreground">Loading memberships...</div>
      </div>
    );
  }

  if (error || !data?.success) {
    const errorMessage = data?.errors?.[0]?.message || "Failed to load memberships";

    // Check if it's an admin access error
    if (errorMessage === "Admin access required") {
      return (
        <div className="border-destructive/50 bg-destructive/10 rounded-lg border p-6">
          <h3 className="text-destructive text-lg font-semibold">Access Denied</h3>
          <p className="text-muted-foreground mt-2">
            You do not have permission to view this report. Admin access is required.
          </p>
        </div>
      );
    }

    return (
      <div className="border-destructive/50 bg-destructive/10 rounded-lg border p-6">
        <h3 className="text-destructive text-lg font-semibold">Error Loading Report</h3>
        <p className="text-muted-foreground mt-2">{errorMessage}</p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-2xl font-bold tracking-tight">Memberships Report</h2>
          <p className="text-muted-foreground">
            View and export all membership data across the platform
          </p>
        </div>
        <div className="flex items-center gap-4">
          <select
            value={statusFilter}
            onChange={(e) =>
              setStatusFilter(
                e.target.value as "all" | "active" | "expired" | "cancelled",
              )
            }
            className="border-input bg-background ring-offset-background focus-visible:ring-ring rounded-md border px-3 py-2 text-sm focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:outline-none"
          >
            <option value="all">All Status</option>
            <option value="active">Active</option>
            <option value="expired">Expired</option>
            <option value="cancelled">Cancelled</option>
          </select>
        </div>
      </div>

      <DataTable
        columns={columns}
        data={data.data || []}
        pageSize={20}
        onExport={handleExport}
      />
    </div>
  );
}
</file>

<file path="src/features/roles/__tests__/permission.service.test.ts">
import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";
import { isAnyAdmin, PermissionService, userHasRole } from "../permission.service";

// Mock the database
const mockDbInstance = {
  select: vi.fn().mockReturnThis(),
  from: vi.fn().mockReturnThis(),
  innerJoin: vi.fn().mockReturnThis(),
  where: vi.fn().mockReturnThis(),
  limit: vi.fn().mockResolvedValue([]),
};

vi.mock("~/db", () => ({
  db: vi.fn(() => mockDbInstance),
}));

describe("PermissionService", () => {
  beforeEach(() => {
    vi.clearAllMocks();
    // Reset the mock chain
    mockDbInstance.select.mockReturnThis();
    mockDbInstance.from.mockReturnThis();
    mockDbInstance.innerJoin.mockReturnThis();
    mockDbInstance.where.mockReturnThis();
    mockDbInstance.limit.mockResolvedValue([]);
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe("isGlobalAdmin", () => {
    it("should return true for Solstice Admin", async () => {
      const mockResult = [{ id: "role-1", name: "Solstice Admin" }];
      mockDbInstance.limit.mockResolvedValueOnce(mockResult);

      const result = await PermissionService.isGlobalAdmin("user-123");
      expect(result).toBe(true);
    });

    it("should return true for Quadball Canada Admin", async () => {
      const mockResult = [{ id: "role-2", name: "Quadball Canada Admin" }];
      mockDbInstance.limit.mockResolvedValueOnce(mockResult);

      const result = await PermissionService.isGlobalAdmin("user-123");
      expect(result).toBe(true);
    });

    it("should return false for non-admin users", async () => {
      mockDbInstance.limit.mockResolvedValueOnce([]);

      const result = await PermissionService.isGlobalAdmin("user-123");
      expect(result).toBe(false);
    });
  });

  describe("canManageTeam", () => {
    it("should return true for global admins", async () => {
      // Mock isGlobalAdmin to return true
      vi.spyOn(PermissionService, "isGlobalAdmin").mockResolvedValue(true);

      const result = await PermissionService.canManageTeam("user-123", "team-456");
      expect(result).toBe(true);
    });

    it("should return true for team-specific admin", async () => {
      // Mock isGlobalAdmin to return false
      vi.spyOn(PermissionService, "isGlobalAdmin").mockResolvedValue(false);

      // Mock team admin query
      const mockResult = [{ id: "role-3", name: "Team Admin", teamId: "team-456" }];
      mockDbInstance.limit.mockResolvedValueOnce(mockResult);

      const result = await PermissionService.canManageTeam("user-123", "team-456");
      expect(result).toBe(true);
    });

    it("should return false for non-admin users", async () => {
      vi.spyOn(PermissionService, "isGlobalAdmin").mockResolvedValue(false);
      mockDbInstance.limit.mockResolvedValueOnce([]);

      const result = await PermissionService.canManageTeam("user-123", "team-456");
      expect(result).toBe(false);
    });
  });

  describe("getUserRoles", () => {
    it("should return all roles for a user", async () => {
      const mockRoles = [
        {
          id: "ur-1",
          userId: "user-123",
          roleId: "role-1",
          teamId: null,
          eventId: null,
          assignedBy: "admin-123",
          assignedAt: new Date(),
          expiresAt: null,
          notes: null,
          role: {
            id: "role-1",
            name: "Solstice Admin",
            description: "Platform admin",
            permissions: { "*": true },
          },
        },
      ];

      // Mock the where method to return the roles
      mockDbInstance.where.mockResolvedValueOnce(mockRoles);

      const result = await PermissionService.getUserRoles("user-123");
      expect(result).toEqual(mockRoles);
    });
  });
});

describe("Client-side helpers", () => {
  describe("userHasRole", () => {
    const mockUser = {
      roles: [
        {
          role: { name: "Solstice Admin" },
          teamId: null,
          eventId: null,
        },
        {
          role: { name: "Team Admin" },
          teamId: "team-123",
          eventId: null,
        },
      ],
    };

    it("should return true when user has global role", () => {
      expect(userHasRole(mockUser, "Solstice Admin")).toBe(true);
    });

    it("should return true when user has team-specific role", () => {
      expect(userHasRole(mockUser, "Team Admin", { teamId: "team-123" })).toBe(true);
    });

    it("should return false when user lacks role", () => {
      expect(userHasRole(mockUser, "Event Admin")).toBe(false);
    });

    it("should return false when user lacks scoped role", () => {
      expect(userHasRole(mockUser, "Team Admin", { teamId: "team-999" })).toBe(false);
    });

    it("should return false when user has no roles", () => {
      expect(userHasRole({ roles: [] }, "Solstice Admin")).toBe(false);
      expect(userHasRole({}, "Solstice Admin")).toBe(false);
    });
  });

  describe("isAnyAdmin", () => {
    it("should return true for users with admin roles", () => {
      const adminUser = {
        roles: [{ role: { name: "Team Admin" } }],
      };
      expect(isAnyAdmin(adminUser)).toBe(true);
    });

    it("should return false for users without admin roles", () => {
      const regularUser = {
        roles: [{ role: { name: "Player" } }],
      };
      expect(isAnyAdmin(regularUser)).toBe(false);
    });

    it("should return false for users with no roles", () => {
      expect(isAnyAdmin({ roles: [] })).toBe(false);
      expect(isAnyAdmin({})).toBe(false);
    });
  });
});
</file>

<file path="src/features/roles/components/__tests__/role-management-dashboard.test.tsx">
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { render, screen, waitFor } from "@testing-library/react";
import { beforeEach, describe, expect, it, vi } from "vitest";
import type { RoleManagementData } from "~/features/roles/roles.types";

vi.mock("~/features/roles/roles.queries", () => ({
  getRoleManagementData: vi.fn(),
  searchRoleEligibleUsers: vi.fn(),
}));

vi.mock("~/features/roles/roles.mutations", () => ({
  assignRoleToUser: vi.fn(async () => ({ success: true })),
  removeRoleAssignment: vi.fn(async () => ({ success: true })),
}));

vi.mock("sonner", () => ({
  toast: {
    success: vi.fn(),
    error: vi.fn(),
  },
}));

const { RoleManagementDashboard } = await import("../role-management-dashboard");
const { getRoleManagementData } = await import("~/features/roles/roles.queries");

const getRoleManagementDataMock = vi.mocked(getRoleManagementData);

function renderDashboard() {
  const client = new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
      },
    },
  });

  return render(
    <QueryClientProvider client={client}>
      <RoleManagementDashboard />
    </QueryClientProvider>,
  );
}

describe("RoleManagementDashboard", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("renders role summaries and assignments", async () => {
    const sampleData: RoleManagementData = {
      roles: [
        {
          id: "solstice-admin",
          name: "Solstice Admin",
          description: "Platform administrator",
          permissions: { "system:*": true },
          assignmentCount: 2,
          createdAt: new Date("2024-01-01"),
          updatedAt: new Date("2024-01-02"),
        },
      ],
      assignments: [
        {
          id: "assignment-1",
          roleId: "solstice-admin",
          roleName: "Solstice Admin",
          roleDescription: "Platform administrator",
          userId: "user-1",
          userName: "Admin User",
          userEmail: "admin@example.com",
          teamId: null,
          eventId: null,
          assignedBy: "assigner-1",
          assignedByName: "Seeder",
          assignedByEmail: "seeder@example.com",
          assignedAt: new Date("2024-02-01T12:00:00Z"),
          expiresAt: null,
          notes: "Seeded",
        },
      ],
    };

    getRoleManagementDataMock.mockResolvedValue({ success: true, data: sampleData });

    renderDashboard();

    await waitFor(() => {
      expect(screen.getAllByText("Solstice Admin").length).toBeGreaterThan(0);
    });

    expect(screen.getAllByText("Platform administrator").length).toBeGreaterThan(0);
    expect(screen.getByText("Admin User")).toBeInTheDocument();
    expect(screen.getByText("admin@example.com")).toBeInTheDocument();
    expect(screen.getByText("2 assigned")).toBeInTheDocument();
  });

  it("shows an error alert when loading fails", async () => {
    getRoleManagementDataMock.mockRejectedValue(new Error("boom"));

    renderDashboard();

    await waitFor(() => {
      expect(screen.getByText("Could not load roles")).toBeInTheDocument();
    });
  });
});
</file>

<file path="src/features/roles/components/role-management-dashboard.tsx">
import { useForm, useStore } from "@tanstack/react-form";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { Loader2, Search, ShieldCheck, UsersRound, XCircle } from "lucide-react";
import { useMemo, useState } from "react";
import { toast } from "sonner";
import { Alert, AlertDescription, AlertTitle } from "~/components/ui/alert";
import { Badge } from "~/components/ui/badge";
import { Button } from "~/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "~/components/ui/command";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "~/components/ui/dialog";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";
import { Popover, PopoverContent, PopoverTrigger } from "~/components/ui/popover";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "~/components/ui/table";
import { Textarea } from "~/components/ui/textarea";
import { assignRoleToUser, removeRoleAssignment } from "~/features/roles/roles.mutations";
import {
  getRoleManagementData,
  searchRoleEligibleUsers,
} from "~/features/roles/roles.queries";
import type {
  RoleAssignmentRow,
  RoleManagementData,
  RoleSummary,
  RoleUserSearchResult,
} from "~/features/roles/roles.types";

function useRoleManagementData() {
  return useQuery<RoleManagementData>({
    queryKey: ["role-management"],
    queryFn: async () => {
      const result = await getRoleManagementData();
      if (!result.success || !result.data) {
        throw new Error(
          result.errors?.[0]?.message || "Failed to load role management data",
        );
      }

      const normalized: RoleManagementData = {
        roles: result.data.roles.map((role) => ({
          ...role,
          assignmentCount: Number(role.assignmentCount),
        })),
        assignments: result.data.assignments.map((assignment) => ({
          ...assignment,
          assignedAt: new Date(assignment.assignedAt),
          expiresAt: assignment.expiresAt ? new Date(assignment.expiresAt) : null,
        })),
      };

      return normalized;
    },
  });
}

function useRoleAssignmentForm(
  roles: RoleSummary[],
  onSuccess: (assignment: RoleAssignmentRow) => void,
) {
  const form = useForm({
    defaultValues: {
      userId: "",
      roleId: "",
      teamId: "",
      eventId: "",
      notes: "",
      expiresAt: "",
    },
    onSubmit: async ({ value }) => {
      try {
        const result = await assignRoleToUser({
          data: {
            userId: value.userId,
            roleId: value.roleId,
            teamId: value.teamId || undefined,
            eventId: value.eventId || undefined,
            notes: value.notes || undefined,
            expiresAt: value.expiresAt
              ? new Date(value.expiresAt).toISOString()
              : undefined,
          },
        });

        if (!result.success || !result.data) {
          throw new Error(result.errors?.[0]?.message || "Failed to assign role");
        }

        onSuccess(result.data);
        form.reset();
        toast.success("Role assigned successfully");
      } catch (error) {
        const message = error instanceof Error ? error.message : "Failed to assign role";
        toast.error(message);
      }
    },
  });

  const selectedRoleId = useStore(form.store, (state) => state.values.roleId);
  const selectedRole = roles.find((role) => role.id === selectedRoleId) ?? null;

  const scopeType = useMemo(() => {
    if (!selectedRole) return "none" as const;
    if (selectedRole.name === "Team Admin") return "team" as const;
    if (selectedRole.name === "Event Admin") return "event" as const;
    return "none" as const;
  }, [selectedRole]);

  return { form, selectedRole, scopeType };
}

export function RoleManagementDashboard() {
  const queryClient = useQueryClient();
  const { data, isLoading, isError, error } = useRoleManagementData();
  const [assignDialogOpen, setAssignDialogOpen] = useState(false);
  const [userSearchTerm, setUserSearchTerm] = useState("");
  const [userSearchOpen, setUserSearchOpen] = useState(false);
  const [userResults, setUserResults] = useState<RoleUserSearchResult[]>([]);
  const [isSearchingUsers, setIsSearchingUsers] = useState(false);
  const [assignmentToRemove, setAssignmentToRemove] = useState<RoleAssignmentRow | null>(
    null,
  );

  const removeMutation = useMutation({
    mutationFn: removeRoleAssignment,
    onSuccess: (result) => {
      if (!result.success || !result.data) {
        toast.error(result.errors?.[0]?.message || "Failed to remove role assignment");
        return;
      }

      toast.success("Role assignment removed");
      queryClient.invalidateQueries({ queryKey: ["role-management"] });
    },
    onError: (mutationError) => {
      const message =
        mutationError instanceof Error
          ? mutationError.message
          : "Failed to remove role assignment";
      toast.error(message);
    },
    onSettled: () => {
      setAssignmentToRemove(null);
    },
  });

  const { form, scopeType } = useRoleAssignmentForm(data?.roles ?? [], () => {
    queryClient.invalidateQueries({ queryKey: ["role-management"] });
    setAssignDialogOpen(false);
    setUserSearchTerm("");
    setUserResults([]);
    setUserSearchOpen(false);
  });

  const handleDialogOpenChange = (open: boolean) => {
    setAssignDialogOpen(open);
    if (!open) {
      form.reset();
      setUserSearchTerm("");
      setUserResults([]);
      setUserSearchOpen(false);
    }
  };

  const roleOptions = useMemo(
    () =>
      (data?.roles ?? []).map((role) => ({
        value: role.id,
        label: role.name,
      })),
    [data?.roles],
  );

  const selectedUserId = useStore(form.store, (state) => state.values.userId);
  const selectedUser = useMemo(
    () => userResults.find((user) => user.id === selectedUserId) ?? null,
    [selectedUserId, userResults],
  );

  async function runUserSearch(term: string) {
    if (term.trim().length < 2) {
      setUserResults([]);
      return;
    }

    setIsSearchingUsers(true);
    try {
      const result = await searchRoleEligibleUsers({ data: { query: term.trim() } });
      if (result.success && result.data) {
        setUserResults(result.data);
      } else {
        toast.error(result.errors?.[0]?.message || "Failed to search users");
      }
    } catch (searchError) {
      const message =
        searchError instanceof Error ? searchError.message : "Failed to search users";
      toast.error(message);
    } finally {
      setIsSearchingUsers(false);
    }
  }

  function handleUserSearchChange(term: string) {
    setUserSearchTerm(term);
    if (term.trim().length >= 2) {
      void runUserSearch(term);
    } else {
      setUserResults([]);
    }
  }

  if (isLoading) {
    return (
      <div className="flex h-64 items-center justify-center">
        <div className="text-muted-foreground flex items-center gap-2">
          <Loader2 className="h-5 w-5 animate-spin" />
          Loading role management data...
        </div>
      </div>
    );
  }

  if (isError || !data) {
    return (
      <div className="container mx-auto p-6">
        <Alert variant="destructive">
          <AlertTitle>Could not load roles</AlertTitle>
          <AlertDescription>
            {error instanceof Error
              ? error.message
              : "Unknown error. Please try again later."}
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  const assignments = data.assignments;

  return (
    <div className="space-y-8">
      <section>
        <div className="mb-6 flex flex-col gap-4 lg:flex-row lg:items-center lg:justify-between">
          <div>
            <h1 className="text-3xl font-bold tracking-tight">Role Management</h1>
            <p className="text-muted-foreground mt-1">
              Assign and revoke administrator access across Solstice and teams.
            </p>
          </div>
          <Dialog open={assignDialogOpen} onOpenChange={handleDialogOpenChange}>
            <DialogTrigger asChild>
              <Button>
                <ShieldCheck className="mr-2 h-4 w-4" />
                Assign Role
              </Button>
            </DialogTrigger>
            <DialogContent className="sm:max-w-lg">
              <DialogHeader>
                <DialogTitle>Assign a Role</DialogTitle>
                <DialogDescription>
                  Search for a user and grant them a role. Scoped roles require either a
                  team or event context.
                </DialogDescription>
              </DialogHeader>

              <form
                className="space-y-5"
                onSubmit={(event) => {
                  event.preventDefault();
                  event.stopPropagation();
                  form.handleSubmit();
                }}
              >
                <form.Field
                  name="userId"
                  validators={{
                    onChange: ({ value }) => (!value ? "Select a user" : undefined),
                  }}
                >
                  {(field) => {
                    const selected =
                      userResults.find((user) => user.id === field.state.value) ??
                      selectedUser;

                    return (
                      <div className="space-y-2">
                        <Label>User</Label>
                        <Popover
                          open={userSearchOpen}
                          onOpenChange={(open) => setUserSearchOpen(open)}
                        >
                          <PopoverTrigger asChild>
                            <Button
                              type="button"
                              variant="outline"
                              role="combobox"
                              aria-expanded={userSearchOpen}
                              className="w-full justify-between"
                              disabled={form.state.isSubmitting}
                            >
                              {selected ? (
                                <span>
                                  {selected.name}
                                  <span className="text-muted-foreground ml-1 text-xs">
                                    ({selected.email})
                                  </span>
                                </span>
                              ) : (
                                <span className="text-muted-foreground">
                                  Search by name or email
                                </span>
                              )}
                              <Search className="ml-2 h-4 w-4 shrink-0 opacity-60" />
                            </Button>
                          </PopoverTrigger>
                          <PopoverContent
                            className="w-[--radix-popover-trigger-width] p-0"
                            align="start"
                          >
                            <Command shouldFilter={false}>
                              <CommandInput
                                placeholder="Search users..."
                                value={userSearchTerm}
                                onValueChange={handleUserSearchChange}
                              />
                              <CommandListWithResults
                                isSearching={isSearchingUsers}
                                results={userResults}
                                onSelect={(user) => {
                                  field.handleChange(user.id);
                                  setUserResults([
                                    user,
                                    ...userResults.filter((item) => item.id !== user.id),
                                  ]);
                                  setUserSearchOpen(false);
                                }}
                              />
                            </Command>
                          </PopoverContent>
                        </Popover>
                        {field.state.meta.isTouched &&
                          field.state.meta.errors.length > 0 && (
                            <p className="text-destructive text-sm font-medium">
                              {field.state.meta.errors.join(", ")}
                            </p>
                          )}
                      </div>
                    );
                  }}
                </form.Field>

                <form.Field
                  name="roleId"
                  validators={{
                    onChange: ({ value }) => (!value ? "Select a role" : undefined),
                  }}
                >
                  {(field) => (
                    <div className="space-y-2">
                      <Label htmlFor="role-select">Role</Label>
                      <select
                        id="role-select"
                        className="border-input focus-visible:border-ring focus-visible:ring-ring/50 flex h-10 w-full rounded-md border bg-transparent px-3 py-2 text-sm outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50"
                        value={field.state.value}
                        onChange={(event) => field.handleChange(event.target.value)}
                        disabled={form.state.isSubmitting}
                      >
                        <option value="" disabled>
                          Select a role
                        </option>
                        {roleOptions.map((role) => (
                          <option key={role.value} value={role.value}>
                            {role.label}
                          </option>
                        ))}
                      </select>
                      {field.state.meta.isTouched &&
                        field.state.meta.errors.length > 0 && (
                          <p className="text-destructive text-sm font-medium">
                            {field.state.meta.errors.join(", ")}
                          </p>
                        )}
                    </div>
                  )}
                </form.Field>

                <div className="grid gap-4 md:grid-cols-2">
                  <form.Field name="teamId">
                    {(field) => (
                      <div className="space-y-2">
                        <Label htmlFor="role-team">Team Scope</Label>
                        <Input
                          id="role-team"
                          placeholder="Team ID"
                          value={field.state.value}
                          onChange={(event) => field.handleChange(event.target.value)}
                          disabled={form.state.isSubmitting || scopeType !== "team"}
                        />
                        <FieldHint>
                          Use for assigning <strong>Team Admin</strong>. Leave blank for
                          global roles.
                        </FieldHint>
                      </div>
                    )}
                  </form.Field>

                  <form.Field name="eventId">
                    {(field) => (
                      <div className="space-y-2">
                        <Label htmlFor="role-event">Event Scope</Label>
                        <Input
                          id="role-event"
                          placeholder="Event ID"
                          value={field.state.value}
                          onChange={(event) => field.handleChange(event.target.value)}
                          disabled={form.state.isSubmitting || scopeType !== "event"}
                        />
                        <FieldHint>
                          Use for assigning <strong>Event Admin</strong>. Leave blank for
                          global roles.
                        </FieldHint>
                      </div>
                    )}
                  </form.Field>
                </div>

                <form.Field name="expiresAt">
                  {(field) => (
                    <div className="space-y-2">
                      <Label htmlFor="role-expiration">Expiration</Label>
                      <Input
                        id="role-expiration"
                        type="datetime-local"
                        value={field.state.value}
                        onChange={(event) => field.handleChange(event.target.value)}
                        disabled={form.state.isSubmitting}
                      />
                      <FieldHint>Optional  leave blank for no expiration.</FieldHint>
                    </div>
                  )}
                </form.Field>

                <form.Field name="notes">
                  {(field) => (
                    <div className="space-y-2">
                      <Label htmlFor="role-notes">Notes</Label>
                      <Textarea
                        id="role-notes"
                        placeholder="Add context for this assignment (optional)"
                        value={field.state.value}
                        onChange={(event) => field.handleChange(event.target.value)}
                        disabled={form.state.isSubmitting}
                      />
                    </div>
                  )}
                </form.Field>

                <DialogFooter>
                  <Button type="submit" disabled={form.state.isSubmitting}>
                    {form.state.isSubmitting && (
                      <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    )}
                    Assign Role
                  </Button>
                </DialogFooter>
              </form>
            </DialogContent>
          </Dialog>
        </div>

        <RoleSummaryGrid roles={data.roles} />
      </section>

      <section>
        <Card>
          <CardHeader>
            <CardTitle>Current Role Assignments</CardTitle>
            <CardDescription>
              Audit log of who has access, when it was granted, and by whom.
            </CardDescription>
          </CardHeader>
          <CardContent className="overflow-x-auto">
            {assignments.length === 0 ? (
              <div className="text-muted-foreground flex items-center gap-2 rounded-md border border-dashed p-6 text-sm">
                <UsersRound className="h-4 w-4" />
                No role assignments yet. Use Assign Role to get started.
              </div>
            ) : (
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>User</TableHead>
                    <TableHead>Role</TableHead>
                    <TableHead>Scope</TableHead>
                    <TableHead>Assigned By</TableHead>
                    <TableHead>Assigned At</TableHead>
                    <TableHead>Expires</TableHead>
                    <TableHead>Notes</TableHead>
                    <TableHead className="w-[120px] text-right">Actions</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {assignments.map((assignment) => (
                    <TableRow key={assignment.id}>
                      <TableCell>
                        <div className="flex flex-col">
                          <span className="font-medium">{assignment.userName}</span>
                          <span className="text-muted-foreground text-xs">
                            {assignment.userEmail}
                          </span>
                        </div>
                      </TableCell>
                      <TableCell>
                        <Badge variant="secondary">{assignment.roleName}</Badge>
                        {assignment.roleDescription && (
                          <p className="text-muted-foreground mt-1 text-xs">
                            {assignment.roleDescription}
                          </p>
                        )}
                      </TableCell>
                      <TableCell>
                        {assignment.teamId ? (
                          <Badge variant="outline">Team: {assignment.teamId}</Badge>
                        ) : assignment.eventId ? (
                          <Badge variant="outline">Event: {assignment.eventId}</Badge>
                        ) : (
                          <span className="text-muted-foreground text-xs">Global</span>
                        )}
                      </TableCell>
                      <TableCell>
                        {assignment.assignedByName ? (
                          <div className="flex flex-col">
                            <span>{assignment.assignedByName}</span>
                            <span className="text-muted-foreground text-xs">
                              {assignment.assignedByEmail}
                            </span>
                          </div>
                        ) : (
                          <span className="text-muted-foreground text-xs">System</span>
                        )}
                      </TableCell>
                      <TableCell>
                        <time dateTime={assignment.assignedAt.toISOString()}>
                          {new Date(assignment.assignedAt).toLocaleString()}
                        </time>
                      </TableCell>
                      <TableCell>
                        {assignment.expiresAt ? (
                          <time dateTime={assignment.expiresAt.toISOString()}>
                            {new Date(assignment.expiresAt).toLocaleString()}
                          </time>
                        ) : (
                          <span className="text-muted-foreground text-xs">
                            No expiration
                          </span>
                        )}
                      </TableCell>
                      <TableCell className="max-w-xs text-sm whitespace-pre-line">
                        {assignment.notes || (
                          <span className="text-muted-foreground"></span>
                        )}
                      </TableCell>
                      <TableCell className="text-right">
                        <Dialog
                          open={assignmentToRemove?.id === assignment.id}
                          onOpenChange={(open) =>
                            open
                              ? setAssignmentToRemove(assignment)
                              : setAssignmentToRemove(null)
                          }
                        >
                          <DialogTrigger asChild>
                            <Button variant="destructive" size="sm">
                              <XCircle className="mr-2 h-4 w-4" />
                              Remove
                            </Button>
                          </DialogTrigger>
                          <DialogContent>
                            <DialogHeader>
                              <DialogTitle>Remove role assignment</DialogTitle>
                              <DialogDescription>
                                This will revoke {assignment.roleName} from{" "}
                                {assignment.userName}. This action cannot be undone.
                              </DialogDescription>
                            </DialogHeader>
                            <DialogFooter className="flex items-center justify-end gap-2">
                              <Button
                                variant="outline"
                                onClick={() => setAssignmentToRemove(null)}
                              >
                                Cancel
                              </Button>
                              <Button
                                variant="destructive"
                                disabled={removeMutation.isPending}
                                onClick={() => {
                                  setAssignmentToRemove(assignment);
                                  removeMutation.mutate({
                                    data: { assignmentId: assignment.id },
                                  });
                                }}
                              >
                                {removeMutation.isPending && (
                                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                                )}
                                Remove access
                              </Button>
                            </DialogFooter>
                          </DialogContent>
                        </Dialog>
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            )}
          </CardContent>
        </Card>
      </section>
    </div>
  );
}

function RoleSummaryGrid({ roles }: { roles: RoleSummary[] }) {
  if (!roles.length) return null;

  return (
    <div className="grid gap-4 md:grid-cols-2 xl:grid-cols-3">
      {roles.map((role) => (
        <Card key={role.id}>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">{role.name}</CardTitle>
            <Badge variant="outline">{role.assignmentCount} assigned</Badge>
          </CardHeader>
          <CardContent className="space-y-3 text-sm">
            <p className="text-muted-foreground text-sm">
              {role.description || "No description provided."}
            </p>
            <div>
              <p className="text-muted-foreground mb-1 text-xs uppercase">Permissions</p>
              <div className="flex flex-wrap gap-2">
                {Object.keys(role.permissions).length === 0 ? (
                  <Badge variant="secondary">None configured</Badge>
                ) : (
                  Object.keys(role.permissions)
                    .filter((key) => role.permissions[key])
                    .map((key) => (
                      <Badge key={key} variant="secondary">
                        {key}
                      </Badge>
                    ))
                )}
              </div>
            </div>
          </CardContent>
        </Card>
      ))}
    </div>
  );
}

function FieldHint({ children }: { children: React.ReactNode }) {
  return <p className="text-muted-foreground text-xs">{children}</p>;
}

function CommandListWithResults({
  isSearching,
  results,
  onSelect,
}: {
  isSearching: boolean;
  results: RoleUserSearchResult[];
  onSelect: (result: RoleUserSearchResult) => void;
}) {
  return (
    <CommandList className="relative">
      <CommandEmpty>
        {isSearching ? (
          <div className="text-muted-foreground flex items-center gap-2 text-sm">
            <Loader2 className="h-4 w-4 animate-spin" /> Searching users...
          </div>
        ) : (
          "No users found."
        )}
      </CommandEmpty>
      <CommandGroup>
        {results.map((result) => (
          <CommandItem
            key={result.id}
            value={`${result.name} ${result.email}`}
            onSelect={() => onSelect(result)}
          >
            <div className="flex flex-col">
              <span className="font-medium">{result.name}</span>
              <span className="text-muted-foreground text-xs">{result.email}</span>
              {result.roleNames.length > 0 && (
                <span className="text-muted-foreground text-[11px]">
                  Roles: {result.roleNames.join(", ")}
                </span>
              )}
            </div>
          </CommandItem>
        ))}
      </CommandGroup>
    </CommandList>
  );
}
</file>

<file path="src/features/roles/roles.types.ts">
export type RoleOperationErrorCode =
  | "VALIDATION_ERROR"
  | "UNAUTHORIZED"
  | "NOT_FOUND"
  | "DATABASE_ERROR";

export interface RoleOperationError {
  code: RoleOperationErrorCode;
  message: string;
}

export interface RoleOperationResult<T> {
  success: boolean;
  data?: T;
  errors?: RoleOperationError[];
}

export interface RoleSummary {
  id: string;
  name: string;
  description: string | null;
  permissions: Record<string, boolean>;
  assignmentCount: number;
  createdAt: Date;
  updatedAt: Date;
}

export interface RoleAssignmentRow {
  id: string;
  roleId: string;
  roleName: string;
  roleDescription: string | null;
  userId: string;
  userName: string;
  userEmail: string;
  teamId: string | null;
  eventId: string | null;
  assignedBy: string;
  assignedByName: string | null;
  assignedByEmail: string | null;
  assignedAt: Date;
  expiresAt: Date | null;
  notes: string | null;
}

export interface RoleManagementData {
  roles: RoleSummary[];
  assignments: RoleAssignmentRow[];
}

export interface RoleUserSearchResult {
  id: string;
  name: string;
  email: string;
  roleNames: string[];
}
</file>

<file path="src/lib/auth/guards/route-guards.ts">
import { redirect } from "@tanstack/react-router";
import type { User } from "better-auth";
import { requireCompleteProfile } from "~/features/profile/profile-guard";
import type { User as ExtendedUser } from "~/lib/auth/types";

/**
 * Route guard that requires authentication
 * Redirects to login page if user is not authenticated
 *
 * @example
 * export const Route = createFileRoute("/protected")({
 *   beforeLoad: async ({ context, location }) => {
 *     requireAuth({ user: context.user, location });
 *   },
 * });
 */
export function requireAuth({
  user,
  location,
  redirectTo = "/auth/login",
}: {
  user: User | null;
  location: { pathname: string };
  redirectTo?: string;
}) {
  if (!user) {
    throw redirect({
      to: redirectTo,
      search: {
        redirect: location.pathname,
      },
    });
  }
}

/**
 * Route guard that redirects authenticated users
 * Useful for login/signup pages
 *
 * @example
 * export const Route = createFileRoute("/auth/login")({
 *   beforeLoad: async ({ context }) => {
 *     redirectIfAuthenticated({ user: context.user });
 *   },
 * });
 */
export function redirectIfAuthenticated({
  user,
  redirectTo = "/dashboard",
}: {
  user: User | null;
  redirectTo?: string;
}) {
  if (user) {
    throw redirect({
      to: redirectTo,
    });
  }
}

/**
 * Composite guard that checks both auth and profile completion
 * Note: This expects the ExtendedUser type from route context which includes profile fields
 *
 * @example
 * export const Route = createFileRoute("/app/feature")({
 *   beforeLoad: async ({ context, location }) => {
 *     requireAuthAndProfile({ user: context.user, location });
 *   },
 * });
 */
export function requireAuthAndProfile({
  user,
  location,
}: {
  user: ExtendedUser | null;
  location: { pathname: string };
}) {
  // First check auth (will throw if user is null)
  requireAuth({ user, location });

  // Then check profile completion
  // The type assertion is safe because requireAuth would have thrown if user was null
  requireCompleteProfile(user as ExtendedUser);
}
</file>

<file path="src/lib/auth/middleware/__tests__/auth-guard.test.ts">
import { beforeEach, describe, expect, it, vi } from "vitest";

// Mock the auth module to avoid server-side environment variable access
vi.mock("~/lib/auth", () => ({
  auth: {
    api: {
      getSession: vi.fn(),
    },
  },
}));

// Mock TanStack Start server functions
vi.mock("@tanstack/react-start/server", () => ({
  getRequest: vi.fn(() => new Request("http://localhost", { headers: new Headers() })),
  setResponseStatus: vi.fn(),
}));

describe("authMiddleware", () => {
  // Since the authMiddleware uses TanStack Start's createMiddleware which is complex to test,
  // we'll focus on testing the authentication logic separately

  it("should be defined", async () => {
    const { authMiddleware } = await import("../auth-guard");
    expect(authMiddleware).toBeDefined();
    expect(typeof authMiddleware).toBe("object");
  });

  describe("authentication logic", () => {
    // Mock functions for testing the auth logic
    const mockGetSession = vi.fn();

    beforeEach(() => {
      vi.clearAllMocks();
    });

    it("should allow access when session exists", async () => {
      const mockUser = {
        id: "test-user-id",
        email: "test@example.com",
        name: "Test User",
      };

      const mockSession = {
        user: mockUser,
        session: { id: "test-session-id" },
      };

      mockGetSession.mockResolvedValueOnce(mockSession);

      // Test the authentication logic
      const headers = new Headers({ cookie: "session=test" });
      const result = await mockGetSession({
        headers,
        query: { disableCookieCache: true },
      });

      expect(result).toEqual(mockSession);
      expect(result.user).toEqual(mockUser);
    });

    it("should deny access when no session exists", async () => {
      mockGetSession.mockResolvedValueOnce(null);

      // Test the authentication logic
      const headers = new Headers({ cookie: "session=invalid" });
      const result = await mockGetSession({
        headers,
        query: { disableCookieCache: true },
      });

      expect(result).toBeNull();

      // In the actual middleware, this would trigger:
      // - setResponseStatus(401)
      // - throw new Error('Unauthorized')
    });

    it("should pass correct parameters to getSession", async () => {
      const headers = new Headers({
        cookie: "session=test-session",
        authorization: "Bearer token",
      });

      mockGetSession.mockResolvedValueOnce({ user: {}, session: {} });

      await mockGetSession({
        headers,
        query: { disableCookieCache: true },
      });

      expect(mockGetSession).toHaveBeenCalledWith({
        headers,
        query: { disableCookieCache: true },
      });
    });

    it("should always disable cookie cache for fresh session check", async () => {
      const headers = new Headers({ cookie: "session=test" });

      mockGetSession.mockResolvedValueOnce({ user: {}, session: {} });

      await mockGetSession({
        headers,
        query: { disableCookieCache: true },
      });

      const call = mockGetSession.mock.calls[0][0];
      expect(call.query.disableCookieCache).toBe(true);
    });
  });
});
</file>

<file path="src/lib/auth/index.ts">
/**
 * Auth module - Client-safe exports
 *
 * For server-side auth configuration, import from ~/lib/auth/server-helpers
 */

// Export types that are safe for client use
export type { Session, User } from "better-auth";
export type { AuthUser, User as ExtendedUser } from "./types";
</file>

<file path="src/lib/auth/types.ts">
import type { User as BetterAuthUser } from "better-auth";
import type { Tag } from "~/db/schema";

// User role with full role information
export interface UserRole {
  id: string;
  userId: string;
  roleId: string;
  role: {
    id: string;
    name: string;
    description: string | null;
    permissions: Record<string, boolean>;
  };
  teamId?: string | null;
  eventId?: string | null;
  assignedBy: string;
  assignedAt: Date;
  expiresAt?: Date | null;
  notes?: string | null;
}

// User tag (for future implementation)
export interface UserTag {
  id: string;
  userId: string;
  tagId: string;
  tag: Tag;
  assignedBy?: string | null;
  assignedAt: Date;
  expiresAt?: Date | null;
  notes?: string | null;
}

// Extended user type that includes our custom fields
export interface User extends BetterAuthUser {
  // Profile completion tracking
  profileComplete: boolean;

  // Required profile fields
  dateOfBirth?: Date | null;
  emergencyContact?: string | null; // JSON string

  // Optional profile fields
  gender?: string | null;
  pronouns?: string | null;
  phone?: string | null;

  // Privacy and preferences
  privacySettings?: string | null; // JSON string

  // Audit and versioning
  profileVersion: number;
  profileUpdatedAt?: Date | null;

  // Roles and permissions
  roles?: UserRole[];

  // Tags (for future implementation)
  tags?: UserTag[];
}

// Type definitions that can be safely imported on both client and server
export type AuthUser = User | null;
</file>

<file path="src/lib/pacer/hooks.ts">
import { useAsyncRateLimitedCallback } from "@tanstack/react-pacer";
import { toast } from "sonner";
import { rateLimitPresets, type RateLimitType } from "./rate-limit-config";

interface UseRateLimitedServerFnOptions {
  type?: RateLimitType;
  onReject?: (limiter: {
    getMsUntilNextWindow?: () => number;
    store?: { state: Record<string, unknown> };
  }) => void;
  showToast?: boolean;
}

/**
 * Hook to rate limit server function calls on the client side
 *
 * @example
 * ```tsx
 * const rateLimitedCreateTeam = useRateLimitedServerFn(
 *   createTeam,
 *   { type: 'mutation' }
 * );
 *
 * // Use it like the original function
 * await rateLimitedCreateTeam({ data: teamData });
 * ```
 */
export function useRateLimitedServerFn<TArgs extends unknown[], TReturn>(
  serverFn: (...args: TArgs) => Promise<TReturn>,
  options: UseRateLimitedServerFnOptions = {},
) {
  const { type = "api", onReject, showToast = true } = options;
  const preset = rateLimitPresets[type];

  // Type assertion needed due to TanStack Pacer's alpha API
  /* eslint-disable @typescript-eslint/no-explicit-any */
  return useAsyncRateLimitedCallback(serverFn, {
    ...preset,
    onReject: (limiter: any) => {
      if (showToast) {
        const msUntilNext = limiter.getMsUntilNextWindow?.() || 1000;
        const seconds = Math.ceil(msUntilNext / 1000);
        toast.error(
          `Too many requests. Please try again in ${seconds} second${seconds === 1 ? "" : "s"}.`,
        );
      }
      onReject?.(limiter);
    },
    onError: (error: unknown) => {
      // Let the original error bubble up
      throw error;
    },
  } as any);
  /* eslint-enable @typescript-eslint/no-explicit-any */
}

/**
 * Hook for rate limiting search operations with debouncing
 * Combines rate limiting with a slight delay to avoid too many requests while typing
 */
export function useRateLimitedSearch<TReturn>(
  searchFn: (query: string) => Promise<TReturn>,
  options: Omit<UseRateLimitedServerFnOptions, "type"> = {},
) {
  return useRateLimitedServerFn(searchFn, {
    ...options,
    type: "search",
  });
}
</file>

<file path="src/lib/pacer/index.ts">
export { useRateLimitedSearch, useRateLimitedServerFn } from "./hooks";
export { rateLimitPresets, type RateLimitType } from "./rate-limit-config";

// Re-export commonly used types from TanStack Pacer
export type { AsyncRateLimiter, RateLimiter } from "@tanstack/pacer";
</file>

<file path="src/lib/pacer/rate-limit-config.ts">
// Rate limit configuration for TanStack Pacer

// Rate limit presets for different types of operations
export const rateLimitPresets = {
  auth: {
    limit: 5,
    window: 15 * 60 * 1000, // 15 minutes
    windowType: "fixed" as const,
  },
  api: {
    limit: 100,
    window: 60 * 1000, // 1 minute
    windowType: "sliding" as const,
  },
  search: {
    limit: 10,
    window: 10 * 1000, // 10 seconds
    windowType: "sliding" as const,
  },
  mutation: {
    limit: 20,
    window: 60 * 1000, // 1 minute
    windowType: "fixed" as const,
  },
};

export type RateLimitType = keyof typeof rateLimitPresets;
</file>

<file path="src/lib/security/config.ts">
/**
 * Security configuration for the application
 * Centralizes all security-related settings
 */

import { env, getBaseUrl, isProduction } from "~/lib/env.server";
import { PASSWORD_CONFIG } from "./password-config";

// This module should only be imported in server-side code

export const securityConfig = {
  // Cookie security settings
  cookies: {
    httpOnly: true,
    sameSite: "lax" as const,
    // Force secure cookies in production or when base URL starts with https://
    // This ensures secure cookies even in preview deployments where NODE_ENV might be "test"
    secure: isProduction() || getBaseUrl().startsWith("https://"),
    path: "/",
    // Optional domain restriction for production
    // Set COOKIE_DOMAIN env var to restrict cookies to specific domain
    ...(isProduction() && env.COOKIE_DOMAIN ? { domain: env.COOKIE_DOMAIN } : {}),
  },

  // Session configuration
  session: {
    maxAge: 60 * 60 * 24 * 30, // 30 days
    updateAge: 60 * 60 * 24, // Update session if older than 1 day
    cookieCache: {
      enabled: true,
      maxAge: 60 * 5, // 5 minutes
    },
  },

  // CORS configuration
  cors: {
    credentials: true,
    origin: getBaseUrl(),
    methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allowedHeaders: ["Content-Type", "Authorization"],
  },

  // Rate limiting defaults
  rateLimit: {
    auth: {
      windowMs: 15 * 60 * 1000, // 15 minutes
      max: 5, // 5 requests per window
    },
    api: {
      windowMs: 15 * 60 * 1000, // 15 minutes
      max: 100, // 100 requests per window
    },
  },

  // Password requirements (using shared config)
  password: {
    ...PASSWORD_CONFIG,
    maxLength: 128, // Additional server-side constraint
  },

  // OAuth configuration
  oauth: {
    // Allowed email domains for OAuth sign-ups (comma-separated in env)
    // Example: OAUTH_ALLOWED_DOMAINS=company.com,partner.com
    allowedDomains: env.OAUTH_ALLOWED_DOMAINS,
  },
} as const;

// Type exports
export type SecurityConfig = typeof securityConfig;
export type CookieConfig = typeof securityConfig.cookies;
export type SessionConfig = typeof securityConfig.session;
</file>

<file path="src/lib/security/index.ts">
/**
 * Security module exports
 * Centralizes all security-related functionality
 */

// Server-only exports - only import these in server code
export { securityConfig } from "./config";
export type { CookieConfig, SecurityConfig, SessionConfig } from "./config";

// Shared exports - safe for both client and server
export { PASSWORD_CONFIG } from "./password-config";
export {
  getPasswordStrength,
  getPasswordStrengthLabel,
  validatePassword,
} from "./utils/password-validator";
</file>

<file path="src/routes/auth/login.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { z } from "zod";
import LoginForm from "~/features/auth/components/login";

const searchSchema = z.object({
  redirect: z.string().optional(),
});

export const Route = createFileRoute("/auth/login")({
  validateSearch: (search) => searchSchema.parse(search),
  component: LoginRoute,
});

function LoginRoute() {
  const { redirect } = Route.useSearch();

  return <LoginForm redirectPath={redirect} />;
}
</file>

<file path="src/routes/dashboard/route.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { AdminLayout } from "~/features/layouts/admin-layout";
import { requireAuthAndProfile } from "~/lib/auth/guards/route-guards";

export const Route = createFileRoute("/dashboard")({
  component: DashboardLayout,
  beforeLoad: async ({ context, location }) => {
    //   Redirect unauthenticated visitors to `/auth/login`
    //   Redirect authenticated but incomplete profiles to `/onboarding`
    requireAuthAndProfile({ user: context.user, location });
  },
});

function DashboardLayout() {
  return <AdminLayout />;
}
</file>

<file path="src/db/schema/roles.schema.ts">
import { sql } from "drizzle-orm";
import { boolean, index, jsonb, pgTable, text, timestamp } from "drizzle-orm/pg-core";
import { user } from "./auth.schema";

/**
 * Roles table - defines available roles in the system
 */
export const roles = pgTable("roles", {
  id: text("id")
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  name: text("name").notNull().unique(),
  description: text("description"),
  permissions: jsonb("permissions")
    .$type<Record<string, boolean>>()
    .notNull()
    .default({}),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
});

/**
 * User roles assignment table - maps users to roles with optional scope
 */
export const userRoles = pgTable(
  "user_roles",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    roleId: text("role_id")
      .notNull()
      .references(() => roles.id, { onDelete: "cascade" }),
    // Scope fields (NULL for global roles)
    teamId: text("team_id"),
    eventId: text("event_id"),
    // Metadata
    assignedBy: text("assigned_by")
      .notNull()
      .references(() => user.id),
    assignedAt: timestamp("assigned_at", { withTimezone: true }).notNull().defaultNow(),
    expiresAt: timestamp("expires_at", { withTimezone: true }),
    notes: text("notes"),
  },
  (table) => [
    index("idx_user_roles_user_id").on(table.userId),
    index("idx_user_roles_team_id")
      .on(table.teamId)
      .where(sql`${table.teamId} IS NOT NULL`),
    index("idx_user_roles_event_id")
      .on(table.eventId)
      .where(sql`${table.eventId} IS NOT NULL`),
    index("idx_user_roles_unique").on(
      table.userId,
      table.roleId,
      table.teamId,
      table.eventId,
    ),
  ],
);

/**
 * Tags table - for user categorization (future implementation)
 */
export const tags = pgTable("tags", {
  id: text("id")
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  name: text("name").notNull().unique(),
  category: text("category").notNull(), // 'official', 'team', 'player', 'custom'
  description: text("description"),
  color: text("color"), // For UI display
  icon: text("icon"), // Icon identifier
  isActive: boolean("is_active").default(true),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
});

/**
 * User tags assignment table (future implementation)
 */
export const userTags = pgTable(
  "user_tags",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    tagId: text("tag_id")
      .notNull()
      .references(() => tags.id, { onDelete: "cascade" }),
    assignedBy: text("assigned_by").references(() => user.id),
    assignedAt: timestamp("assigned_at", { withTimezone: true }).notNull().defaultNow(),
    expiresAt: timestamp("expires_at", { withTimezone: true }),
    notes: text("notes"),
  },
  (table) => [
    index("idx_user_tags_user_id").on(table.userId),
    index("idx_user_tags_tag_id").on(table.tagId),
    index("idx_user_tags_expires_at")
      .on(table.expiresAt)
      .where(sql`${table.expiresAt} IS NOT NULL`),
    index("idx_user_tags_unique").on(table.userId, table.tagId),
  ],
);

// Type exports for TypeScript
export type Role = typeof roles.$inferSelect;
export type NewRole = typeof roles.$inferInsert;
export type UserRole = typeof userRoles.$inferSelect;
export type NewUserRole = typeof userRoles.$inferInsert;
export type Tag = typeof tags.$inferSelect;
export type NewTag = typeof tags.$inferInsert;
export type UserTag = typeof userTags.$inferSelect;
export type NewUserTag = typeof userTags.$inferInsert;
</file>

<file path="src/db/schema/teams.schema.ts">
import { createId } from "@paralleldrive/cuid2";
import { relations, sql } from "drizzle-orm";
import {
  index,
  integer,
  pgEnum,
  pgTable,
  text,
  timestamp,
  uniqueIndex,
  varchar,
} from "drizzle-orm/pg-core";
import { user } from "./auth.schema";

// Enum for team member roles
export const teamMemberRoleEnum = pgEnum("team_member_role", [
  "captain",
  "coach",
  "player",
  "substitute",
]);

// Enum for team member status
export const teamMemberStatusEnum = pgEnum("team_member_status", [
  "pending",
  "active",
  "inactive",
  "removed",
]);

/**
 * Teams table
 * Stores team information for Quadball teams
 */
export const teams = pgTable(
  "teams",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => createId()),
    name: varchar("name", { length: 255 }).notNull(),
    slug: varchar("slug", { length: 255 }).notNull().unique(),
    description: text("description"),
    city: varchar("city", { length: 255 }),
    province: varchar("province", { length: 2 }), // ON, BC, etc.
    logoUrl: text("logo_url"),
    primaryColor: varchar("primary_color", { length: 7 }), // Hex color
    secondaryColor: varchar("secondary_color", { length: 7 }), // Hex color
    foundedYear: varchar("founded_year", { length: 4 }),
    website: text("website"),
    socialLinks: text("social_links"), // JSON string of social media links
    isActive: text("is_active").default("true").notNull(),
    createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
    updatedAt: timestamp("updated_at", { withTimezone: true })
      .notNull()
      .defaultNow()
      .$onUpdate(() => new Date()),
    createdBy: text("created_by")
      .notNull()
      .references(() => user.id),
  },
  (table) => [
    uniqueIndex("teams_slug_idx").on(table.slug),
    index("teams_created_by_idx").on(table.createdBy),
    index("teams_is_active_idx").on(table.isActive),
  ],
);

/**
 * Team members junction table
 * Manages the many-to-many relationship between users and teams
 */
export const teamMembers = pgTable(
  "team_members",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => createId()),
    teamId: text("team_id")
      .notNull()
      .references(() => teams.id, { onDelete: "cascade" }),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    role: teamMemberRoleEnum("role").notNull().default("player"),
    status: teamMemberStatusEnum("status").notNull().default("pending"),
    jerseyNumber: varchar("jersey_number", { length: 3 }),
    position: varchar("position", { length: 50 }), // Chaser, Beater, Keeper, Seeker
    joinedAt: timestamp("joined_at", { withTimezone: true }).notNull().defaultNow(),
    leftAt: timestamp("left_at", { withTimezone: true }),
    invitedBy: text("invited_by").references(() => user.id),
    notes: text("notes"),
    invitedAt: timestamp("invited_at", { withTimezone: true }),
    lastInvitationReminderAt: timestamp("last_invitation_reminder_at", {
      withTimezone: true,
    }),
    invitationReminderCount: integer("invitation_reminder_count").notNull().default(0),
    requestedAt: timestamp("requested_at", { withTimezone: true }),
  },
  (table) => [
    uniqueIndex("team_members_team_user_idx").on(table.teamId, table.userId),
    index("team_members_team_status_idx").on(table.teamId, table.status),
    index("team_members_user_status_idx").on(table.userId, table.status),
    uniqueIndex("team_members_active_user_idx")
      .on(table.userId)
      .where(sql`status = 'active'`),
  ],
);

// Relations
export const teamsRelations = relations(teams, ({ many, one }) => ({
  members: many(teamMembers),
  creator: one(user, {
    fields: [teams.createdBy],
    references: [user.id],
  }),
}));

export const teamMembersRelations = relations(teamMembers, ({ one }) => ({
  team: one(teams, {
    fields: [teamMembers.teamId],
    references: [teams.id],
  }),
  user: one(user, {
    fields: [teamMembers.userId],
    references: [user.id],
  }),
  inviter: one(user, {
    fields: [teamMembers.invitedBy],
    references: [user.id],
  }),
}));

// Types
export type Team = typeof teams.$inferSelect;
export type NewTeam = typeof teams.$inferInsert;
export type TeamMember = typeof teamMembers.$inferSelect;
export type NewTeamMember = typeof teamMembers.$inferInsert;
export type TeamMemberRole = (typeof teamMemberRoleEnum.enumValues)[number];
export type TeamMemberStatus = (typeof teamMemberStatusEnum.enumValues)[number];
</file>

<file path="src/features/auth/__tests__/login.test.tsx">
import userEvent from "@testing-library/user-event";
import { beforeEach, describe, expect, it, vi } from "vitest";

// Setup mocks before imports
const mockNavigate = vi.fn();
const mockInvalidateQueries = vi.fn();

// Mock auth client
vi.mock("~/lib/auth-client", () => ({
  auth: {
    signIn: {
      email: vi.fn(),
    },
    signUp: {
      email: vi.fn(),
    },
    signInWithOAuth: vi.fn(),
    signOut: vi.fn(),
    getSession: vi.fn(),
  },
  default: {
    signIn: {
      email: vi.fn(),
      social: vi.fn(),
    },
    signUp: {
      email: vi.fn(),
    },
    signOut: vi.fn(),
    getSession: vi.fn(),
  },
}));

// Mock TanStack Router
vi.mock("@tanstack/react-router", () => ({
  // eslint-disable-next-line @eslint-react/hooks-extra/no-unnecessary-use-prefix
  useNavigate: () => mockNavigate,
  // eslint-disable-next-line @eslint-react/hooks-extra/no-unnecessary-use-prefix
  useRouteContext: () => ({ redirectUrl: "/dashboard" }),
  // eslint-disable-next-line @eslint-react/hooks-extra/no-unnecessary-use-prefix
  useRouterState: () => ({ location: { pathname: "/auth/login" } }),
  // eslint-disable-next-line @eslint-react/hooks-extra/no-unnecessary-use-prefix
  useRouter: () => ({ invalidate: vi.fn() }),
  Link: ({
    to,
    children,
    ...props
  }: {
    to: string;
    children: React.ReactNode;
  } & React.AnchorHTMLAttributes<HTMLAnchorElement>) => (
    <a href={to} {...props}>
      {children}
    </a>
  ),
}));

// Mock SafeLink
vi.mock("~/components/ui/SafeLink", () => ({
  SafeLink: ({
    to,
    children,
    ...props
  }: {
    to: string;
    children: React.ReactNode;
  } & React.AnchorHTMLAttributes<HTMLAnchorElement>) => (
    <a href={to} {...props}>
      {children}
    </a>
  ),
}));

vi.mock("@tanstack/react-query", async (importOriginal) => {
  const actual = await importOriginal<typeof import("@tanstack/react-query")>();
  return {
    ...actual,
    // eslint-disable-next-line @eslint-react/hooks-extra/no-unnecessary-use-prefix
    useQueryClient: () => ({ invalidateQueries: mockInvalidateQueries }),
  };
});

import { auth } from "~/lib/auth-client";
import { createAuthMocks } from "~/tests/mocks/auth";
import { render, screen, waitFor } from "~/tests/utils";
import LoginForm from "../components/login";

describe("LoginForm", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("renders login form with all elements", () => {
    render(<LoginForm />);

    // Check for form elements
    expect(screen.getByLabelText("Email")).toBeInTheDocument();
    expect(screen.getByLabelText("Password")).toBeInTheDocument();
    expect(screen.getByRole("button", { name: "Login" })).toBeInTheDocument();

    // Check for social login button
    expect(screen.getByRole("button", { name: "Login with Google" })).toBeInTheDocument();

    // Check for signup link
    expect(screen.getByText("Don't have an account?")).toBeInTheDocument();
    expect(screen.getByRole("link", { name: "Sign up" })).toHaveAttribute(
      "href",
      "/auth/signup",
    );
  });

  it("handles successful email login", async () => {
    const user = userEvent.setup();
    const { mockUser, mockSession } = createAuthMocks();

    // Setup successful login response
    vi.mocked(auth.signIn.email).mockResolvedValueOnce({
      data: { user: mockUser, session: mockSession },
      error: null,
    });

    render(<LoginForm />);

    // Fill in form
    await user.type(screen.getByLabelText("Email"), "test@example.com");
    await user.type(screen.getByLabelText("Password"), "password123");

    // Submit form
    await user.click(screen.getByRole("button", { name: "Login" }));

    await waitFor(() => {
      // Verify auth client was called
      expect(auth.signIn.email).toHaveBeenCalledWith({
        email: "test@example.com",
        password: "password123",
      });

      // Verify queries were invalidated
      expect(mockInvalidateQueries).toHaveBeenCalledWith({ queryKey: ["user"] });

      // Verify navigation
      expect(mockNavigate).toHaveBeenCalledWith({ to: "/dashboard" });
    });
  });

  it("displays error message on failed login", async () => {
    const user = userEvent.setup();
    const errorMessage = "Invalid email or password";

    // Setup failed login response
    vi.mocked(auth.signIn.email).mockResolvedValueOnce({
      data: null,
      error: {
        message: errorMessage,
      },
    });

    render(<LoginForm />);

    // Fill in form
    await user.type(screen.getByLabelText("Email"), "test@example.com");
    await user.type(screen.getByLabelText("Password"), "wrongpassword");

    // Submit form
    await user.click(screen.getByRole("button", { name: "Login" }));

    await waitFor(() => {
      // Verify error message is displayed
      expect(screen.getByText(errorMessage)).toBeInTheDocument();
    });
  });

  it("disables form during submission", async () => {
    const user = userEvent.setup();

    // Setup delayed login response
    vi.mocked(auth.signIn.email).mockImplementationOnce(() => {
      return new Promise(() => {}); // Never resolves
    });

    render(<LoginForm />);

    // Fill in form
    await user.type(screen.getByLabelText("Email"), "test@example.com");
    await user.type(screen.getByLabelText("Password"), "password123");

    // Submit form
    await user.click(screen.getByRole("button", { name: "Login" }));

    // Check loading state
    expect(screen.getByRole("button", { name: "Logging in..." })).toBeDisabled();
    expect(screen.getByLabelText("Email")).toBeDisabled();
    expect(screen.getByLabelText("Password")).toBeDisabled();

    // Social login button should also be disabled
    expect(screen.getByRole("button", { name: "Login with Google" })).toBeDisabled();
  });

  it("handles Google social login", async () => {
    const user = userEvent.setup();
    const { mockUser } = createAuthMocks();

    vi.mocked(auth.signInWithOAuth).mockResolvedValueOnce({
      redirect: true,
      token: "mock-token",
      url: undefined,
      user: mockUser,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } as any);

    render(<LoginForm />);

    await user.click(screen.getByRole("button", { name: "Login with Google" }));

    expect(auth.signInWithOAuth).toHaveBeenCalledWith(
      {
        provider: "google",
        callbackURL: "/dashboard",
      },
      expect.objectContaining({
        onRequest: expect.any(Function),
        onError: expect.any(Function),
      }),
    );
  });

  it("validates required fields", async () => {
    const user = userEvent.setup();

    render(<LoginForm />);

    // Try to submit empty form
    await user.click(screen.getByRole("button", { name: "Login" }));

    // Auth client should not be called
    expect(auth.signIn.email).not.toHaveBeenCalled();
  });
});
</file>

<file path="src/features/auth/__tests__/signup-with-router.test.tsx">
import userEvent from "@testing-library/user-event";
import { beforeEach, describe, expect, it, vi } from "vitest";
import { auth } from "~/lib/auth-client";
import { renderWithRouter, screen, waitFor } from "~/tests/utils";
import SignupForm from "../components/signup";

// Mock auth client
vi.mock("~/lib/auth-client", () => ({
  auth: {
    signUp: {
      email: vi.fn(),
    },
    signInWithOAuth: vi.fn(),
  },
}));

describe("SignupForm with Router", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("renders signup form with all fields", async () => {
    await renderWithRouter(<SignupForm />);

    expect(screen.getByLabelText("Name")).toBeInTheDocument();
    expect(screen.getByLabelText("Email")).toBeInTheDocument();
    expect(screen.getByLabelText("Password")).toBeInTheDocument();
    expect(screen.getByLabelText("Confirm Password")).toBeInTheDocument();
    expect(screen.getByRole("button", { name: "Sign up" })).toBeInTheDocument();
  });

  it("validates password confirmation", async () => {
    const user = userEvent.setup();

    await renderWithRouter(<SignupForm />);

    // Fill form with mismatched passwords
    await user.type(screen.getByLabelText("Name"), "Test User");
    await user.type(screen.getByLabelText("Email"), "test@example.com");
    await user.type(screen.getByLabelText("Password"), "password123");
    await user.type(screen.getByLabelText("Confirm Password"), "password456");

    await user.click(screen.getByRole("button", { name: "Sign up" }));

    // Should show password mismatch error
    await waitFor(() => {
      expect(screen.getByText(/passwords do not match/i)).toBeInTheDocument();
    });

    // Auth should not be called
    expect(auth.signUp.email).not.toHaveBeenCalled();
  });

  it("handles successful signup", async () => {
    const user = userEvent.setup();

    vi.mocked(auth.signUp.email).mockImplementation((data, handlers) => {
      handlers?.onSuccess?.({ data: { user: {}, session: {} } } as Parameters<
        NonNullable<typeof handlers.onSuccess>
      >[0]);
      return Promise.resolve({ data: { user: {}, session: {} }, error: null });
    });

    const { router } = await renderWithRouter(<SignupForm />);

    // Fill form correctly
    await user.type(screen.getByLabelText("Name"), "New User");
    await user.type(screen.getByLabelText("Email"), "newuser@example.com");
    await user.type(screen.getByLabelText("Password"), "securepassword123");
    await user.type(screen.getByLabelText("Confirm Password"), "securepassword123");

    await user.click(screen.getByRole("button", { name: "Sign up" }));

    await waitFor(() => {
      expect(auth.signUp.email).toHaveBeenCalledWith(
        expect.objectContaining({
          email: "newuser@example.com",
          password: "securepassword123",
          name: "New User",
          callbackURL: "/dashboard",
        }),
      );
    });

    // Verify router exists for navigation
    expect(router).toBeDefined();
  });

  it("displays login link", async () => {
    await renderWithRouter(<SignupForm />);

    const loginLink = screen.getByRole("link", { name: "Login" });
    expect(loginLink).toHaveAttribute("href", "/auth/login");
  });

  it("handles OAuth signup", async () => {
    const user = userEvent.setup();

    vi.mocked(auth.signInWithOAuth).mockResolvedValue(
      {} as ReturnType<typeof auth.signInWithOAuth>,
    );

    await renderWithRouter(<SignupForm />);

    const googleButton = screen.getByRole("button", { name: /sign up with google/i });
    await user.click(googleButton);

    expect(auth.signInWithOAuth).toHaveBeenCalledWith(
      expect.objectContaining({
        provider: "google",
      }),
      expect.any(Object),
    );
  });
});
</file>

<file path="src/features/auth/hooks/useAuthForm.ts">
import { useQueryClient } from "@tanstack/react-query";
import { useNavigate, useRouter } from "@tanstack/react-router";
import { useState } from "react";
import { authQueryKey } from "../auth.queries";

interface UseAuthFormOptions {
  redirectUrl?: string;
}

/**
 * Custom hook for handling authentication form state and navigation
 * Reduces repetitive code in login and signup components
 *
 * @example
 * const { isLoading, errorMessage, handleAuth } = useAuthForm();
 *
 * const onSubmit = async (e) => {
 *   await handleAuth(async () => {
 *     // Your auth logic here
 *   });
 * };
 */
export function useAuthForm(options: UseAuthFormOptions = {}) {
  const { redirectUrl = "/dashboard" } = options;
  const [isLoading, setIsLoading] = useState(false);
  const [errorMessage, setErrorMessage] = useState("");
  const queryClient = useQueryClient();
  const navigate = useNavigate();
  const router = useRouter();

  const handleAuth = async (
    authFunction: () => Promise<void>,
    onError?: (error: unknown) => void,
  ) => {
    setIsLoading(true);
    setErrorMessage("");

    try {
      await authFunction();
      // Success is handled by the auth function's onSuccess callback
    } catch (error) {
      const message = error instanceof Error ? error.message : "Authentication failed";
      setErrorMessage(message);
      onError?.(error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleAuthSuccess = async () => {
    queryClient.invalidateQueries({ queryKey: authQueryKey });
    await router.invalidate();
    navigate({ to: redirectUrl });
  };

  const resetError = () => setErrorMessage("");

  return {
    isLoading,
    errorMessage,
    handleAuth,
    handleAuthSuccess,
    resetError,
    setErrorMessage,
    setIsLoading,
  };
}
</file>

<file path="src/features/auth/index.ts">
// Export auth hooks
export { useAuth, useAuthenticatedUser } from "./hooks/useAuth";

// Export components (default exports)
export { default as Login } from "./components/login";
export { default as Signup } from "./components/signup";

// Route guard utilities are available in ~/lib/auth/guards/route-guards
</file>

<file path="src/features/membership/__tests__/square.webhook.test.ts">
import { beforeEach, describe, expect, it, vi } from "vitest";
import { __squareWebhookTestUtils } from "~/routes/api/webhooks/square";

const sendMembershipPurchaseReceiptMock = vi.fn();
const getEmailServiceMock = vi.fn();

const finalizeMembershipForSessionMock = vi.fn();
const getDbMock = vi.fn();

vi.mock("~/db/server-helpers", () => ({
  getDb: getDbMock,
}));

vi.mock("~/features/membership/membership.finalize", () => ({
  finalizeMembershipForSession: finalizeMembershipForSessionMock,
}));

vi.mock("~/lib/email/sendgrid", () => ({
  sendMembershipPurchaseReceipt: sendMembershipPurchaseReceiptMock,
  getEmailService: getEmailServiceMock,
}));

describe("square webhook helpers", () => {
  let limit: ReturnType<typeof vi.fn>;
  let from: ReturnType<typeof vi.fn>;
  let where: ReturnType<typeof vi.fn>;
  let select: ReturnType<typeof vi.fn>;
  let updateRecords: Array<{ table: unknown; values: unknown }>;
  let update: ReturnType<typeof vi.fn>;

  const sessionBase = {
    id: "session-1",
    userId: "user-1",
    membershipTypeId: "type-1",
    squareCheckoutId: "checkout-1",
    squarePaymentId: "pay-1",
    squareOrderId: "order-1",
    amountCents: 4500,
    currency: "CAD",
    status: "pending" as const,
    metadata: {},
    updatedAt: new Date(),
    createdAt: new Date(),
  };

  const membershipType = {
    id: "type-1",
    name: "Annual Player Membership",
    description: null,
    priceCents: 4500,
    durationMonths: 12,
    status: "active" as const,
    metadata: {},
    createdAt: new Date(),
    updatedAt: new Date(),
  };

  const chainFactory = () => ({
    from,
    where,
    limit,
  });

  beforeEach(() => {
    limit = vi.fn();
    from = vi.fn(() => chainFactory());
    where = vi.fn(() => chainFactory());
    select = vi.fn(() => chainFactory());

    updateRecords = [];
    update = vi.fn((table: unknown) => ({
      set: (values: unknown) => {
        updateRecords.push({ table, values });
        return {
          where: vi.fn(async () => undefined),
        };
      },
    }));

    sendMembershipPurchaseReceiptMock.mockReset();
    getEmailServiceMock.mockReset();
    finalizeMembershipForSessionMock.mockReset();

    getDbMock.mockResolvedValue({
      select,
      update,
    });

    delete process.env["SUPPORT_EMAIL"];
  });

  it("finalizes membership and sends receipt on completed payment", async () => {
    const membershipSession = { ...sessionBase };

    limit
      .mockResolvedValueOnce([membershipSession]) // find session by payment id
      .mockResolvedValueOnce([membershipType]) // fetch membership type
      .mockResolvedValueOnce([{ email: "member@example.com", name: "Jess" }]); // fetch user

    finalizeMembershipForSessionMock.mockResolvedValue({
      membership: {
        id: "membership-1",
        userId: membershipSession.userId,
        membershipTypeId: membershipType.id,
        startDate: "2025-09-20",
        endDate: "2026-09-20",
        status: "active" as const,
        paymentProvider: "square",
        paymentId: "pay-1",
        metadata: {},
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      wasCreated: true,
    });

    await __squareWebhookTestUtils.finalizeMembershipFromWebhook({
      paymentId: "pay-1",
      orderId: "order-1",
      eventType: "payment.updated",
    });

    expect(finalizeMembershipForSessionMock).toHaveBeenCalledWith(
      expect.objectContaining({
        paymentId: "pay-1",
        orderId: "order-1",
      }),
    );

    expect(sendMembershipPurchaseReceiptMock).toHaveBeenCalledWith(
      expect.objectContaining({
        to: expect.objectContaining({ email: "member@example.com" }),
        membershipType: membershipType.name,
      }),
    );

    expect(updateRecords.length).toBeGreaterThanOrEqual(1);
    // With atomic JSONB merge, metadata is a SQL expression, not a plain object
    // Verify the update was called with updatedAt set
    expect(updateRecords.at(-1)?.values).toMatchObject({
      updatedAt: expect.any(Date),
    });
    // Verify metadata field exists (will be SQL expression)
    expect(
      (updateRecords.at(-1)?.values as Record<string, unknown>)?.["metadata"],
    ).toBeDefined();
  });

  it("cancels membership and notifies support on refund", async () => {
    process.env["SUPPORT_EMAIL"] = "ops@example.com";

    const membership = {
      id: "membership-1",
      userId: sessionBase.userId,
      membershipTypeId: membershipType.id,
      startDate: "2025-09-20",
      endDate: "2026-09-20",
      status: "active" as const,
      paymentProvider: "square",
      paymentId: "pay-1",
      metadata: {},
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    limit.mockResolvedValueOnce([membership]);

    const sendSpy = vi.fn();
    getEmailServiceMock.mockResolvedValue({ send: sendSpy });

    await __squareWebhookTestUtils.handleRefundEvent({
      paymentId: "pay-1",
      refundId: "refund-1",
      status: "COMPLETED",
      eventType: "refund.updated",
    });

    expect(updateRecords.length).toBe(1);
    // With atomic JSONB merge, metadata is a SQL expression, not a plain object
    expect(updateRecords[0].values).toMatchObject({
      status: "cancelled",
      updatedAt: expect.any(Date),
    });
    // Verify metadata field exists (will be SQL expression)
    expect(
      (updateRecords[0].values as Record<string, unknown>)?.["metadata"],
    ).toBeDefined();

    expect(getEmailServiceMock).toHaveBeenCalled();
    expect(sendSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        to: { email: "ops@example.com" },
        subject: expect.stringContaining("Membership refund"),
      }),
    );
  });
});
</file>

<file path="src/features/membership/hooks/usePaymentReturn.ts">
import { useMemo } from "react";

export interface PaymentReturnParams {
  isMockCheckout: boolean;
  sessionId: string | null;
  success: boolean;
  error: string | null;
  paymentId: string | null;
  membershipTypeId: string | null;
}

/**
 * Parse payment return parameters from URL without using useEffect
 * This hook extracts payment-related query parameters for processing
 */
export function usePaymentReturn(): PaymentReturnParams {
  return useMemo(() => {
    if (typeof window === "undefined") {
      return {
        isMockCheckout: false,
        sessionId: null,
        success: false,
        error: null,
        paymentId: null,
        membershipTypeId: null,
      };
    }

    const searchParams = new URLSearchParams(window.location.search);

    const parseParam = (value: string | null): string | boolean | null => {
      if (value === null) return null;
      try {
        return JSON.parse(value);
      } catch {
        // If the value isn't JSON-encoded, fall back to the raw string
        return value;
      }
    };

    const asString = (value: string | boolean | null): string | null => {
      if (typeof value === "string") return value;
      if (typeof value === "boolean") return value ? "true" : "false";
      return null;
    };

    const successRaw = parseParam(searchParams.get("success"));
    const paymentIdRaw = parseParam(searchParams.get("payment_id"));
    const sessionRaw = parseParam(searchParams.get("session"));
    const typeRaw = parseParam(searchParams.get("type"));
    const errorRaw = parseParam(searchParams.get("error"));
    const mockCheckoutRaw = parseParam(searchParams.get("mock_checkout"));

    return {
      isMockCheckout: mockCheckoutRaw === true || mockCheckoutRaw === "true",
      sessionId: asString(sessionRaw),
      success: successRaw === true || successRaw === "true",
      error: asString(errorRaw),
      paymentId: asString(paymentIdRaw),
      membershipTypeId: asString(typeRaw),
    };
  }, []); // Empty deps since URL doesn't change after mount
}

/**
 * Get appropriate error message for payment errors
 */
export function getPaymentErrorMessage(error: string | null): string | null {
  if (!error) return null;

  const errorMessages: Record<string, string> = {
    cancelled: "Payment was cancelled",
    verification_failed: "Payment verification failed",
    processing_error: "An error occurred while processing your payment",
  };

  return errorMessages[error] || "Payment failed";
}

/**
 * Clear payment-related query parameters from URL
 */
export function clearPaymentParams(): void {
  if (typeof window !== "undefined") {
    window.history.replaceState({}, document.title, window.location.pathname);
  }
}
</file>

<file path="src/features/membership/membership.db-types.ts">
/**
 * Type definitions for membership database jsonb fields
 */

/* eslint-disable @typescript-eslint/no-explicit-any */

export interface MembershipMetadata {
  [key: string]: any;
  paymentDetails?: Record<string, any>;
  notes?: string;
}
</file>

<file path="src/features/membership/membership.finalize.ts">
import { eq } from "drizzle-orm";
import type {
  Membership,
  MembershipPaymentSession,
  MembershipType,
} from "~/db/schema/membership.schema";
import { membershipPaymentSessions, memberships } from "~/db/schema/membership.schema";
import type { getDb } from "~/db/server-helpers";
import { atomicJsonbMerge } from "~/lib/db/jsonb-utils";

export type MembershipPaymentSessionRow = MembershipPaymentSession;
export type MembershipTypeRow = MembershipType;
export type MembershipRow = Membership;

export type MembershipDbClient = Awaited<ReturnType<typeof getDb>>;

export interface FinalizeMembershipParams {
  db: MembershipDbClient;
  paymentSession: MembershipPaymentSessionRow;
  membershipType: MembershipTypeRow;
  paymentId: string;
  orderId?: string | null;
  sessionId: string;
  now: Date;
}

export interface FinalizeMembershipResult {
  membership: MembershipRow;
  wasCreated: boolean;
}

export async function finalizeMembershipForSession({
  db,
  paymentSession,
  membershipType,
  paymentId,
  orderId,
  sessionId,
  now,
}: FinalizeMembershipParams): Promise<FinalizeMembershipResult> {
  const nowIso = now.toISOString();
  const resolvedOrderId = orderId ?? paymentSession.squareOrderId ?? null;

  return db.transaction(async (tx) => {
    const [existingMembershipByPayment] = await tx
      .select()
      .from(memberships)
      .where(eq(memberships.paymentId, paymentId))
      .limit(1);

    if (existingMembershipByPayment) {
      await tx
        .update(membershipPaymentSessions)
        .set({
          status: "completed",
          squarePaymentId: paymentId,
          squareOrderId: resolvedOrderId,
          metadata: atomicJsonbMerge(membershipPaymentSessions.metadata, {
            membershipId: existingMembershipByPayment.id,
            paymentConfirmedAt: nowIso,
            squareOrderId: resolvedOrderId,
            squareTransactionId: paymentId,
          }),
          updatedAt: now,
        })
        .where(eq(membershipPaymentSessions.id, paymentSession.id));

      return {
        membership: existingMembershipByPayment,
        wasCreated: false,
      } satisfies FinalizeMembershipResult;
    }

    const startDate = new Date(now);
    const endDate = new Date(now);
    endDate.setMonth(endDate.getMonth() + membershipType.durationMonths);

    const membershipMetadata: Record<string, unknown> = {
      ...(paymentSession.metadata ?? {}),
      sessionId,
      purchasedAt: nowIso,
      squareTransactionId: paymentId,
    };

    if (resolvedOrderId) {
      membershipMetadata["squareOrderId"] = resolvedOrderId;
    }

    const [newMembership] = await tx
      .insert(memberships)
      .values({
        userId: paymentSession.userId,
        membershipTypeId: membershipType.id,
        startDate: startDate.toISOString().split("T")[0],
        endDate: endDate.toISOString().split("T")[0],
        status: "active",
        paymentProvider: "square",
        paymentId,
        metadata: membershipMetadata,
      })
      .returning();

    await tx
      .update(membershipPaymentSessions)
      .set({
        status: "completed",
        squarePaymentId: paymentId,
        squareOrderId: resolvedOrderId,
        metadata: atomicJsonbMerge(membershipPaymentSessions.metadata, {
          membershipId: newMembership.id,
          paymentConfirmedAt: nowIso,
          squareOrderId: resolvedOrderId,
          squareTransactionId: paymentId,
        }),
        updatedAt: now,
      })
      .where(eq(membershipPaymentSessions.id, paymentSession.id));

    return {
      membership: newMembership,
      wasCreated: true,
    } satisfies FinalizeMembershipResult;
  });
}
</file>

<file path="src/features/membership/membership.schemas.ts">
import { z } from "zod";

// Query schemas
export const getMembershipTypeSchema = z.object({
  membershipTypeId: z.string(),
});
export type GetMembershipTypeInput = z.infer<typeof getMembershipTypeSchema>;

// Mutation schemas
export const purchaseMembershipSchema = z.object({
  membershipTypeId: z.string(),
  autoRenew: z.boolean().prefault(false),
});
export type PurchaseMembershipInput = z.infer<typeof purchaseMembershipSchema>;

export const cancelMembershipSchema = z.object({
  membershipId: z.string(),
  reason: z.string().optional(),
  immediate: z.boolean().prefault(false),
});
export type CancelMembershipInput = z.infer<typeof cancelMembershipSchema>;

export const confirmMembershipPurchaseSchema = z.object({
  membershipTypeId: z.string(),
  sessionId: z.string(),
  paymentId: z.string().optional(),
});
export type ConfirmMembershipPurchaseInput = z.infer<
  typeof confirmMembershipPurchaseSchema
>;
</file>

<file path="src/features/membership/membership.types.ts">
// Define types manually since we can't import from schema at top level
import type { MembershipMetadata } from "./membership.db-types";
export interface MembershipType {
  id: string;
  name: string;
  description: string | null;
  priceCents: number;
  durationMonths: number;
  status: "active" | "inactive";
  metadata: MembershipMetadata | null;
  createdAt: Date;
  updatedAt: Date;
}

export interface Membership {
  id: string;
  userId: string;
  membershipTypeId: string;
  /** ISO date string (YYYY-MM-DD) from database date column */
  startDate: string;
  /** ISO date string (YYYY-MM-DD) from database date column */
  endDate: string;
  status: "active" | "cancelled" | "expired";
  paymentId: string | null;
  metadata: MembershipMetadata | null;
  createdAt: Date;
  updatedAt: Date;
}

export interface MembershipOperationResult<T = unknown> {
  success: boolean;
  data?: T;
  errors?: Array<{
    code: "VALIDATION_ERROR" | "DATABASE_ERROR" | "PAYMENT_ERROR" | "NOT_FOUND";
    field?: string;
    message: string;
  }>;
}

export interface CheckoutSessionResult {
  checkoutUrl: string;
  sessionId: string;
}

export interface MembershipPurchaseInput {
  membershipTypeId: string;
  sessionId: string;
  paymentId?: string;
}

export interface UserMembership extends Membership {
  membershipType: MembershipType;
}

export interface MembershipStatus {
  hasMembership: boolean;
  currentMembership?: UserMembership;
  expiresAt?: Date;
  daysRemaining?: number;
}
</file>

<file path="src/features/roles/permission.server.ts">
import { createServerOnlyFn } from "@tanstack/react-start";
import { and, eq, inArray } from "drizzle-orm";
import { roles, userRoles } from "~/db/schema";

/**
 * Server-side permission service
 * All methods here use database queries and should only be called on the server
 */
export class PermissionService {
  /**
   * Check if a user has global admin permissions
   */
  static isGlobalAdmin = createServerOnlyFn(async (userId: string): Promise<boolean> => {
    const { getDb } = await import("~/db/server-helpers");
    const db = await getDb();

    const [row] = await db
      .select()
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(
        and(
          eq(userRoles.userId, userId),
          inArray(roles.name, ["Solstice Admin", "Quadball Canada Admin"]),
        ),
      )
      .limit(1);

    return !!row;
  });

  /**
   * Check if a user can manage a specific team
   */
  static canManageTeam = createServerOnlyFn(
    async (userId: string, teamId: string): Promise<boolean> => {
      // Global admins can manage any team
      if (await PermissionService.isGlobalAdmin(userId)) return true;

      const { getDb } = await import("~/db/server-helpers");
      const db = await getDb();

      // Check for team-specific admin role
      const [row] = await db
        .select()
        .from(userRoles)
        .innerJoin(roles, eq(userRoles.roleId, roles.id))
        .where(
          and(
            eq(userRoles.userId, userId),
            eq(roles.name, "Team Admin"),
            eq(userRoles.teamId, teamId),
          ),
        )
        .limit(1);

      return !!row;
    },
  );

  /**
   * Check if a user can manage a specific event
   */
  static canManageEvent = createServerOnlyFn(
    async (userId: string, eventId: string): Promise<boolean> => {
      // Global admins can manage any event
      if (await PermissionService.isGlobalAdmin(userId)) return true;

      const { getDb } = await import("~/db/server-helpers");
      const db = await getDb();

      // Check for event-specific admin role
      const [row] = await db
        .select()
        .from(userRoles)
        .innerJoin(roles, eq(userRoles.roleId, roles.id))
        .where(
          and(
            eq(userRoles.userId, userId),
            eq(roles.name, "Event Admin"),
            eq(userRoles.eventId, eventId),
          ),
        )
        .limit(1);

      return !!row;
    },
  );

  /**
   * Get all roles for a user including scope information
   */
  static getUserRoles = createServerOnlyFn(async (userId: string) => {
    const { getDb } = await import("~/db/server-helpers");
    const db = await getDb();

    const userRolesList = await db
      .select({
        id: userRoles.id,
        userId: userRoles.userId,
        roleId: userRoles.roleId,
        teamId: userRoles.teamId,
        eventId: userRoles.eventId,
        assignedBy: userRoles.assignedBy,
        assignedAt: userRoles.assignedAt,
        expiresAt: userRoles.expiresAt,
        notes: userRoles.notes,
        role: {
          id: roles.id,
          name: roles.name,
          description: roles.description,
          permissions: roles.permissions,
        },
      })
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(eq(userRoles.userId, userId));

    return userRolesList;
  });
}
</file>

<file path="src/features/roles/permission.service.ts">
import { and, eq, inArray } from "drizzle-orm";
import { roles, userRoles } from "~/db/schema";

export class PermissionService {
  /**
   * Check if a user has global admin permissions
   */
  static async isGlobalAdmin(userId: string): Promise<boolean> {
    const { db } = await import("~/db");
    const database = await db();
    const [row] = await database
      .select()
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(
        and(
          eq(userRoles.userId, userId),
          inArray(roles.name, ["Solstice Admin", "Quadball Canada Admin"]),
        ),
      )
      .limit(1);

    return !!row;
  }

  /**
   * Check if a user can manage a specific team
   */
  static async canManageTeam(userId: string, teamId: string): Promise<boolean> {
    // Global admins can manage any team
    if (await this.isGlobalAdmin(userId)) return true;

    // Check for team-specific admin role
    const { db } = await import("~/db");
    const database = await db();
    const [row] = await database
      .select()
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(
        and(
          eq(userRoles.userId, userId),
          eq(roles.name, "Team Admin"),
          eq(userRoles.teamId, teamId),
        ),
      )
      .limit(1);

    return !!row;
  }

  /**
   * Check if a user can manage a specific event
   */
  static async canManageEvent(userId: string, eventId: string): Promise<boolean> {
    // Global admins can manage any event
    if (await this.isGlobalAdmin(userId)) return true;

    // Check for event-specific admin role
    const { db } = await import("~/db");
    const database = await db();
    const [row] = await database
      .select()
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(
        and(
          eq(userRoles.userId, userId),
          eq(roles.name, "Event Admin"),
          eq(userRoles.eventId, eventId),
        ),
      )
      .limit(1);

    return !!row;
  }

  /**
   * Get all roles for a user including scope information
   */
  static async getUserRoles(userId: string) {
    const { db } = await import("~/db");
    const database = await db();
    const userRolesList = await database
      .select({
        id: userRoles.id,
        userId: userRoles.userId,
        roleId: userRoles.roleId,
        teamId: userRoles.teamId,
        eventId: userRoles.eventId,
        assignedBy: userRoles.assignedBy,
        assignedAt: userRoles.assignedAt,
        expiresAt: userRoles.expiresAt,
        notes: userRoles.notes,
        role: {
          id: roles.id,
          name: roles.name,
          description: roles.description,
          permissions: roles.permissions,
        },
      })
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(eq(userRoles.userId, userId));

    return userRolesList;
  }
}

/**
 * Client-side helper to check if a user has a specific role
 * This is for UI display purposes only - actual authorization happens server-side
 */
export function userHasRole(
  user: {
    roles?: Array<{
      role: { name: string };
      teamId?: string | null;
      eventId?: string | null;
    }>;
  },
  roleName: string,
  options?: { teamId?: string; eventId?: string },
): boolean {
  if (!user.roles) return false;

  return user.roles.some((userRole) => {
    if (userRole.role.name !== roleName) return false;

    // For global roles
    if (!options?.teamId && !options?.eventId) {
      return !userRole.teamId && !userRole.eventId;
    }

    // For team-specific roles
    if (options.teamId) {
      return userRole.teamId === options.teamId;
    }

    // For event-specific roles
    if (options.eventId) {
      return userRole.eventId === options.eventId;
    }

    return false;
  });
}

/**
 * Client-side helper to check if user is any kind of admin
 */
export function isAnyAdmin(user: { roles?: Array<{ role: { name: string } }> }): boolean {
  if (!user.roles) return false;

  return user.roles.some((userRole) =>
    ["Solstice Admin", "Quadball Canada Admin", "Team Admin", "Event Admin"].includes(
      userRole.role.name,
    ),
  );
}
</file>

<file path="netlify/edge-functions/security-headers.ts">
import type { Config, Context } from "@netlify/edge-functions";

export default async function handler(req: Request, context: Context) {
  const response = await context.next();

  // Generate a nonce for CSP (may be replaced with one from HTML)
  let nonce: string = crypto.randomUUID();

  // Determine if we're in development
  const url = new URL(req.url);
  const isDevelopment = url.hostname === "localhost" || url.hostname === "127.0.0.1";

  const buildHeaders = (nonceValue: string) => ({
    "Content-Security-Policy": [
      "default-src 'self'",
      `script-src 'self' 'nonce-${nonceValue}' 'sha256-NatFdn9qa3ivEDVSUujTj3/04jf+6XsuTh7hTdyWQdE=' 'sha256-KlDLetaHs3jydugAFrZVquz1h6i4vHS3ohIh0sfZqC4=' 'sha256-5JedoFHPMD1o/9fNxPf7aN8DGXTYs9UJC2bTfRPBFxY=' 'sha256-gHUVPg/ygmuHop+u65qJwyip1pg0/k2Ch2Va8wmwlgY=' https://challenges.cloudflare.com`,
      "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com",
      "font-src 'self' https://fonts.gstatic.com",
      "img-src 'self' data: https: blob:",
      `connect-src 'self' ${isDevelopment ? "ws://localhost:*" : ""} https://accounts.google.com https://www.googleapis.com`,
      "frame-src 'self' https://challenges.cloudflare.com",
      "object-src 'none'",
      "base-uri 'self'",
      "form-action 'self'",
      "frame-ancestors 'none'",
      "upgrade-insecure-requests",
    ].join("; "),
    "X-Frame-Options": "DENY",
    "X-Content-Type-Options": "nosniff",
    "Referrer-Policy": "strict-origin-when-cross-origin",
    "Permissions-Policy": "geolocation=(), microphone=(), camera=()",
    "Strict-Transport-Security": "max-age=31536000; includeSubDomains; preload",
    "X-XSS-Protection": "1; mode=block", // Deprecated, but good for older browsers
  });

  const contentType = response.headers.get("content-type");
  const isHtml = contentType?.includes("text/html");

  // If not HTML, clone response and add headers
  if (!isHtml) {
    const newResponse = new Response(response.body, response);
    const headers = buildHeaders(nonce);
    Object.entries(headers).forEach(([key, value]) => {
      newResponse.headers.set(key, value);
    });
    newResponse.headers.delete("X-Powered-By");
    return newResponse;
  }

  // For HTML responses, read the body, reuse existing nonce if present, and inject if missing
  const text = await response.text();
  const nonceMatch =
    text.match(/<meta[^>]+property=["']csp-nonce["'][^>]+content=["']([^"']+)["']/i) ??
    text.match(/<script[^>]+nonce=["']([^"']+)["']/i);

  if (nonceMatch?.[1]) {
    nonce = nonceMatch[1];
  }

  const modifiedHtml = text.replace(
    /<script(?![^>]*\snonce=)/g,
    `<script nonce="${nonce}"`,
  );

  const newResponse = new Response(modifiedHtml, {
    status: response.status,
    statusText: response.statusText,
    headers: response.headers,
  });

  const headers = buildHeaders(nonce);
  Object.entries(headers).forEach(([key, value]) => {
    newResponse.headers.set(key, value);
  });
  newResponse.headers.delete("X-Powered-By");

  return newResponse;
}

export const config: Config = {
  path: "/*",
};
</file>

<file path="src/db/schema/membership.schema.ts">
import { createId } from "@paralleldrive/cuid2";
import { sql } from "drizzle-orm";
import {
  date,
  index,
  integer,
  jsonb,
  pgTable,
  timestamp,
  uniqueIndex,
  varchar,
} from "drizzle-orm/pg-core";
import { user } from "./auth.schema";

export const membershipTypes = pgTable(
  "membership_types",
  {
    id: varchar("id", { length: 255 })
      .$defaultFn(() => createId())
      .primaryKey(),
    name: varchar("name", { length: 255 }).notNull(),
    description: varchar("description", { length: 1000 }),
    priceCents: integer("price_cents").notNull(),
    durationMonths: integer("duration_months").notNull(),
    status: varchar("status", { length: 50 })
      .$type<"active" | "inactive">()
      .notNull()
      .default("active"),
    metadata: jsonb("metadata").$type<Record<string, unknown>>(),
    createdAt: timestamp("created_at").notNull().defaultNow(),
    updatedAt: timestamp("updated_at").notNull().defaultNow(),
  },
  (table) => [index("membership_types_status_idx").on(table.status)],
);

export const memberships = pgTable(
  "memberships",
  {
    id: varchar("id", { length: 255 })
      .$defaultFn(() => createId())
      .primaryKey(),
    userId: varchar("user_id", { length: 255 })
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    membershipTypeId: varchar("membership_type_id", { length: 255 })
      .notNull()
      .references(() => membershipTypes.id),
    startDate: date("start_date").notNull(),
    endDate: date("end_date").notNull(),
    status: varchar("status", { length: 50 })
      .$type<"active" | "expired" | "cancelled">()
      .notNull()
      .default("active"),
    paymentProvider: varchar("payment_provider", { length: 100 }),
    paymentId: varchar("payment_id", { length: 255 }),
    metadata: jsonb("metadata").$type<{
      paymentDetails?: Record<string, unknown>;
      notes?: string;
      [key: string]: unknown;
    }>(),
    createdAt: timestamp("created_at").notNull().defaultNow(),
    updatedAt: timestamp("updated_at").notNull().defaultNow(),
  },
  (table) => [
    index("memberships_user_id_idx").on(table.userId),
    index("memberships_status_idx").on(table.status),
    index("memberships_end_date_idx").on(table.endDate),
    index("memberships_payment_id_idx").on(table.paymentId),
    // Prevent duplicate payments - unique on (provider, paymentId) when paymentId exists
    // This allows multiple NULL paymentIds but prevents replay attacks
    uniqueIndex("memberships_payment_provider_id_unique")
      .on(table.paymentProvider, table.paymentId)
      .where(sql`${table.paymentId} IS NOT NULL`),
  ],
);

export const membershipPaymentSessions = pgTable(
  "membership_payment_sessions",
  {
    id: varchar("id", { length: 255 })
      .$defaultFn(() => createId())
      .primaryKey(),
    userId: varchar("user_id", { length: 255 })
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    membershipTypeId: varchar("membership_type_id", { length: 255 })
      .notNull()
      .references(() => membershipTypes.id),
    squareCheckoutId: varchar("square_checkout_id", { length: 255 }).notNull(),
    squarePaymentLinkUrl: varchar("square_payment_link_url", { length: 2048 }).notNull(),
    squareOrderId: varchar("square_order_id", { length: 255 }),
    squarePaymentId: varchar("square_payment_id", { length: 255 }),
    status: varchar("status", { length: 50 })
      .$type<"pending" | "completed" | "cancelled" | "failed">()
      .notNull()
      .default("pending"),
    amountCents: integer("amount_cents").notNull(),
    currency: varchar("currency", { length: 10 }).notNull().default("CAD"),
    expiresAt: timestamp("expires_at"),
    metadata: jsonb("metadata").$type<Record<string, unknown>>(),
    createdAt: timestamp("created_at").notNull().defaultNow(),
    updatedAt: timestamp("updated_at").notNull().defaultNow(),
  },
  (table) => [
    index("membership_payment_sessions_user_idx").on(table.userId),
    uniqueIndex("membership_payment_sessions_checkout_idx").on(table.squareCheckoutId),
    index("membership_payment_sessions_order_idx").on(table.squareOrderId),
    index("membership_payment_sessions_payment_idx").on(table.squarePaymentId),
    index("membership_payment_sessions_type_idx").on(table.membershipTypeId),
  ],
);

// Export inferred types
export type MembershipType = typeof membershipTypes.$inferSelect;
export type NewMembershipType = typeof membershipTypes.$inferInsert;
export type Membership = typeof memberships.$inferSelect;
export type NewMembership = typeof memberships.$inferInsert;
export type MembershipPaymentSession = typeof membershipPaymentSessions.$inferSelect;
export type NewMembershipPaymentSession = typeof membershipPaymentSessions.$inferInsert;
</file>

<file path="src/db/connections.ts">
import { Pool, neonConfig } from "@neondatabase/serverless";
import { createServerOnlyFn } from "@tanstack/react-start";
import { drizzle as drizzleNeon } from "drizzle-orm/neon-serverless";
import { drizzle as drizzlePostgres } from "drizzle-orm/postgres-js";
import postgres from "postgres";
import * as schema from "./schema";

// Singleton instances
let pooledInstance: ReturnType<typeof drizzleNeon> | null = null;
let unpooledInstance: ReturnType<typeof drizzlePostgres> | null = null;
let poolInstance: Pool | null = null;
let sqlInstance: ReturnType<typeof postgres> | null = null;

/**
 * Pooled database connection using Neon's serverless driver.
 *
 * Uses DATABASE_URL (pooled) or NETLIFY_DATABASE_URL for serverless functions.
 * This connection goes through Neon's connection pooler for efficient
 * concurrent request handling.
 *
 * Use this for:
 * - API routes and serverless functions
 * - Short-lived queries
 * - High-concurrency scenarios
 */
export const pooledDb = createServerOnlyFn(async () => {
  // Return existing instance if available
  if (pooledInstance) {
    return pooledInstance;
  }

  const { getPooledDbUrl, isServerless } = await import("../lib/env.server");

  // Configure Neon for serverless environments
  if (isServerless()) {
    neonConfig.useSecureWebSocket = true;
    neonConfig.poolQueryViaFetch = true;
  }

  const connectionString = getPooledDbUrl();

  poolInstance = new Pool({ connectionString });
  pooledInstance = drizzleNeon({
    client: poolInstance,
    schema,
    casing: "snake_case",
  });

  return pooledInstance;
});

/**
 * Unpooled (direct) database connection using standard postgres driver.
 *
 * Uses DATABASE_URL_UNPOOLED or NETLIFY_DATABASE_URL_UNPOOLED for
 * migrations and long operations. This creates a direct connection
 * to the database without going through the pooler.
 *
 * Use this for:
 * - Database migrations
 * - Long-running operations
 * - Batch imports/exports
 * - Operations requiring session-level features
 */
export const unpooledDb = createServerOnlyFn(async () => {
  // Return existing instance if available
  if (unpooledInstance) {
    return unpooledInstance;
  }

  const { getUnpooledDbUrl } = await import("../lib/env.server");
  const connectionString = getUnpooledDbUrl();

  // Set a reasonable connection pool size
  sqlInstance = postgres(connectionString, {
    max: 10, // Maximum number of connections in the pool
    idle_timeout: 20, // Close idle connections after 20 seconds
    connect_timeout: 10, // Connection timeout
  });

  unpooledInstance = drizzlePostgres({
    client: sqlInstance,
    schema,
    casing: "snake_case",
  });

  return unpooledInstance;
});

/**
 * Returns the appropriate database connection based on the environment.
 *
 * - In serverless environments (Netlify/Vercel): Uses pooled connection
 * - In development or traditional servers: Uses unpooled connection
 *
 * This is the recommended export for most use cases as it automatically
 * selects the optimal connection type.
 */
export const getDb = createServerOnlyFn(async () => {
  const { isServerless } = await import("../lib/env.server");
  if (isServerless()) {
    console.log("Using pooled connection for serverless environment");
    return await pooledDb();
  } else {
    console.log("Using unpooled connection for traditional environment");
    return await unpooledDb();
  }
});

/**
 * Cleanup function to close all database connections
 * Should be called when shutting down the server
 */
export const closeConnections = createServerOnlyFn(async () => {
  const promises: Promise<void>[] = [];

  if (poolInstance) {
    promises.push(poolInstance.end());
    poolInstance = null;
    pooledInstance = null;
  }

  if (sqlInstance) {
    promises.push(sqlInstance.end({ timeout: 3 }));
    sqlInstance = null;
    unpooledInstance = null;
  }

  await Promise.all(promises);
  console.log("Database connections closed");
});
</file>

<file path="src/lib/auth/middleware/auth-guard.ts">
import { createMiddleware } from "@tanstack/react-start";
import { getRequest, setResponseStatus } from "@tanstack/react-start/server";

import type { AuthUser } from "~/lib/auth/types";

export type AuthedRequestContext = {
  user: NonNullable<AuthUser>;
};

/**
 * Middleware to force authentication on a server function, and add the user to the context.
 */
export const authMiddleware = createMiddleware({ type: "function" }).server(
  async ({ next }) => {
    const { getAuth } = await import("~/lib/auth/server-helpers");
    const auth = await getAuth();
    const headers = getRequest().headers;

    const session = await auth.api.getSession({
      headers,
      query: {
        disableCookieCache: true,
      },
    });

    const user = session?.user;

    if (!user) {
      setResponseStatus(401);
      const { unauthorized } = await import("~/lib/server/errors");
      throw unauthorized();
    }

    const context: AuthedRequestContext = { user: user as NonNullable<AuthUser> };

    return next({ context });
  },
);
</file>

<file path="src/lib/auth/middleware/role-guard.ts">
import { redirect } from "@tanstack/react-router";
import { userHasRole } from "~/features/roles/permission.service";
import type { User } from "~/lib/auth/types";
import { isAdminClient } from "~/lib/auth/utils/admin-check";

interface RoleGuardOptions {
  user: User | null;
  requiredRoles?: string[];
  teamId?: string;
  eventId?: string;
  redirectTo?: string;
}

/**
 * Role-based access control guard for routes
 * Use this in route beforeLoad to protect pages based on user roles
 */
export async function requireRole({
  user,
  requiredRoles,
  teamId,
  eventId,
  redirectTo = "/dashboard",
}: RoleGuardOptions) {
  if (!user) {
    throw redirect({ to: "/auth/login" });
  }

  if (!requiredRoles || requiredRoles.length === 0) {
    return;
  }

  const hasAccess = requiredRoles.some((roleName) => {
    if (roleName === "Team Admin" && teamId) {
      return userHasRole(user, roleName, { teamId });
    }

    if (roleName === "Event Admin" && eventId) {
      return userHasRole(user, roleName, { eventId });
    }

    return userHasRole(user, roleName);
  });

  if (!hasAccess) {
    throw redirect({ to: redirectTo });
  }
}

/**
 * Convenience function for requiring global admin access
 */
export async function requireGlobalAdmin(user: User | null, redirectTo = "/dashboard") {
  if (!user) {
    throw redirect({ to: "/auth/login" });
  }

  if (!isAdminClient(user)) {
    throw redirect({ to: redirectTo });
  }
}
</file>

<file path="src/lib/auth/utils/admin-check.ts">
import { createServerOnlyFn } from "@tanstack/react-start";
import type { AuthUser } from "~/lib/auth/types";

const GLOBAL_ADMIN_ROLE_NAMES = ["Solstice Admin", "Quadball Canada Admin"];

const getPermissionService = createServerOnlyFn(async () => {
  const { PermissionService } = await import("~/features/roles/permission.service");
  return PermissionService;
});

function hasGlobalAdminRole(user: AuthUser): boolean {
  if (!user?.roles || user.roles.length === 0) {
    return false;
  }

  return user.roles.some(({ role }) => GLOBAL_ADMIN_ROLE_NAMES.includes(role.name));
}

export async function isAdmin(userId: string | undefined | null): Promise<boolean> {
  if (!userId) return false;
  const PermissionService = await getPermissionService();
  return PermissionService.isGlobalAdmin(userId);
}

export async function requireAdmin(userId: string | undefined | null): Promise<void> {
  if (!(await isAdmin(userId))) {
    throw new Error("Unauthorized: Admin access required");
  }
}

export function isAdminClient(user: AuthUser): boolean {
  return hasGlobalAdminRole(user);
}

export { GLOBAL_ADMIN_ROLE_NAMES };
</file>

<file path="src/routes/api/auth/$action/$provider.ts">
import { createFileRoute } from "@tanstack/react-router";
import { getAuth } from "~/lib/auth/server-helpers";

export const Route = createFileRoute("/api/auth/$action/$provider")({
  server: {
    handlers: {
      GET: async ({ request }) => {
        const auth = await getAuth();
        return await auth.handler(request);
      },
      POST: async ({ request }) => {
        const auth = await getAuth();
        return await auth.handler(request);
      },
    },
  },
});
</file>

<file path="src/routes/api/auth/$.ts">
import { createFileRoute } from "@tanstack/react-router";
import { getAuth } from "~/lib/auth/server-helpers";

export const Route = createFileRoute("/api/auth/$")({
  server: {
    handlers: {
      GET: async ({ request }) => {
        const auth = await getAuth();
        return await auth.handler(request);
      },
      POST: async ({ request }) => {
        const auth = await getAuth();
        return await auth.handler(request);
      },
      OPTIONS: async ({ request }) => {
        const auth = await getAuth();
        return await auth.handler(request);
      },
    },
  },
});
</file>

<file path="src/routes/auth/route.tsx">
import { createFileRoute, Outlet } from "@tanstack/react-router";
import { redirectIfAuthenticated } from "~/lib/auth/guards/route-guards";

export const Route = createFileRoute("/auth")({
  component: RouteComponent,
  beforeLoad: async ({ context }) => {
    redirectIfAuthenticated({ user: context.user });
  },
});

function RouteComponent() {
  return (
    <div className="bg-background flex min-h-screen flex-col">
      <main className="flex flex-1 flex-col items-center justify-center gap-6 p-6 md:p-10">
        <div className="w-full max-w-sm">
          <Outlet />
        </div>
      </main>
    </div>
  );
}
</file>

<file path="src/db/schema/events.schema.ts">
import { createId } from "@paralleldrive/cuid2";
import { relations } from "drizzle-orm";
import {
  boolean,
  date,
  index,
  integer,
  jsonb,
  pgEnum,
  pgTable,
  text,
  timestamp,
  uniqueIndex,
  uuid,
  varchar,
} from "drizzle-orm/pg-core";
import { createInsertSchema, createSelectSchema } from "drizzle-zod";
import { z } from "zod";
import { user } from "./auth.schema";
import { teams } from "./teams.schema";

/**
 * Event status enum
 */
export const eventStatusEnum = pgEnum("event_status", [
  "draft", // Event is being planned, not visible in listings
  "published", // Event is visible but registration not open
  "registration_open", // Teams can register
  "registration_closed", // No more registrations
  "in_progress", // Event is currently happening
  "completed", // Event finished
  "cancelled", // Event was cancelled
]);

/**
 * Event type enum
 */
export const eventTypeEnum = pgEnum("event_type", [
  "tournament", // Competitive tournament
  "league", // League play
  "camp", // Training camp
  "clinic", // Skills clinic
  "social", // Social/fun event
  "other", // Other type
]);

/**
 * Registration type enum
 */
export const registrationTypeEnum = pgEnum("registration_type", [
  "team", // Teams register together
  "individual", // Individuals register and are assigned to teams
  "both", // Supports both team and individual registration
]);

/**
 * Main events table
 */
export const events = pgTable("events", {
  id: uuid("id").primaryKey().defaultRandom(),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),

  // Basic information
  name: varchar("name", { length: 255 }).notNull(),
  slug: varchar("slug", { length: 255 }).notNull().unique(), // URL-friendly identifier
  description: text("description"),
  shortDescription: varchar("short_description", { length: 500 }), // For cards/previews

  // Event details
  type: eventTypeEnum("type").notNull().default("tournament"),
  status: eventStatusEnum("status").notNull().default("draft"),

  // Location
  venueName: varchar("venue_name", { length: 255 }),
  venueAddress: text("venue_address"),
  city: varchar("city", { length: 100 }),
  province: varchar("province", { length: 50 }),
  postalCode: varchar("postal_code", { length: 10 }),
  locationNotes: text("location_notes"), // Parking info, directions, etc.

  // Dates and times
  startDate: date("start_date").notNull(),
  endDate: date("end_date").notNull(),
  registrationOpensAt: timestamp("registration_opens_at"),
  registrationClosesAt: timestamp("registration_closes_at"),

  // Registration settings
  registrationType: registrationTypeEnum("registration_type").notNull().default("team"),
  maxTeams: integer("max_teams"),
  maxParticipants: integer("max_participants"),
  minPlayersPerTeam: integer("min_players_per_team").default(7),
  maxPlayersPerTeam: integer("max_players_per_team").default(21),

  // Pricing (in cents)
  teamRegistrationFee: integer("team_registration_fee").default(0),
  individualRegistrationFee: integer("individual_registration_fee").default(0),
  earlyBirdDiscount: integer("early_bird_discount").default(0), // Percentage
  earlyBirdDeadline: timestamp("early_bird_deadline"),

  // Contact information
  organizerId: text("organizer_id")
    .notNull()
    .references(() => user.id),
  contactEmail: varchar("contact_email", { length: 255 }),
  contactPhone: varchar("contact_phone", { length: 20 }),

  // Additional data
  rules: jsonb("rules"), // Custom rules/modifications
  schedule: jsonb("schedule"), // Detailed schedule info
  divisions: jsonb("divisions"), // e.g. [{name: "Competitive", maxTeams: 8}, {name: "Recreational", maxTeams: 12}]
  amenities: jsonb("amenities"), // ["parking", "concessions", "livestream", etc.]
  requirements: jsonb("requirements"), // ["valid membership", "insurance", etc.]

  // Media
  logoUrl: text("logo_url"),
  bannerUrl: text("banner_url"),

  // Metadata
  metadata: jsonb("metadata"), // Flexible field for additional data
  allowEtransfer: boolean("allow_etransfer").notNull().default(false),
  etransferInstructions: text("etransfer_instructions"),
  etransferRecipient: varchar("etransfer_recipient", { length: 255 }),
});

/**
 * Event registrations table - tracks team/individual registrations for events
 */
export const eventRegistrations = pgTable("event_registrations", {
  id: uuid("id").primaryKey().defaultRandom(),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),

  // References
  eventId: uuid("event_id")
    .notNull()
    .references(() => events.id),
  teamId: text("team_id").references(() => teams.id), // Null for individual registrations
  userId: text("user_id")
    .notNull()
    .references(() => user.id), // Who registered

  // Registration details
  registrationType: registrationTypeEnum("registration_type").notNull(),
  division: varchar("division", { length: 100 }), // Which division they're in

  // Status
  status: varchar("status", { length: 50 }).notNull().default("pending"), // pending, confirmed, waitlisted, cancelled
  paymentStatus: varchar("payment_status", { length: 50 }).notNull().default("pending"), // pending, paid, refunded
  paymentId: text("payment_id"), // Reference to payment record
  paymentMethod: varchar("payment_method", { length: 50 }).notNull().default("square"),
  amountDueCents: integer("amount_due_cents").notNull().default(0),
  amountPaidCents: integer("amount_paid_cents"),
  paymentCompletedAt: timestamp("payment_completed_at"),
  paymentMetadata: jsonb("payment_metadata"),

  // Team roster (for team registrations)
  roster: jsonb("roster"), // Array of player IDs and roles

  // Notes
  notes: text("notes"), // Any special requirements/notes
  internalNotes: text("internal_notes"), // Admin notes

  // Timestamps
  confirmedAt: timestamp("confirmed_at"),
  cancelledAt: timestamp("cancelled_at"),
});

export const eventPaymentSessions = pgTable(
  "event_payment_sessions",
  {
    id: varchar("id", { length: 255 })
      .$defaultFn(() => createId())
      .primaryKey(),
    registrationId: uuid("registration_id")
      .notNull()
      .references(() => eventRegistrations.id, { onDelete: "cascade" }),
    eventId: uuid("event_id")
      .notNull()
      .references(() => events.id, { onDelete: "cascade" }),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    squareCheckoutId: varchar("square_checkout_id", { length: 255 }).notNull(),
    squarePaymentLinkUrl: varchar("square_payment_link_url", { length: 2048 }).notNull(),
    squareOrderId: varchar("square_order_id", { length: 255 }),
    squarePaymentId: varchar("square_payment_id", { length: 255 }),
    status: varchar("status", { length: 50 }).notNull().default("pending"),
    amountCents: integer("amount_cents").notNull(),
    currency: varchar("currency", { length: 10 }).notNull().default("CAD"),
    expiresAt: timestamp("expires_at"),
    metadata: jsonb("metadata"),
    createdAt: timestamp("created_at").notNull().defaultNow(),
    updatedAt: timestamp("updated_at").notNull().defaultNow(),
  },
  (table) => [
    uniqueIndex("event_payment_sessions_checkout_idx").on(table.squareCheckoutId),
    index("event_payment_sessions_payment_idx").on(table.squarePaymentId),
    index("event_payment_sessions_registration_idx").on(table.registrationId),
    index("event_payment_sessions_event_idx").on(table.eventId),
    index("event_payment_sessions_user_idx").on(table.userId),
  ],
);

/**
 * Event announcements/updates
 */
export const eventAnnouncements = pgTable("event_announcements", {
  id: uuid("id").primaryKey().defaultRandom(),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),

  eventId: uuid("event_id")
    .notNull()
    .references(() => events.id),
  authorId: text("author_id")
    .notNull()
    .references(() => user.id),

  title: varchar("title", { length: 255 }).notNull(),
  content: text("content").notNull(),

  isPinned: boolean("is_pinned").notNull().default(false),
  isPublished: boolean("is_published").notNull().default(true),

  // Who should see this
  visibility: varchar("visibility", { length: 50 }).notNull().default("all"), // all, registered, organizers
});

// Relations
export const eventsRelations = relations(events, ({ one, many }) => ({
  organizer: one(user, {
    fields: [events.organizerId],
    references: [user.id],
  }),
  registrations: many(eventRegistrations),
  paymentSessions: many(eventPaymentSessions),
  announcements: many(eventAnnouncements),
}));

export const eventRegistrationsRelations = relations(
  eventRegistrations,
  ({ one, many }) => ({
    event: one(events, {
      fields: [eventRegistrations.eventId],
      references: [events.id],
    }),
    team: one(teams, {
      fields: [eventRegistrations.teamId],
      references: [teams.id],
    }),
    user: one(user, {
      fields: [eventRegistrations.userId],
      references: [user.id],
    }),
    paymentSessions: many(eventPaymentSessions),
  }),
);

export const eventAnnouncementsRelations = relations(eventAnnouncements, ({ one }) => ({
  event: one(events, {
    fields: [eventAnnouncements.eventId],
    references: [events.id],
  }),
  author: one(user, {
    fields: [eventAnnouncements.authorId],
    references: [user.id],
  }),
}));

export const eventPaymentSessionsRelations = relations(
  eventPaymentSessions,
  ({ one }) => ({
    event: one(events, {
      fields: [eventPaymentSessions.eventId],
      references: [events.id],
    }),
    registration: one(eventRegistrations, {
      fields: [eventPaymentSessions.registrationId],
      references: [eventRegistrations.id],
    }),
    user: one(user, {
      fields: [eventPaymentSessions.userId],
      references: [user.id],
    }),
  }),
);

// Zod schemas
export const insertEventSchema = createInsertSchema(events);
export const selectEventSchema = createSelectSchema(events);
export const insertEventRegistrationSchema = createInsertSchema(eventRegistrations);
export const selectEventRegistrationSchema = createSelectSchema(eventRegistrations);
export const insertEventAnnouncementSchema = createInsertSchema(eventAnnouncements);
export const selectEventAnnouncementSchema = createSelectSchema(eventAnnouncements);
export const insertEventPaymentSessionSchema = createInsertSchema(eventPaymentSessions);
export const selectEventPaymentSessionSchema = createSelectSchema(eventPaymentSessions);

// Inferred types
export type EventPaymentSession = typeof eventPaymentSessions.$inferSelect;
export type NewEventPaymentSession = typeof eventPaymentSessions.$inferInsert;

// Custom validation schemas
export const baseCreateEventSchema = z.object({
  name: z.string().min(3).max(255),
  slug: z
    .string()
    .min(3)
    .max(255)
    .regex(/^[a-z0-9-]+$/, "Slug must be lowercase with hyphens only"),
  description: z.string().optional(),
  shortDescription: z.string().max(500).optional(),
  type: z.enum(["tournament", "league", "camp", "clinic", "social", "other"]),
  venueName: z.string().optional(),
  venueAddress: z.string().optional(),
  city: z.string().optional(),
  province: z.string().optional(),
  postalCode: z.string().optional(),
  startDate: z.string(), // Will be converted to Date
  endDate: z.string(), // Will be converted to Date
  registrationType: z.enum(["team", "individual", "both"]),
  maxTeams: z.int().positive().optional(),
  maxParticipants: z.int().positive().optional(),
  teamRegistrationFee: z.int().min(0).optional(),
  individualRegistrationFee: z.int().min(0).optional(),
  contactEmail: z.email().optional(),
  contactPhone: z.string().optional(),
  allowWaitlist: z.boolean().optional(),
  requireMembership: z.boolean().optional(),
  allowEtransfer: z.boolean().optional(),
  etransferRecipient: z
    .email("Enter a valid e-transfer email")
    .optional()
    .or(z.literal("")),
  etransferInstructions: z.string().max(2000).optional(),
});

export const createEventInputSchema = baseCreateEventSchema.superRefine((values, ctx) => {
  if (values.allowEtransfer) {
    const recipient = values.etransferRecipient?.trim() ?? "";
    if (!recipient) {
      ctx.addIssue({
        path: ["etransferRecipient"],
        code: "custom",
        message: "E-transfer recipient email is required when e-transfer is enabled",
      });
    }
  }
});

export type Event = typeof events.$inferSelect;
export type NewEvent = typeof events.$inferInsert;
export type EventRegistration = typeof eventRegistrations.$inferSelect;
export type NewEventRegistration = typeof eventRegistrations.$inferInsert;
export type EventAnnouncement = typeof eventAnnouncements.$inferSelect;
export type NewEventAnnouncement = typeof eventAnnouncements.$inferInsert;
</file>

<file path="src/features/auth/auth.schemas.ts">
import { z } from "zod";

/**
 * Login form validation schema
 */
export const loginFormSchema = z.object({
  email: z.email("Please enter a valid email").min(1, "Email is required"),
  password: z.string().min(1, "Password is required"),
});

export type LoginFormData = z.infer<typeof loginFormSchema>;

/**
 * Base signup form field schemas
 */
export const signupFormFieldSchemas = {
  name: z
    .string()
    .min(1, "Name is required")
    .min(2, "Name must be at least 2 characters"),
  email: z.email("Please enter a valid email").min(1, "Email is required"),
  password: z
    .string()
    .min(1, "Password is required")
    .min(8, "Password must be at least 8 characters"),
  confirmPassword: z.string().min(1, "Please confirm your password"),
};

/**
 * Signup form field validators for TanStack Form
 */
export const signupFormFields = {
  name: ({ value }: { value: string }) => {
    try {
      signupFormFieldSchemas.name.parse(value);
      return undefined;
    } catch (error) {
      if (error instanceof z.ZodError) {
        return error.issues[0]?.message || "Invalid name";
      }
      return "Invalid name";
    }
  },
  email: ({ value }: { value: string }) => {
    try {
      signupFormFieldSchemas.email.parse(value);
      return undefined;
    } catch (error) {
      if (error instanceof z.ZodError) {
        return error.issues[0]?.message || "Invalid email";
      }
      return "Invalid email";
    }
  },
  password: ({ value }: { value: string }) => {
    try {
      signupFormFieldSchemas.password.parse(value);
      return undefined;
    } catch (error) {
      if (error instanceof z.ZodError) {
        return error.issues[0]?.message || "Invalid password";
      }
      return "Invalid password";
    }
  },
  confirmPassword: ({ value }: { value: string }) => {
    try {
      signupFormFieldSchemas.confirmPassword.parse(value);
      return undefined;
    } catch (error) {
      if (error instanceof z.ZodError) {
        return error.issues[0]?.message || "Please confirm your password";
      }
      return "Please confirm your password";
    }
  },
};

/**
 * Signup form validation schema
 */
export const signupFormSchema = z
  .object(signupFormFieldSchemas)
  .refine((data) => data.password === data.confirmPassword, {
    path: ["confirmPassword"],
    error: "Passwords do not match",
  });

export type SignupFormData = z.infer<typeof signupFormSchema>;
</file>

<file path="src/features/membership/membership.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { zod$ } from "~/lib/server/fn-utils";
import { getMembershipTypeSchema } from "./membership.schemas";
import type {
  MembershipOperationResult,
  MembershipStatus,
  UserMembership,
} from "./membership.types";

/**
 * List all active membership types available for purchase
 */
export const listMembershipTypes = createServerFn({ method: "GET" }).handler(
  async (): Promise<
    MembershipOperationResult<import("./membership.types").MembershipType[]>
  > => {
    try {
      // Import server-only modules inside the handler
      const { getDb } = await import("~/db/server-helpers");

      // Import database dependencies inside handler
      const { eq } = await import("drizzle-orm");
      const { membershipTypes } = await import("~/db/schema");

      const db = await getDb();

      const activeTypes = await db
        .select()
        .from(membershipTypes)
        .where(eq(membershipTypes.status, "active"))
        .orderBy(membershipTypes.priceCents);

      return {
        success: true,
        data: activeTypes,
      };
    } catch (error) {
      console.error("Error fetching membership types:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to fetch membership types",
          },
        ],
      };
    }
  },
);

/**
 * Get a specific membership type by ID
 */
export const getMembershipType = createServerFn({ method: "GET" })
  .inputValidator(zod$(getMembershipTypeSchema))
  .handler(
    async ({
      data,
    }): Promise<
      MembershipOperationResult<import("./membership.types").MembershipType>
    > => {
      try {
        // Import server-only modules inside the handler
        const { getDb } = await import("~/db/server-helpers");

        // Import database dependencies inside handler
        const { eq } = await import("drizzle-orm");
        const { membershipTypes } = await import("~/db/schema");

        const db = await getDb();

        const [membershipType] = await db
          .select()
          .from(membershipTypes)
          .where(eq(membershipTypes.id, data.membershipTypeId))
          .limit(1);

        if (!membershipType) {
          return {
            success: false,
            errors: [
              {
                code: "NOT_FOUND",
                message: "Membership type not found",
              },
            ],
          };
        }

        return {
          success: true,
          data: membershipType,
        };
      } catch (error) {
        console.error("Error fetching membership type:", error);
        return {
          success: false,
          errors: [
            {
              code: "DATABASE_ERROR",
              message: "Failed to fetch membership type",
            },
          ],
        };
      }
    },
  );

/**
 * Get current user's membership status
 */
export const getUserMembershipStatus = createServerFn({ method: "GET" }).handler(
  async (): Promise<MembershipOperationResult<MembershipStatus>> => {
    try {
      // Import server-only modules inside the handler
      const [{ getDb }, { getAuth }] = await Promise.all([
        import("~/db/server-helpers"),
        import("~/lib/auth/server-helpers"),
      ]);

      const auth = await getAuth();
      const { getRequest } = await import("@tanstack/react-start/server");
      const { headers } = getRequest();
      const session = await auth.api.getSession({ headers });

      if (!session?.user?.id) {
        return {
          success: false,
          errors: [
            {
              code: "VALIDATION_ERROR",
              message: "User not authenticated",
            },
          ],
        };
      }

      // Import database dependencies inside handler
      const { and, eq, gte, sql } = await import("drizzle-orm");
      const { membershipTypes, memberships } = await import("~/db/schema");

      // Get active membership for the user
      const db = await getDb();

      const [currentMembership] = await db
        .select({
          membership: memberships,
          membershipType: membershipTypes,
        })
        .from(memberships)
        .innerJoin(membershipTypes, eq(memberships.membershipTypeId, membershipTypes.id))
        .where(
          and(
            eq(memberships.userId, session.user.id),
            eq(memberships.status, "active"),
            gte(memberships.endDate, sql`CURRENT_DATE`),
          ),
        )
        .orderBy(sql`${memberships.endDate} DESC`)
        .limit(1);

      if (!currentMembership) {
        return {
          success: true,
          data: {
            hasMembership: false,
          },
        };
      }

      const endDate = new Date(currentMembership.membership.endDate);
      const daysRemaining = Math.ceil(
        (endDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24),
      );

      const userMembership: UserMembership = {
        ...currentMembership.membership,
        membershipType: currentMembership.membershipType,
      };

      return {
        success: true,
        data: {
          hasMembership: true,
          currentMembership: userMembership,
          expiresAt: endDate,
          daysRemaining,
        },
      };
    } catch (error) {
      console.error("Error fetching membership status:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to fetch membership status",
          },
        ],
      };
    }
  },
);
</file>

<file path="src/features/roles/roles.mutations.ts">
import { createServerFn } from "@tanstack/react-start";
import { z } from "zod";
import { zod$ } from "~/lib/server/fn-utils";
import type { RoleAssignmentRow, RoleOperationResult } from "./roles.types";

const assignRoleSchema = z
  .object({
    userId: z.string().min(1, "User is required"),
    roleId: z.string().min(1, "Role is required"),
    teamId: z.string().min(1).optional().nullable(),
    eventId: z.string().min(1).optional().nullable(),
    notes: z.string().trim().max(500, "Notes must be 500 characters or fewer").optional(),
    expiresAt: z.iso.datetime().optional(),
  })
  .superRefine((data, ctx) => {
    if (data.teamId && data.eventId) {
      ctx.addIssue({
        code: "custom",
        message: "Choose either a team scope or an event scopenot both.",
        path: ["teamId"],
      });
    }
  });

const removeRoleSchema = z.object({
  assignmentId: z.string().min(1, "Assignment id is required"),
});

function normalizeNotes(notes?: string) {
  if (!notes) return null;
  const trimmed = notes.trim();
  return trimmed.length > 0 ? trimmed : null;
}

export const assignRoleToUser = createServerFn({ method: "POST" })
  .inputValidator(zod$(assignRoleSchema))
  .handler(async ({ data }): Promise<RoleOperationResult<RoleAssignmentRow>> => {
    try {
      const [{ getDb }, { getAuth }] = await Promise.all([
        import("~/db/server-helpers"),
        import("~/lib/auth/server-helpers"),
      ]);

      const auth = await getAuth();
      const { getRequest } = await import("@tanstack/react-start/server");
      const { headers } = getRequest();
      const session = await auth.api.getSession({ headers });

      if (!session?.user?.id) {
        return {
          success: false,
          errors: [
            {
              code: "UNAUTHORIZED",
              message: "User not authenticated",
            },
          ],
        };
      }

      const { requireAdmin, GLOBAL_ADMIN_ROLE_NAMES } = await import(
        "~/lib/auth/utils/admin-check"
      );
      await requireAdmin(session.user.id);

      const db = await getDb();
      const { roles, user, userRoles } = await import("~/db/schema");
      const { alias } = await import("drizzle-orm/pg-core");
      const { and, eq, isNull } = await import("drizzle-orm");

      const assignerUser = alias(user, "assigner_user");

      const [targetUser] = await db
        .select({ id: user.id, email: user.email, name: user.name })
        .from(user)
        .where(eq(user.id, data.userId))
        .limit(1);

      if (!targetUser) {
        return {
          success: false,
          errors: [
            {
              code: "NOT_FOUND",
              message: "User not found",
            },
          ],
        };
      }

      const [roleRecord] = await db
        .select({ id: roles.id, name: roles.name })
        .from(roles)
        .where(eq(roles.id, data.roleId))
        .limit(1);

      if (!roleRecord) {
        return {
          success: false,
          errors: [
            {
              code: "NOT_FOUND",
              message: "Role not found",
            },
          ],
        };
      }

      let teamId: string | null = data.teamId ?? null;
      let eventId: string | null = data.eventId ?? null;

      if (GLOBAL_ADMIN_ROLE_NAMES.includes(roleRecord.name)) {
        teamId = null;
        eventId = null;
      } else if (roleRecord.name === "Team Admin") {
        if (!teamId) {
          return {
            success: false,
            errors: [
              {
                code: "VALIDATION_ERROR",
                message: "Team Admin roles must be scoped to a specific team.",
              },
            ],
          };
        }
        eventId = null;
      } else if (roleRecord.name === "Event Admin") {
        if (!eventId) {
          return {
            success: false,
            errors: [
              {
                code: "VALIDATION_ERROR",
                message: "Event Admin roles must be scoped to a specific event.",
              },
            ],
          };
        }
        teamId = null;
      } else {
        teamId = teamId ?? null;
        eventId = eventId ?? null;
      }

      const expiresAt = data.expiresAt ? new Date(data.expiresAt) : null;
      if (expiresAt && Number.isNaN(expiresAt.getTime())) {
        return {
          success: false,
          errors: [
            {
              code: "VALIDATION_ERROR",
              message: "Invalid expiration date provided.",
            },
          ],
        };
      }

      const scopeConditions = [
        eq(userRoles.userId, targetUser.id),
        eq(userRoles.roleId, roleRecord.id),
        teamId ? eq(userRoles.teamId, teamId) : isNull(userRoles.teamId),
        eventId ? eq(userRoles.eventId, eventId) : isNull(userRoles.eventId),
      ];

      const [existingAssignment] = await db
        .select({ id: userRoles.id })
        .from(userRoles)
        .where(and(...scopeConditions))
        .limit(1);

      const fetchAssignment = async (assignmentId: string) => {
        const [assignment] = await db
          .select({
            id: userRoles.id,
            roleId: userRoles.roleId,
            roleName: roles.name,
            roleDescription: roles.description,
            userId: user.id,
            userName: user.name,
            userEmail: user.email,
            teamId: userRoles.teamId,
            eventId: userRoles.eventId,
            assignedBy: userRoles.assignedBy,
            assignedByName: assignerUser.name,
            assignedByEmail: assignerUser.email,
            assignedAt: userRoles.assignedAt,
            expiresAt: userRoles.expiresAt,
            notes: userRoles.notes,
          })
          .from(userRoles)
          .innerJoin(user, eq(userRoles.userId, user.id))
          .innerJoin(roles, eq(userRoles.roleId, roles.id))
          .leftJoin(assignerUser, eq(assignerUser.id, userRoles.assignedBy))
          .where(eq(userRoles.id, assignmentId))
          .limit(1);

        return assignment ?? null;
      };

      if (existingAssignment) {
        const existing = await fetchAssignment(existingAssignment.id);
        if (!existing) {
          return {
            success: false,
            errors: [
              {
                code: "DATABASE_ERROR",
                message: "Existing role assignment could not be loaded.",
              },
            ],
          };
        }

        return {
          success: true,
          data: existing,
        };
      }

      const [inserted] = await db
        .insert(userRoles)
        .values({
          userId: targetUser.id,
          roleId: roleRecord.id,
          teamId,
          eventId,
          assignedBy: session.user.id,
          notes: normalizeNotes(data.notes),
          expiresAt,
        })
        .returning();

      const created = await fetchAssignment(inserted.id);
      if (!created) {
        return {
          success: false,
          errors: [
            {
              code: "DATABASE_ERROR",
              message: "Role assignment was created but could not be loaded.",
            },
          ],
        };
      }

      return {
        success: true,
        data: created,
      };
    } catch (error) {
      console.error("Error assigning role:", error);

      if (error instanceof Error && error.message.includes("Admin access required")) {
        return {
          success: false,
          errors: [
            {
              code: "UNAUTHORIZED",
              message: "Admin access required",
            },
          ],
        };
      }

      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to assign role",
          },
        ],
      };
    }
  });

export const removeRoleAssignment = createServerFn({ method: "POST" })
  .inputValidator(zod$(removeRoleSchema))
  .handler(async ({ data }): Promise<RoleOperationResult<RoleAssignmentRow>> => {
    try {
      const [{ getDb }, { getAuth }] = await Promise.all([
        import("~/db/server-helpers"),
        import("~/lib/auth/server-helpers"),
      ]);

      const auth = await getAuth();
      const { getRequest } = await import("@tanstack/react-start/server");
      const { headers } = getRequest();
      const session = await auth.api.getSession({ headers });

      if (!session?.user?.id) {
        return {
          success: false,
          errors: [
            {
              code: "UNAUTHORIZED",
              message: "User not authenticated",
            },
          ],
        };
      }

      const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
      await requireAdmin(session.user.id);

      const db = await getDb();
      const { roles, userRoles, user } = await import("~/db/schema");
      const { alias } = await import("drizzle-orm/pg-core");
      const { eq } = await import("drizzle-orm");

      const assignerUser = alias(user, "assigner_user");

      const [existingAssignment] = await db
        .select({
          id: userRoles.id,
          roleId: userRoles.roleId,
          roleName: roles.name,
          roleDescription: roles.description,
          userId: user.id,
          userName: user.name,
          userEmail: user.email,
          teamId: userRoles.teamId,
          eventId: userRoles.eventId,
          assignedBy: userRoles.assignedBy,
          assignedByName: assignerUser.name,
          assignedByEmail: assignerUser.email,
          assignedAt: userRoles.assignedAt,
          expiresAt: userRoles.expiresAt,
          notes: userRoles.notes,
        })
        .from(userRoles)
        .innerJoin(user, eq(userRoles.userId, user.id))
        .innerJoin(roles, eq(userRoles.roleId, roles.id))
        .leftJoin(assignerUser, eq(assignerUser.id, userRoles.assignedBy))
        .where(eq(userRoles.id, data.assignmentId))
        .limit(1);

      if (!existingAssignment) {
        return {
          success: false,
          errors: [
            {
              code: "NOT_FOUND",
              message: "Role assignment not found",
            },
          ],
        };
      }

      await db.delete(userRoles).where(eq(userRoles.id, data.assignmentId));

      return {
        success: true,
        data: existingAssignment,
      };
    } catch (error) {
      console.error("Error removing role assignment:", error);

      if (error instanceof Error && error.message.includes("Admin access required")) {
        return {
          success: false,
          errors: [
            {
              code: "UNAUTHORIZED",
              message: "Admin access required",
            },
          ],
        };
      }

      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to remove role assignment",
          },
        ],
      };
    }
  });
</file>

<file path="src/lib/env.server.ts">
/**
 * Server-only environment configuration
 * This module should only be imported in server-side code
 */

// This module should only be imported in server-side code

// Load dotenv synchronously before createEnv is called
import dotenv from "dotenv";
if (import.meta.env.SSR && import.meta.env.DEV) {
  dotenv.config();
  dotenv.config({ path: ".env", override: true });
}

import { createEnv } from "@t3-oss/env-core";
import { z } from "zod";

import { parseOAuthAllowedDomains } from "./env/oauth-domain";

export const env = createEnv({
  server: {
    // Database
    DATABASE_URL: z.url(),
    DATABASE_URL_UNPOOLED: z.url().optional(),
    DATABASE_POOLED_URL: z.url().optional(),
    DATABASE_UNPOOLED_URL: z.url().optional(),
    NETLIFY_DATABASE_URL: z.url().optional(),
    NETLIFY_DATABASE_URL_UNPOOLED: z.url().optional(),

    // Auth - Secret must be set explicitly, no fallbacks
    // Generate with: node scripts/generate-auth-secret.js
    BETTER_AUTH_SECRET: z
      .string()
      .min(32, "BETTER_AUTH_SECRET must be at least 32 characters"),
    GOOGLE_CLIENT_ID: z.string().optional(),
    GOOGLE_CLIENT_SECRET: z.string().optional(),
    OAUTH_ALLOWED_DOMAINS: z
      .string()
      .optional()
      .transform((value, ctx) => {
        try {
          return parseOAuthAllowedDomains(value);
        } catch (error) {
          ctx.addIssue({
            code: "custom",
            message:
              error instanceof Error
                ? error.message
                : "Invalid OAuth allowed domains configuration",
            path: ["OAUTH_ALLOWED_DOMAINS"],
          });
          return z.NEVER;
        }
      }),

    // Square Payment Integration
    SQUARE_ENV: z.enum(["sandbox", "production"]).optional(),
    SQUARE_APPLICATION_ID: z.string().optional(),
    SQUARE_ACCESS_TOKEN: z.string().optional(),
    SQUARE_LOCATION_ID: z.string().optional(),
    SQUARE_WEBHOOK_SIGNATURE_KEY: z.string().optional(),
    SQUARE_WEBHOOK_URL: z.url().optional(),
    SUPPORT_EMAIL: z.email().optional(),

    // SendGrid Email Integration
    SENDGRID_API_KEY: z.string().optional(),
    SENDGRID_FROM_EMAIL: z.email().optional(),
    SENDGRID_FROM_NAME: z.string().optional(),

    // Other
    COOKIE_DOMAIN: z.string().optional(),
    NODE_ENV: z.enum(["development", "production", "test"]).prefault("development"),
    NETLIFY: z.string().optional(),
    VERCEL_ENV: z.string().optional(),

    // Client vars are also available on server
    // In production, Netlify provides URL env var
    VITE_BASE_URL: z.url().optional(),

    // Netlify automatically provides these
    URL: z.url().optional(), // The main URL of the site
    SITE_URL: z.url().optional(), // The site's URL
    DEPLOY_URL: z.url().optional(), // The specific deploy URL
    DEPLOY_PRIME_URL: z.url().optional(), // The prime URL for the deploy
  },
  // Use process.env since we've just loaded .env
  runtimeEnv: process.env,
  emptyStringAsUndefined: true,
});

// Helper functions
export const getDbUrl = () => env.DATABASE_URL;

export const getPooledDbUrl = () =>
  env.DATABASE_POOLED_URL || env.NETLIFY_DATABASE_URL || env.DATABASE_URL;

export const getUnpooledDbUrl = () =>
  env.DATABASE_UNPOOLED_URL ||
  env.DATABASE_URL_UNPOOLED ||
  env.NETLIFY_DATABASE_URL_UNPOOLED ||
  env.DATABASE_URL;

export const getBaseUrl = () => {
  const explicit = env.VITE_BASE_URL;
  const netlifyUrl = env.URL || env.SITE_URL || env.DEPLOY_PRIME_URL || env.DEPLOY_URL;
  const vercelCandidate = process.env["NEXT_PUBLIC_VERCEL_URL"];
  const vercelUrl = vercelCandidate
    ? vercelCandidate.startsWith("http")
      ? vercelCandidate
      : `https://${vercelCandidate}`
    : undefined;

  const candidate = explicit || netlifyUrl || vercelUrl;

  if (!candidate) {
    throw new Error(
      "Base URL is unknown. Set VITE_BASE_URL or rely on Netlify/Vercel provided URLs.",
    );
  }

  return candidate;
};
export const getAuthSecret = () => env.BETTER_AUTH_SECRET;

export const isProduction = () => env.NODE_ENV === "production";
export const isDevelopment = () => env.NODE_ENV === "development";
export const isTest = () => env.NODE_ENV === "test";
export const isServerless = () =>
  !!(env.NETLIFY || env.VERCEL_ENV || process.env["VERCEL"] === "1");
</file>

<file path="src/routes/__root.tsx">
/// <reference types="vite/client" />
import type { QueryClient } from "@tanstack/react-query";
import {
  createRootRouteWithContext,
  HeadContent,
  Outlet,
  ScriptOnce,
  Scripts,
} from "@tanstack/react-router";

import { lazy, Suspense } from "react";
import {
  authQueryOptions,
  getCurrentUser,
  type AuthQueryResult,
} from "~/features/auth/auth.queries";
import appCss from "~/styles.css?url";

// Lazy load devtools only in development to exclude from production bundles
const ReactQueryDevtools = import.meta.env.DEV
  ? lazy(() =>
      import("@tanstack/react-query-devtools").then((mod) => ({
        default: mod.ReactQueryDevtools,
      })),
    )
  : null;

const TanStackRouterDevtools = import.meta.env.DEV
  ? lazy(() =>
      import("@tanstack/react-router-devtools").then((mod) => ({
        default: mod.TanStackRouterDevtools,
      })),
    )
  : null;

// Lazy load Toaster to avoid SSR issues
const Toaster = lazy(() => import("sonner").then((mod) => ({ default: mod.Toaster })));

export const Route = createRootRouteWithContext<{
  queryClient: QueryClient;
  user: AuthQueryResult;
}>()({
  beforeLoad: async ({ context }) => {
    try {
      // Check if we're on the server or client
      if (typeof window === "undefined") {
        // Server: use the server function
        const user = await getCurrentUser();
        return { user };
      } else {
        // Client: fetch the full user data
        const user = await context.queryClient.fetchQuery(authQueryOptions());
        return { user };
      }
    } catch (error) {
      console.error("Error loading user:", error);
      return { user: null };
    }
  },
  head: () => ({
    meta: [
      {
        charSet: "utf-8",
      },
      {
        name: "viewport",
        content: "width=device-width, initial-scale=1",
      },
      {
        title: "Quadball Canada",
      },
      {
        name: "description",
        content:
          "Official hub for Quadball Canada competitions, club resources, and national team updates.",
      },
    ],
    links: [{ rel: "stylesheet", href: appCss }],
  }),
  component: RootComponent,
});

function RootComponent() {
  return (
    <RootDocument>
      <Outlet />
    </RootDocument>
  );
}

function RootDocument({ children }: { readonly children: React.ReactNode }) {
  return (
    // suppress since we're updating the "dark" class in a custom script below
    <html lang="en" suppressHydrationWarning>
      <head>
        <HeadContent />
      </head>
      <body>
        <ScriptOnce>
          {`
            // Minimal process shim for TanStack server functions
            if (typeof globalThis.process === 'undefined') {
              globalThis.process = {
                env: { NODE_ENV: '${import.meta.env.PROD ? "production" : "development"}' },
                versions: { node: '22.0.0' }
              };
            }

            // Theme toggle
            document.documentElement.classList.toggle(
              'dark',
              localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)
            );
          `}
        </ScriptOnce>

        {children}

        <Suspense fallback={null}>
          <Toaster richColors closeButton />
        </Suspense>
        {import.meta.env.DEV && ReactQueryDevtools && TanStackRouterDevtools && (
          <Suspense fallback={null}>
            <ReactQueryDevtools buttonPosition="bottom-left" />
            <TanStackRouterDevtools position="bottom-right" />
          </Suspense>
        )}

        <Scripts />
      </body>
    </html>
  );
}
</file>

<file path="src/features/roles/roles.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { z } from "zod";
import { zod$ } from "~/lib/server/fn-utils";
import type {
  RoleManagementData,
  RoleOperationResult,
  RoleUserSearchResult,
} from "./roles.types";

function escapeLike(term: string) {
  return term.replace(/\\/g, "\\\\").replace(/%/g, "\\%").replace(/_/g, "\\_");
}

const searchUsersSchema = z.object({
  query: z.string().min(2, "Enter at least 2 characters"),
  limit: z.int().positive().max(25).optional().prefault(10),
});

export const getRoleManagementData = createServerFn({ method: "GET" }).handler(
  async (): Promise<RoleOperationResult<RoleManagementData>> => {
    try {
      const [{ getDb }, { getAuth }] = await Promise.all([
        import("~/db/server-helpers"),
        import("~/lib/auth/server-helpers"),
      ]);

      const auth = await getAuth();
      const { getRequest } = await import("@tanstack/react-start/server");
      const { headers } = getRequest();
      const session = await auth.api.getSession({ headers });

      if (!session?.user?.id) {
        return {
          success: false,
          errors: [
            {
              code: "UNAUTHORIZED",
              message: "User not authenticated",
            },
          ],
        };
      }

      const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
      await requireAdmin(session.user.id);

      const db = await getDb();
      const { roles, userRoles, user } = await import("~/db/schema");
      const { asc, desc, sql, eq } = await import("drizzle-orm");
      const { alias } = await import("drizzle-orm/pg-core");

      const roleSummaries = await db
        .select({
          id: roles.id,
          name: roles.name,
          description: roles.description,
          permissions: roles.permissions,
          createdAt: roles.createdAt,
          updatedAt: roles.updatedAt,
          assignmentCount: sql<number>`count(${userRoles.id})`,
        })
        .from(roles)
        .leftJoin(userRoles, eq(userRoles.roleId, roles.id))
        .groupBy(
          roles.id,
          roles.name,
          roles.description,
          roles.permissions,
          roles.createdAt,
          roles.updatedAt,
        )
        .orderBy(asc(roles.name));

      const assignerUser = alias(user, "assigner_user");

      const assignments = await db
        .select({
          id: userRoles.id,
          roleId: userRoles.roleId,
          roleName: roles.name,
          roleDescription: roles.description,
          userId: user.id,
          userName: user.name,
          userEmail: user.email,
          teamId: userRoles.teamId,
          eventId: userRoles.eventId,
          assignedBy: userRoles.assignedBy,
          assignedByName: assignerUser.name,
          assignedByEmail: assignerUser.email,
          assignedAt: userRoles.assignedAt,
          expiresAt: userRoles.expiresAt,
          notes: userRoles.notes,
        })
        .from(userRoles)
        .innerJoin(user, eq(userRoles.userId, user.id))
        .innerJoin(roles, eq(userRoles.roleId, roles.id))
        .leftJoin(assignerUser, eq(assignerUser.id, userRoles.assignedBy))
        .orderBy(desc(userRoles.assignedAt));

      return {
        success: true,
        data: {
          roles: roleSummaries,
          assignments,
        },
      };
    } catch (error) {
      console.error("Error loading role management data:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to load role management data",
          },
        ],
      };
    }
  },
);

export const searchRoleEligibleUsers = createServerFn({ method: "GET" })
  .inputValidator(zod$(searchUsersSchema))
  .handler(async ({ data }): Promise<RoleOperationResult<RoleUserSearchResult[]>> => {
    try {
      const [{ getDb }, { getAuth }] = await Promise.all([
        import("~/db/server-helpers"),
        import("~/lib/auth/server-helpers"),
      ]);

      const auth = await getAuth();
      const { getRequest } = await import("@tanstack/react-start/server");
      const { headers } = getRequest();
      const session = await auth.api.getSession({ headers });

      if (!session?.user?.id) {
        return {
          success: false,
          errors: [
            {
              code: "UNAUTHORIZED",
              message: "User not authenticated",
            },
          ],
        };
      }

      const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
      await requireAdmin(session.user.id);

      const db = await getDb();
      const { user, userRoles, roles } = await import("~/db/schema");
      const { asc, ilike, or, sql, eq } = await import("drizzle-orm");

      const searchTerm = `%${escapeLike(data.query.trim())}%`;

      const matches = await db
        .select({
          id: user.id,
          name: user.name,
          email: user.email,
          roleNames: sql<string[]>`array_remove(array_agg(${roles.name}), NULL)`,
        })
        .from(user)
        .leftJoin(userRoles, eq(userRoles.userId, user.id))
        .leftJoin(roles, eq(userRoles.roleId, roles.id))
        .where(or(ilike(user.email, searchTerm), ilike(user.name, searchTerm)))
        .groupBy(user.id)
        .orderBy(asc(user.name))
        .limit(data.limit);

      const results: RoleUserSearchResult[] = matches.map((match) => ({
        id: match.id,
        name: match.name,
        email: match.email,
        roleNames: Array.isArray(match.roleNames) ? match.roleNames : [],
      }));

      return {
        success: true,
        data: results,
      };
    } catch (error) {
      console.error("Error searching users for roles:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to search users",
          },
        ],
      };
    }
  });
</file>

<file path="src/features/auth/auth.queries.ts">
import { queryOptions } from "@tanstack/react-query";
import { createServerFn } from "@tanstack/react-start";
import type { User } from "~/lib/auth/types";

/**
 * Server function to get the current user with all custom fields
 */
export const getCurrentUser = createServerFn({ method: "GET" }).handler(
  async (): Promise<User | null> => {
    // Import server-only modules inside the handler
    const { getDb } = await import("~/db/server-helpers");
    const { getAuth } = await import("~/lib/auth/server-helpers");
    const auth = await getAuth();
    const { getRequest } = await import("@tanstack/react-start/server");
    const { headers } = getRequest();

    const session = await auth.api.getSession({ headers });

    if (!session?.user) {
      return null;
    }

    // Import schema and ORM inside the handler
    const { eq } = await import("drizzle-orm");
    const { user } = await import("~/db/schema");

    // Fetch the full user data from the database
    const db = await getDb();
    const dbUser = await db
      .select()
      .from(user)
      .where(eq(user.id, session.user.id))
      .limit(1);

    if (!dbUser[0]) {
      return null;
    }

    // Fetch user roles
    const { PermissionService } = await import("~/features/roles/permission.service");
    const userRoles = await PermissionService.getUserRoles(session.user.id);

    // Map the database user to our extended User type
    return {
      ...session.user,
      profileComplete: dbUser[0].profileComplete,
      dateOfBirth: dbUser[0].dateOfBirth,
      emergencyContact: dbUser[0].emergencyContact,
      gender: dbUser[0].gender,
      pronouns: dbUser[0].pronouns,
      phone: dbUser[0].phone,
      privacySettings: dbUser[0].privacySettings,
      profileVersion: dbUser[0].profileVersion,
      profileUpdatedAt: dbUser[0].profileUpdatedAt,
      roles: userRoles,
    };
  },
);

export type AuthQueryResult = Awaited<ReturnType<typeof getCurrentUser>>;

export const authQueryKey = ["user"] as const;

export const authQueryOptions = () =>
  queryOptions({
    queryKey: authQueryKey,
    queryFn: ({ signal }) => getCurrentUser({ signal }),
  });
</file>

<file path="src/features/membership/membership.admin-queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { z } from "zod";
import { zod$ } from "~/lib/server/fn-utils";
import type { MembershipOperationResult } from "./membership.types";

const getAllMembershipsSchema = z.object({
  status: z.enum(["all", "active", "expired", "cancelled"]).optional().prefault("all"),
  limit: z.number().optional().prefault(100),
  offset: z.number().optional().prefault(0),
});

export interface MembershipReportRow {
  id: string;
  userName: string;
  userEmail: string;
  membershipType: string;
  startDate: string;
  endDate: string;
  status: "active" | "expired" | "cancelled";
  priceCents: number;
  paymentId: string | null;
  createdAt: Date;
}

/**
 * Admin-only: Get all memberships with user information
 */
export const getAllMemberships = createServerFn({ method: "GET" })
  .inputValidator(zod$(getAllMembershipsSchema))
  .handler(
    async ({ data }): Promise<MembershipOperationResult<MembershipReportRow[]>> => {
      try {
        // Import server-only modules inside the handler
        const [{ getDb }, { getAuth }] = await Promise.all([
          import("~/db/server-helpers"),
          import("~/lib/auth/server-helpers"),
        ]);

        const auth = await getAuth();
        const { getRequest } = await import("@tanstack/react-start/server");
        const { headers } = getRequest();
        const session = await auth.api.getSession({ headers });

        if (!session?.user?.id) {
          return {
            success: false,
            errors: [
              {
                code: "VALIDATION_ERROR",
                message: "User not authenticated",
              },
            ],
          };
        }

        // Check admin access
        const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
        await requireAdmin(session.user.id);

        // Import database dependencies inside handler
        const { and, eq, sql } = await import("drizzle-orm");
        const { memberships, membershipTypes, user } = await import("~/db/schema");

        const db = await getDb();

        // Build where conditions
        const conditions = [];
        if (data.status !== "all") {
          conditions.push(eq(memberships.status, data.status));
        }
        const query = db
          .select({
            id: memberships.id,
            userName: user.name,
            userEmail: user.email,
            membershipType: membershipTypes.name,
            startDate: memberships.startDate,
            endDate: memberships.endDate,
            status: memberships.status,
            priceCents: membershipTypes.priceCents,
            paymentId: memberships.paymentId,
            createdAt: memberships.createdAt,
          })
          .from(memberships)
          .innerJoin(user, eq(memberships.userId, user.id))
          .innerJoin(
            membershipTypes,
            eq(memberships.membershipTypeId, membershipTypes.id),
          )
          .orderBy(sql`${memberships.createdAt} DESC`)
          .limit(data.limit)
          .offset(data.offset);

        if (conditions.length > 0) {
          const results = await query.where(and(...conditions));
          return {
            success: true,
            data: results,
          };
        }

        const results = await query;
        return {
          success: true,
          data: results,
        };
      } catch (error) {
        console.error("Error fetching memberships:", error);

        if ((error as Error).message?.includes("Admin access required")) {
          return {
            success: false,
            errors: [
              {
                code: "VALIDATION_ERROR",
                message: "Admin access required",
              },
            ],
          };
        }

        return {
          success: false,
          errors: [
            {
              code: "DATABASE_ERROR",
              message: "Failed to fetch memberships",
            },
          ],
        };
      }
    },
  );
</file>

<file path="src/lib/auth/server-helpers.ts">
/**
 * Server-only auth helpers
 * This module contains auth configuration that requires server-side environment variables
 */
import { APIError, betterAuth } from "better-auth";
import { drizzleAdapter } from "better-auth/adapters/drizzle";
import { tanstackStartCookies } from "better-auth/tanstack-start";

// Lazy-loaded auth instance
let authInstance: ReturnType<typeof betterAuth> | undefined;
let authInitPromise: Promise<ReturnType<typeof betterAuth>> | undefined;

const assertServerOnly = () => {
  if (typeof window !== "undefined") {
    throw new Error("Auth helpers can only be used on the server.");
  }
};

// Create and export the auth instance with server configuration
const createAuth = async (): Promise<ReturnType<typeof betterAuth>> => {
  assertServerOnly();
  // Import server modules when auth is created
  const { db } = await import("~/db");
  const schema = await import("~/db/schema");
  const { env, getAuthSecret, getBaseUrl, isProduction } = await import(
    "~/lib/env.server"
  );

  const baseUrl = getBaseUrl();
  const isHttpsDeployment = baseUrl?.startsWith("https://") ?? false;
  const cookieDomain = env.COOKIE_DOMAIN;
  const allowedOAuthDomains = Array.isArray(env.OAUTH_ALLOWED_DOMAINS)
    ? env.OAUTH_ALLOWED_DOMAINS
    : [];
  const googleClientId = env.GOOGLE_CLIENT_ID || "";
  const googleClientSecret = env.GOOGLE_CLIENT_SECRET || "";

  if (process.env["NODE_ENV"] !== "production") {
    console.log("Auth config loading...");
    console.log("Base URL:", baseUrl);

    console.log(
      "Google Client ID:",
      googleClientId ? `Set (${googleClientId.substring(0, 10)}...)` : "Missing",
    );
    console.log("Google Client Secret:", googleClientSecret ? "Set" : "Missing");
    if (allowedOAuthDomains.length > 0) {
      console.log("OAuth allowed domains:", allowedOAuthDomains.join(", "));
    }
  }

  // Get database connection
  const dbConnection = await db();

  return betterAuth({
    baseURL: baseUrl,
    secret: getAuthSecret(),
    trustedOrigins: isProduction()
      ? [baseUrl]
      : [
          baseUrl,
          "http://localhost:5173",
          "http://localhost:5174",
          "http://localhost:8888",
        ],
    database: drizzleAdapter(dbConnection, {
      provider: "pg",
      schema: {
        user: schema.user,
        session: schema.session,
        account: schema.account,
        verification: schema.verification,
      },
    }),

    // Session configuration with security settings
    session: {
      expiresIn: 60 * 60 * 24 * 30, // 30 days
      updateAge: 60 * 60 * 24, // 1 day
      // NOTE: cookieCache is disabled due to a known bug with tanstackStartCookies
      // that prevents session_token cookie from being set. See:
      // https://github.com/better-auth/better-auth/issues/5639
      // Re-enable once the upstream fix is released.
    },

    // Secure cookie configuration
    advanced: {
      cookiePrefix: "solstice",
      useSecureCookies: isHttpsDeployment,
      defaultCookieAttributes: cookieDomain
        ? {
            secure: isHttpsDeployment,
            sameSite: "lax",
            httpOnly: true,
            path: "/",
            domain: cookieDomain,
          }
        : {
            secure: isHttpsDeployment,
            sameSite: "lax",
            httpOnly: true,
            path: "/",
          },
    },

    // OAuth providers configuration
    socialProviders: {
      google: {
        clientId: googleClientId,
        clientSecret: googleClientSecret,
        ...(allowedOAuthDomains.length > 0
          ? {
              mapProfileToUser: (profile: {
                email?: string | null | undefined;
                hd?: string | undefined;
              }) => {
                const email = profile.email?.toLowerCase();
                const domain = email?.split("@")[1];
                const hostedDomain = profile.hd?.toLowerCase();

                const isAllowed = [domain, hostedDomain]
                  .filter((value): value is string => Boolean(value))
                  .some((value) => allowedOAuthDomains.includes(value));

                if (!isAllowed) {
                  const allowedList =
                    allowedOAuthDomains.length === 1
                      ? allowedOAuthDomains[0]
                      : allowedOAuthDomains.join(", ");
                  throw new APIError("UNAUTHORIZED", {
                    message: `Access restricted. Please sign in with an approved domain (${allowedList}).`,
                  });
                }

                return {};
              },
            }
          : {}),
      },
    },

    // Email and password authentication
    emailAndPassword: {
      enabled: true,
      requireEmailVerification: isProduction(),
    },

    // Account linking configuration
    account: {
      accountLinking: {
        enabled: true,
        trustedProviders: ["google"], // Auto-link these providers
      },
    },

    // https://www.better-auth.com/docs/integrations/tanstack#usage-tips
    plugins: [tanstackStartCookies()], // MUST be the last plugin
  });
};

// Export auth as a getter that creates instance on first use
export const auth = new Proxy({} as ReturnType<typeof betterAuth>, {
  get(target, prop) {
    if (!authInstance) {
      throw new Error("Auth must be initialized asynchronously. Use getAuth() instead.");
    }
    return authInstance[prop as keyof typeof authInstance];
  },
});

// Export async getter for auth
export const getAuth = async (): Promise<ReturnType<typeof betterAuth>> => {
  assertServerOnly();

  if (authInstance) {
    return authInstance;
  }

  if (!authInitPromise) {
    authInitPromise = createAuth().then((instance) => {
      authInstance = instance;
      return instance;
    });
  }

  return authInitPromise;
};
</file>

<file path="src/features/auth/components/signup.tsx">
import { useQueryClient } from "@tanstack/react-query";
import { useNavigate, useRouter } from "@tanstack/react-router";
import { useState } from "react";
import { FormSubmitButton } from "~/components/form-fields/FormSubmitButton";
import { ValidatedInput } from "~/components/form-fields/ValidatedInput";
import { Button } from "~/components/ui/button";
import { GoogleIcon, LogoIcon } from "~/components/ui/icons";
import { SafeLink as Link } from "~/components/ui/SafeLink";
import { auth } from "~/lib/auth-client";
import { useAppForm } from "~/lib/hooks/useAppForm";
import { authQueryKey } from "../auth.queries";
import { signupFormFields } from "../auth.schemas";

export default function SignupForm() {
  const queryClient = useQueryClient();
  const navigate = useNavigate();
  const router = useRouter();
  const redirectUrl = "/dashboard"; // Default redirect after signup

  const [isLoading, setIsLoading] = useState(false);
  const [errorMessage, setErrorMessage] = useState("");

  const form = useAppForm({
    defaultValues: {
      name: "",
      email: "",
      password: "",
      confirmPassword: "",
    },
    onSubmit: async ({ value }) => {
      setIsLoading(true);
      setErrorMessage("");

      try {
        const result = await auth.signUp.email({
          name: value.name,
          email: value.email,
          password: value.password,
          callbackURL: redirectUrl,
        });

        if (result?.error) {
          throw new Error(result.error.message || "Signup failed");
        }

        // Success path
        await queryClient.invalidateQueries({ queryKey: authQueryKey });
        await router.invalidate();
        await navigate({ to: redirectUrl });
      } catch (error) {
        // Error handling
        setErrorMessage((error as Error)?.message || "Signup failed");
        // Keep form values but reset submitting state by resetting with current values
        form.reset({
          name: value.name,
          email: value.email,
          password: value.password,
          confirmPassword: value.confirmPassword,
        });
      } finally {
        // Always reset loading state
        setIsLoading(false);
      }
    },
  });

  return (
    <div className="flex flex-col gap-6">
      <form
        onSubmit={async (e) => {
          e.preventDefault();
          e.stopPropagation();
          await form.handleSubmit();
        }}
      >
        <div className="flex flex-col gap-6">
          <div className="flex flex-col items-center gap-2">
            <a href="#" className="flex flex-col items-center gap-2 font-medium">
              <div className="flex h-8 w-8 items-center justify-center rounded-md">
                <LogoIcon className="size-6" />
              </div>
              <span className="sr-only">Quadball Canada</span>
            </a>
            <h1 className="text-xl font-bold">Sign up for Quadball Canada</h1>
          </div>
          <div className="flex flex-col gap-5">
            <form.Field
              name="name"
              validators={{
                onChange: signupFormFields.name,
              }}
            >
              {(field) => (
                <ValidatedInput
                  field={field}
                  label="Name"
                  type="text"
                  placeholder="John Doe"
                  autoComplete="name"
                  autoFocus
                />
              )}
            </form.Field>
            <form.Field
              name="email"
              validators={{
                onChange: signupFormFields.email,
              }}
            >
              {(field) => (
                <ValidatedInput
                  field={field}
                  label="Email"
                  type="email"
                  placeholder="hello@example.com"
                  autoComplete="email"
                />
              )}
            </form.Field>
            <form.Field
              name="password"
              validators={{
                onChange: signupFormFields.password,
              }}
            >
              {(field) => (
                <ValidatedInput
                  field={field}
                  label="Password"
                  type="password"
                  placeholder="Password"
                  autoComplete="new-password"
                />
              )}
            </form.Field>
            <form.Field
              name="confirmPassword"
              validators={{
                onChangeListenTo: ["password"],
                onChange: ({ value, fieldApi }) => {
                  const password = fieldApi.form.getFieldValue("password");
                  // Only validate if both fields have values
                  if (value && password && value !== password) {
                    return "Passwords do not match";
                  }
                  return undefined;
                },
              }}
            >
              {(field) => (
                <ValidatedInput
                  field={field}
                  label="Confirm Password"
                  type="password"
                  placeholder="Confirm Password"
                  autoComplete="new-password"
                />
              )}
            </form.Field>
            <FormSubmitButton
              isSubmitting={form.state.isSubmitting || isLoading}
              className="mt-2 w-full"
              size="lg"
              loadingText="Signing up..."
            >
              Sign up
            </FormSubmitButton>
          </div>
          {errorMessage && (
            <span className="text-destructive text-center text-sm">{errorMessage}</span>
          )}
          <div className="after:border-border relative text-center text-sm after:absolute after:inset-0 after:top-1/2 after:z-0 after:flex after:items-center after:border-t">
            <span className="bg-background text-muted-foreground relative z-10 px-2">
              Or
            </span>
          </div>
          <Button
            variant="outline"
            className="w-full"
            type="button"
            disabled={isLoading || form.state.isSubmitting}
            onClick={() =>
              auth.signInWithOAuth(
                {
                  provider: "google",
                  callbackURL: redirectUrl,
                },
                {
                  onRequest: () => {
                    setIsLoading(true);
                    setErrorMessage("");
                  },
                  // eslint-disable-next-line @typescript-eslint/no-explicit-any
                  onError: (ctx: any) => {
                    setIsLoading(false);
                    setErrorMessage(ctx.error?.message || "OAuth signup failed");
                  },
                },
              )
            }
          >
            <GoogleIcon />
            Sign up with Google
          </Button>
        </div>
      </form>

      <div className="text-center text-sm">
        Already have an account?{" "}
        <Link to="/auth/login" className="underline underline-offset-4">
          Login
        </Link>
      </div>
    </div>
  );
}
</file>

<file path="src/features/membership/membership.mutations.ts">
import { createServerFn } from "@tanstack/react-start";
import { and, eq, gte, sql } from "drizzle-orm";
import { membershipPaymentSessions, memberships, membershipTypes } from "~/db/schema";
import { atomicJsonbMerge } from "~/lib/db/jsonb-utils";
import { getAuthMiddleware, requireUser } from "~/lib/server/auth";
import { zod$ } from "~/lib/server/fn-utils";
import type { MembershipMetadata } from "./membership.db-types";
import {
  confirmMembershipPurchaseSchema,
  purchaseMembershipSchema,
} from "./membership.schemas";
import type {
  CheckoutSessionResult,
  Membership,
  MembershipOperationResult,
} from "./membership.types";

// Helper to cast membership jsonb fields
function castMembershipJsonbFields(
  membership: typeof memberships.$inferSelect,
): Membership {
  return {
    ...membership,
    metadata: (membership.metadata || {}) as MembershipMetadata,
  } as Membership;
}

const RETRYABLE_PAYMENT_ERROR_PATTERNS = [/pending/i, /not available/i, /processing/i];

function isRetryablePaymentError(message: string | undefined): boolean {
  if (!message) return false;
  return RETRYABLE_PAYMENT_ERROR_PATTERNS.some((pattern) => pattern.test(message));
}

async function wait(ms: number) {
  await new Promise((resolve) => setTimeout(resolve, ms));
}

const getSquarePaymentService = async () => {
  const { squarePaymentService } = await import("~/lib/payments/square");
  return squarePaymentService;
};

/**
 * Create a checkout session for membership purchase
 */
export const createCheckoutSession = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(purchaseMembershipSchema.omit({ autoRenew: true })))
  .handler(
    async ({
      data,
      context,
    }): Promise<MembershipOperationResult<CheckoutSessionResult>> => {
      try {
        // Import server-only modules inside the handler
        const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);

        const db = await getDb();
        const user = requireUser(context);

        // Verify membership type exists and is active

        const [membershipType] = await db
          .select()
          .from(membershipTypes)
          .where(
            and(
              eq(membershipTypes.id, data.membershipTypeId),
              eq(membershipTypes.status, "active"),
            ),
          )
          .limit(1);

        if (!membershipType) {
          return {
            success: false,
            errors: [
              {
                code: "NOT_FOUND",
                message: "Membership type not found or inactive",
              },
            ],
          };
        }

        // Check if user already has an active, unexpired membership
        // Must check both status AND date to allow renewal of expired memberships
        const [existingMembership] = await db
          .select()
          .from(memberships)
          .where(
            and(
              eq(memberships.userId, user.id),
              eq(memberships.status, "active"),
              gte(memberships.endDate, sql`CURRENT_DATE`),
            ),
          )
          .limit(1);

        if (existingMembership) {
          return {
            success: false,
            errors: [
              {
                code: "VALIDATION_ERROR",
                message: "User already has an active membership",
              },
            ],
          };
        }

        // Create checkout session with Square
        const squarePaymentService = await getSquarePaymentService();
        const checkoutSession = await squarePaymentService.createCheckoutSession(
          membershipType.id,
          user.id,
          membershipType.priceCents,
        );

        await db
          .insert(membershipPaymentSessions)
          .values({
            userId: user.id,
            membershipTypeId: membershipType.id,
            squareCheckoutId: checkoutSession.id,
            squarePaymentLinkUrl: checkoutSession.checkoutUrl,
            squareOrderId: checkoutSession.orderId || null,
            amountCents: membershipType.priceCents,
            currency: checkoutSession.currency,
            expiresAt: checkoutSession.expiresAt ?? null,
            metadata: {
              membershipName: membershipType.name,
              squareOrderId: checkoutSession.orderId || null,
            },
          })
          .onConflictDoUpdate({
            target: membershipPaymentSessions.squareCheckoutId,
            set: {
              membershipTypeId: membershipType.id,
              squarePaymentLinkUrl: checkoutSession.checkoutUrl,
              squareOrderId: checkoutSession.orderId || null,
              amountCents: membershipType.priceCents,
              currency: checkoutSession.currency,
              expiresAt: checkoutSession.expiresAt ?? null,
              metadata: {
                membershipName: membershipType.name,
                squareOrderId: checkoutSession.orderId || null,
              },
              updatedAt: new Date(),
            },
          });

        return {
          success: true,
          data: {
            checkoutUrl: checkoutSession.checkoutUrl,
            sessionId: checkoutSession.id,
          },
        };
      } catch (error) {
        console.error("Error creating checkout session:", error);
        return {
          success: false,
          errors: [
            {
              code: "PAYMENT_ERROR",
              message: "Failed to create checkout session",
            },
          ],
        };
      }
    },
  );

/**
 * Confirm membership purchase after payment
 */
export const confirmMembershipPurchase = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(confirmMembershipPurchaseSchema))
  .handler(async ({ data, context }): Promise<MembershipOperationResult<Membership>> => {
    try {
      // Import server-only modules inside the handler
      const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);

      const db = await getDb();
      const user = requireUser(context);

      // Look up the stored payment session
      const [paymentSession] = await db
        .select()
        .from(membershipPaymentSessions)
        .where(eq(membershipPaymentSessions.squareCheckoutId, data.sessionId))
        .limit(1);

      if (!paymentSession) {
        return {
          success: false,
          errors: [
            {
              code: "NOT_FOUND",
              message: "Checkout session not found",
            },
          ],
        };
      }

      if (paymentSession.userId !== user.id) {
        return {
          success: false,
          errors: [
            {
              code: "VALIDATION_ERROR",
              message: "Payment session does not belong to user",
            },
          ],
        };
      }

      if (data.membershipTypeId !== paymentSession.membershipTypeId) {
        return {
          success: false,
          errors: [
            {
              code: "VALIDATION_ERROR",
              message: "Membership type mismatch",
            },
          ],
        };
      }

      if (paymentSession.status === "completed" && paymentSession.squarePaymentId) {
        const [existingMembershipByPayment] = await db
          .select()
          .from(memberships)
          .where(eq(memberships.paymentId, paymentSession.squarePaymentId))
          .limit(1);

        if (existingMembershipByPayment) {
          return {
            success: true,
            data: castMembershipJsonbFields(existingMembershipByPayment),
          };
        }
      }

      // Verify payment with Square
      const squarePaymentService = await getSquarePaymentService();
      let paymentResult = await squarePaymentService.verifyPayment(
        paymentSession.squareCheckoutId,
        data.paymentId ?? paymentSession.squarePaymentId ?? undefined,
      );

      let retryAttempts = 0;
      const maxRetryAttempts = 2;

      while (
        !paymentResult.success &&
        retryAttempts < maxRetryAttempts &&
        isRetryablePaymentError(paymentResult.error)
      ) {
        retryAttempts += 1;
        await wait(750 * retryAttempts);

        const [latestSession] = await db
          .select()
          .from(membershipPaymentSessions)
          .where(eq(membershipPaymentSessions.id, paymentSession.id))
          .limit(1);

        if (
          latestSession &&
          latestSession.status === "completed" &&
          latestSession.squarePaymentId
        ) {
          paymentResult = {
            success: true,
            paymentId: latestSession.squarePaymentId,
            orderId: latestSession.squareOrderId,
            status: "COMPLETED",
            amount: latestSession.amountCents,
            currency: latestSession.currency,
          };
          break;
        }

        paymentResult = await squarePaymentService.verifyPayment(
          paymentSession.squareCheckoutId,
          data.paymentId ?? paymentSession.squarePaymentId ?? undefined,
        );
      }

      if (!paymentResult.success) {
        const now = new Date();
        await db
          .update(membershipPaymentSessions)
          .set({
            status: paymentSession.status === "completed" ? "completed" : "failed",
            metadata: atomicJsonbMerge(membershipPaymentSessions.metadata, {
              lastError: paymentResult.error || "Payment verification failed",
              lastErrorAt: now.toISOString(),
              retryAttempts,
            }),
            updatedAt: now,
          })
          .where(eq(membershipPaymentSessions.id, paymentSession.id));

        return {
          success: false,
          errors: [
            {
              code: "PAYMENT_ERROR",
              message: paymentResult.error || "Payment verification failed",
            },
          ],
        };
      }

      const squarePaymentId =
        paymentResult.paymentId ?? data.paymentId ?? paymentSession.squarePaymentId;

      if (!squarePaymentId) {
        return {
          success: false,
          errors: [
            {
              code: "PAYMENT_ERROR",
              message: "Missing payment identifier",
            },
          ],
        };
      }

      // Get membership type details

      const [membershipType] = await db
        .select()
        .from(membershipTypes)
        .where(eq(membershipTypes.id, data.membershipTypeId))
        .limit(1);

      if (!membershipType) {
        return {
          success: false,
          errors: [
            {
              code: "NOT_FOUND",
              message: "Membership type not found",
            },
          ],
        };
      }

      if (
        typeof paymentResult.amount === "number" &&
        paymentResult.amount !== membershipType.priceCents
      ) {
        return {
          success: false,
          errors: [
            {
              code: "PAYMENT_ERROR",
              message: "Payment amount does not match membership price",
            },
          ],
        };
      }

      if (paymentResult.currency && paymentResult.currency !== "CAD") {
        return {
          success: false,
          errors: [
            {
              code: "PAYMENT_ERROR",
              message: "Payment currency is not supported",
            },
          ],
        };
      }

      const now = new Date();
      const { finalizeMembershipForSession } = await import("./membership.finalize");
      const finalizeResult = await finalizeMembershipForSession({
        db,
        paymentSession,
        membershipType,
        paymentId: squarePaymentId,
        orderId: paymentResult.orderId ?? paymentSession.squareOrderId ?? null,
        sessionId: data.sessionId,
        now,
      });

      const confirmedMembership = finalizeResult.membership;
      const membershipWasCreated = finalizeResult.wasCreated;

      // Send confirmation email
      if (membershipWasCreated) {
        try {
          const { sendMembershipPurchaseReceipt } = await import("~/lib/email/sendgrid");

          await sendMembershipPurchaseReceipt({
            to: {
              email: user.email,
              name: user.name || undefined,
            },
            membershipType: membershipType.name,
            amount: membershipType.priceCents,
            paymentId: squarePaymentId,
            expiresAt: new Date(confirmedMembership.endDate),
          });
        } catch (emailError) {
          // Log error but don't fail the purchase
          console.error("Failed to send confirmation email:", emailError);
        }
      }

      return {
        success: true,
        data: castMembershipJsonbFields(
          confirmedMembership as typeof memberships.$inferSelect,
        ),
      };
    } catch (error) {
      console.error("Error confirming membership purchase:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to create membership record",
          },
        ],
      };
    }
  });
</file>

<file path="src/features/auth/components/login.tsx">
import { useQueryClient } from "@tanstack/react-query";
import { useNavigate, useRouter } from "@tanstack/react-router";
import { useEffect, useState } from "react";
import { z } from "zod";
import { FormSubmitButton } from "~/components/form-fields/FormSubmitButton";
import { ValidatedInput } from "~/components/form-fields/ValidatedInput";
import { Button } from "~/components/ui/button";
import { GoogleIcon, LogoIcon } from "~/components/ui/icons";
import { SafeLink as Link } from "~/components/ui/SafeLink";
import { auth } from "~/lib/auth-client";
import { useAppForm } from "~/lib/hooks/useAppForm";
import { authQueryKey } from "../auth.queries";
import { loginFormSchema } from "../auth.schemas";

type LoginFormProps = {
  redirectPath?: string | undefined;
};

export default function LoginForm(props?: LoginFormProps) {
  const queryClient = useQueryClient();
  const navigate = useNavigate();
  const router = useRouter();

  const safeRedirectPath = props?.redirectPath?.startsWith("/")
    ? props.redirectPath
    : "/dashboard";

  const [isHydrated, setIsHydrated] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [errorMessage, setErrorMessage] = useState("");

  useEffect(() => {
    // Form handlers need to wait for hydration; setting state here is intentional.
    // eslint-disable-next-line @eslint-react/hooks-extra/no-direct-set-state-in-use-effect
    setIsHydrated(true);
  }, []);

  const form = useAppForm({
    defaultValues: {
      email: "",
      password: "",
    },
    onSubmit: async ({ value }) => {
      setIsLoading(true);
      setErrorMessage("");

      try {
        const result = await auth.signIn.email(value);

        if (result?.error) {
          throw new Error(result.error.message || "Invalid email or password");
        }

        // Success path
        await queryClient.invalidateQueries({ queryKey: authQueryKey });
        await router.invalidate();
        await navigate({ to: safeRedirectPath });
      } catch (error) {
        // Error handling
        setErrorMessage((error as Error)?.message || "Invalid email or password");
        // Keep form values but reset submitting state by resetting with current values
        form.reset(value);
      } finally {
        // Always reset loading state
        setIsLoading(false);
      }
    },
  });

  return (
    <div className="flex flex-col gap-6">
      <form
        data-testid="login-form"
        data-hydrated={isHydrated ? "true" : "false"}
        onSubmit={async (e) => {
          e.preventDefault();
          e.stopPropagation();
          await form.handleSubmit();
        }}
      >
        <div className="flex flex-col gap-6">
          <div className="flex flex-col items-center gap-2">
            <a href="#" className="flex flex-col items-center gap-2 font-medium">
              <div className="flex h-8 w-8 items-center justify-center rounded-md">
                <LogoIcon className="size-6" />
              </div>
              <span className="sr-only">Quadball Canada</span>
            </a>
            <h1 className="text-xl font-bold">Welcome back to Quadball Canada</h1>
          </div>
          <div className="flex flex-col gap-5">
            <form.Field
              name="email"
              validators={{
                onChange: ({ value }) => {
                  try {
                    loginFormSchema.shape.email.parse(value);
                    return undefined;
                  } catch (error) {
                    if (error instanceof z.ZodError) {
                      return error.issues[0]?.message || "Invalid email";
                    }
                    return "Invalid email";
                  }
                },
              }}
            >
              {(field) => (
                <ValidatedInput
                  field={field}
                  label="Email"
                  type="email"
                  placeholder="hello@example.com"
                  autoComplete="email"
                  autoFocus
                />
              )}
            </form.Field>
            <form.Field
              name="password"
              validators={{
                onChange: ({ value }) => {
                  try {
                    loginFormSchema.shape.password.parse(value);
                    return undefined;
                  } catch (error) {
                    if (error instanceof z.ZodError) {
                      return error.issues[0]?.message || "Password is required";
                    }
                    return "Password is required";
                  }
                },
              }}
            >
              {(field) => (
                <ValidatedInput
                  field={field}
                  label="Password"
                  type="password"
                  placeholder="Password"
                  autoComplete="current-password"
                />
              )}
            </form.Field>
            <FormSubmitButton
              isSubmitting={form.state.isSubmitting || isLoading}
              className="mt-2 w-full"
              size="lg"
              loadingText="Logging in..."
            >
              Login
            </FormSubmitButton>
          </div>
          {errorMessage && (
            <span className="text-destructive text-center text-sm">{errorMessage}</span>
          )}
          <div className="after:border-border relative text-center text-sm after:absolute after:inset-0 after:top-1/2 after:z-0 after:flex after:items-center after:border-t">
            <span className="bg-background text-muted-foreground relative z-10 px-2">
              Or
            </span>
          </div>
          <Button
            variant="outline"
            className="w-full"
            type="button"
            disabled={isLoading || form.state.isSubmitting}
            onClick={() =>
              auth.signInWithOAuth(
                {
                  provider: "google",
                  callbackURL: safeRedirectPath,
                },
                {
                  onRequest: () => {
                    setIsLoading(true);
                    setErrorMessage("");
                  },
                  // eslint-disable-next-line @typescript-eslint/no-explicit-any
                  onError: (ctx: any) => {
                    setIsLoading(false);
                    setErrorMessage(ctx.error?.message || "OAuth login failed");
                  },
                },
              )
            }
          >
            <GoogleIcon />
            Login with Google
          </Button>
        </div>
      </form>

      <div className="text-center text-sm">
        Don&apos;t have an account?{" "}
        <Link to="/auth/signup" className="underline underline-offset-4">
          Sign up
        </Link>
      </div>
    </div>
  );
}
</file>

</files>
