This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/components/form-fields/FormSubmitButton.tsx, src/components/form-fields/ValidatedCheckbox.tsx, src/components/form-fields/ValidatedColorPicker.tsx, src/components/form-fields/ValidatedCombobox.tsx, src/components/form-fields/ValidatedDatePicker.tsx, src/components/form-fields/ValidatedFileUpload.tsx, src/components/form-fields/ValidatedInput.tsx, src/components/form-fields/ValidatedPhoneInput.tsx, src/components/form-fields/ValidatedSelect.tsx, src/lib/form.ts, src/lib/db/**/*.ts, src/lib/utils/**/*.ts, src/db/**/*.ts, src/features/events/events.*.ts, src/features/events/index.ts, src/features/events/components/**/*.tsx, src/features/events/utils/**/*.ts, src/features/teams/teams.schemas.ts, src/features/teams/teams.mutations.ts, src/features/teams/teams.queries.ts, src/features/profile/profile.schemas.ts, src/features/profile/profile.mutations.ts, src/features/profile/profile.queries.ts, src/features/profile/profile.types.ts, drizzle.config.ts, repomix-bundles/REQUIREMENTS-BUNDLE-2.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
repomix-bundles/
  REQUIREMENTS-BUNDLE-2.md
src/
  components/
    form-fields/
      FormSubmitButton.tsx
      ValidatedCheckbox.tsx
      ValidatedColorPicker.tsx
      ValidatedCombobox.tsx
      ValidatedDatePicker.tsx
      ValidatedFileUpload.tsx
      ValidatedInput.tsx
      ValidatedPhoneInput.tsx
      ValidatedSelect.tsx
  db/
    schema/
      auth.schema.ts
      events.schema.ts
      index.ts
      membership.schema.ts
      roles.schema.ts
      teams.schema.ts
    connections.ts
    index.ts
    server-helpers.ts
  features/
    events/
      components/
        event-create-form-minimal.tsx
        event-create-form.tsx
        event-list.tsx
      utils/
        index.ts
        jsonb.ts
        payment-metadata.ts
        pricing.ts
        time.ts
      events.db-types.ts
      events.mutations.ts
      events.queries.ts
      events.schemas.ts
      events.types.ts
      index.ts
    profile/
      profile.mutations.ts
      profile.queries.ts
      profile.schemas.ts
      profile.types.ts
    teams/
      teams.mutations.ts
      teams.queries.ts
      teams.schemas.ts
  lib/
    db/
      jsonb-utils.ts
    utils/
      csv-export.ts
    form.ts
drizzle.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="repomix-bundles/REQUIREMENTS-BUNDLE-2.md">
# Bundle 2: Data Collection, Forms & Validation

> **Your Task:** Implement or enhance the 6 requirements below for the viaSport Strength in Numbers (SIN) system.

---

## Requirements You Must Address

### DM-AGG-001: Data Collection & Submission
**Description:** The system shall enable customizable form building, support flexible data entry through variable formats (forms, file uploads), with capabilities for real-time submission tracking, editing, and historical data migration.

**Acceptance Criteria:** Users and System Admin can successfully submit, track, and edit data.

**Current Status:** 40% complete
- Form components exist (ValidatedInput, ValidatedSelect, ValidatedFileUpload, etc.)
- Zod schema validation
- No dynamic/customizable form builder

**Gaps to Implement:**
- [ ] Admin UI to create custom forms (drag-and-drop field builder)
- [ ] Form template system (save/load form configurations)
- [ ] Real-time submission tracking dashboard
- [ ] Submission editing with version history
- [ ] File upload with multiple format support

---

### DM-AGG-002: Data Processing & Integration
**Description:** The system shall enable standardization of data formatting, logging of transformation processes, and integration with external platforms through API (optional), and data import/export mechanisms.

**Acceptance Criteria:** Incoming data is processed uniformly, logged for traceability, and exchanged with external platforms.

**Current Status:** 30% complete
- Zod schemas standardize data formats
- CSV export utility exists
- No bulk import or API integration

**Gaps to Implement:**
- [ ] Data transformation logging (track what changed during processing)
- [ ] Bulk data import from CSV/Excel
- [ ] Field mapping UI for imports
- [ ] Export to multiple formats (CSV, Excel, JSON)
- [ ] Optional: REST API for external platform integration

---

### DM-AGG-004: Data Quality & Integrity
**Description:** The system shall ensure relational integrity and continuously monitor data quality using validation rules and automated checks.

**Acceptance Criteria:** Submitted data meets validation rules.

**Current Status:** 75% complete
- Drizzle ORM enforces relational integrity
- Zod schemas validate all inputs
- Foreign key constraints in database

**Gaps to Implement:**
- [ ] Data quality dashboard (show validation errors, missing fields)
- [ ] Automated data quality checks (scheduled jobs)
- [ ] Custom validation rules per form/field
- [ ] Data completeness scoring

---

### DM-AGG-005: Data Storage & Retention
**Description:** The system shall support regular backups, disaster recovery mechanisms, data archiving, and secure cloud hosting aligned with retention policies.

**Acceptance Criteria:** Data is backed up, archived as scheduled, and securely hosted in the cloud.

**Current Status:** 80% complete
- Neon PostgreSQL with managed backups
- Netlify cloud hosting
- Connection pooling for reliability

**Gaps to Implement:**
- [ ] Data retention policy configuration (per data type)
- [ ] Automated archiving of old data
- [ ] Archive retrieval workflow
- [ ] Backup verification/testing procedures

---

### DM-AGG-006: Legacy Data Migration & Bulk Import
**Description:** The system shall provide tooling and configurable mapping templates to import historical data from CSV/Excel, legacy databases, or APIs, including validation, error-handling, and rollback.

**Acceptance Criteria:** Administrators can map legacy fields to system fields, preview results, and execute import; import logs stored for audit.

**Current Status:** 0% complete
- No migration tooling exists

**Gaps to Implement:**
- [ ] CSV/Excel file upload for bulk import
- [ ] Field mapping UI (source field → target field)
- [ ] Data preview before import execution
- [ ] Validation with error reporting per row
- [ ] Import rollback capability
- [ ] Import audit logs (who, when, what, success/failure)
- [ ] Configurable mapping templates (save/reuse mappings)

---

### RP-AGG-001: Data Validation & Submission Rules
**Description:** The system shall validate submissions to ensure they are complete, clean, use the correct file types, and contain valid data fields such as dates and contact information.

**Acceptance Criteria:** Submissions that fail validation are rejected with appropriate error messages.

**Current Status:** 80% complete
- Zod schemas validate all server function inputs
- Form-level validation with error messages
- File type validation in ValidatedFileUpload

**Gaps to Implement:**
- [ ] Configurable validation rules per submission type
- [ ] Enhanced date/contact validation helpers
- [ ] Validation rule builder for admins
- [ ] Submission completeness checker

---

## Context: viaSport SIN Project

viaSport BC is replacing legacy systems (BC Activity Reporter and BC Sport Information System) with a modern platform for B.C. amateur sport data management.

**Key Context:**
- Historical data: 20+ million rows to migrate
- Growth: ~1M rows per year
- Object storage: Hundreds of documents per year
- File formats: CSV, Excel from legacy systems

## Existing Patterns to Follow

The codebase uses these patterns for data handling:

```typescript
// Schema pattern (see events.schemas.ts, teams.schemas.ts)
export const mySchema = z.object({
  field: z.string().min(1),
  // ...
});

// Server function pattern (see events.mutations.ts)
export const myServerFn = createServerFn({ method: "POST" })
  .inputValidator(mySchema.parse)
  .handler(async ({ data }) => {
    // Implementation
  });

// Form component pattern (see ValidatedInput.tsx)
<ValidatedInput form={form} name="fieldName" label="Field Label" />
```
</file>

<file path="src/db/schema/auth.schema.ts">
import { boolean, integer, pgTable, text, timestamp } from "drizzle-orm/pg-core";

export const user = pgTable("user", {
  id: text("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  emailVerified: boolean("email_verified")
    .$defaultFn(() => false)
    .notNull(),
  image: text("image"),
  createdAt: timestamp("created_at")
    .$defaultFn(() => /* @__PURE__ */ new Date())
    .notNull(),
  updatedAt: timestamp("updated_at")
    .$defaultFn(() => /* @__PURE__ */ new Date())
    .notNull(),
  // Profile completion tracking
  profileComplete: boolean("profile_complete")
    .$defaultFn(() => false)
    .notNull(),

  // Required profile fields
  dateOfBirth: timestamp("date_of_birth"),
  emergencyContact: text("emergency_contact"), // JSON string

  // Optional profile fields
  gender: text("gender"),
  pronouns: text("pronouns"),
  phone: text("phone"),

  // Privacy and preferences
  privacySettings: text("privacy_settings"), // JSON string

  // Audit and versioning
  profileVersion: integer("profile_version")
    .$defaultFn(() => 1)
    .notNull(),
  profileUpdatedAt: timestamp("profile_updated_at").$defaultFn(() => new Date()),
});

export const session = pgTable("session", {
  id: text("id").primaryKey(),
  expiresAt: timestamp("expires_at").notNull(),
  token: text("token").notNull().unique(),
  createdAt: timestamp("created_at").notNull(),
  updatedAt: timestamp("updated_at").notNull(),
  ipAddress: text("ip_address"),
  userAgent: text("user_agent"),
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
});

export const account = pgTable("account", {
  id: text("id").primaryKey(),
  accountId: text("account_id").notNull(),
  providerId: text("provider_id").notNull(),
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  accessToken: text("access_token"),
  refreshToken: text("refresh_token"),
  idToken: text("id_token"),
  accessTokenExpiresAt: timestamp("access_token_expires_at"),
  refreshTokenExpiresAt: timestamp("refresh_token_expires_at"),
  scope: text("scope"),
  password: text("password"),
  createdAt: timestamp("created_at").notNull(),
  updatedAt: timestamp("updated_at").notNull(),
});

export const verification = pgTable("verification", {
  id: text("id").primaryKey(),
  identifier: text("identifier").notNull(),
  value: text("value").notNull(),
  expiresAt: timestamp("expires_at").notNull(),
  createdAt: timestamp("created_at").$defaultFn(() => /* @__PURE__ */ new Date()),
  updatedAt: timestamp("updated_at").$defaultFn(() => /* @__PURE__ */ new Date()),
});
</file>

<file path="src/features/profile/profile.types.ts">
export interface EmergencyContact {
  name: string;
  relationship: string;
  phone?: string;
  email?: string;
}

export interface PrivacySettings {
  showEmail: boolean;
  showPhone: boolean;
  showBirthYear: boolean;
  allowTeamInvitations: boolean;
}

export interface UserProfile {
  id: string;
  name: string;
  email: string;
  profileComplete: boolean;
  dateOfBirth?: Date | undefined;
  emergencyContact?: EmergencyContact | undefined;
  gender?: string | undefined;
  pronouns?: string | undefined;
  phone?: string | undefined;
  privacySettings?: PrivacySettings | undefined;
  profileVersion: number;
  profileUpdatedAt?: Date | undefined;
}

export interface ProfileInput {
  dateOfBirth: Date;
  emergencyContact?: EmergencyContact;
  gender?: string;
  pronouns?: string;
  phone?: string;
  privacySettings?: PrivacySettings;
}

export interface ProfileError {
  field?: string;
  message: string;
  code:
    | "VALIDATION_ERROR"
    | "MISSING_REQUIRED_FIELD"
    | "INVALID_FORMAT"
    | "DATABASE_ERROR";
}

export interface ProfileOperationResult {
  success: boolean;
  data?: UserProfile;
  errors?: ProfileError[];
}

export const defaultPrivacySettings: PrivacySettings = {
  showEmail: false,
  showPhone: false,
  showBirthYear: true,
  allowTeamInvitations: true,
};
</file>

<file path="drizzle.config.ts">
import type { Config } from "drizzle-kit";

// Use unpooled connection for migrations
// Priority: DATABASE_URL_UNPOOLED > NETLIFY_DATABASE_URL_UNPOOLED > DATABASE_URL
const getDatabaseUrl = () => {
  return (
    process.env["DATABASE_URL_UNPOOLED"] ||
    process.env["NETLIFY_DATABASE_URL_UNPOOLED"] ||
    (process.env["DATABASE_URL"] as string)
  );
};

export default {
  out: "./src/db/migrations",
  schema: "./src/db/schema/index.ts",
  breakpoints: true,
  verbose: true,
  strict: true,
  dialect: "postgresql",
  casing: "snake_case",
  dbCredentials: {
    url: getDatabaseUrl(),
  },
} satisfies Config;
</file>

<file path="src/components/form-fields/FormSubmitButton.tsx">
import React from "react";
import { Button } from "~/components/ui/button";
import { Loader2 } from "~/components/ui/icons";
import { cn } from "~/shared/lib/utils";

interface FormSubmitButtonProps extends React.ComponentProps<typeof Button> {
  isSubmitting?: boolean;
  loadingText?: string;
}

export const FormSubmitButton: React.FC<FormSubmitButtonProps> = ({
  isSubmitting = false,
  loadingText,
  children,
  disabled,
  className,
  ...props
}) => {
  return (
    <Button
      type="submit"
      disabled={disabled || isSubmitting}
      className={cn(className)}
      {...props}
    >
      {isSubmitting ? (
        <>
          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
          {loadingText || "Loading..."}
        </>
      ) : (
        children
      )}
    </Button>
  );
};
</file>

<file path="src/components/form-fields/ValidatedColorPicker.tsx">
import React from "react";
import { Label } from "~/components/ui/label";
import { FieldComponentProps, isFieldApi } from "~/lib/form";
import { cn } from "~/shared/lib/utils";

interface ValidatedColorPickerProps extends FieldComponentProps {
  description?: string;
}

export const ValidatedColorPicker: React.FC<ValidatedColorPickerProps> = (props) => {
  const { field, label, className, description } = props;

  if (!isFieldApi(field)) {
    console.error("ValidatedColorPicker requires a valid field prop.", { field, props });
    return null;
  }

  const inputId = `${field.name}-color-picker`;
  const meta = field.state.meta;

  // Preset colors for quick selection
  const presetColors = [
    "#E2E2E2", // Light gray
    "#ff75c3", // Pink
    "#ffa647", // Orange
    "#ffe83f", // Yellow
    "#9fff5b", // Light green
    "#70e2ff", // Light blue
    "#cd93ff", // Purple
    "#09203f", // Dark blue
  ];

  return (
    <div className={cn("space-y-2", className)}>
      <Label htmlFor={inputId}>{label}</Label>
      {description && <p className="text-muted-foreground text-sm">{description}</p>}
      <div className="flex flex-col gap-3">
        {/* Color input with visual preview */}
        <div className="flex items-center gap-2">
          <input
            type="color"
            id={inputId}
            name={field.name}
            value={field.state.value || "#000000"}
            onChange={(e) => field.handleChange(e.target.value)}
            onBlur={field.handleBlur}
            className="border-input h-10 w-20 cursor-pointer rounded border"
            aria-invalid={!!meta.errors.length}
            aria-describedby={meta.errors.length ? `${inputId}-errors` : undefined}
          />
          <input
            type="text"
            value={field.state.value || "#000000"}
            onChange={(e) => field.handleChange(e.target.value)}
            onBlur={field.handleBlur}
            placeholder="#000000"
            className={cn(
              "border-input bg-background ring-offset-background placeholder:text-muted-foreground focus-visible:ring-ring flex h-10 w-32 rounded-md border px-3 py-2 text-sm focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
              meta.isTouched && meta.errors.length > 0 && "border-destructive",
            )}
            disabled={field.form.state.isSubmitting}
          />
          <span className="text-muted-foreground text-sm">
            {field.state.value || "#000000"}
          </span>
        </div>

        {/* Preset color palette */}
        <div className="flex flex-wrap gap-1">
          {presetColors.map((color) => (
            <button
              key={color}
              type="button"
              className={cn(
                "h-6 w-6 rounded-md border border-neutral-200 shadow-sm transition-all hover:scale-110 dark:border-neutral-800",
                field.state.value === color &&
                  "ring-2 ring-neutral-900 ring-offset-1 dark:ring-neutral-400",
              )}
              style={{ backgroundColor: color }}
              onClick={() => field.handleChange(color)}
              aria-label={`Select color ${color}`}
            />
          ))}
        </div>
      </div>
      {meta.isTouched && meta.errors.length > 0 && (
        <div id={`${inputId}-errors`} className="text-destructive text-sm font-medium">
          {meta.errors.join(", ")}
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/components/form-fields/ValidatedCombobox.tsx">
import React, { useState } from "react";
import { Button } from "~/components/ui/button";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "~/components/ui/command";
import { CheckIcon, ChevronsUpDownIcon } from "~/components/ui/icons";
import { Label } from "~/components/ui/label";
import { Popover, PopoverContent, PopoverTrigger } from "~/components/ui/popover";
import { FieldComponentProps, isFieldApi } from "~/lib/form";
import { cn } from "~/shared/lib/utils";

interface ValidatedComboboxProps extends FieldComponentProps {
  options: Array<{ value: string; label: string }>;
  searchPlaceholder?: string;
  emptyText?: string;
}

export const ValidatedCombobox: React.FC<ValidatedComboboxProps> = (props) => {
  const {
    field,
    label,
    placeholder = "Select an option...",
    className,
    options,
    searchPlaceholder = "Search...",
    emptyText = "No option found.",
  } = props;

  const [open, setOpen] = useState(false);

  if (!isFieldApi(field)) {
    console.error("ValidatedCombobox requires a valid field prop.", { field, props });
    return null;
  }

  const inputId = `${field.name}-combobox`;
  const meta = field.state.meta;
  const selectedOption = options.find((option) => option.value === field.state.value);

  return (
    <div className={cn("space-y-2", className)}>
      <Label htmlFor={inputId}>{label}</Label>
      <Popover open={open} onOpenChange={setOpen}>
        <PopoverTrigger asChild>
          <Button
            id={inputId}
            variant="outline"
            role="combobox"
            aria-expanded={open}
            aria-invalid={!!meta.errors.length}
            aria-describedby={meta.errors.length ? `${inputId}-errors` : undefined}
            className={cn(
              "w-full justify-between",
              !selectedOption && "text-muted-foreground",
            )}
            disabled={field.form.state.isSubmitting}
          >
            {selectedOption ? selectedOption.label : placeholder}
            <ChevronsUpDownIcon className="ml-2 h-4 w-4 shrink-0 opacity-50" />
          </Button>
        </PopoverTrigger>
        <PopoverContent className="w-[--radix-popover-trigger-width] p-0" align="start">
          <Command>
            <CommandInput placeholder={searchPlaceholder} />
            <CommandList>
              <CommandEmpty>{emptyText}</CommandEmpty>
              <CommandGroup>
                {options.map((option) => (
                  <CommandItem
                    key={option.value}
                    value={option.label}
                    onSelect={() => {
                      field.handleChange(option.value);
                      setOpen(false);
                    }}
                  >
                    <CheckIcon
                      className={cn(
                        "mr-2 h-4 w-4",
                        field.state.value === option.value ? "opacity-100" : "opacity-0",
                      )}
                    />
                    {option.label}
                  </CommandItem>
                ))}
              </CommandGroup>
            </CommandList>
          </Command>
        </PopoverContent>
      </Popover>
      {meta.isTouched && meta.errors.length > 0 && (
        <div id={`${inputId}-errors`} className="text-destructive text-sm font-medium">
          {meta.errors.join(", ")}
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/components/form-fields/ValidatedFileUpload.tsx">
import { useEffect, useMemo, useState } from "react";
import { Button } from "~/components/ui/button";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";
import { FieldComponentProps } from "~/lib/form";
import { cn } from "~/shared/lib/utils";

interface ValidatedFileUploadProps extends FieldComponentProps {
  accept?: string;
  maxSizeMb?: number;
  description?: string;
  helperText?: string;
  previewAlt?: string;
}

export function ValidatedFileUpload(props: ValidatedFileUploadProps) {
  const {
    field,
    label,
    placeholder,
    className,
    accept = "image/*",
    maxSizeMb = 5,
    description,
    helperText,
    previewAlt = "Uploaded file preview",
  } = props;

  const inputId = `${field.name}-file-input`;
  const meta = field.state.meta;
  const currentValue = field.state.value as File | string | null | undefined;

  const [sizeError, setSizeError] = useState<string | null>(null);

  const objectUrl = useMemo(() => {
    if (currentValue instanceof File) {
      return URL.createObjectURL(currentValue);
    }
    if (typeof currentValue === "string" && currentValue.length > 0) {
      return currentValue;
    }
    return null;
  }, [currentValue]);

  useEffect(() => {
    if (currentValue instanceof File && objectUrl) {
      const revoke =
        typeof URL.revokeObjectURL === "function" ? URL.revokeObjectURL.bind(URL) : null;
      if (revoke) {
        return () => revoke(objectUrl);
      }
    }
    return undefined;
  }, [currentValue, objectUrl]);

  const humanReadableSize = useMemo(() => {
    if (currentValue instanceof File) {
      return formatFileSize(currentValue.size);
    }
    return null;
  }, [currentValue]);

  return (
    <div className={cn("space-y-3", className)}>
      <Label htmlFor={inputId}>{label}</Label>
      <div className="flex flex-col gap-3">
        <Input
          id={inputId}
          type="file"
          accept={accept}
          placeholder={placeholder}
          onBlur={field.handleBlur}
          disabled={field.form.state.isSubmitting}
          onChange={(event) => {
            const file = event.target.files?.[0];
            if (!file) {
              field.handleChange(null);
              setSizeError(null);
              return;
            }

            if (maxSizeMb && file.size > maxSizeMb * 1024 * 1024) {
              setSizeError(`File is too large. Maximum size is ${maxSizeMb}MB.`);
              event.target.value = "";
              return;
            }

            setSizeError(null);
            field.handleChange(file);
          }}
        />
        {helperText && <p className="text-xs text-gray-500">{helperText}</p>}
        {sizeError && <p className="text-destructive text-sm font-medium">{sizeError}</p>}

        {objectUrl && (
          <div className="rounded-lg border border-dashed border-gray-300 bg-gray-50 p-4">
            <p className="text-sm font-semibold text-gray-900">Selected file</p>
            <p className="text-xs text-gray-500">
              {currentValue instanceof File ? currentValue.name : "Existing upload"}
              {humanReadableSize ? ` · ${humanReadableSize}` : ""}
            </p>
            {accept.startsWith("image") && (
              <img
                src={objectUrl}
                alt={previewAlt}
                className="mt-3 max-h-48 w-full rounded-md object-cover"
                loading="lazy"
              />
            )}
            <div className="mt-3 flex justify-end">
              <Button
                type="button"
                variant="ghost"
                size="sm"
                onClick={() => {
                  field.handleChange(null);
                  setSizeError(null);
                }}
              >
                Remove file
              </Button>
            </div>
          </div>
        )}
      </div>
      {description && <p className="text-muted-foreground text-sm">{description}</p>}
      {meta.isTouched && meta.errors.length > 0 && (
        <div className="text-destructive text-sm font-medium">
          {meta.errors.join(", ")}
        </div>
      )}
    </div>
  );
}

function formatFileSize(bytes: number) {
  if (bytes < 1024) return `${bytes} bytes`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}
</file>

<file path="src/components/form-fields/ValidatedPhoneInput.tsx">
import { useMemo } from "react";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";
import { FieldComponentProps } from "~/lib/form";
import { cn } from "~/shared/lib/utils";

interface ValidatedPhoneInputProps extends FieldComponentProps {
  countryCode?: string;
  description?: string;
  disabled?: boolean;
  required?: boolean;
}

const DEFAULT_COUNTRY_CODE = "+1";

export function ValidatedPhoneInput(props: ValidatedPhoneInputProps) {
  const {
    field,
    label,
    placeholder = "(555) 123-4567",
    className,
    countryCode = DEFAULT_COUNTRY_CODE,
    description,
    disabled,
    required,
  } = props;

  const inputId = `${field.name}-phone-input`;
  const meta = field.state.meta;
  const normalizedDigits = useMemo(
    () => extractDigits(field.state.value as string | null, countryCode),
    [field.state.value, countryCode],
  );
  const formattedValue = formatForDisplay(normalizedDigits);

  return (
    <div className={cn("space-y-2", className)}>
      <Label htmlFor={inputId}>{label}</Label>
      <Input
        id={inputId}
        name={field.name}
        type="tel"
        inputMode="tel"
        autoComplete="tel"
        value={formattedValue}
        placeholder={placeholder}
        onBlur={field.handleBlur}
        onChange={(event) => {
          const digits = event.target.value.replace(/\D/g, "");
          const canonical =
            digits.length === 0 ? "" : ensureCountryCode(digits, countryCode);
          field.handleChange(canonical);
        }}
        disabled={field.form.state.isSubmitting || disabled}
        aria-invalid={!!meta.errors.length}
        aria-describedby={meta.errors.length ? `${inputId}-errors` : undefined}
        required={required}
      />
      {description && <p className="text-muted-foreground text-sm">{description}</p>}
      {meta.isTouched && meta.errors.length > 0 && (
        <div id={`${inputId}-errors`} className="text-destructive text-sm font-medium">
          {meta.errors.join(", ")}
        </div>
      )}
    </div>
  );
}

function extractDigits(value: string | null | undefined, countryCode: string) {
  if (!value) return "";
  const digitsOnly = value.replace(/\D/g, "");
  const normalizedCountry = countryCode.replace(/\D/g, "");
  if (digitsOnly.startsWith(normalizedCountry)) {
    return digitsOnly.slice(normalizedCountry.length).slice(0, 10);
  }
  return digitsOnly.slice(0, 10);
}

function ensureCountryCode(digits: string, countryCode: string) {
  const normalizedCountry = countryCode.replace(/\D/g, "");
  const trimmed = digits.startsWith(normalizedCountry)
    ? digits.slice(normalizedCountry.length)
    : digits;
  const limited = trimmed.slice(0, 10);
  return `${countryCode}${limited}`;
}

function formatForDisplay(digits: string) {
  if (!digits) return "";
  const part1 = digits.slice(0, 3);
  const part2 = digits.slice(3, 6);
  const part3 = digits.slice(6, 10);

  if (digits.length <= 3) {
    return `(${part1}`;
  }

  if (digits.length <= 6) {
    return `(${part1}) ${part2}`;
  }

  return `(${part1}) ${part2}-${part3}`;
}
</file>

<file path="src/db/schema/index.ts">
export * from "./auth.schema";
export * from "./events.schema";
export * from "./membership.schema";
export * from "./roles.schema";
export * from "./teams.schema";
</file>

<file path="src/db/index.ts">
import { closeConnections, getDb, pooledDb, unpooledDb } from "./connections";
import * as schema from "./schema";

// Export the auto-selected database connection based on environment
// This must be a function that is called within a server context.
export const db = getDb;

// Export specific connections for when you need explicit control
export { closeConnections, pooledDb, unpooledDb };

// Re-export all schemas and types
export * from "./schema";
export { schema };
</file>

<file path="src/features/events/components/event-create-form-minimal.tsx">
import { Button } from "~/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";

export function EventCreateFormMinimal() {
  return (
    <Card className="mx-auto max-w-2xl">
      <CardHeader>
        <CardTitle>Create New Event (Test)</CardTitle>
      </CardHeader>
      <CardContent>
        <p>This is a minimal test form to isolate the rendering issue.</p>
        <Button>Test Button</Button>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/events/utils/index.ts">
export * from "./jsonb";
export * from "./payment-metadata";
export * from "./pricing";
export * from "./time";
</file>

<file path="src/features/events/utils/payment-metadata.ts">
import type { EventPaymentMetadata } from "../events.db-types";
import type { Clock } from "./time";
import { isoTimestamp } from "./time";

export type ActorId = string;

/**
 * Capture a snapshot of the e-transfer instructions that were visible when the
 * registration was created. Keeps downstream finance emails consistent.
 */
export function buildEtransferSnapshot(
  instructions?: string | null,
  recipient?: string | null,
): EventPaymentMetadata {
  const metadata: EventPaymentMetadata = {};
  if (instructions) metadata.instructionsSnapshot = instructions;
  if (recipient) metadata.recipient = recipient;
  return metadata;
}

/** Record that an e-transfer was marked paid by a specific actor at a specific time. */
export function markEtransferPaidMetadata(
  existing: EventPaymentMetadata | undefined,
  actorId: ActorId,
  clock?: Clock,
): EventPaymentMetadata {
  const metadata: EventPaymentMetadata = { ...(existing ?? {}) };
  metadata.markedPaidAt = isoTimestamp(clock);
  metadata.markedPaidBy = actorId;
  return metadata;
}

/** Record that a reminder email was sent for an outstanding e-transfer. */
export function markEtransferReminderMetadata(
  existing: EventPaymentMetadata | undefined,
  actorId: ActorId,
  clock?: Clock,
): EventPaymentMetadata {
  const metadata: EventPaymentMetadata = { ...(existing ?? {}) };
  metadata.lastReminderAt = isoTimestamp(clock);
  metadata.lastReminderBy = actorId;
  return metadata;
}

/**
 * Optionally attach cancellation notes so finance/admin teams have context when
 * reviewing payment metadata.
 */
export function appendCancellationNote(
  existing: EventPaymentMetadata | undefined,
  note: string | undefined,
): EventPaymentMetadata {
  const metadata: EventPaymentMetadata = { ...(existing ?? {}) };
  if (note) {
    const existingNotes = metadata.notes ? metadata.notes.split("\n") : [];
    if (!existingNotes.includes(note)) {
      metadata.notes = existingNotes.length > 0 ? `${metadata.notes}\n${note}` : note;
    }
  }
  return metadata;
}
</file>

<file path="src/features/events/utils/pricing.ts">
import type { Event as DbEvent } from "~/db/schema";

/**
 * Calculate the registration amount in cents for a given event/registration type.
 * Applies early-bird discounts when eligible and handles zero/negative pricing.
 */
export function calculateRegistrationAmountCents(
  event: DbEvent,
  registrationType: "team" | "individual",
  now: Date,
): number {
  const baseFee =
    registrationType === "team"
      ? (event.teamRegistrationFee ?? 0)
      : (event.individualRegistrationFee ?? 0);

  if (!baseFee || baseFee <= 0) {
    return 0;
  }

  const discountPercentage = event.earlyBirdDiscount ?? 0;
  const deadline = event.earlyBirdDeadline ? new Date(event.earlyBirdDeadline) : null;

  if (discountPercentage > 0 && deadline && now <= deadline) {
    const clampedDiscount = Math.min(100, Math.max(0, discountPercentage));
    const discounted = Math.round(baseFee - (baseFee * clampedDiscount) / 100);
    return Math.max(0, discounted);
  }

  return baseFee;
}
</file>

<file path="src/features/events/utils/time.ts">
export interface Clock {
  now(): Date;
}

export const systemClock: Clock = {
  now: () => new Date(),
};

/** Returns the current Date using the provided or system clock. */
export const currentTimestamp = (clock: Clock = systemClock): Date => clock.now();

/** Returns an ISO string timestamp using the provided or system clock. */
export const isoTimestamp = (clock: Clock = systemClock): string =>
  clock.now().toISOString();

/** Retrieves a test clock from the server-fn context, falling back to the system clock. */
export const getClockFromContext = (context: unknown): Clock => {
  const candidate = (context as Record<string, unknown> | undefined)?.["clock"];
  if (candidate && typeof (candidate as Partial<Clock>).now === "function") {
    return candidate as Clock;
  }
  return systemClock;
};

/** Creates a clock that always returns the provided fixed instant. */
export const fixedClock = (at: Date | string | number): Clock => {
  const fixedDate = at instanceof Date ? at : new Date(at);
  return {
    now: () => fixedDate,
  };
};

/**
 * Creates a clock whose value can change. Useful for deterministic tests that need to
 * advance time in steps.
 */
export const mutableClock = (start: Date = new Date()) => {
  let current = start;
  return {
    now: () => current,
    set: (next: Date | string | number) => {
      current = next instanceof Date ? next : new Date(next);
    },
  } as Clock & { set: (next: Date | string | number) => void };
};
</file>

<file path="src/features/events/index.ts">
// Event queries
export {
  checkEventRegistration,
  getEvent,
  getUpcomingEvents,
  listEvents,
} from "./events.queries";

// Event mutations
export {
  cancelEvent,
  cancelEventRegistration,
  createEvent,
  registerForEvent,
  updateEvent,
} from "./events.mutations";

// Event types
export type {
  CreateEventInput,
  EventError,
  EventErrorCode,
  EventFilters,
  EventListResult,
  EventOperationResult,
  EventRegistrationInput,
  EventRegistrationWithDetails,
  EventStatus,
  EventType,
  EventWithDetails,
  RegistrationType,
  UpdateEventInput,
} from "./events.types";
</file>

<file path="src/lib/db/jsonb-utils.ts">
import { sql, type SQL } from "drizzle-orm";
import type { PgColumn } from "drizzle-orm/pg-core";

/**
 * Atomic JSONB merge utility for Drizzle ORM
 *
 * Uses PostgreSQL's `||` operator for atomic JSONB concatenation.
 * This prevents race conditions where concurrent updates would overwrite each other.
 *
 * @example
 * // Instead of:
 * .set({ metadata: { ...existing, newField: value } })
 *
 * // Use:
 * .set({ metadata: atomicJsonbMerge(table.metadata, { newField: value }) })
 */
export function atomicJsonbMerge<T extends Record<string, unknown>>(
  column: PgColumn,
  updates: T,
): SQL {
  // Use COALESCE to handle null columns, then merge with ||
  return sql`COALESCE(${column}, '{}'::jsonb) || ${JSON.stringify(updates)}::jsonb`;
}

/**
 * Atomic JSONB set for a specific path
 *
 * Uses PostgreSQL's `jsonb_set()` function for atomic path-based updates.
 *
 * @example
 * // Set metadata.lastUpdated = "2025-01-01"
 * .set({ metadata: atomicJsonbSet(table.metadata, ['lastUpdated'], '2025-01-01') })
 */
export function atomicJsonbSet(
  column: PgColumn,
  path: string[],
  value: unknown,
  createMissing = true,
): SQL {
  const pathArray = `{${path.join(",")}}`;
  return sql`jsonb_set(COALESCE(${column}, '{}'::jsonb), ${pathArray}::text[], ${JSON.stringify(value)}::jsonb, ${createMissing})`;
}

/**
 * Atomic JSONB delete for a specific key
 *
 * Uses PostgreSQL's `-` operator for atomic key removal.
 *
 * @example
 * // Remove the 'deprecated' key from metadata
 * .set({ metadata: atomicJsonbDelete(table.metadata, 'deprecated') })
 */
export function atomicJsonbDelete(column: PgColumn, key: string): SQL {
  return sql`COALESCE(${column}, '{}'::jsonb) - ${key}`;
}

/**
 * Atomic JSONB deep merge that preserves nested objects
 *
 * Uses a custom SQL expression that recursively merges objects.
 * For arrays, the new value replaces the old value.
 *
 * @example
 * // Deep merge nested settings
 * .set({ metadata: atomicJsonbDeepMerge(table.metadata, { settings: { theme: 'dark' } }) })
 */
export function atomicJsonbDeepMerge<T extends Record<string, unknown>>(
  column: PgColumn,
  updates: T,
): SQL {
  // PostgreSQL recursive merge using jsonb_strip_nulls to clean up
  return sql`(
    SELECT jsonb_object_agg(
      COALESCE(k1, k2),
      CASE
        WHEN v1 IS NULL THEN v2
        WHEN v2 IS NULL THEN v1
        WHEN jsonb_typeof(v1) = 'object' AND jsonb_typeof(v2) = 'object'
        THEN v1 || v2
        ELSE v2
      END
    )
    FROM jsonb_each(COALESCE(${column}, '{}'::jsonb)) e1(k1, v1)
    FULL OUTER JOIN jsonb_each(${JSON.stringify(updates)}::jsonb) e2(k2, v2)
    ON k1 = k2
  )`;
}
</file>

<file path="src/lib/utils/csv-export.ts">
/**
 * Utility for exporting data to CSV format
 */

export function exportToCSV<T extends Record<string, unknown>>(
  data: T[],
  filename: string,
  headers?: { [K in keyof T]?: string },
) {
  if (data.length === 0) {
    console.warn("No data to export");
    return;
  }

  // Get all unique keys from the data
  const keys = Object.keys(data[0]) as (keyof T)[];

  // Create header row
  const headerRow = keys
    .map((key) => {
      const headerLabel = headers?.[key] || String(key);
      // Escape quotes and wrap in quotes if needed
      return `"${String(headerLabel).replace(/"/g, '""')}"`;
    })
    .join(",");

  // Create data rows
  const dataRows = data.map((row) => {
    return keys
      .map((key) => {
        const value = row[key];

        // Handle different value types
        if (value === null || value === undefined) {
          return "";
        }

        if (value instanceof Date) {
          return `"${value.toISOString()}"`;
        }

        if (typeof value === "object") {
          return `"${JSON.stringify(value).replace(/"/g, '""')}"`;
        }

        // Convert to string and escape quotes
        const stringValue = String(value);

        // Wrap in quotes if contains comma, newline, or quotes
        if (
          stringValue.includes(",") ||
          stringValue.includes("\n") ||
          stringValue.includes('"')
        ) {
          return `"${stringValue.replace(/"/g, '""')}"`;
        }

        return stringValue;
      })
      .join(",");
  });

  // Combine header and data
  const csvContent = [headerRow, ...dataRows].join("\n");

  // Create blob and download
  const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
  const link = document.createElement("a");

  if (link.download !== undefined) {
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute("download", filename);
    link.style.visibility = "hidden";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }
}

/**
 * Format currency for display
 */
export function formatCurrency(cents: number): string {
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
  }).format(cents / 100);
}

/**
 * Format date for display
 */
export function formatDate(date: string | Date): string {
  const d = typeof date === "string" ? new Date(date) : date;
  return new Intl.DateTimeFormat("en-US", {
    year: "numeric",
    month: "short",
    day: "numeric",
  }).format(d);
}
</file>

<file path="src/lib/form.ts">
import { AnyFieldApi } from "@tanstack/react-form";
import React from "react";

// ---=== Helper Types ===---

// Base props for field components
export interface FieldComponentProps {
  field: AnyFieldApi;
  label: string;
  placeholder?: string;
  className?: string;
}

// Props for form submit button components
export interface FormSubmitButtonProps
  extends Omit<React.ComponentProps<"button">, "type" | "children"> {
  children?: React.ReactNode;
}

// Type guard to check if an object is a FieldApi instance
export function isFieldApi(obj: unknown): obj is AnyFieldApi {
  if (typeof obj !== "object" || obj === null) return false;

  // Check for essential field properties from TanStack Form v5
  const hasState = "state" in obj;
  const hasHandleChange = "handleChange" in obj;
  const hasHandleBlur = "handleBlur" in obj;
  const hasForm = "form" in obj;
  const hasName = "name" in obj;

  return hasState && hasHandleChange && hasHandleBlur && hasForm && hasName;
}
</file>

<file path="src/components/form-fields/ValidatedCheckbox.tsx">
import React from "react";
import { Checkbox } from "~/components/ui/checkbox";
import { Label } from "~/components/ui/label";
import { FieldComponentProps, isFieldApi } from "~/lib/form";
import { cn } from "~/shared/lib/utils";

interface ValidatedCheckboxProps extends FieldComponentProps {
  description?: string;
  disabled?: boolean;
}

export const ValidatedCheckbox: React.FC<ValidatedCheckboxProps> = (props) => {
  const { field, label, description, className, disabled = false } = props;

  if (!isFieldApi(field)) {
    console.error("ValidatedCheckbox requires a valid field prop.");
    return null;
  }

  const inputId = `${field.name}-checkbox`;
  const meta = field.state.meta;

  return (
    <div className={cn("space-y-2", className)}>
      <div className="flex items-center space-x-2">
        <Checkbox
          id={inputId}
          checked={!!field.state.value}
          onCheckedChange={(checked) => field.handleChange(!!checked)}
          onBlur={field.handleBlur}
          disabled={disabled || field.form.state.isSubmitting}
          aria-invalid={!!meta.errors.length}
          aria-describedby={
            [
              description ? `${inputId}-description` : null,
              meta.isTouched && meta.errors.length ? `${inputId}-errors` : null,
            ]
              .filter(Boolean)
              .join(" ") || undefined
          }
        />
        <Label
          htmlFor={inputId}
          className="cursor-pointer text-sm leading-none font-normal peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
        >
          {label}
        </Label>
      </div>
      {description && (
        <p id={`${inputId}-description`} className="text-muted-foreground ml-6 text-sm">
          {description}
        </p>
      )}
      {meta.isTouched && meta.errors.length > 0 && (
        <div
          id={`${inputId}-errors`}
          className="text-destructive ml-6 text-sm font-medium"
        >
          {meta.errors.join(", ")}
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/components/form-fields/ValidatedDatePicker.tsx">
import React from "react";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";
import { FieldComponentProps, isFieldApi } from "~/lib/form";
import { cn } from "~/shared/lib/utils";

interface ValidatedDatePickerProps extends FieldComponentProps {
  minAge?: number;
  maxAge?: number;
}

export const ValidatedDatePicker: React.FC<ValidatedDatePickerProps> = (props) => {
  const { field, label, minAge = 13, maxAge = 120, className } = props;

  if (!isFieldApi(field)) {
    console.error("ValidatedDatePicker requires a valid field prop.");
    return null;
  }

  const inputId = `${field.name}-date`;
  const meta = field.state.meta;

  // Calculate min and max dates based on age restrictions, using UTC for consistency
  const today = new Date();
  const maxDate = new Date(
    Date.UTC(today.getUTCFullYear() - minAge, today.getUTCMonth(), today.getUTCDate()),
  );
  const minDate = new Date(
    Date.UTC(today.getUTCFullYear() - maxAge, today.getUTCMonth(), today.getUTCDate()),
  );

  // Format date for input value using UTC components
  const formatDate = (date: Date | string | undefined): string => {
    if (!date) return "";
    const d = typeof date === "string" ? new Date(date) : date;
    if (isNaN(d.getTime())) return "";
    const year = d.getUTCFullYear();
    const month = String(d.getUTCMonth() + 1).padStart(2, "0");
    const day = String(d.getUTCDate()).padStart(2, "0");
    return `${year}-${month}-${day}`;
  };

  return (
    <div className={cn("space-y-2", className)}>
      <Label htmlFor={inputId}>{label}</Label>
      <Input
        id={inputId}
        type="date"
        value={formatDate(field.state.value)}
        onChange={(e) => {
          const value = e.target.value;
          if (value) {
            // Parse the date string as UTC to prevent timezone shifts
            const [year, month, day] = value.split("-").map(Number);
            const date = new Date(Date.UTC(year, month - 1, day));
            // Always store a UTC midnight ISO string so client & server match
            field.handleChange(date.toISOString().split("T")[0]);
          } else {
            field.handleChange(undefined);
          }
        }}
        onBlur={field.handleBlur}
        min={formatDate(minDate)}
        max={formatDate(maxDate)}
        disabled={field.form.state.isSubmitting}
        aria-invalid={!!meta.errors.length}
        aria-describedby={meta.errors.length ? `${inputId}-errors` : undefined}
      />
      <p className="text-muted-foreground text-sm">
        You must be between {minAge} and {maxAge} years old
      </p>
      {meta.isTouched && meta.errors.length > 0 && (
        <div id={`${inputId}-errors`} className="text-destructive text-sm font-medium">
          {meta.errors.join(", ")}
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/db/schema/roles.schema.ts">
import { sql } from "drizzle-orm";
import { boolean, index, jsonb, pgTable, text, timestamp } from "drizzle-orm/pg-core";
import { user } from "./auth.schema";

/**
 * Roles table - defines available roles in the system
 */
export const roles = pgTable("roles", {
  id: text("id")
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  name: text("name").notNull().unique(),
  description: text("description"),
  permissions: jsonb("permissions")
    .$type<Record<string, boolean>>()
    .notNull()
    .default({}),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
});

/**
 * User roles assignment table - maps users to roles with optional scope
 */
export const userRoles = pgTable(
  "user_roles",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    roleId: text("role_id")
      .notNull()
      .references(() => roles.id, { onDelete: "cascade" }),
    // Scope fields (NULL for global roles)
    teamId: text("team_id"),
    eventId: text("event_id"),
    // Metadata
    assignedBy: text("assigned_by")
      .notNull()
      .references(() => user.id),
    assignedAt: timestamp("assigned_at", { withTimezone: true }).notNull().defaultNow(),
    expiresAt: timestamp("expires_at", { withTimezone: true }),
    notes: text("notes"),
  },
  (table) => [
    index("idx_user_roles_user_id").on(table.userId),
    index("idx_user_roles_team_id")
      .on(table.teamId)
      .where(sql`${table.teamId} IS NOT NULL`),
    index("idx_user_roles_event_id")
      .on(table.eventId)
      .where(sql`${table.eventId} IS NOT NULL`),
    index("idx_user_roles_unique").on(
      table.userId,
      table.roleId,
      table.teamId,
      table.eventId,
    ),
  ],
);

/**
 * Tags table - for user categorization (future implementation)
 */
export const tags = pgTable("tags", {
  id: text("id")
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  name: text("name").notNull().unique(),
  category: text("category").notNull(), // 'official', 'team', 'player', 'custom'
  description: text("description"),
  color: text("color"), // For UI display
  icon: text("icon"), // Icon identifier
  isActive: boolean("is_active").default(true),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
});

/**
 * User tags assignment table (future implementation)
 */
export const userTags = pgTable(
  "user_tags",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    tagId: text("tag_id")
      .notNull()
      .references(() => tags.id, { onDelete: "cascade" }),
    assignedBy: text("assigned_by").references(() => user.id),
    assignedAt: timestamp("assigned_at", { withTimezone: true }).notNull().defaultNow(),
    expiresAt: timestamp("expires_at", { withTimezone: true }),
    notes: text("notes"),
  },
  (table) => [
    index("idx_user_tags_user_id").on(table.userId),
    index("idx_user_tags_tag_id").on(table.tagId),
    index("idx_user_tags_expires_at")
      .on(table.expiresAt)
      .where(sql`${table.expiresAt} IS NOT NULL`),
    index("idx_user_tags_unique").on(table.userId, table.tagId),
  ],
);

// Type exports for TypeScript
export type Role = typeof roles.$inferSelect;
export type NewRole = typeof roles.$inferInsert;
export type UserRole = typeof userRoles.$inferSelect;
export type NewUserRole = typeof userRoles.$inferInsert;
export type Tag = typeof tags.$inferSelect;
export type NewTag = typeof tags.$inferInsert;
export type UserTag = typeof userTags.$inferSelect;
export type NewUserTag = typeof userTags.$inferInsert;
</file>

<file path="src/db/schema/teams.schema.ts">
import { createId } from "@paralleldrive/cuid2";
import { relations, sql } from "drizzle-orm";
import {
  index,
  integer,
  pgEnum,
  pgTable,
  text,
  timestamp,
  uniqueIndex,
  varchar,
} from "drizzle-orm/pg-core";
import { user } from "./auth.schema";

// Enum for team member roles
export const teamMemberRoleEnum = pgEnum("team_member_role", [
  "captain",
  "coach",
  "player",
  "substitute",
]);

// Enum for team member status
export const teamMemberStatusEnum = pgEnum("team_member_status", [
  "pending",
  "active",
  "inactive",
  "removed",
]);

/**
 * Teams table
 * Stores team information for Quadball teams
 */
export const teams = pgTable(
  "teams",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => createId()),
    name: varchar("name", { length: 255 }).notNull(),
    slug: varchar("slug", { length: 255 }).notNull().unique(),
    description: text("description"),
    city: varchar("city", { length: 255 }),
    province: varchar("province", { length: 2 }), // ON, BC, etc.
    logoUrl: text("logo_url"),
    primaryColor: varchar("primary_color", { length: 7 }), // Hex color
    secondaryColor: varchar("secondary_color", { length: 7 }), // Hex color
    foundedYear: varchar("founded_year", { length: 4 }),
    website: text("website"),
    socialLinks: text("social_links"), // JSON string of social media links
    isActive: text("is_active").default("true").notNull(),
    createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
    updatedAt: timestamp("updated_at", { withTimezone: true })
      .notNull()
      .defaultNow()
      .$onUpdate(() => new Date()),
    createdBy: text("created_by")
      .notNull()
      .references(() => user.id),
  },
  (table) => [
    uniqueIndex("teams_slug_idx").on(table.slug),
    index("teams_created_by_idx").on(table.createdBy),
    index("teams_is_active_idx").on(table.isActive),
  ],
);

/**
 * Team members junction table
 * Manages the many-to-many relationship between users and teams
 */
export const teamMembers = pgTable(
  "team_members",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => createId()),
    teamId: text("team_id")
      .notNull()
      .references(() => teams.id, { onDelete: "cascade" }),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    role: teamMemberRoleEnum("role").notNull().default("player"),
    status: teamMemberStatusEnum("status").notNull().default("pending"),
    jerseyNumber: varchar("jersey_number", { length: 3 }),
    position: varchar("position", { length: 50 }), // Chaser, Beater, Keeper, Seeker
    joinedAt: timestamp("joined_at", { withTimezone: true }).notNull().defaultNow(),
    leftAt: timestamp("left_at", { withTimezone: true }),
    invitedBy: text("invited_by").references(() => user.id),
    notes: text("notes"),
    invitedAt: timestamp("invited_at", { withTimezone: true }),
    lastInvitationReminderAt: timestamp("last_invitation_reminder_at", {
      withTimezone: true,
    }),
    invitationReminderCount: integer("invitation_reminder_count").notNull().default(0),
    requestedAt: timestamp("requested_at", { withTimezone: true }),
  },
  (table) => [
    uniqueIndex("team_members_team_user_idx").on(table.teamId, table.userId),
    index("team_members_team_status_idx").on(table.teamId, table.status),
    index("team_members_user_status_idx").on(table.userId, table.status),
    uniqueIndex("team_members_active_user_idx")
      .on(table.userId)
      .where(sql`status = 'active'`),
  ],
);

// Relations
export const teamsRelations = relations(teams, ({ many, one }) => ({
  members: many(teamMembers),
  creator: one(user, {
    fields: [teams.createdBy],
    references: [user.id],
  }),
}));

export const teamMembersRelations = relations(teamMembers, ({ one }) => ({
  team: one(teams, {
    fields: [teamMembers.teamId],
    references: [teams.id],
  }),
  user: one(user, {
    fields: [teamMembers.userId],
    references: [user.id],
  }),
  inviter: one(user, {
    fields: [teamMembers.invitedBy],
    references: [user.id],
  }),
}));

// Types
export type Team = typeof teams.$inferSelect;
export type NewTeam = typeof teams.$inferInsert;
export type TeamMember = typeof teamMembers.$inferSelect;
export type NewTeamMember = typeof teamMembers.$inferInsert;
export type TeamMemberRole = (typeof teamMemberRoleEnum.enumValues)[number];
export type TeamMemberStatus = (typeof teamMemberStatusEnum.enumValues)[number];
</file>

<file path="src/db/server-helpers.ts">
import { createServerOnlyFn } from "@tanstack/react-start";

/**
 * Server-only helper to get the database connection
 * This ensures the database module is never included in the client bundle
 */
export const getDb = createServerOnlyFn(async () => {
  const { db } = await import("~/db");
  return db();
});

/**
 * Server-only helper to get the unpooled database connection
 * Use this for migrations and long-running operations
 */
export const getUnpooledDb = createServerOnlyFn(async () => {
  const { unpooledDb } = await import("~/db");
  return unpooledDb();
});
</file>

<file path="src/features/events/utils/jsonb.ts">
import type { Event as DbEvent, EventRegistration } from "~/db/schema";
import type {
  EventAmenities,
  EventDivisions,
  EventMetadata,
  EventPaymentMetadata,
  EventRegistrationRoster,
  EventRequirements,
  EventRules,
  EventSchedule,
} from "../events.db-types";
import type { EventWithDetails } from "../events.types";

export type EventRegistrationWithRoster = Omit<
  EventRegistration,
  "roster" | "paymentMetadata"
> & {
  roster: EventRegistrationRoster;
  paymentMetadata: EventPaymentMetadata | null;
};

export function castEventJsonbFields(event: DbEvent): EventWithDetails {
  return {
    ...event,
    rules: (event.rules || {}) as EventRules,
    schedule: (event.schedule || {}) as EventSchedule,
    divisions: (event.divisions || {}) as EventDivisions,
    amenities: (event.amenities || {}) as EventAmenities,
    requirements: (event.requirements || {}) as EventRequirements,
    metadata: (event.metadata || {}) as EventMetadata,
  } as EventWithDetails;
}

export function castRegistrationJsonbFields(
  registration: EventRegistration,
): EventRegistrationWithRoster {
  return {
    ...registration,
    roster: (registration.roster || {}) as EventRegistrationRoster,
    paymentMetadata: registration.paymentMetadata
      ? (registration.paymentMetadata as EventPaymentMetadata)
      : null,
  };
}
</file>

<file path="src/features/events/events.db-types.ts">
/**
 * Type definitions for events database jsonb fields
 */

/* eslint-disable @typescript-eslint/no-explicit-any */

export interface EventRules {
  [key: string]: any;
}

export interface EventScheduleItem {
  time: string;
  activity: string;
  location?: string;
  notes?: string;
}

export interface EventSchedule {
  items?: EventScheduleItem[];
  [key: string]: any;
}

export interface EventDivision {
  name: string;
  maxTeams?: number;
  description?: string;
  [key: string]: any;
}

export interface EventDivisions {
  divisions?: EventDivision[];
  [key: string]: any;
}

export type EventAmenity = string;

export interface EventAmenities {
  amenities?: EventAmenity[];
  [key: string]: any;
}

export type EventRequirement = string;

export interface EventRequirements {
  requirements?: EventRequirement[];
  [key: string]: any;
}

export interface EventMetadata {
  [key: string]: any;
}

export interface EventRegistrationRosterPlayer {
  userId: string;
  name?: string;
  role?: string;
  jerseyNumber?: string;
  [key: string]: any;
}

export interface EventRegistrationRoster {
  players?: EventRegistrationRosterPlayer[];
  [key: string]: any;
}

export interface EventPaymentMetadata {
  instructionsSnapshot?: string;
  recipient?: string;
  lastReminderAt?: string;
  lastReminderBy?: string;
  markedPaidAt?: string;
  markedPaidBy?: string;
  notes?: string;
  [key: string]: any;
}
</file>

<file path="src/components/form-fields/ValidatedSelect.tsx">
import React from "react";
import { Label } from "~/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";
import { FieldComponentProps, isFieldApi } from "~/lib/form";
import { cn } from "~/shared/lib/utils";

interface ValidatedSelectProps extends FieldComponentProps {
  options: Array<{ value: string; label: string }>;
  placeholderText?: string;
  required?: boolean;
}

export const ValidatedSelect: React.FC<ValidatedSelectProps> = (props) => {
  const {
    field,
    label,
    options,
    placeholderText = "Select an option",
    className,
    required,
  } = props;

  if (!isFieldApi(field)) {
    console.error("ValidatedSelect requires a valid field prop.");
    return null;
  }

  const selectId = `${field.name}-select`;
  const meta = field.state.meta;
  const EMPTY_OPTION_VALUE = "__empty_option__";
  const placeholderOption = options.find((option) => option.value === "");
  const normalizedOptions = options.map((option) =>
    option.value === "" ? { ...option, value: EMPTY_OPTION_VALUE } : option,
  );
  const selectValue = placeholderOption
    ? field.state.value === "" || field.state.value === undefined
      ? EMPTY_OPTION_VALUE
      : (field.state.value as string)
    : ((field.state.value as string | undefined) ?? undefined);

  return (
    <div className={cn("space-y-2", className)}>
      <Label htmlFor={selectId}>{label}</Label>
      <Select
        {...(selectValue !== undefined ? { value: selectValue } : {})}
        onValueChange={(value) => {
          const normalizedValue =
            placeholderOption && value === EMPTY_OPTION_VALUE ? "" : value;
          field.handleChange(normalizedValue);
        }}
        disabled={field.form.state.isSubmitting}
      >
        <SelectTrigger
          id={selectId}
          aria-invalid={!!meta.errors.length}
          aria-required={required}
          aria-describedby={meta.errors.length ? `${selectId}-errors` : undefined}
        >
          <SelectValue placeholder={placeholderOption?.label ?? placeholderText} />
        </SelectTrigger>
        <SelectContent>
          {normalizedOptions.map((option) => (
            <SelectItem key={option.value} value={option.value}>
              {option.label}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
      {meta.isTouched && meta.errors.length > 0 && (
        <div id={`${selectId}-errors`} className="text-destructive text-sm font-medium">
          {meta.errors.join(", ")}
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/db/schema/membership.schema.ts">
import { createId } from "@paralleldrive/cuid2";
import { sql } from "drizzle-orm";
import {
  date,
  index,
  integer,
  jsonb,
  pgTable,
  timestamp,
  uniqueIndex,
  varchar,
} from "drizzle-orm/pg-core";
import { user } from "./auth.schema";

export const membershipTypes = pgTable(
  "membership_types",
  {
    id: varchar("id", { length: 255 })
      .$defaultFn(() => createId())
      .primaryKey(),
    name: varchar("name", { length: 255 }).notNull(),
    description: varchar("description", { length: 1000 }),
    priceCents: integer("price_cents").notNull(),
    durationMonths: integer("duration_months").notNull(),
    status: varchar("status", { length: 50 })
      .$type<"active" | "inactive">()
      .notNull()
      .default("active"),
    metadata: jsonb("metadata").$type<Record<string, unknown>>(),
    createdAt: timestamp("created_at").notNull().defaultNow(),
    updatedAt: timestamp("updated_at").notNull().defaultNow(),
  },
  (table) => [index("membership_types_status_idx").on(table.status)],
);

export const memberships = pgTable(
  "memberships",
  {
    id: varchar("id", { length: 255 })
      .$defaultFn(() => createId())
      .primaryKey(),
    userId: varchar("user_id", { length: 255 })
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    membershipTypeId: varchar("membership_type_id", { length: 255 })
      .notNull()
      .references(() => membershipTypes.id),
    startDate: date("start_date").notNull(),
    endDate: date("end_date").notNull(),
    status: varchar("status", { length: 50 })
      .$type<"active" | "expired" | "cancelled">()
      .notNull()
      .default("active"),
    paymentProvider: varchar("payment_provider", { length: 100 }),
    paymentId: varchar("payment_id", { length: 255 }),
    metadata: jsonb("metadata").$type<{
      paymentDetails?: Record<string, unknown>;
      notes?: string;
      [key: string]: unknown;
    }>(),
    createdAt: timestamp("created_at").notNull().defaultNow(),
    updatedAt: timestamp("updated_at").notNull().defaultNow(),
  },
  (table) => [
    index("memberships_user_id_idx").on(table.userId),
    index("memberships_status_idx").on(table.status),
    index("memberships_end_date_idx").on(table.endDate),
    index("memberships_payment_id_idx").on(table.paymentId),
    // Prevent duplicate payments - unique on (provider, paymentId) when paymentId exists
    // This allows multiple NULL paymentIds but prevents replay attacks
    uniqueIndex("memberships_payment_provider_id_unique")
      .on(table.paymentProvider, table.paymentId)
      .where(sql`${table.paymentId} IS NOT NULL`),
  ],
);

export const membershipPaymentSessions = pgTable(
  "membership_payment_sessions",
  {
    id: varchar("id", { length: 255 })
      .$defaultFn(() => createId())
      .primaryKey(),
    userId: varchar("user_id", { length: 255 })
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    membershipTypeId: varchar("membership_type_id", { length: 255 })
      .notNull()
      .references(() => membershipTypes.id),
    squareCheckoutId: varchar("square_checkout_id", { length: 255 }).notNull(),
    squarePaymentLinkUrl: varchar("square_payment_link_url", { length: 2048 }).notNull(),
    squareOrderId: varchar("square_order_id", { length: 255 }),
    squarePaymentId: varchar("square_payment_id", { length: 255 }),
    status: varchar("status", { length: 50 })
      .$type<"pending" | "completed" | "cancelled" | "failed">()
      .notNull()
      .default("pending"),
    amountCents: integer("amount_cents").notNull(),
    currency: varchar("currency", { length: 10 }).notNull().default("CAD"),
    expiresAt: timestamp("expires_at"),
    metadata: jsonb("metadata").$type<Record<string, unknown>>(),
    createdAt: timestamp("created_at").notNull().defaultNow(),
    updatedAt: timestamp("updated_at").notNull().defaultNow(),
  },
  (table) => [
    index("membership_payment_sessions_user_idx").on(table.userId),
    uniqueIndex("membership_payment_sessions_checkout_idx").on(table.squareCheckoutId),
    index("membership_payment_sessions_order_idx").on(table.squareOrderId),
    index("membership_payment_sessions_payment_idx").on(table.squarePaymentId),
    index("membership_payment_sessions_type_idx").on(table.membershipTypeId),
  ],
);

// Export inferred types
export type MembershipType = typeof membershipTypes.$inferSelect;
export type NewMembershipType = typeof membershipTypes.$inferInsert;
export type Membership = typeof memberships.$inferSelect;
export type NewMembership = typeof memberships.$inferInsert;
export type MembershipPaymentSession = typeof membershipPaymentSessions.$inferSelect;
export type NewMembershipPaymentSession = typeof membershipPaymentSessions.$inferInsert;
</file>

<file path="src/db/connections.ts">
import { Pool, neonConfig } from "@neondatabase/serverless";
import { createServerOnlyFn } from "@tanstack/react-start";
import { drizzle as drizzleNeon } from "drizzle-orm/neon-serverless";
import { drizzle as drizzlePostgres } from "drizzle-orm/postgres-js";
import postgres from "postgres";
import * as schema from "./schema";

// Singleton instances
let pooledInstance: ReturnType<typeof drizzleNeon> | null = null;
let unpooledInstance: ReturnType<typeof drizzlePostgres> | null = null;
let poolInstance: Pool | null = null;
let sqlInstance: ReturnType<typeof postgres> | null = null;

/**
 * Pooled database connection using Neon's serverless driver.
 *
 * Uses DATABASE_URL (pooled) or NETLIFY_DATABASE_URL for serverless functions.
 * This connection goes through Neon's connection pooler for efficient
 * concurrent request handling.
 *
 * Use this for:
 * - API routes and serverless functions
 * - Short-lived queries
 * - High-concurrency scenarios
 */
export const pooledDb = createServerOnlyFn(async () => {
  // Return existing instance if available
  if (pooledInstance) {
    return pooledInstance;
  }

  const { getPooledDbUrl, isServerless } = await import("../lib/env.server");

  // Configure Neon for serverless environments
  if (isServerless()) {
    neonConfig.useSecureWebSocket = true;
    neonConfig.poolQueryViaFetch = true;
  }

  const connectionString = getPooledDbUrl();

  poolInstance = new Pool({ connectionString });
  pooledInstance = drizzleNeon({
    client: poolInstance,
    schema,
    casing: "snake_case",
  });

  return pooledInstance;
});

/**
 * Unpooled (direct) database connection using standard postgres driver.
 *
 * Uses DATABASE_URL_UNPOOLED or NETLIFY_DATABASE_URL_UNPOOLED for
 * migrations and long operations. This creates a direct connection
 * to the database without going through the pooler.
 *
 * Use this for:
 * - Database migrations
 * - Long-running operations
 * - Batch imports/exports
 * - Operations requiring session-level features
 */
export const unpooledDb = createServerOnlyFn(async () => {
  // Return existing instance if available
  if (unpooledInstance) {
    return unpooledInstance;
  }

  const { getUnpooledDbUrl } = await import("../lib/env.server");
  const connectionString = getUnpooledDbUrl();

  // Set a reasonable connection pool size
  sqlInstance = postgres(connectionString, {
    max: 10, // Maximum number of connections in the pool
    idle_timeout: 20, // Close idle connections after 20 seconds
    connect_timeout: 10, // Connection timeout
  });

  unpooledInstance = drizzlePostgres({
    client: sqlInstance,
    schema,
    casing: "snake_case",
  });

  return unpooledInstance;
});

/**
 * Returns the appropriate database connection based on the environment.
 *
 * - In serverless environments (Netlify/Vercel): Uses pooled connection
 * - In development or traditional servers: Uses unpooled connection
 *
 * This is the recommended export for most use cases as it automatically
 * selects the optimal connection type.
 */
export const getDb = createServerOnlyFn(async () => {
  const { isServerless } = await import("../lib/env.server");
  if (isServerless()) {
    console.log("Using pooled connection for serverless environment");
    return await pooledDb();
  } else {
    console.log("Using unpooled connection for traditional environment");
    return await unpooledDb();
  }
});

/**
 * Cleanup function to close all database connections
 * Should be called when shutting down the server
 */
export const closeConnections = createServerOnlyFn(async () => {
  const promises: Promise<void>[] = [];

  if (poolInstance) {
    promises.push(poolInstance.end());
    poolInstance = null;
    pooledInstance = null;
  }

  if (sqlInstance) {
    promises.push(sqlInstance.end({ timeout: 3 }));
    sqlInstance = null;
    unpooledInstance = null;
  }

  await Promise.all(promises);
  console.log("Database connections closed");
});
</file>

<file path="src/features/events/components/event-list.tsx">
import { useQuery } from "@tanstack/react-query";
import { Link } from "@tanstack/react-router";
import { format } from "date-fns";
import { CalendarIcon, ClockIcon, MapPinIcon, TagIcon, UsersIcon } from "lucide-react";
import { useState } from "react";
import { Badge } from "~/components/ui/badge";
import { Button } from "~/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";
import { Skeleton } from "~/components/ui/skeleton";
import { cn } from "~/shared/lib/utils";
import { listEvents } from "../events.queries";
import type { EventFilters, EventListResult, EventWithDetails } from "../events.types";

type SortBy = "startDate" | "name" | "createdAt";
type SortOrder = "asc" | "desc";

interface EventListProps {
  showFilters?: boolean;
  initialFilters?: EventFilters;
  pageSize?: number;
}

const DEFAULT_FILTERS: EventFilters = {};
const SKELETON_CARD_KEYS = [
  "skeleton-0",
  "skeleton-1",
  "skeleton-2",
  "skeleton-3",
  "skeleton-4",
  "skeleton-5",
];

const SORT_OPTIONS: { label: string; value: SortBy }[] = [
  { label: "Start Date", value: "startDate" },
  { label: "Name", value: "name" },
  { label: "Recently Added", value: "createdAt" },
];

const SORT_ORDER_OPTIONS: { label: string; value: SortOrder }[] = [
  { label: "Ascending", value: "asc" },
  { label: "Descending", value: "desc" },
];

export function EventList({
  showFilters = true,
  initialFilters = DEFAULT_FILTERS,
  pageSize = 12,
}: EventListProps) {
  const [filters, setFilters] = useState<EventFilters>(() => ({ ...initialFilters }));
  const [page, setPage] = useState(1);
  const [sortBy, setSortBy] = useState<SortBy>("startDate");
  const [sortOrder, setSortOrder] = useState<SortOrder>("asc");

  const { data, isLoading, error } = useQuery<EventListResult, Error>({
    queryKey: ["events", filters, page, pageSize, sortBy, sortOrder],
    queryFn: () =>
      listEvents({
        data: {
          filters,
          page,
          pageSize,
          sortBy,
          sortOrder,
        },
      }),
  });

  const handleFilterChange = <K extends keyof EventFilters>(
    key: K,
    value: EventFilters[K] | undefined,
  ) => {
    setFilters((prev) => {
      const next: EventFilters = { ...prev };
      if (value === undefined || (typeof value === "string" && value.length === 0)) {
        delete next[key];
      } else {
        next[key] = value as EventFilters[K];
      }
      return next;
    });
    setPage(1);
  };

  const typeFilterValue = typeof filters.type === "string" ? filters.type : "all";
  const statusFilterValue = typeof filters.status === "string" ? filters.status : "all";
  const provinceFilterValue = filters.province ?? "all";

  const filterSection = showFilters ? (
    <Card>
      <CardHeader>
        <CardTitle>Filter Events</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
          <div className="space-y-2">
            <Label htmlFor="type">Event Type</Label>
            <Select
              value={typeFilterValue}
              onValueChange={(value) =>
                handleFilterChange(
                  "type",
                  value === "all" ? undefined : (value as EventFilters["type"]),
                )
              }
            >
              <SelectTrigger id="type">
                <SelectValue placeholder="All types" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">All types</SelectItem>
                <SelectItem value="tournament">Tournament</SelectItem>
                <SelectItem value="league">League</SelectItem>
                <SelectItem value="camp">Camp</SelectItem>
                <SelectItem value="clinic">Clinic</SelectItem>
                <SelectItem value="social">Social</SelectItem>
                <SelectItem value="other">Other</SelectItem>
              </SelectContent>
            </Select>
          </div>

          <div className="space-y-2">
            <Label htmlFor="status">Status</Label>
            <Select
              value={statusFilterValue}
              onValueChange={(value) =>
                handleFilterChange(
                  "status",
                  value === "all" ? undefined : (value as EventFilters["status"]),
                )
              }
            >
              <SelectTrigger id="status">
                <SelectValue placeholder="All statuses" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">All statuses</SelectItem>
                <SelectItem value="published">Published</SelectItem>
                <SelectItem value="registration_open">Registration Open</SelectItem>
                <SelectItem value="registration_closed">Registration Closed</SelectItem>
                <SelectItem value="in_progress">In Progress</SelectItem>
                <SelectItem value="completed">Completed</SelectItem>
              </SelectContent>
            </Select>
          </div>

          <div className="space-y-2">
            <Label htmlFor="city">City</Label>
            <Input
              id="city"
              placeholder="Filter by city"
              value={filters.city ?? ""}
              onChange={(event) =>
                handleFilterChange("city", event.target.value || undefined)
              }
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="province">Province</Label>
            <Select
              value={provinceFilterValue}
              onValueChange={(value) =>
                handleFilterChange(
                  "province",
                  value === "all" ? undefined : (value as EventFilters["province"]),
                )
              }
            >
              <SelectTrigger id="province">
                <SelectValue placeholder="All provinces" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">All provinces</SelectItem>
                <SelectItem value="AB">Alberta</SelectItem>
                <SelectItem value="BC">British Columbia</SelectItem>
                <SelectItem value="MB">Manitoba</SelectItem>
                <SelectItem value="NB">New Brunswick</SelectItem>
                <SelectItem value="NL">Newfoundland and Labrador</SelectItem>
                <SelectItem value="NS">Nova Scotia</SelectItem>
                <SelectItem value="ON">Ontario</SelectItem>
                <SelectItem value="PE">Prince Edward Island</SelectItem>
                <SelectItem value="QC">Quebec</SelectItem>
                <SelectItem value="SK">Saskatchewan</SelectItem>
              </SelectContent>
            </Select>
          </div>

          <div className="space-y-2">
            <Label htmlFor="sortBy">Sort By</Label>
            <Select value={sortBy} onValueChange={(value) => setSortBy(value as SortBy)}>
              <SelectTrigger id="sortBy">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                {SORT_OPTIONS.map((option) => (
                  <SelectItem key={option.value} value={option.value}>
                    {option.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          <div className="space-y-2">
            <Label htmlFor="sortOrder">Sort Order</Label>
            <Select
              value={sortOrder}
              onValueChange={(value) => setSortOrder(value as SortOrder)}
            >
              <SelectTrigger id="sortOrder">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                {SORT_ORDER_OPTIONS.map((option) => (
                  <SelectItem key={option.value} value={option.value}>
                    {option.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </div>
      </CardContent>
    </Card>
  ) : null;

  if (error) {
    return (
      <div className="text-destructive text-center">
        Error loading events: {error.message}
      </div>
    );
  }

  const events = data?.events ?? [];
  const hasNoEvents = !isLoading && events.length === 0;

  return (
    <div className="space-y-6">
      {filterSection}

      {isLoading ? (
        <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {SKELETON_CARD_KEYS.map((key) => (
            <Card key={key}>
              <CardHeader>
                <Skeleton className="h-6 w-3/4" />
              </CardHeader>
              <CardContent className="space-y-2">
                <Skeleton className="h-4 w-full" />
                <Skeleton className="h-4 w-2/3" />
                <Skeleton className="h-4 w-1/2" />
              </CardContent>
            </Card>
          ))}
        </div>
      ) : hasNoEvents ? (
        <Card className="p-8 text-center">
          <p className="text-muted-foreground">No events found matching your criteria.</p>
        </Card>
      ) : (
        <>
          <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
            {events.map((event) => (
              <EventCard key={event.id} event={event} />
            ))}
          </div>

          {data && data.pageInfo.totalPages > 1 && (
            <div className="flex items-center justify-between">
              <div className="text-muted-foreground text-sm">
                Showing {(page - 1) * pageSize + 1}-
                {Math.min(page * pageSize, data.totalCount)} of {data.totalCount} events
              </div>
              <div className="flex gap-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((prev) => Math.max(1, prev - 1))}
                  disabled={!data.pageInfo.hasPreviousPage}
                >
                  Previous
                </Button>
                <div className="flex items-center gap-1">
                  {Array.from(
                    { length: Math.min(5, data.pageInfo.totalPages) },
                    (_, index) => {
                      const pageNumber = index + 1;
                      return (
                        <Button
                          key={`page-${pageNumber}`}
                          variant={pageNumber === page ? "default" : "outline"}
                          size="sm"
                          onClick={() => setPage(pageNumber)}
                        >
                          {pageNumber}
                        </Button>
                      );
                    },
                  )}
                  {data.pageInfo.totalPages > 5 && (
                    <span className="text-muted-foreground px-2">...</span>
                  )}
                </div>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((prev) => prev + 1)}
                  disabled={!data.pageInfo.hasNextPage}
                >
                  Next
                </Button>
              </div>
            </div>
          )}
        </>
      )}
    </div>
  );
}

function EventCard({ event }: { event: EventWithDetails }) {
  const typeIcon = getTypeIcon(event.type);
  const badgeAppearance = getStatusBadgeAppearance(event.status);

  return (
    <Card className="group transition-all hover:shadow-lg">
      <CardHeader>
        <div className="flex items-start justify-between">
          <div className="flex-1">
            <Link
              to="/dashboard/events/$slug"
              params={{ slug: event.slug }}
              className="group-hover:underline"
            >
              <CardTitle className="line-clamp-2">
                <span className="mr-2">{typeIcon}</span>
                {event.name}
              </CardTitle>
            </Link>
          </div>
          <Badge
            variant={badgeAppearance.variant}
            className={cn("ml-2 capitalize", badgeAppearance.className)}
          >
            {event.status.replace("_", " ")}
          </Badge>
        </div>
      </CardHeader>
      <CardContent className="space-y-4">
        <p className="text-muted-foreground line-clamp-3 text-sm">
          {event.shortDescription || event.description}
        </p>

        <div className="space-y-2 text-sm">
          <div className="flex items-center gap-2">
            <CalendarIcon className="text-muted-foreground h-4 w-4" />
            <span>
              {format(new Date(event.startDate), "MMM d")}
              {event.endDate !== event.startDate &&
                ` - ${format(new Date(event.endDate), "MMM d, yyyy")}`}
            </span>
          </div>

          {event.city ? (
            <div className="flex items-center gap-2">
              <MapPinIcon className="text-muted-foreground h-4 w-4" />
              <span>
                {event.city}
                {event.province && `, ${event.province}`}
              </span>
            </div>
          ) : null}

          {event.isRegistrationOpen ? (
            <div className="flex items-center gap-2">
              <ClockIcon className="h-4 w-4 text-emerald-600" />
              <span className="font-medium text-emerald-600">Registration Open</span>
              {event.availableSpots !== undefined ? (
                <span className="text-muted-foreground">
                  ({event.availableSpots} spots left)
                </span>
              ) : null}
            </div>
          ) : null}

          <div className="flex items-center gap-2">
            <UsersIcon className="text-muted-foreground h-4 w-4" />
            <span>{event.registrationCount} registered</span>
          </div>

          <div className="flex items-center gap-2">
            <TagIcon className="text-muted-foreground h-4 w-4" />
            <span className="capitalize">{event.registrationType} registration</span>
          </div>
        </div>

        <div className="pt-2">
          <Button asChild className="w-full" size="sm">
            <Link to="/dashboard/events/$slug" params={{ slug: event.slug }}>
              View Details
            </Link>
          </Button>
        </div>
      </CardContent>
    </Card>
  );
}

function getStatusBadgeAppearance(status: EventWithDetails["status"]): {
  variant: "default" | "secondary" | "destructive" | "outline";
  className?: string;
} {
  switch (status) {
    case "draft":
      return { variant: "secondary" };
    case "published":
      return { variant: "default" };
    case "registration_open":
      return {
        variant: "outline",
        className: "border-emerald-200 bg-emerald-50 text-emerald-700",
      };
    case "registration_closed":
      return {
        variant: "outline",
        className: "border-amber-200 bg-amber-50 text-amber-700",
      };
    case "in_progress":
      return {
        variant: "outline",
        className: "border-sky-200 bg-sky-50 text-sky-700",
      };
    case "completed":
      return { variant: "default" };
    case "cancelled":
      return { variant: "destructive" };
    default:
      return { variant: "default" };
  }
}

function getTypeIcon(type: EventWithDetails["type"]): string {
  const icons: Record<EventWithDetails["type"], string> = {
    tournament: "🏆",
    league: "📅",
    camp: "🏕️",
    clinic: "🎓",
    social: "🎉",
    other: "📍",
  };

  return icons[type] ?? "📍";
}
</file>

<file path="src/features/profile/profile.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import type {
  EmergencyContact,
  PrivacySettings,
  ProfileOperationResult,
  UserProfile,
} from "./profile.types";

function parseJsonField<T>(value: string | null | undefined): T | undefined {
  if (!value) return undefined;
  try {
    return JSON.parse(value) as T;
  } catch {
    return undefined;
  }
}

function mapDbUserToProfile(dbUser: {
  id: string;
  name: string;
  email: string;
  profileComplete: boolean;
  dateOfBirth: Date | null;
  emergencyContact: string | null;
  gender: string | null;
  pronouns: string | null;
  phone: string | null;
  privacySettings: string | null;
  profileVersion: number;
  profileUpdatedAt: Date | null;
}): UserProfile {
  return {
    id: dbUser.id,
    name: dbUser.name,
    email: dbUser.email,
    profileComplete: dbUser.profileComplete,
    dateOfBirth: dbUser.dateOfBirth ?? undefined,
    emergencyContact: parseJsonField<EmergencyContact>(dbUser.emergencyContact),
    gender: dbUser.gender ?? undefined,
    pronouns: dbUser.pronouns ?? undefined,
    phone: dbUser.phone ?? undefined,
    privacySettings: parseJsonField<PrivacySettings>(dbUser.privacySettings),
    profileVersion: dbUser.profileVersion,
    profileUpdatedAt: dbUser.profileUpdatedAt ?? undefined,
  };
}

export const getUserProfile = createServerFn({ method: "GET" }).handler(
  async (): Promise<ProfileOperationResult> => {
    try {
      // Import server-only modules inside the handler
      const [{ getDb }, { getAuth }] = await Promise.all([
        import("~/db/server-helpers"),
        import("~/lib/auth/server-helpers"),
      ]);

      const auth = await getAuth();
      const { getRequest } = await import("@tanstack/react-start/server");
      const { headers } = getRequest();
      const session = await auth.api.getSession({ headers });

      if (!session?.user?.id) {
        return {
          success: false,
          errors: [{ code: "VALIDATION_ERROR", message: "User not authenticated" }],
        };
      }

      const { eq } = await import("drizzle-orm");
      const { user } = await import("~/db/schema");

      const db = await getDb();

      const [dbUser] = await db
        .select()
        .from(user)
        .where(eq(user.id, session.user.id))
        .limit(1);

      if (!dbUser) {
        return {
          success: false,
          errors: [{ code: "DATABASE_ERROR", message: "User not found" }],
        };
      }

      return {
        success: true,
        data: mapDbUserToProfile(dbUser),
      };
    } catch (error) {
      console.error("Error fetching user profile:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to fetch user profile",
          },
        ],
      };
    }
  },
);

export const getProfileCompletionStatus = createServerFn({ method: "GET" }).handler(
  async (): Promise<{ complete: boolean; missingFields: string[] }> => {
    try {
      // Import server-only modules inside the handler
      const [{ getDb }, { getAuth }] = await Promise.all([
        import("~/db/server-helpers"),
        import("~/lib/auth/server-helpers"),
      ]);

      const auth = await getAuth();
      const { getRequest } = await import("@tanstack/react-start/server");
      const { headers } = getRequest();
      const session = await auth.api.getSession({ headers });

      if (!session?.user?.id) {
        throw new Error("User not authenticated");
      }

      const { eq } = await import("drizzle-orm");
      const { user } = await import("~/db/schema");

      const db = await getDb();

      const [dbUser] = await db
        .select()
        .from(user)
        .where(eq(user.id, session.user.id))
        .limit(1);

      if (!dbUser) {
        throw new Error("User not found");
      }

      const missingFields: string[] = [];

      // Required fields for profile completion
      if (!dbUser.dateOfBirth) {
        missingFields.push("dateOfBirth");
      }

      // Note: Emergency contact is optional but recommended
      // It is NOT included in missingFields to maintain consistency
      // with the UI which marks it as "optional but recommended"

      return {
        complete: dbUser.profileComplete,
        missingFields,
      };
    } catch (error) {
      console.error("Error checking profile completion:", error);
      throw error;
    }
  },
);

// Re-export utility function
export { isProfileComplete } from "./profile.utils";
</file>

<file path="src/features/profile/profile.schemas.ts">
import { z } from "zod";

export const emergencyContactSchema = z
  .object({
    name: z.string().min(1, "Emergency contact name is required"),
    relationship: z.string().min(1, "Relationship is required"),
    phone: z.string().optional(),
    email: z.email("Invalid emergency contact email").optional(),
  })
  .refine((data) => data.phone || data.email, {
    path: ["phone"], // This will show the error on the phone field
    error: "Please provide at least one contact method (phone or email)",
  });

export const privacySettingsSchema = z.object({
  showEmail: z.boolean(),
  showPhone: z.boolean(),
  showBirthYear: z.boolean(),
  allowTeamInvitations: z.boolean(),
});

export const profileInputSchema = z.object({
  dateOfBirth: z
    .preprocess((arg) => {
      if (typeof arg === "string" && !arg.includes("T")) {
        return new Date(`${arg}T00:00:00.000Z`);
      }
      return typeof arg === "string" ? new Date(arg) : arg;
    }, z.date())
    .refine(
      (date) => {
        const today = new Date();
        let age = today.getUTCFullYear() - date.getUTCFullYear();
        const m = today.getUTCMonth() - date.getUTCMonth();
        if (m < 0 || (m === 0 && today.getUTCDate() < date.getUTCDate())) {
          age--;
        }
        return age >= 13 && age <= 120;
      },
      {
        error: "You must be between 13 and 120 years old",
      },
    ),
  emergencyContact: emergencyContactSchema.optional(),
  gender: z.string().optional(),
  pronouns: z.string().optional(),
  phone: z.string().optional(),
  privacySettings: privacySettingsSchema.optional(),
});

export const partialProfileInputSchema = profileInputSchema.partial();

export type ProfileInputType = z.infer<typeof profileInputSchema>;
export type PartialProfileInputType = z.infer<typeof partialProfileInputSchema>;

// Server function input schemas
export const updateUserProfileInputSchema = z.object({
  data: partialProfileInputSchema,
});

export const completeUserProfileInputSchema = z.object({
  data: profileInputSchema,
});

export const updatePrivacySettingsInputSchema = z.object({
  data: privacySettingsSchema,
});
</file>

<file path="src/db/schema/events.schema.ts">
import { createId } from "@paralleldrive/cuid2";
import { relations } from "drizzle-orm";
import {
  boolean,
  date,
  index,
  integer,
  jsonb,
  pgEnum,
  pgTable,
  text,
  timestamp,
  uniqueIndex,
  uuid,
  varchar,
} from "drizzle-orm/pg-core";
import { createInsertSchema, createSelectSchema } from "drizzle-zod";
import { z } from "zod";
import { user } from "./auth.schema";
import { teams } from "./teams.schema";

/**
 * Event status enum
 */
export const eventStatusEnum = pgEnum("event_status", [
  "draft", // Event is being planned, not visible in listings
  "published", // Event is visible but registration not open
  "registration_open", // Teams can register
  "registration_closed", // No more registrations
  "in_progress", // Event is currently happening
  "completed", // Event finished
  "cancelled", // Event was cancelled
]);

/**
 * Event type enum
 */
export const eventTypeEnum = pgEnum("event_type", [
  "tournament", // Competitive tournament
  "league", // League play
  "camp", // Training camp
  "clinic", // Skills clinic
  "social", // Social/fun event
  "other", // Other type
]);

/**
 * Registration type enum
 */
export const registrationTypeEnum = pgEnum("registration_type", [
  "team", // Teams register together
  "individual", // Individuals register and are assigned to teams
  "both", // Supports both team and individual registration
]);

/**
 * Main events table
 */
export const events = pgTable("events", {
  id: uuid("id").primaryKey().defaultRandom(),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),

  // Basic information
  name: varchar("name", { length: 255 }).notNull(),
  slug: varchar("slug", { length: 255 }).notNull().unique(), // URL-friendly identifier
  description: text("description"),
  shortDescription: varchar("short_description", { length: 500 }), // For cards/previews

  // Event details
  type: eventTypeEnum("type").notNull().default("tournament"),
  status: eventStatusEnum("status").notNull().default("draft"),

  // Location
  venueName: varchar("venue_name", { length: 255 }),
  venueAddress: text("venue_address"),
  city: varchar("city", { length: 100 }),
  province: varchar("province", { length: 50 }),
  postalCode: varchar("postal_code", { length: 10 }),
  locationNotes: text("location_notes"), // Parking info, directions, etc.

  // Dates and times
  startDate: date("start_date").notNull(),
  endDate: date("end_date").notNull(),
  registrationOpensAt: timestamp("registration_opens_at"),
  registrationClosesAt: timestamp("registration_closes_at"),

  // Registration settings
  registrationType: registrationTypeEnum("registration_type").notNull().default("team"),
  maxTeams: integer("max_teams"),
  maxParticipants: integer("max_participants"),
  minPlayersPerTeam: integer("min_players_per_team").default(7),
  maxPlayersPerTeam: integer("max_players_per_team").default(21),

  // Pricing (in cents)
  teamRegistrationFee: integer("team_registration_fee").default(0),
  individualRegistrationFee: integer("individual_registration_fee").default(0),
  earlyBirdDiscount: integer("early_bird_discount").default(0), // Percentage
  earlyBirdDeadline: timestamp("early_bird_deadline"),

  // Contact information
  organizerId: text("organizer_id")
    .notNull()
    .references(() => user.id),
  contactEmail: varchar("contact_email", { length: 255 }),
  contactPhone: varchar("contact_phone", { length: 20 }),

  // Additional data
  rules: jsonb("rules"), // Custom rules/modifications
  schedule: jsonb("schedule"), // Detailed schedule info
  divisions: jsonb("divisions"), // e.g. [{name: "Competitive", maxTeams: 8}, {name: "Recreational", maxTeams: 12}]
  amenities: jsonb("amenities"), // ["parking", "concessions", "livestream", etc.]
  requirements: jsonb("requirements"), // ["valid membership", "insurance", etc.]

  // Media
  logoUrl: text("logo_url"),
  bannerUrl: text("banner_url"),

  // Metadata
  metadata: jsonb("metadata"), // Flexible field for additional data
  allowEtransfer: boolean("allow_etransfer").notNull().default(false),
  etransferInstructions: text("etransfer_instructions"),
  etransferRecipient: varchar("etransfer_recipient", { length: 255 }),
});

/**
 * Event registrations table - tracks team/individual registrations for events
 */
export const eventRegistrations = pgTable("event_registrations", {
  id: uuid("id").primaryKey().defaultRandom(),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),

  // References
  eventId: uuid("event_id")
    .notNull()
    .references(() => events.id),
  teamId: text("team_id").references(() => teams.id), // Null for individual registrations
  userId: text("user_id")
    .notNull()
    .references(() => user.id), // Who registered

  // Registration details
  registrationType: registrationTypeEnum("registration_type").notNull(),
  division: varchar("division", { length: 100 }), // Which division they're in

  // Status
  status: varchar("status", { length: 50 }).notNull().default("pending"), // pending, confirmed, waitlisted, cancelled
  paymentStatus: varchar("payment_status", { length: 50 }).notNull().default("pending"), // pending, paid, refunded
  paymentId: text("payment_id"), // Reference to payment record
  paymentMethod: varchar("payment_method", { length: 50 }).notNull().default("square"),
  amountDueCents: integer("amount_due_cents").notNull().default(0),
  amountPaidCents: integer("amount_paid_cents"),
  paymentCompletedAt: timestamp("payment_completed_at"),
  paymentMetadata: jsonb("payment_metadata"),

  // Team roster (for team registrations)
  roster: jsonb("roster"), // Array of player IDs and roles

  // Notes
  notes: text("notes"), // Any special requirements/notes
  internalNotes: text("internal_notes"), // Admin notes

  // Timestamps
  confirmedAt: timestamp("confirmed_at"),
  cancelledAt: timestamp("cancelled_at"),
});

export const eventPaymentSessions = pgTable(
  "event_payment_sessions",
  {
    id: varchar("id", { length: 255 })
      .$defaultFn(() => createId())
      .primaryKey(),
    registrationId: uuid("registration_id")
      .notNull()
      .references(() => eventRegistrations.id, { onDelete: "cascade" }),
    eventId: uuid("event_id")
      .notNull()
      .references(() => events.id, { onDelete: "cascade" }),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    squareCheckoutId: varchar("square_checkout_id", { length: 255 }).notNull(),
    squarePaymentLinkUrl: varchar("square_payment_link_url", { length: 2048 }).notNull(),
    squareOrderId: varchar("square_order_id", { length: 255 }),
    squarePaymentId: varchar("square_payment_id", { length: 255 }),
    status: varchar("status", { length: 50 }).notNull().default("pending"),
    amountCents: integer("amount_cents").notNull(),
    currency: varchar("currency", { length: 10 }).notNull().default("CAD"),
    expiresAt: timestamp("expires_at"),
    metadata: jsonb("metadata"),
    createdAt: timestamp("created_at").notNull().defaultNow(),
    updatedAt: timestamp("updated_at").notNull().defaultNow(),
  },
  (table) => [
    uniqueIndex("event_payment_sessions_checkout_idx").on(table.squareCheckoutId),
    index("event_payment_sessions_payment_idx").on(table.squarePaymentId),
    index("event_payment_sessions_registration_idx").on(table.registrationId),
    index("event_payment_sessions_event_idx").on(table.eventId),
    index("event_payment_sessions_user_idx").on(table.userId),
  ],
);

/**
 * Event announcements/updates
 */
export const eventAnnouncements = pgTable("event_announcements", {
  id: uuid("id").primaryKey().defaultRandom(),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),

  eventId: uuid("event_id")
    .notNull()
    .references(() => events.id),
  authorId: text("author_id")
    .notNull()
    .references(() => user.id),

  title: varchar("title", { length: 255 }).notNull(),
  content: text("content").notNull(),

  isPinned: boolean("is_pinned").notNull().default(false),
  isPublished: boolean("is_published").notNull().default(true),

  // Who should see this
  visibility: varchar("visibility", { length: 50 }).notNull().default("all"), // all, registered, organizers
});

// Relations
export const eventsRelations = relations(events, ({ one, many }) => ({
  organizer: one(user, {
    fields: [events.organizerId],
    references: [user.id],
  }),
  registrations: many(eventRegistrations),
  paymentSessions: many(eventPaymentSessions),
  announcements: many(eventAnnouncements),
}));

export const eventRegistrationsRelations = relations(
  eventRegistrations,
  ({ one, many }) => ({
    event: one(events, {
      fields: [eventRegistrations.eventId],
      references: [events.id],
    }),
    team: one(teams, {
      fields: [eventRegistrations.teamId],
      references: [teams.id],
    }),
    user: one(user, {
      fields: [eventRegistrations.userId],
      references: [user.id],
    }),
    paymentSessions: many(eventPaymentSessions),
  }),
);

export const eventAnnouncementsRelations = relations(eventAnnouncements, ({ one }) => ({
  event: one(events, {
    fields: [eventAnnouncements.eventId],
    references: [events.id],
  }),
  author: one(user, {
    fields: [eventAnnouncements.authorId],
    references: [user.id],
  }),
}));

export const eventPaymentSessionsRelations = relations(
  eventPaymentSessions,
  ({ one }) => ({
    event: one(events, {
      fields: [eventPaymentSessions.eventId],
      references: [events.id],
    }),
    registration: one(eventRegistrations, {
      fields: [eventPaymentSessions.registrationId],
      references: [eventRegistrations.id],
    }),
    user: one(user, {
      fields: [eventPaymentSessions.userId],
      references: [user.id],
    }),
  }),
);

// Zod schemas
export const insertEventSchema = createInsertSchema(events);
export const selectEventSchema = createSelectSchema(events);
export const insertEventRegistrationSchema = createInsertSchema(eventRegistrations);
export const selectEventRegistrationSchema = createSelectSchema(eventRegistrations);
export const insertEventAnnouncementSchema = createInsertSchema(eventAnnouncements);
export const selectEventAnnouncementSchema = createSelectSchema(eventAnnouncements);
export const insertEventPaymentSessionSchema = createInsertSchema(eventPaymentSessions);
export const selectEventPaymentSessionSchema = createSelectSchema(eventPaymentSessions);

// Inferred types
export type EventPaymentSession = typeof eventPaymentSessions.$inferSelect;
export type NewEventPaymentSession = typeof eventPaymentSessions.$inferInsert;

// Custom validation schemas
export const baseCreateEventSchema = z.object({
  name: z.string().min(3).max(255),
  slug: z
    .string()
    .min(3)
    .max(255)
    .regex(/^[a-z0-9-]+$/, "Slug must be lowercase with hyphens only"),
  description: z.string().optional(),
  shortDescription: z.string().max(500).optional(),
  type: z.enum(["tournament", "league", "camp", "clinic", "social", "other"]),
  venueName: z.string().optional(),
  venueAddress: z.string().optional(),
  city: z.string().optional(),
  province: z.string().optional(),
  postalCode: z.string().optional(),
  startDate: z.string(), // Will be converted to Date
  endDate: z.string(), // Will be converted to Date
  registrationType: z.enum(["team", "individual", "both"]),
  maxTeams: z.int().positive().optional(),
  maxParticipants: z.int().positive().optional(),
  teamRegistrationFee: z.int().min(0).optional(),
  individualRegistrationFee: z.int().min(0).optional(),
  contactEmail: z.email().optional(),
  contactPhone: z.string().optional(),
  allowWaitlist: z.boolean().optional(),
  requireMembership: z.boolean().optional(),
  allowEtransfer: z.boolean().optional(),
  etransferRecipient: z
    .email("Enter a valid e-transfer email")
    .optional()
    .or(z.literal("")),
  etransferInstructions: z.string().max(2000).optional(),
});

export const createEventInputSchema = baseCreateEventSchema.superRefine((values, ctx) => {
  if (values.allowEtransfer) {
    const recipient = values.etransferRecipient?.trim() ?? "";
    if (!recipient) {
      ctx.addIssue({
        path: ["etransferRecipient"],
        code: "custom",
        message: "E-transfer recipient email is required when e-transfer is enabled",
      });
    }
  }
});

export type Event = typeof events.$inferSelect;
export type NewEvent = typeof events.$inferInsert;
export type EventRegistration = typeof eventRegistrations.$inferSelect;
export type NewEventRegistration = typeof eventRegistrations.$inferInsert;
export type EventAnnouncement = typeof eventAnnouncements.$inferSelect;
export type NewEventAnnouncement = typeof eventAnnouncements.$inferInsert;
</file>

<file path="src/components/form-fields/ValidatedInput.tsx">
import React from "react";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";
import { FieldComponentProps, isFieldApi } from "~/lib/form";
import { cn } from "~/shared/lib/utils";

// Type specifically for ValidatedInput, extending the base props
interface ValidatedInputProps extends FieldComponentProps {
  type?: React.HTMLInputTypeAttribute; // Allow passing input type (text, password, email, etc.)
  maxLength?: number;
  min?: string | number;
  max?: string | number;
  step?: string | number;
  autoComplete?: string;
  autoFocus?: boolean;
  pattern?: string;
  required?: boolean;
  readOnly?: boolean;
  disabled?: boolean;
  description?: string;
  onValueChange?: (value: string, event: React.ChangeEvent<HTMLInputElement>) => void;
}

// Correctly define the component receiving props
export const ValidatedInput: React.FC<ValidatedInputProps> = (props) => {
  const {
    field,
    label,
    type = "text",
    placeholder,
    className,
    description,
    onValueChange,
    ...rest // Collect rest of props here
  } = props;

  // Ensure field is correctly passed
  if (!isFieldApi(field)) {
    console.error("ValidatedInput requires a valid field prop.", { field, props });
    return null;
  }

  const inputId = `${field.name}-input`;
  const meta = field.state.meta;

  return (
    <div className={cn("space-y-2", className)}>
      <Label htmlFor={inputId}>{label}</Label>
      <Input
        id={inputId}
        name={field.name}
        type={type}
        value={field.state.value ?? ""}
        onBlur={field.handleBlur}
        onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
          if (onValueChange) {
            onValueChange(event.target.value, event);
            return;
          }
          field.handleChange(event.target.value);
        }}
        placeholder={placeholder}
        disabled={field.form.state.isSubmitting || props.disabled}
        // Add aria-invalid for accessibility based on errors
        aria-invalid={!!meta.errors.length}
        aria-describedby={meta.errors.length ? `${inputId}-errors` : undefined}
        {...rest}
      />
      {description && <p className="text-muted-foreground text-sm">{description}</p>}
      {/* Show errors only if the field has been touched and has errors */}
      {meta.isTouched && meta.errors.length > 0 && (
        <div id={`${inputId}-errors`} className="text-destructive text-sm font-medium">
          {meta.errors.join(", ")}
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/features/profile/profile.mutations.ts">
import { createServerFn } from "@tanstack/react-start";
import { getAuthMiddleware, requireUser } from "~/lib/server/auth";
import { zod$ } from "~/lib/server/fn-utils";
import { isProfileComplete } from "./profile.queries";
import {
  partialProfileInputSchema,
  privacySettingsSchema,
  profileInputSchema,
} from "./profile.schemas";
import type {
  EmergencyContact,
  PrivacySettings,
  ProfileOperationResult,
  UserProfile,
} from "./profile.types";
import { defaultPrivacySettings } from "./profile.types";

function parseJsonField<T>(value: string | null | undefined): T | undefined {
  if (!value) return undefined;
  try {
    return JSON.parse(value) as T;
  } catch {
    return undefined;
  }
}

function mapDbUserToProfile(dbUser: {
  id: string;
  name: string;
  email: string;
  profileComplete: boolean;
  dateOfBirth: Date | null;
  emergencyContact: string | null;
  gender: string | null;
  pronouns: string | null;
  phone: string | null;
  privacySettings: string | null;
  profileVersion: number;
  profileUpdatedAt: Date | null;
}): UserProfile {
  return {
    id: dbUser.id,
    name: dbUser.name,
    email: dbUser.email,
    profileComplete: dbUser.profileComplete,
    dateOfBirth: dbUser.dateOfBirth ?? undefined,
    emergencyContact: parseJsonField<EmergencyContact>(dbUser.emergencyContact),
    gender: dbUser.gender ?? undefined,
    pronouns: dbUser.pronouns ?? undefined,
    phone: dbUser.phone ?? undefined,
    privacySettings: parseJsonField<PrivacySettings>(dbUser.privacySettings),
    profileVersion: dbUser.profileVersion,
    profileUpdatedAt: dbUser.profileUpdatedAt ?? undefined,
  };
}

export const updateUserProfile = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(partialProfileInputSchema))
  .handler(async ({ data: inputData, context }): Promise<ProfileOperationResult> => {
    // Now inputData contains the actual profile data
    try {
      const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);
      const db = await getDb();
      const currentUser = requireUser(context);

      // Input is already validated by .inputValidator(), just check if it's empty
      if (!inputData || Object.keys(inputData).length === 0) {
        return {
          success: false,
          errors: [{ code: "VALIDATION_ERROR", message: "No data provided" }],
        };
      }

      // Import database dependencies inside handler
      const { eq, sql } = await import("drizzle-orm");
      const { user } = await import("~/db/schema");

      const updateData: Record<string, unknown> = {
        profileUpdatedAt: new Date(),
        profileVersion: sql`${user.profileVersion} + 1`,
      };

      if (inputData.dateOfBirth !== undefined) {
        // Convert string date to Date object if needed
        updateData["dateOfBirth"] =
          typeof inputData.dateOfBirth === "string"
            ? new Date(inputData.dateOfBirth)
            : inputData.dateOfBirth;
      }
      if (inputData.emergencyContact !== undefined) {
        updateData["emergencyContact"] = JSON.stringify(inputData.emergencyContact);
      }
      if (inputData.gender !== undefined) {
        updateData["gender"] = inputData.gender;
      }
      if (inputData.pronouns !== undefined) {
        updateData["pronouns"] = inputData.pronouns;
      }
      if (inputData.phone !== undefined) {
        updateData["phone"] = inputData.phone;
      }
      if (inputData.privacySettings !== undefined) {
        updateData["privacySettings"] = JSON.stringify(inputData.privacySettings);
      }
      const [updatedUser] = await db
        .update(user)
        .set(updateData)
        .where(eq(user.id, currentUser.id))
        .returning();

      if (!updatedUser) {
        return {
          success: false,
          errors: [{ code: "DATABASE_ERROR", message: "Failed to update profile" }],
        };
      }

      // Check if profile is now complete
      const profile = mapDbUserToProfile(updatedUser);
      const profileComplete = isProfileComplete(profile);

      if (profileComplete !== updatedUser.profileComplete) {
        const [finalUser] = await db
          .update(user)
          .set({ profileComplete })
          .where(eq(user.id, currentUser.id))
          .returning();

        return {
          success: true,
          data: mapDbUserToProfile(finalUser),
        };
      }

      return {
        success: true,
        data: profile,
      };
    } catch (error) {
      console.error("Error updating user profile:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to update profile",
          },
        ],
      };
    }
  });

export const completeUserProfile = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(profileInputSchema))
  .handler(async ({ data, context }): Promise<ProfileOperationResult> => {
    try {
      const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);
      const db = await getDb();
      const currentUser = requireUser(context);

      const { eq, sql } = await import("drizzle-orm");
      const { user } = await import("~/db/schema");

      const updateData = {
        dateOfBirth: data.dateOfBirth,
        emergencyContact: JSON.stringify(data.emergencyContact),
        gender: data.gender || null,
        pronouns: data.pronouns || null,
        phone: data.phone || null,
        privacySettings: JSON.stringify(data.privacySettings || defaultPrivacySettings),
        profileComplete: true,
        profileUpdatedAt: new Date(),
        profileVersion: sql`${user.profileVersion} + 1`,
      };

      const [updatedUser] = await db
        .update(user)
        .set(updateData)
        .where(eq(user.id, currentUser.id))
        .returning();

      if (!updatedUser) {
        return {
          success: false,
          errors: [{ code: "DATABASE_ERROR", message: "Failed to complete profile" }],
        };
      }

      return {
        success: true,
        data: mapDbUserToProfile(updatedUser),
      };
    } catch (error) {
      console.error("Error completing user profile:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to complete profile",
          },
        ],
      };
    }
  });

export const updatePrivacySettings = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(privacySettingsSchema))
  .handler(async ({ data, context }): Promise<ProfileOperationResult> => {
    try {
      const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);
      const db = await getDb();
      const currentUser = requireUser(context);

      const { eq } = await import("drizzle-orm");
      const { user } = await import("~/db/schema");

      const [updatedUser] = await db
        .update(user)
        .set({
          privacySettings: JSON.stringify(data),
          profileUpdatedAt: new Date(),
        })
        .where(eq(user.id, currentUser.id))
        .returning();

      if (!updatedUser) {
        return {
          success: false,
          errors: [
            { code: "DATABASE_ERROR", message: "Failed to update privacy settings" },
          ],
        };
      }

      return {
        success: true,
        data: mapDbUserToProfile(updatedUser),
      };
    } catch (error) {
      console.error("Error updating privacy settings:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to update privacy settings",
          },
        ],
      };
    }
  });
</file>

<file path="src/features/teams/teams.schemas.ts">
import { z } from "zod";

// Query schemas
export const getTeamSchema = z.object({
  teamId: z.string(),
});
export type GetTeamInput = z.infer<typeof getTeamSchema>;

export const getTeamBySlugSchema = z.object({
  slug: z.string(),
});
export type GetTeamBySlugInput = z.infer<typeof getTeamBySlugSchema>;

const listTeamsInputSchema = z.object({
  includeInactive: z.boolean().optional().prefault(false),
});

export const listTeamsSchema = listTeamsInputSchema
  .nullish()
  .transform((value) => value ?? { includeInactive: false });
export type ListTeamsInput = z.infer<typeof listTeamsSchema>;

export const getTeamMembersSchema = z.object({
  teamId: z.string(),
  includeInactive: z.boolean().optional(),
});
export type GetTeamMembersInput = z.infer<typeof getTeamMembersSchema>;

export const isTeamMemberSchema = z.object({
  teamId: z.string(),
  userId: z.string(),
});
export type IsTeamMemberInput = z.infer<typeof isTeamMemberSchema>;

export const searchTeamsSchema = z.object({
  query: z.string().trim().min(1),
});
export type SearchTeamsInput = z.infer<typeof searchTeamsSchema>;

// Mutation schemas
export const createTeamSchema = z.object({
  name: z.string().min(1, "Team name is required"),
  slug: z
    .string()
    .min(1, "A unique URL slug is required")
    .regex(
      /^[a-z0-9-]+$/,
      "Slug can only contain lowercase letters, numbers, and hyphens",
    ),
  description: z.string().optional(),
  city: z.string().optional(),
  province: z.string().optional(),
  primaryColor: z
    .string()
    .regex(/^#[0-9A-Fa-f]{6}$/)
    .optional(),
  secondaryColor: z
    .string()
    .regex(/^#[0-9A-Fa-f]{6}$/)
    .optional(),
  foundedYear: z.string().length(4).optional(),
  website: z.url().optional(),
  socialLinks: z.record(z.string(), z.string()).optional(),
});
export type CreateTeamInput = z.infer<typeof createTeamSchema>;

export const updateTeamSchema = z.object({
  teamId: z.string(),
  data: createTeamSchema.partial(),
});
export type UpdateTeamInput = z.infer<typeof updateTeamSchema>;

export const addTeamMemberSchema = z.object({
  teamId: z.string(),
  email: z.email("Please enter a valid email address"),
  role: z.enum(["captain", "coach", "player", "substitute"]),
  jerseyNumber: z.string().optional(),
  position: z.string().optional(),
});
export type AddTeamMemberInput = z.infer<typeof addTeamMemberSchema>;

export const updateTeamMemberSchema = z.object({
  teamId: z.string(),
  memberId: z.string(),
  role: z.enum(["captain", "coach", "player", "substitute"]).optional(),
  jerseyNumber: z.string().optional(),
  position: z.string().optional(),
  notes: z.string().optional(),
});
export type UpdateTeamMemberInput = z.infer<typeof updateTeamMemberSchema>;

export const removeTeamMemberSchema = z.object({
  teamId: z.string(),
  memberId: z.string(),
});
export type RemoveTeamMemberInput = z.infer<typeof removeTeamMemberSchema>;

export const teamInviteActionSchema = z.object({
  teamId: z.string(),
});
export type TeamInviteActionInput = z.infer<typeof teamInviteActionSchema>;

export const requestTeamMembershipSchema = z.object({
  teamId: z.string(),
});
export type RequestTeamMembershipInput = z.infer<typeof requestTeamMembershipSchema>;
</file>

<file path="src/features/events/events.types.ts">
import type { z } from "zod";
import type { Event, EventRegistration } from "~/db/schema";
import type { createEventInputSchema } from "~/db/schema/events.schema";
import type {
  EventAmenities,
  EventDivisions,
  EventMetadata,
  EventPaymentMetadata,
  EventRegistrationRoster,
  EventRequirements,
  EventRules,
  EventSchedule,
} from "./events.db-types";

// Input types
export type CreateEventInput = z.infer<typeof createEventInputSchema>;

export type UpdateEventInput = Partial<CreateEventInput> & {
  status?: EventStatus;
};

export type EventFilters = {
  status?: Event["status"] | Event["status"][];
  type?: Event["type"] | Event["type"][];
  organizerId?: string;
  startDateFrom?: Date;
  startDateTo?: Date;
  city?: string;
  province?: string;
};

export type EventRegistrationInput = {
  eventId: string;
  teamId?: string;
  division?: string;
  notes?: string;
  roster?: {
    userId: string;
    role: string;
  }[];
};

// Response types
export interface EventWithDetails
  extends Omit<
    Event,
    "rules" | "schedule" | "divisions" | "amenities" | "requirements" | "metadata"
  > {
  rules: EventRules;
  schedule: EventSchedule;
  divisions: EventDivisions;
  amenities: EventAmenities;
  requirements: EventRequirements;
  metadata: EventMetadata;
  organizer: {
    id: string;
    name: string;
    email: string;
  };
  registrationCount: number;
  isRegistrationOpen: boolean;
  availableSpots: number | undefined;
}

export interface EventRegistrationWithDetails
  extends Omit<EventRegistration, "roster" | "paymentMetadata"> {
  roster: EventRegistrationRoster;
  paymentMetadata: EventPaymentMetadata | null;
  event: EventWithDetails;
  team?: {
    id: string;
    name: string;
    slug: string;
  };
  user: {
    id: string;
    name: string;
    email: string;
  };
}

export type EventPaymentMethod = EventRegistration["paymentMethod"];
export type EventPaymentStatus = EventRegistration["paymentStatus"];

export type EventRegistrationPaymentInfo =
  | {
      method: "square";
      checkoutUrl: string;
      sessionId: string;
    }
  | {
      method: "etransfer";
      instructions?: string | null;
      recipient?: string | null;
    }
  | {
      method: "free";
    };

export interface EventRegistrationResultPayload {
  registration: EventRegistrationWithDetails;
  payment?: EventRegistrationPaymentInfo;
}

export type CancelEventErrorCode =
  | "REFUND_FAILED"
  | "NO_PAYMENT_SESSION"
  | "NOT_PAID"
  | "UNAUTHORIZED";

export interface CancelEventResult {
  eventId: string;
  affected: {
    totalRegistrations: number;
    cancelled: number;
    alreadyCancelled: number;
    squareRefunded: number;
    etransferMarkedForRefund: number;
    freeOrUnpaid: number;
  };
  errors: Array<{
    registrationId: string;
    code: CancelEventErrorCode;
    message: string;
    paymentId?: string;
  }>;
}

// Operation result types
export type EventOperationResult<T = Event> =
  | { success: true; data: T }
  | { success: false; errors: EventError[] };

export type EventError = {
  code: EventErrorCode;
  message: string;
  field?: string;
};

export type EventErrorCode =
  | "VALIDATION_ERROR"
  | "NOT_FOUND"
  | "DUPLICATE_SLUG"
  | "UNAUTHORIZED"
  | "FORBIDDEN"
  | "REGISTRATION_CLOSED"
  | "EVENT_FULL"
  | "ALREADY_REGISTERED"
  | "INVALID_DATES"
  | "DATABASE_ERROR";

// Utility types
export type EventStatus = Event["status"];
export type EventType = Event["type"];
export type RegistrationType = Event["registrationType"];

// Pagination
export type EventListResult = {
  events: EventWithDetails[];
  totalCount: number;
  pageInfo: {
    currentPage: number;
    pageSize: number;
    totalPages: number;
    hasNextPage: boolean;
    hasPreviousPage: boolean;
  };
};
</file>

<file path="src/features/events/components/event-create-form.tsx">
import { useForm, useStore } from "@tanstack/react-form";
import { useMutation } from "@tanstack/react-query";
import { useNavigate } from "@tanstack/react-router";
import { ArrowLeft, ArrowRight } from "lucide-react";
import { useEffect, useRef, useState } from "react";
import { toast } from "sonner";
import { z } from "zod";
import { FormSubmitButton } from "~/components/form-fields/FormSubmitButton";
import { ValidatedCheckbox } from "~/components/form-fields/ValidatedCheckbox";
import { ValidatedInput } from "~/components/form-fields/ValidatedInput";
import { ValidatedSelect } from "~/components/form-fields/ValidatedSelect";
import { Button } from "~/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";
import { Label } from "~/components/ui/label";
import { Textarea } from "~/components/ui/textarea";
import { createEvent } from "../events.mutations";
import type { EventOperationResult, EventWithDetails } from "../events.types";

const EVENT_TYPE_OPTIONS = [
  { value: "tournament", label: "Tournament" },
  { value: "league", label: "League" },
  { value: "camp", label: "Training Camp" },
  { value: "clinic", label: "Skills Clinic" },
  { value: "social", label: "Social Event" },
  { value: "other", label: "Other" },
];

const EVENT_STATUS_OPTIONS = [
  { value: "draft", label: "Draft (Not visible)" },
  { value: "published", label: "Published (Visible)" },
  { value: "registration_open", label: "Registration Open" },
];

const PROVINCE_OPTIONS = [
  { value: "", label: "Select Province" },
  { value: "AB", label: "Alberta" },
  { value: "BC", label: "British Columbia" },
  { value: "MB", label: "Manitoba" },
  { value: "NB", label: "New Brunswick" },
  { value: "NL", label: "Newfoundland and Labrador" },
  { value: "NS", label: "Nova Scotia" },
  { value: "ON", label: "Ontario" },
  { value: "PE", label: "Prince Edward Island" },
  { value: "QC", label: "Quebec" },
  { value: "SK", label: "Saskatchewan" },
];

const REGISTRATION_TYPE_OPTIONS = [
  { value: "team", label: "Team" },
  { value: "individual", label: "Individual" },
  { value: "both", label: "Team & Individual" },
];

function Separator() {
  return <div className="border-t" />;
}

const eventFormSchema = z
  .object({
    name: z.string().min(1, "Event name is required").max(255),
    slug: z
      .string()
      .min(1, "URL slug is required")
      .max(255)
      .regex(/^[a-z0-9-]+$/, "Slug must be lowercase letters, numbers, and hyphens only"),
    description: z.string().optional(),
    shortDescription: z
      .string()
      .max(500, "Short description must be under 500 characters")
      .optional(),
    type: z.enum(["tournament", "league", "camp", "clinic", "social", "other"]),
    status: z.enum(["draft", "published", "registration_open"]),
    venueName: z.string().max(255).optional(),
    venueAddress: z.string().optional(),
    city: z.string().max(100).optional(),
    province: z.string().max(50).optional(),
    postalCode: z.string().max(10).optional(),
    locationNotes: z.string().optional(),
    startDate: z.string().min(1, "Start date is required"),
    endDate: z.string().min(1, "End date is required"),
    registrationOpensAt: z.string().optional(),
    registrationClosesAt: z.string().optional(),
    registrationType: z.enum(["team", "individual", "both"]),
    maxTeams: z.number().min(1).optional(),
    maxParticipants: z.number().min(1).optional(),
    minPlayersPerTeam: z.number().min(1).prefault(7),
    maxPlayersPerTeam: z.number().min(1).prefault(21),
    teamRegistrationFee: z.number().min(0).prefault(0),
    individualRegistrationFee: z.number().min(0).prefault(0),
    earlyBirdDiscount: z.number().min(0).max(100).prefault(0),
    earlyBirdDeadline: z.string().optional(),
    contactEmail: z.email().optional(),
    contactPhone: z.string().optional(),
    websiteUrl: z.url().optional().or(z.literal("")),
    allowWaitlist: z.boolean().prefault(false),
    requireMembership: z.boolean().prefault(false),
    allowEtransfer: z.boolean().prefault(false),
    etransferRecipient: z
      .email("Enter a valid e-transfer email")
      .optional()
      .or(z.literal("")),
    etransferInstructions: z.string().max(2000).optional(),
  })
  .superRefine((values, ctx) => {
    if (values.allowEtransfer) {
      const recipient = values.etransferRecipient?.trim() ?? "";
      if (!recipient) {
        ctx.addIssue({
          path: ["etransferRecipient"],
          code: "custom",
          message: "E-transfer recipient email is required when e-transfer is enabled",
        });
      }
    }
  });

type EventFormData = z.infer<typeof eventFormSchema>;

export function EventCreateForm() {
  const navigate = useNavigate();
  const [currentStep, setCurrentStep] = useState(0);
  const slugManuallyEditedRef = useRef(false);

  const defaultValues: EventFormData = {
    name: "",
    slug: "",
    description: "",
    shortDescription: "",
    type: "tournament",
    status: "draft",
    venueName: "",
    venueAddress: "",
    city: "",
    province: "",
    postalCode: "",
    locationNotes: "",
    startDate: "",
    endDate: "",
    registrationOpensAt: "",
    registrationClosesAt: "",
    registrationType: "team",
    maxTeams: undefined,
    maxParticipants: undefined,
    minPlayersPerTeam: 7,
    maxPlayersPerTeam: 21,
    teamRegistrationFee: 0,
    individualRegistrationFee: 0,
    earlyBirdDiscount: 0,
    earlyBirdDeadline: "",
    contactEmail: "",
    contactPhone: "",
    websiteUrl: "",
    allowWaitlist: false,
    requireMembership: false,
    allowEtransfer: false,
    etransferRecipient: "",
    etransferInstructions: "",
  };

  const form = useForm({
    defaultValues,
    onSubmit: async ({ value }) => {
      const validationResult = eventFormSchema.safeParse(value);

      if (!validationResult.success) {
        const firstIssue = validationResult.error.issues[0];
        toast.error(firstIssue?.message ?? "Please fix the highlighted fields.");
        return;
      }

      const parsed = validationResult.data;

      const formData: EventFormData = {
        ...parsed,
        teamRegistrationFee: Math.round((parsed.teamRegistrationFee || 0) * 100),
        individualRegistrationFee: Math.round(
          (parsed.individualRegistrationFee || 0) * 100,
        ),
        description: parsed.description || undefined,
        shortDescription: parsed.shortDescription || undefined,
        venueName: parsed.venueName || undefined,
        venueAddress: parsed.venueAddress || undefined,
        city: parsed.city || undefined,
        province: parsed.province || undefined,
        postalCode: parsed.postalCode || undefined,
        locationNotes: parsed.locationNotes || undefined,
        registrationOpensAt: parsed.registrationOpensAt || undefined,
        registrationClosesAt: parsed.registrationClosesAt || undefined,
        earlyBirdDeadline: parsed.earlyBirdDeadline || undefined,
        contactEmail: parsed.contactEmail || undefined,
        contactPhone: parsed.contactPhone || undefined,
        websiteUrl: parsed.websiteUrl,
        maxTeams: parsed.maxTeams,
        maxParticipants: parsed.maxParticipants,
        minPlayersPerTeam: parsed.minPlayersPerTeam,
        maxPlayersPerTeam: parsed.maxPlayersPerTeam,
        status: parsed.status,
        allowEtransfer: parsed.allowEtransfer ?? false,
        etransferRecipient: parsed.etransferRecipient?.trim()
          ? parsed.etransferRecipient.trim()
          : undefined,
        etransferInstructions: parsed.etransferInstructions?.trim()
          ? parsed.etransferInstructions.trim()
          : undefined,
      };

      createMutation.mutate(formData);
    },
  });

  const formState = useStore(form.store, (state) => state);

  useEffect(() => {
    const generatedSlug = generateSlug(formState.values.name ?? "");
    if (!slugManuallyEditedRef.current && formState.values.slug !== generatedSlug) {
      form.setFieldValue("slug", generatedSlug);
    }
  }, [form, formState.values.name, formState.values.slug]);

  useEffect(() => {
    if (!formState.values.slug) {
      slugManuallyEditedRef.current = false;
    }
  }, [formState.values.slug]);

  const createMutation = useMutation<
    EventOperationResult<EventWithDetails>,
    Error,
    EventFormData
  >({
    mutationFn: async (data: EventFormData) =>
      createEvent({ data }) as Promise<EventOperationResult<EventWithDetails>>,
    onSuccess: (result) => {
      if (!result.success) {
        const errorMessage = result.errors[0]?.message ?? "Failed to create event";
        toast.error(errorMessage);
        return;
      }

      toast.success("Event created successfully!");

      navigate({ to: "/dashboard/events/$slug", params: { slug: result.data.slug } });
    },
    onError: (error) => {
      toast.error("An error occurred while creating the event");
      console.error(error);
    },
  });

  const steps = [
    { title: "Basic Info", description: "Event name and description" },
    { title: "Location & Dates", description: "Where and when" },
    { title: "Registration", description: "Registration settings and pricing" },
    { title: "Additional Details", description: "Contact info and settings" },
  ];

  const canProceedToNext = () => {
    switch (currentStep) {
      case 0:
        return Boolean(formState.values.name?.trim() && formState.values.slug?.trim());
      case 1:
        return Boolean(formState.values.startDate && formState.values.endDate);
      default:
        return true;
    }
  };

  return (
    <Card className="mx-auto max-w-4xl">
      <CardHeader>
        <CardTitle>Create New Event</CardTitle>
        <CardDescription>
          Fill in the details to create a new Quadball event. You can save as draft and
          publish later.
        </CardDescription>
      </CardHeader>
      <CardContent>
        <div className="mb-8">
          <div className="flex items-center justify-between">
            {steps.map((step, index) => (
              <div
                key={step.title}
                className={`flex-1 ${index !== steps.length - 1 ? "relative" : ""}`}
              >
                <div
                  className={`flex items-center ${
                    index <= currentStep ? "text-primary" : "text-muted-foreground"
                  }`}
                >
                  <div
                    className={`flex h-10 w-10 items-center justify-center rounded-full border-2 ${
                      index <= currentStep
                        ? "border-primary bg-primary text-primary-foreground"
                        : "border-muted-foreground"
                    }`}
                  >
                    {index + 1}
                  </div>
                  <div className="ml-3 hidden md:block">
                    <div className="text-sm leading-tight font-medium">{step.title}</div>
                    <div className="text-muted-foreground mt-0.5 text-xs">
                      {step.description}
                    </div>
                  </div>
                </div>
                {index !== steps.length - 1 && (
                  <div
                    className={`absolute top-5 left-5 h-0.5 w-full ${
                      index < currentStep ? "bg-primary" : "bg-muted-foreground/30"
                    }`}
                    style={{ width: "calc(100% - 2.5rem)" }}
                  />
                )}
              </div>
            ))}
          </div>
        </div>

        <form
          onSubmit={(e) => {
            e.preventDefault();
            e.stopPropagation();
            form.handleSubmit();
          }}
          className="space-y-6"
        >
          {currentStep === 0 && (
            <div className="space-y-6">
              <form.Field name="name">
                {(field) => (
                  <ValidatedInput
                    field={field}
                    label="Event Name"
                    placeholder="2024 Summer Championship"
                    required
                    onValueChange={(value) => {
                      field.handleChange(value);
                      if (!value) {
                        slugManuallyEditedRef.current = false;
                      }
                    }}
                  />
                )}
              </form.Field>

              <form.Field name="slug">
                {(field) => (
                  <ValidatedInput
                    field={field}
                    label="URL Slug"
                    placeholder="2024-summer-championship"
                    description="This will be used in the event URL"
                    required
                    onValueChange={(value) => {
                      field.handleChange(value);
                      const generated = generateSlug(formState.values.name ?? "");
                      slugManuallyEditedRef.current =
                        Boolean(value) && value !== generated;
                    }}
                  />
                )}
              </form.Field>

              <form.Field name="shortDescription">
                {(field) => (
                  <ValidatedInput
                    field={field}
                    label="Short Description"
                    placeholder="Brief description for event cards and previews"
                    description="Max 500 characters"
                    maxLength={500}
                  />
                )}
              </form.Field>

              <form.Field name="description">
                {(field) => (
                  <div className="space-y-2">
                    <Label htmlFor={field.name}>Full Description</Label>
                    <Textarea
                      id={field.name}
                      value={field.state.value ?? ""}
                      onChange={(event) => field.handleChange(event.target.value)}
                      onBlur={field.handleBlur}
                      placeholder="Detailed event description..."
                      rows={6}
                      className="resize-none"
                    />
                    {field.state.meta.errors[0] && (
                      <p className="text-destructive text-sm">
                        {field.state.meta.errors[0]}
                      </p>
                    )}
                  </div>
                )}
              </form.Field>

              <div className="grid gap-4 md:grid-cols-2">
                <form.Field name="type">
                  {(field) => (
                    <ValidatedSelect
                      field={field}
                      label="Event Type"
                      options={EVENT_TYPE_OPTIONS}
                      required
                    />
                  )}
                </form.Field>

                <form.Field name="status">
                  {(field) => (
                    <ValidatedSelect
                      field={field}
                      label="Initial Status"
                      options={EVENT_STATUS_OPTIONS}
                      required
                    />
                  )}
                </form.Field>
              </div>
            </div>
          )}

          {currentStep === 1 && (
            <div className="space-y-6">
              <div className="grid gap-4 md:grid-cols-2">
                <form.Field name="venueName">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Venue Name"
                      placeholder="Community Sports Complex"
                    />
                  )}
                </form.Field>

                <form.Field name="venueAddress">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Venue Address"
                      placeholder="123 Main Street"
                    />
                  )}
                </form.Field>
              </div>

              <div className="grid gap-4 md:grid-cols-3">
                <form.Field name="city">
                  {(field) => (
                    <ValidatedInput field={field} label="City" placeholder="Toronto" />
                  )}
                </form.Field>

                <form.Field name="province">
                  {(field) => (
                    <ValidatedSelect
                      field={field}
                      label="Province"
                      options={PROVINCE_OPTIONS}
                    />
                  )}
                </form.Field>

                <form.Field name="postalCode">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Postal Code"
                      placeholder="M5V 3A8"
                    />
                  )}
                </form.Field>
              </div>

              <form.Field name="locationNotes">
                {(field) => (
                  <div className="space-y-2">
                    <Label htmlFor={field.name}>Location Notes</Label>
                    <Textarea
                      id={field.name}
                      value={field.state.value ?? ""}
                      onChange={(event) => field.handleChange(event.target.value)}
                      onBlur={field.handleBlur}
                      placeholder="Parking information, directions, accessibility notes..."
                      rows={3}
                      className="resize-none"
                    />
                    {field.state.meta.errors[0] && (
                      <p className="text-destructive text-sm">
                        {field.state.meta.errors[0]}
                      </p>
                    )}
                  </div>
                )}
              </form.Field>

              <Separator />

              <div className="grid gap-4 md:grid-cols-2">
                <form.Field name="startDate">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Start Date"
                      type="date"
                      required
                      onValueChange={(value) => {
                        field.handleChange(value);
                        if (!formState.values.endDate) {
                          form.setFieldValue("endDate", value);
                        }
                      }}
                    />
                  )}
                </form.Field>

                <form.Field name="endDate">
                  {(field) => (
                    <ValidatedInput field={field} label="End Date" type="date" required />
                  )}
                </form.Field>
              </div>

              <div className="grid gap-4 md:grid-cols-2">
                <form.Field name="registrationOpensAt">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Registration Opens"
                      type="date"
                    />
                  )}
                </form.Field>

                <form.Field name="registrationClosesAt">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Registration Closes"
                      type="date"
                    />
                  )}
                </form.Field>
              </div>
            </div>
          )}

          {currentStep === 2 && (
            <div className="space-y-6">
              <form.Field name="registrationType">
                {(field) => (
                  <ValidatedSelect
                    field={field}
                    label="Registration Type"
                    options={REGISTRATION_TYPE_OPTIONS}
                    required
                  />
                )}
              </form.Field>

              <div className="grid gap-4 md:grid-cols-2">
                <form.Field name="maxTeams">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Maximum Teams"
                      type="number"
                      min={1}
                      onValueChange={(value) => {
                        const nextValue = value ? Number.parseInt(value, 10) : undefined;
                        field.handleChange(nextValue as unknown as number);
                      }}
                    />
                  )}
                </form.Field>

                <form.Field name="maxParticipants">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Maximum Participants"
                      type="number"
                      min={1}
                      onValueChange={(value) => {
                        const nextValue = value ? Number.parseInt(value, 10) : undefined;
                        field.handleChange(nextValue as unknown as number);
                      }}
                    />
                  )}
                </form.Field>
              </div>

              <div className="grid gap-4 md:grid-cols-2">
                <form.Field name="minPlayersPerTeam">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Minimum Players per Team"
                      type="number"
                      min={1}
                      onValueChange={(value) => {
                        const nextValue = value ? Number.parseInt(value, 10) : undefined;
                        field.handleChange(nextValue as unknown as number);
                      }}
                    />
                  )}
                </form.Field>

                <form.Field name="maxPlayersPerTeam">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Maximum Players per Team"
                      type="number"
                      min={1}
                      onValueChange={(value) => {
                        const nextValue = value ? Number.parseInt(value, 10) : undefined;
                        field.handleChange(nextValue as unknown as number);
                      }}
                    />
                  )}
                </form.Field>
              </div>

              <Separator />

              <div className="space-y-4">
                <h3 className="text-lg font-semibold">Pricing</h3>
                <div className="grid gap-4 md:grid-cols-2">
                  <form.Field name="teamRegistrationFee">
                    {(field) => (
                      <ValidatedInput
                        field={field}
                        label="Team Registration Fee ($)"
                        type="number"
                        min={0}
                        step="0.01"
                        onValueChange={(value) => {
                          field.handleChange(value === "" ? 0 : Number.parseFloat(value));
                        }}
                      />
                    )}
                  </form.Field>

                  <form.Field name="individualRegistrationFee">
                    {(field) => (
                      <ValidatedInput
                        field={field}
                        label="Individual Registration Fee ($)"
                        type="number"
                        min={0}
                        step="0.01"
                        onValueChange={(value) => {
                          field.handleChange(value === "" ? 0 : Number.parseFloat(value));
                        }}
                      />
                    )}
                  </form.Field>
                </div>
              </div>

              <div className="space-y-4">
                <h3 className="text-lg font-semibold">Early Bird Discount</h3>
                <div className="grid gap-4 md:grid-cols-2">
                  <form.Field name="earlyBirdDiscount">
                    {(field) => (
                      <ValidatedInput
                        field={field}
                        label="Discount Percentage"
                        type="number"
                        min={0}
                        max={100}
                        onValueChange={(value) => {
                          field.handleChange(
                            value === "" ? 0 : Number.parseInt(value, 10),
                          );
                        }}
                        description="Percentage discount for early registration"
                      />
                    )}
                  </form.Field>

                  <form.Field name="earlyBirdDeadline">
                    {(field) => (
                      <ValidatedInput
                        field={field}
                        label="Early Bird Deadline"
                        type="date"
                        disabled={!formState.values.earlyBirdDiscount}
                      />
                    )}
                  </form.Field>
                </div>
              </div>

              <Separator />

              <div className="space-y-4">
                <h3 className="text-lg font-semibold">Alternate Payment Options</h3>
                <form.Field name="allowEtransfer">
                  {(field) => (
                    <ValidatedCheckbox
                      field={field}
                      label="Allow Interac e-Transfer"
                      description="Let registrants choose e-transfer instead of Square checkout"
                    />
                  )}
                </form.Field>

                <div className="grid gap-4 md:grid-cols-2">
                  <form.Field name="etransferRecipient">
                    {(field) => (
                      <ValidatedInput
                        field={field}
                        label="E-transfer Recipient Email"
                        type="email"
                        disabled={!formState.values.allowEtransfer}
                        onValueChange={(value) => field.handleChange(value ?? "")}
                        description="Where e-transfer payments should be sent"
                      />
                    )}
                  </form.Field>
                </div>

                <form.Field name="etransferInstructions">
                  {(field) => (
                    <div className="space-y-2">
                      <Label htmlFor="etransferInstructions">
                        E-transfer Instructions
                      </Label>
                      <Textarea
                        id="etransferInstructions"
                        placeholder="Include the security question, expected password, or any other notes for e-transfer payments."
                        value={field.state.value ?? ""}
                        onChange={(event) => field.handleChange(event.target.value)}
                        onBlur={field.handleBlur}
                        disabled={!formState.values.allowEtransfer}
                        className="min-h-[120px]"
                      />
                      {field.state.meta.errors?.length ? (
                        <p className="text-destructive text-sm">
                          {field.state.meta.errors[0]}
                        </p>
                      ) : null}
                    </div>
                  )}
                </form.Field>
              </div>

              <div className="space-y-4">
                <form.Field name="allowWaitlist">
                  {(field) => (
                    <ValidatedCheckbox
                      field={field}
                      label="Allow Waitlist"
                      description="Allow registrations to join a waitlist when the event is full"
                    />
                  )}
                </form.Field>

                <form.Field name="requireMembership">
                  {(field) => (
                    <ValidatedCheckbox
                      field={field}
                      label="Require Active Membership"
                      description="Only allow users with active Quadball Canada memberships to register"
                    />
                  )}
                </form.Field>
              </div>
            </div>
          )}

          {currentStep === 3 && (
            <div className="space-y-6">
              <div className="space-y-4">
                <h3 className="text-lg font-semibold">Contact Information</h3>
                <div className="grid gap-4 md:grid-cols-2">
                  <form.Field name="contactEmail">
                    {(field) => (
                      <ValidatedInput
                        field={field}
                        label="Contact Email"
                        type="email"
                        placeholder="event@example.com"
                      />
                    )}
                  </form.Field>

                  <form.Field name="contactPhone">
                    {(field) => (
                      <ValidatedInput
                        field={field}
                        label="Contact Phone"
                        type="tel"
                        placeholder="(555) 123-4567"
                      />
                    )}
                  </form.Field>
                </div>

                <form.Field name="websiteUrl">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Event Website"
                      type="url"
                      placeholder="https://example.com/event"
                    />
                  )}
                </form.Field>
              </div>
            </div>
          )}

          <div className="flex items-center justify-between pt-6">
            <Button
              type="button"
              variant="outline"
              onClick={() => setCurrentStep((prev) => Math.max(0, prev - 1))}
              disabled={currentStep === 0}
            >
              <ArrowLeft className="mr-2 h-4 w-4" />
              Previous
            </Button>

            {currentStep < steps.length - 1 ? (
              <Button
                type="button"
                onClick={() =>
                  setCurrentStep((prev) => Math.min(steps.length - 1, prev + 1))
                }
                disabled={!canProceedToNext()}
              >
                Next
                <ArrowRight className="ml-2 h-4 w-4" />
              </Button>
            ) : (
              <FormSubmitButton
                isSubmitting={createMutation.isPending}
                loadingText="Creating..."
                disabled={!formState.canSubmit}
              >
                Create Event
              </FormSubmitButton>
            )}
          </div>
        </form>
      </CardContent>
    </Card>
  );
}

function generateSlug(name: string) {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "");
}
</file>

<file path="src/features/events/events.schemas.ts">
import { z } from "zod";
import { baseCreateEventSchema, createEventInputSchema } from "~/db/schema/events.schema";

// Query schemas
export const listEventsSchema = z
  .object({
    filters: z
      .object({
        status: z.union([z.string(), z.array(z.string())]).optional(),
        type: z.union([z.string(), z.array(z.string())]).optional(),
        organizerId: z.string().optional(),
        startDateFrom: z.date().optional(),
        startDateTo: z.date().optional(),
        city: z.string().optional(),
        province: z.string().optional(),
      })
      .optional(),
    page: z.int().positive().optional(),
    pageSize: z.int().positive().optional(),
    sortBy: z.enum(["startDate", "createdAt", "name"]).optional(),
    sortOrder: z.enum(["asc", "desc"]).optional(),
  })
  .optional()
  .prefault({});
export type ListEventsInput = z.infer<typeof listEventsSchema>;

export const getEventSchema = z.object({
  id: z.string().optional(),
  slug: z.string().optional(),
});
export type GetEventInput = z.infer<typeof getEventSchema>;

export const getUpcomingEventsSchema = z
  .object({
    limit: z.int().positive().max(10).optional(),
  })
  .optional()
  .prefault({});
export type GetUpcomingEventsInput = z.infer<typeof getUpcomingEventsSchema>;

export const checkEventRegistrationSchema = z.object({
  eventId: z.string(),
  // userId is now inferred from session - not passed from client
  teamId: z.string().optional(),
});
export type CheckEventRegistrationInput = z.infer<typeof checkEventRegistrationSchema>;

// Mutation schemas
export const createEventSchema = createEventInputSchema;
export type CreateEventInput = z.infer<typeof createEventSchema>;

export const updateEventSchema = z.object({
  eventId: z.string(),
  data: baseCreateEventSchema.partial().extend({
    status: z
      .enum([
        "draft",
        "published",
        "registration_open",
        "registration_closed",
        "in_progress",
        "completed",
        "cancelled",
      ])
      .optional(),
  }),
});
export type UpdateEventInput = z.infer<typeof updateEventSchema>;

const rosterPlayerSchema = z.object({
  userId: z.string(),
  role: z.string().optional(),
  name: z.string().optional(),
  jerseyNumber: z.string().optional(),
});

const rosterObjectSchema = z.looseObject({
  players: z.array(rosterPlayerSchema).optional(),
  emergencyContact: z
    .looseObject({
      name: z.string().optional(),
      phone: z.string().optional(),
      relationship: z.string().optional(),
    })
    .optional(),
});

export const registerForEventSchema = z.object({
  eventId: z.string(),
  teamId: z.string().optional(),
  division: z.string().optional(),
  notes: z.string().optional(),
  roster: z.union([z.array(rosterPlayerSchema), rosterObjectSchema]).optional(),
  paymentMethod: z.enum(["square", "etransfer"]).prefault("square"),
});
export type RegisterForEventInput = z.infer<typeof registerForEventSchema>;

export const cancelEventRegistrationSchema = z.object({
  registrationId: z.string(),
  reason: z.string().optional(),
});
export type CancelEventRegistrationInput = z.infer<typeof cancelEventRegistrationSchema>;

export const cancelEntireEventSchema = z.object({
  eventId: z.uuid(),
  reason: z.string().optional(),
  notify: z.boolean().optional().prefault(true),
  refundMode: z.enum(["auto", "manual", "none"]).optional().prefault("auto"),
});
export type CancelEntireEventInput = z.infer<typeof cancelEntireEventSchema>;

export const markEtransferPaidSchema = z.object({
  registrationId: z.string(),
});

export const markEtransferReminderSchema = z.object({
  registrationId: z.string(),
});
</file>

<file path="src/features/teams/teams.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { zod$ } from "~/lib/server/fn-utils";
import {
  getTeamBySlugSchema,
  getTeamMembersSchema,
  getTeamSchema,
  isTeamMemberSchema,
  listTeamsSchema,
  searchTeamsSchema,
} from "./teams.schemas";

/**
 * Get a team by ID with member count
 */
export const getTeam = createServerFn({ method: "GET" })
  .inputValidator(zod$(getTeamSchema))
  .handler(async ({ data }) => {
    // Import server-only modules inside the handler
    const { getDb } = await import("~/db/server-helpers");
    const { teams, teamMembers } = await import("~/db/schema");
    const { and, eq, sql } = await import("drizzle-orm");

    const db = await getDb();

    const result = await db
      .select({
        team: teams,
        memberCount: sql<number>`count(distinct ${teamMembers.userId})::int`,
      })
      .from(teams)
      .leftJoin(
        teamMembers,
        and(eq(teamMembers.teamId, teams.id), eq(teamMembers.status, "active")),
      )
      .where(eq(teams.id, data.teamId))
      .groupBy(teams.id)
      .limit(1);

    return result[0] || null;
  });

/**
 * Get a team by slug
 */
export const getTeamBySlug = createServerFn({ method: "GET" })
  .inputValidator(zod$(getTeamBySlugSchema))
  .handler(async ({ data }) => {
    // Import server-only modules inside the handler
    const { getDb } = await import("~/db/server-helpers");
    const { teams, teamMembers } = await import("~/db/schema");
    const { and, eq, sql } = await import("drizzle-orm");

    const db = await getDb();

    const result = await db
      .select({
        team: teams,
        memberCount: sql<number>`count(distinct ${teamMembers.userId})::int`,
      })
      .from(teams)
      .leftJoin(
        teamMembers,
        and(eq(teamMembers.teamId, teams.id), eq(teamMembers.status, "active")),
      )
      .where(eq(teams.slug, data.slug))
      .groupBy(teams.id)
      .limit(1);

    return result[0] || null;
  });

/**
 * List all active teams
 */
export const listTeams = createServerFn({ method: "GET" })
  .inputValidator(zod$(listTeamsSchema))
  .handler(async ({ data }) => {
    // Import server-only modules inside the handler
    const { getDb } = await import("~/db/server-helpers");
    const { teams, teamMembers, user } = await import("~/db/schema");
    const { and, desc, eq, sql } = await import("drizzle-orm");

    const db = await getDb();

    const conditions = data?.includeInactive ? undefined : eq(teams.isActive, "true");

    const result = await db
      .select({
        team: teams,
        memberCount: sql<number>`count(distinct ${teamMembers.userId})::int`,
        creator: {
          id: user.id,
          name: user.name,
          email: user.email,
        },
      })
      .from(teams)
      .leftJoin(user, eq(teams.createdBy, user.id))
      .leftJoin(
        teamMembers,
        and(eq(teamMembers.teamId, teams.id), eq(teamMembers.status, "active")),
      )
      .where(conditions)
      .groupBy(teams.id, user.id, user.name, user.email)
      .orderBy(desc(teams.createdAt));

    return result;
  });

/**
 * Get teams for the current user
 */
export const getUserTeams = createServerFn({ method: "GET" })
  .inputValidator(zod$(listTeamsSchema))
  .handler(async ({ data }) => {
    // Import server-only modules inside the handler
    const [{ getCurrentUser }, { getDb }] = await Promise.all([
      import("~/features/auth/auth.queries"),
      import("~/db/server-helpers"),
    ]);
    const { teams, teamMembers } = await import("~/db/schema");
    const { and, desc, eq, sql } = await import("drizzle-orm");

    const currentUser = await getCurrentUser();
    if (!currentUser) {
      throw new Error("Not authenticated");
    }

    const db = await getDb();

    const statusConditions = data?.includeInactive
      ? undefined
      : eq(teamMembers.status, "active");

    const result = await db
      .select({
        team: teams,
        membership: {
          role: teamMembers.role,
          status: teamMembers.status,
          joinedAt: teamMembers.joinedAt,
          jerseyNumber: teamMembers.jerseyNumber,
          position: teamMembers.position,
        },
        memberCount: sql<number>`count(distinct tm2.user_id)::int`,
      })
      .from(teamMembers)
      .innerJoin(teams, eq(teamMembers.teamId, teams.id))
      .leftJoin(
        sql`${teamMembers} as tm2`,
        and(sql`tm2.team_id = ${teams.id}`, sql`tm2.status = 'active'`),
      )
      .where(and(eq(teamMembers.userId, currentUser.id), statusConditions))
      .groupBy(
        teams.id,
        teamMembers.role,
        teamMembers.status,
        teamMembers.joinedAt,
        teamMembers.jerseyNumber,
        teamMembers.position,
      )
      .orderBy(desc(teamMembers.joinedAt));

    return result;
  });

/**
 * Get team members
 */
export const getTeamMembers = createServerFn({ method: "GET" })
  .inputValidator(zod$(getTeamMembersSchema))
  .handler(async ({ data }) => {
    // Import server-only modules inside the handler
    const { getDb } = await import("~/db/server-helpers");
    const { teamMembers, user } = await import("~/db/schema");
    const { and, eq, inArray, sql } = await import("drizzle-orm");

    const db = await getDb();

    const statusCondition = data.includeInactive
      ? undefined
      : inArray(teamMembers.status, ["active", "pending"]);

    const conditions = and(eq(teamMembers.teamId, data.teamId), statusCondition);

    const result = await db
      .select({
        member: {
          id: teamMembers.id,
          role: teamMembers.role,
          status: teamMembers.status,
          jerseyNumber: teamMembers.jerseyNumber,
          position: teamMembers.position,
          joinedAt: teamMembers.joinedAt,
          leftAt: teamMembers.leftAt,
          notes: teamMembers.notes,
          invitedAt: teamMembers.invitedAt,
          requestedAt: teamMembers.requestedAt,
          invitationReminderCount: teamMembers.invitationReminderCount,
          lastInvitationReminderAt: teamMembers.lastInvitationReminderAt,
        },
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
          image: user.image,
        },
        invitedBy: {
          id: sql<string | null>`inviter.id`,
          name: sql<string | null>`inviter.name`,
          email: sql<string | null>`inviter.email`,
        },
      })
      .from(teamMembers)
      .innerJoin(user, eq(teamMembers.userId, user.id))
      .leftJoin(sql`${user} as inviter`, sql`${teamMembers.invitedBy} = inviter.id`)
      .where(conditions)
      .orderBy(
        sql`CASE ${teamMembers.role} 
          WHEN 'captain' THEN 1 
          WHEN 'coach' THEN 2 
          WHEN 'player' THEN 3 
          WHEN 'substitute' THEN 4 
        END`,
        teamMembers.joinedAt,
      );

    return result;
  });

export const getPendingTeamInvites = createServerFn({ method: "GET" }).handler(
  async () => {
    const [{ getCurrentUser }, { getDb }, { and, eq, sql }] = await Promise.all([
      import("~/features/auth/auth.queries"),
      import("~/db/server-helpers"),
      import("drizzle-orm"),
    ]);
    const { teamMembers, teams, user } = await import("~/db/schema");

    const currentUser = await getCurrentUser();
    if (!currentUser) {
      throw new Error("Not authenticated");
    }

    const db = await getDb();

    const invites = await db
      .select({
        membership: {
          id: teamMembers.id,
          teamId: teamMembers.teamId,
          role: teamMembers.role,
          invitedAt: teamMembers.invitedAt,
          requestedAt: teamMembers.requestedAt,
          invitedBy: teamMembers.invitedBy,
        },
        team: {
          id: teams.id,
          name: teams.name,
          slug: teams.slug,
        },
        inviter: {
          id: user.id,
          name: user.name,
          email: user.email,
        },
      })
      .from(teamMembers)
      .innerJoin(teams, eq(teamMembers.teamId, teams.id))
      .leftJoin(user, eq(teamMembers.invitedBy, user.id))
      .where(
        and(eq(teamMembers.userId, currentUser.id), eq(teamMembers.status, "pending")),
      )
      .orderBy(sql`COALESCE(${teamMembers.invitedAt}, ${teamMembers.requestedAt}) DESC`);

    return invites;
  },
);

/**
 * Check if a user is a member of a team
 */
export const isTeamMember = createServerFn({ method: "GET" })
  .inputValidator(zod$(isTeamMemberSchema))
  .handler(async ({ data }) => {
    // Import server-only modules inside the handler
    const { getDb } = await import("~/db/server-helpers");
    const { teamMembers } = await import("~/db/schema");
    const { and, eq, sql } = await import("drizzle-orm");

    const db = await getDb();

    const result = await db
      .select({
        isMember: sql<boolean>`COUNT(*) > 0`,
        role: teamMembers.role,
        status: teamMembers.status,
      })
      .from(teamMembers)
      .where(
        and(eq(teamMembers.teamId, data.teamId), eq(teamMembers.userId, data.userId)),
      )
      .groupBy(teamMembers.role, teamMembers.status)
      .limit(1);

    return result[0] || { isMember: false, role: null, status: null };
  });

/**
 * Search teams by name or city
 */
export const searchTeams = createServerFn({ method: "GET" })
  .inputValidator(zod$(searchTeamsSchema))
  .handler(async ({ data }) => {
    // Import server-only modules inside the handler
    const { getDb } = await import("~/db/server-helpers");
    const { teams, teamMembers } = await import("~/db/schema");
    const { and, eq, sql } = await import("drizzle-orm");

    const db = await getDb();
    const searchTerm = `%${data.query}%`;
    const cityProvince = sql`
      coalesce(${teams.city}, '') || ', ' || coalesce(${teams.province}, '')
    `;

    const result = await db
      .select({
        team: teams,
        memberCount: sql<number>`count(distinct ${teamMembers.userId})::int`,
      })
      .from(teams)
      .leftJoin(
        teamMembers,
        and(eq(teamMembers.teamId, teams.id), eq(teamMembers.status, "active")),
      )
      .where(
        and(
          eq(teams.isActive, "true"),
          sql`(
            ${teams.name} ILIKE ${searchTerm} OR
            ${teams.city} ILIKE ${searchTerm} OR
            ${teams.province} ILIKE ${searchTerm} OR
            ${cityProvince} ILIKE ${searchTerm}
          )`,
        ),
      )
      .groupBy(teams.id)
      .orderBy(teams.name)
      .limit(20);

    return result;
  });

// Export types
export type TeamWithMemberCount = Awaited<ReturnType<typeof getTeam>>;
export type TeamListItem = Awaited<ReturnType<typeof listTeams>>[number];
export type UserTeam = Awaited<ReturnType<typeof getUserTeams>>[number];
export type TeamMemberDetails = Awaited<ReturnType<typeof getTeamMembers>>[number];
export type PendingTeamInvite = Awaited<ReturnType<typeof getPendingTeamInvites>>[number];
</file>

<file path="src/features/teams/teams.mutations.ts">
import { createServerFn } from "@tanstack/react-start";
import { z } from "zod";
import type { TeamMemberRole, TeamMemberStatus } from "~/db/schema";
import { getAuthMiddleware, requireUser } from "~/lib/server/auth";
import { forbidden, notFound, validationError } from "~/lib/server/errors";
import { zod$ } from "~/lib/server/fn-utils";
import {
  addTeamMemberSchema,
  createTeamSchema,
  removeTeamMemberSchema,
  requestTeamMembershipSchema,
  teamInviteActionSchema,
  updateTeamMemberSchema,
  updateTeamSchema,
} from "./teams.schemas";

/**
 * Create a new team
 */
const ACTIVE_TEAM_MEMBERSHIP_CONSTRAINT = "team_members_active_user_idx";

const isActiveMembershipConstraintError = (error: unknown): boolean => {
  if (!error || typeof error !== "object") return false;

  const constraint =
    (error as { constraint?: string }).constraint ??
    (error as { constraint_name?: string }).constraint_name;
  const code = (error as { code?: string }).code;

  if (constraint === ACTIVE_TEAM_MEMBERSHIP_CONSTRAINT && code === "23505") {
    return true;
  }

  if ("cause" in error) {
    return isActiveMembershipConstraintError((error as { cause?: unknown }).cause);
  }

  return false;
};

export const createTeam = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(createTeamSchema))
  .handler(async ({ data, context }) => {
    // Import server-only modules inside the handler
    const [{ getDb }, { createId }] = await Promise.all([
      import("~/db/server-helpers"),
      import("@paralleldrive/cuid2"),
    ]);
    const { teams, teamMembers } = await import("~/db/schema");

    const user = requireUser(context);

    // Debug logging for E2E tests
    if (process.env["NODE_ENV"] === "development") {
      console.log("Creating team with user ID:", user.id);
    }

    const db = await getDb();

    // Start a transaction
    return await db.transaction(async (tx) => {
      // Create the team
      const [newTeam] = await tx
        .insert(teams)
        .values({
          id: createId(),
          name: data.name,
          slug: data.slug.toLowerCase().replace(/[^a-z0-9-]/g, "-"),
          description: data.description,
          city: data.city,
          province: data.province,
          primaryColor: data.primaryColor,
          secondaryColor: data.secondaryColor,
          foundedYear: data.foundedYear,
          website: data.website,
          socialLinks: data.socialLinks ? JSON.stringify(data.socialLinks) : null,
          createdBy: user.id,
        })
        .returning();

      // Add the creator as captain
      try {
        await tx.insert(teamMembers).values({
          id: createId(),
          teamId: newTeam.id,
          userId: user.id,
          role: "captain" as TeamMemberRole,
          status: "active" as TeamMemberStatus,
          invitedBy: user.id,
        });
      } catch (error) {
        if (isActiveMembershipConstraintError(error)) {
          throw validationError(
            "You already have an active team membership. Leave or deactivate your existing team before creating a new one.",
          );
        }

        throw error;
      }

      return newTeam;
    });
  });

/**
 * Update team details
 */
export const updateTeam = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(
    zod$(
      updateTeamSchema.extend({
        data: updateTeamSchema.shape.data.extend({
          socialLinks: z.record(z.string(), z.string()).optional(),
          logoUrl: z.string().optional(),
        }),
      }),
    ),
  )
  .handler(async ({ data, context }) => {
    // Import server-only modules inside the handler
    const [{ getDb }, { and, eq }] = await Promise.all([
      import("~/db/server-helpers"),
      import("drizzle-orm"),
    ]);
    const { teams, teamMembers } = await import("~/db/schema");

    const user = requireUser(context);

    const db = await getDb();

    // Check if user is captain or coach
    const [memberCheck] = await db
      .select({ role: teamMembers.role })
      .from(teamMembers)
      .where(
        and(
          eq(teamMembers.teamId, data.teamId),
          eq(teamMembers.userId, user.id),
          eq(teamMembers.status, "active"),
        ),
      )
      .limit(1);

    if (!memberCheck || !["captain", "coach"].includes(memberCheck.role)) {
      throw forbidden("Only captains or coaches can update team details");
    }

    // Update team
    const [updatedTeam] = await db
      .update(teams)
      .set({
        name: data.data.name,
        description: data.data.description,
        city: data.data.city,
        province: data.data.province,
        primaryColor: data.data.primaryColor,
        secondaryColor: data.data.secondaryColor,
        foundedYear: data.data.foundedYear,
        website: data.data.website,
        socialLinks: data.data.socialLinks
          ? JSON.stringify(data.data.socialLinks)
          : undefined,
        logoUrl: data.data.logoUrl,
      })
      .where(eq(teams.id, data.teamId))
      .returning();

    return updatedTeam;
  });

/**
 * Deactivate a team (soft delete)
 */
export const deactivateTeam = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(z.object({ teamId: z.string() })))
  .handler(async ({ data, context }) => {
    // Import server-only modules inside the handler
    const [{ getDb }, { and, eq }] = await Promise.all([
      import("~/db/server-helpers"),
      import("drizzle-orm"),
    ]);
    const { teams, teamMembers } = await import("~/db/schema");

    const user = requireUser(context);

    const db = await getDb();

    return await db.transaction(async (tx) => {
      // Check if user is captain
      const [memberCheck] = await tx
        .select({ role: teamMembers.role })
        .from(teamMembers)
        .where(
          and(
            eq(teamMembers.teamId, data.teamId),
            eq(teamMembers.userId, user.id),
            eq(teamMembers.status, "active"),
          ),
        )
        .limit(1);

      if (!memberCheck || memberCheck.role !== "captain") {
        throw forbidden("Only team captains can deactivate teams");
      }

      const now = new Date();

      await tx
        .update(teamMembers)
        .set({ status: "inactive", leftAt: now })
        .where(
          and(eq(teamMembers.teamId, data.teamId), eq(teamMembers.status, "active")),
        );

      const [deactivatedTeam] = await tx
        .update(teams)
        .set({ isActive: "false" })
        .where(eq(teams.id, data.teamId))
        .returning();

      return deactivatedTeam;
    });
  });

/**
 * Add a member to a team
 */
export const addTeamMember = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(addTeamMemberSchema))
  .handler(async ({ data, context }) => {
    // Import server-only modules inside the handler
    const [{ getDb }, { and, eq }, { createId }] = await Promise.all([
      import("~/db/server-helpers"),
      import("drizzle-orm"),
      import("@paralleldrive/cuid2"),
    ]);
    const { teamMembers, teams, user } = await import("~/db/schema");

    const currentUser = requireUser(context);

    const db = await getDb();

    // Check if current user has permission to add members
    const [memberCheck] = await db
      .select({ role: teamMembers.role })
      .from(teamMembers)
      .where(
        and(
          eq(teamMembers.teamId, data.teamId),
          eq(teamMembers.userId, currentUser.id),
          eq(teamMembers.status, "active"),
        ),
      )
      .limit(1);

    if (!memberCheck || !["captain", "coach"].includes(memberCheck.role)) {
      throw forbidden("Only captains and coaches can add team members");
    }

    // Find user by email
    const [targetUser] = await db
      .select({ id: user.id, email: user.email, name: user.name })
      .from(user)
      .where(eq(user.email, data.email))
      .limit(1);

    if (!targetUser) {
      throw notFound("User not found with that email address");
    }

    // Check if user is already a member
    const [existingMember] = await db
      .select({ status: teamMembers.status })
      .from(teamMembers)
      .where(
        and(eq(teamMembers.teamId, data.teamId), eq(teamMembers.userId, targetUser.id)),
      )
      .limit(1);

    if (existingMember) {
      if (existingMember.status === "active") {
        throw validationError("User is already an active member of this team");
      }
      // Reactivate if they were previously removed
      const [reactivated] = await db
        .update(teamMembers)
        .set({
          status: "pending" as TeamMemberStatus,
          invitedBy: currentUser.id,
          role: data.role,
          jerseyNumber: data.jerseyNumber,
          position: data.position,
          leftAt: null,
          invitedAt: new Date(),
          invitationReminderCount: 0,
          lastInvitationReminderAt: null,
          requestedAt: null,
        })
        .where(
          and(eq(teamMembers.teamId, data.teamId), eq(teamMembers.userId, targetUser.id)),
        )
        .returning();
      return reactivated;
    }

    // Add new member
    const [newMember] = await db
      .insert(teamMembers)
      .values({
        id: createId(),
        teamId: data.teamId,
        userId: targetUser.id,
        role: data.role,
        status: "pending" as TeamMemberStatus,
        jerseyNumber: data.jerseyNumber,
        position: data.position,
        invitedBy: currentUser.id,
        invitedAt: new Date(),
        invitationReminderCount: 0,
        lastInvitationReminderAt: null,
        requestedAt: null,
      })
      .returning();

    // Send invitation email in the background; failure shouldn't block flow
    const { sendTeamInvitationEmail } = await import("~/lib/email/sendgrid");
    if (targetUser?.email) {
      try {
        const [teamInfo] = await db
          .select({ name: teams.name, slug: teams.slug })
          .from(teams)
          .where(eq(teams.id, data.teamId))
          .limit(1);

        await sendTeamInvitationEmail({
          to: {
            email: targetUser.email,
            name: targetUser.name ?? undefined,
          },
          teamName: teamInfo?.name ?? "Quadball Canada Team",
          teamSlug: teamInfo?.slug ?? data.teamId,
          role: data.role,
          invitedByName: currentUser.name ?? undefined,
          invitedByEmail: currentUser.email ?? undefined,
        });
      } catch (error) {
        console.error("Failed to send team invitation email", error);
      }
    }

    return newMember;
  });

/**
 * Update team member details
 */
export const updateTeamMember = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(updateTeamMemberSchema))
  .handler(async ({ data, context }) => {
    // Import server-only modules inside the handler
    const [{ getDb }, { and, eq, sql }] = await Promise.all([
      import("~/db/server-helpers"),
      import("drizzle-orm"),
    ]);
    const { teamMembers } = await import("~/db/schema");

    const currentUser = requireUser(context);

    const db = await getDb();

    // Check if current user has permission
    const [memberCheck] = await db
      .select({ role: teamMembers.role })
      .from(teamMembers)
      .where(
        and(
          eq(teamMembers.teamId, data.teamId),
          eq(teamMembers.userId, currentUser.id),
          eq(teamMembers.status, "active"),
        ),
      )
      .limit(1);

    if (!memberCheck || !["captain", "coach"].includes(memberCheck.role)) {
      throw forbidden("Only captains and coaches can update team members");
    }

    // Don't allow demoting the last captain
    if (data.role && data.role !== "captain") {
      const [targetMember] = await db
        .select({ role: teamMembers.role })
        .from(teamMembers)
        .where(eq(teamMembers.id, data.memberId))
        .limit(1);

      if (targetMember?.role === "captain") {
        const [captainCount] = await db
          .select({ count: sql<number>`count(*)::int` })
          .from(teamMembers)
          .where(
            and(
              eq(teamMembers.teamId, data.teamId),
              eq(teamMembers.role, "captain"),
              eq(teamMembers.status, "active"),
            ),
          );
        const totalCaptains = captainCount?.count ?? 0;
        if (totalCaptains <= 1) {
          throw validationError("Cannot demote the last captain");
        }
      }
    }

    // Update member
    const [updatedMember] = await db
      .update(teamMembers)
      .set({
        role: data.role,
        jerseyNumber: data.jerseyNumber,
        position: data.position,
        notes: data.notes,
      })
      .where(eq(teamMembers.id, data.memberId))
      .returning();

    return updatedMember;
  });

/**
 * Remove a member from team
 */
export const removeTeamMember = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(removeTeamMemberSchema))
  .handler(async ({ data, context }) => {
    // Import server-only modules inside the handler
    const [{ getDb }, { and, eq, sql }] = await Promise.all([
      import("~/db/server-helpers"),
      import("drizzle-orm"),
    ]);
    const { teamMembers } = await import("~/db/schema");

    const currentUser = requireUser(context);

    const db = await getDb();

    // Check if current user has permission
    const [memberCheck] = await db
      .select({ role: teamMembers.role })
      .from(teamMembers)
      .where(
        and(
          eq(teamMembers.teamId, data.teamId),
          eq(teamMembers.userId, currentUser.id),
          eq(teamMembers.status, "active"),
        ),
      )
      .limit(1);

    if (!memberCheck || !["captain", "coach"].includes(memberCheck.role)) {
      throw forbidden("Only captains and coaches can remove team members");
    }

    // Don't allow removing the last captain
    const [targetMember] = await db
      .select({ role: teamMembers.role })
      .from(teamMembers)
      .where(eq(teamMembers.id, data.memberId))
      .limit(1);

    if (targetMember?.role === "captain") {
      const [captainCount] = await db
        .select({ count: sql<number>`count(*)::int` })
        .from(teamMembers)
        .where(
          and(
            eq(teamMembers.teamId, data.teamId),
            eq(teamMembers.role, "captain"),
            eq(teamMembers.status, "active"),
          ),
        );
      const totalCaptains = captainCount?.count ?? 0;
      if (totalCaptains <= 1) {
        throw validationError("Cannot remove the last captain");
      }
    }

    // Soft delete by updating status
    const [removedMember] = await db
      .update(teamMembers)
      .set({
        status: "inactive" as TeamMemberStatus,
        leftAt: new Date(),
      })
      .where(eq(teamMembers.id, data.memberId))
      .returning();

    return removedMember;
  });

/**
 * Accept a team invite
 */
export const acceptTeamInvite = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(teamInviteActionSchema))
  .handler(async ({ data, context }) => {
    // Import server-only modules inside the handler
    const [{ getDb }, { and, eq }] = await Promise.all([
      import("~/db/server-helpers"),
      import("drizzle-orm"),
    ]);
    const { teamMembers } = await import("~/db/schema");

    const currentUser = requireUser(context);

    const db = await getDb();

    // Update membership status
    const [updatedMember] = await db
      .update(teamMembers)
      .set({
        status: "active" as TeamMemberStatus,
        joinedAt: new Date(),
        requestedAt: null,
      })
      .where(
        and(
          eq(teamMembers.teamId, data.teamId),
          eq(teamMembers.userId, currentUser.id),
          eq(teamMembers.status, "pending"),
        ),
      )
      .returning();

    if (!updatedMember) {
      throw notFound("No pending invite found for this team");
    }

    return updatedMember;
  });

/**
 * Decline a team invite
 */
export const declineTeamInvite = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(teamInviteActionSchema))
  .handler(async ({ data, context }) => {
    // Import server-only modules inside the handler
    const [{ getDb }, { and, eq }] = await Promise.all([
      import("~/db/server-helpers"),
      import("drizzle-orm"),
    ]);
    const { teamMembers } = await import("~/db/schema");

    const currentUser = requireUser(context);

    const db = await getDb();

    // Update membership status
    const [declinedMember] = await db
      .update(teamMembers)
      .set({
        status: "inactive" as TeamMemberStatus,
        leftAt: new Date(),
        requestedAt: null,
      })
      .where(
        and(
          eq(teamMembers.teamId, data.teamId),
          eq(teamMembers.userId, currentUser.id),
          eq(teamMembers.status, "pending"),
        ),
      )
      .returning();

    if (!declinedMember) {
      throw notFound("No pending invite found for this team");
    }

    return declinedMember;
  });

export const requestTeamMembership = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(requestTeamMembershipSchema))
  .handler(async ({ data, context }) => {
    const [{ getDb }, { and, eq }, { createId }] = await Promise.all([
      import("~/db/server-helpers"),
      import("drizzle-orm"),
      import("@paralleldrive/cuid2"),
    ]);
    const { teamMembers } = await import("~/db/schema");

    const currentUser = requireUser(context);

    const db = await getDb();

    const [existingMember] = await db
      .select({
        id: teamMembers.id,
        status: teamMembers.status,
        invitedBy: teamMembers.invitedBy,
      })
      .from(teamMembers)
      .where(
        and(eq(teamMembers.teamId, data.teamId), eq(teamMembers.userId, currentUser.id)),
      )
      .limit(1);

    if (existingMember) {
      if (existingMember.status === "active") {
        throw validationError("You are already an active member of this team");
      }

      if (existingMember.status === "pending") {
        if (existingMember.invitedBy) {
          throw validationError("You already have a pending invitation for this team");
        }

        const [refreshedMember] = await db
          .update(teamMembers)
          .set({
            requestedAt: new Date(),
            invitationReminderCount: 0,
            lastInvitationReminderAt: null,
          })
          .where(eq(teamMembers.id, existingMember.id))
          .returning();

        return refreshedMember;
      }

      const [reactivatedMember] = await db
        .update(teamMembers)
        .set({
          status: "pending" as TeamMemberStatus,
          invitedBy: null,
          requestedAt: new Date(),
          invitedAt: null,
          invitationReminderCount: 0,
          lastInvitationReminderAt: null,
          leftAt: null,
        })
        .where(eq(teamMembers.id, existingMember.id))
        .returning();

      return reactivatedMember;
    }

    const [newRequest] = await db
      .insert(teamMembers)
      .values({
        id: createId(),
        teamId: data.teamId,
        userId: currentUser.id,
        role: "player" as TeamMemberRole,
        status: "pending" as TeamMemberStatus,
        invitedBy: null,
        requestedAt: new Date(),
        invitationReminderCount: 0,
        lastInvitationReminderAt: null,
      })
      .returning();

    return newRequest;
  });

/**
 * Leave a team voluntarily
 */
export const leaveTeam = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(z.object({ teamId: z.string() })))
  .handler(async ({ data, context }) => {
    // Import server-only modules inside the handler
    const [{ getDb }, { and, eq, sql }] = await Promise.all([
      import("~/db/server-helpers"),
      import("drizzle-orm"),
    ]);
    const { teamMembers } = await import("~/db/schema");

    const currentUser = requireUser(context);

    const db = await getDb();

    // Check membership
    const [member] = await db
      .select({ role: teamMembers.role })
      .from(teamMembers)
      .where(
        and(
          eq(teamMembers.teamId, data.teamId),
          eq(teamMembers.userId, currentUser.id),
          eq(teamMembers.status, "active"),
        ),
      )
      .limit(1);

    if (!member) {
      throw notFound("You are not an active member of this team");
    }

    // Don't allow the last captain to leave
    if (member.role === "captain") {
      const [captainCount] = await db
        .select({ count: sql<number>`count(*)::int` })
        .from(teamMembers)
        .where(
          and(
            eq(teamMembers.teamId, data.teamId),
            eq(teamMembers.role, "captain"),
            eq(teamMembers.status, "active"),
          ),
        );
      const totalCaptains = captainCount?.count ?? 0;
      if (totalCaptains <= 1) {
        throw validationError(
          "Cannot leave team as the last captain. Promote another member first.",
        );
      }
    }

    // Update membership status
    const [leftMember] = await db
      .update(teamMembers)
      .set({
        status: "inactive" as TeamMemberStatus,
        leftAt: new Date(),
      })
      .where(
        and(eq(teamMembers.teamId, data.teamId), eq(teamMembers.userId, currentUser.id)),
      )
      .returning();

    return leftMember;
  });
</file>

<file path="src/features/events/events.mutations.ts">
import { createServerFn } from "@tanstack/react-start";
import { and, eq, inArray, or, sql } from "drizzle-orm";
import type { EventRegistration } from "~/db/schema";
import {
  eventPaymentSessions,
  eventRegistrations,
  events,
  teamMembers,
} from "~/db/schema";
import { createEventInputSchema } from "~/db/schema/events.schema";
import { atomicJsonbMerge } from "~/lib/db/jsonb-utils";
import { getAuthMiddleware, requireUser } from "~/lib/server/auth";
import { zod$ } from "~/lib/server/fn-utils";
import type { EventPaymentMetadata } from "./events.db-types";
import {
  cancelEntireEventSchema,
  cancelEventRegistrationSchema,
  createEventSchema,
  markEtransferPaidSchema,
  markEtransferReminderSchema,
  registerForEventSchema,
  updateEventSchema,
} from "./events.schemas";
import type {
  CancelEventResult,
  EventOperationResult,
  EventRegistrationResultPayload,
  EventRegistrationWithDetails,
  EventWithDetails,
} from "./events.types";
import type { EventRegistrationWithRoster } from "./utils";
import {
  appendCancellationNote,
  buildEtransferSnapshot,
  calculateRegistrationAmountCents,
  castEventJsonbFields,
  castRegistrationJsonbFields,
  currentTimestamp,
  getClockFromContext,
  isoTimestamp,
  markEtransferPaidMetadata,
  markEtransferReminderMetadata,
} from "./utils";

/**
 * Cancel an entire event and cascade updates to registrations & payments.
 */
export const cancelEvent = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(cancelEntireEventSchema))
  .handler(
    async ({ data, context }): Promise<EventOperationResult<CancelEventResult>> => {
      const clock = getClockFromContext(context);
      const now = currentTimestamp(clock);
      const nowIso = isoTimestamp(clock);

      try {
        const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);
        const db = await getDb();
        const user = requireUser(context);

        const [eventRecord] = await db
          .select()
          .from(events)
          .where(eq(events.id, data.eventId))
          .limit(1);

        if (!eventRecord) {
          return {
            success: false,
            errors: [
              {
                code: "NOT_FOUND",
                message: "Event not found",
              },
            ],
          };
        }

        let authorized = eventRecord.organizerId === user.id;
        if (!authorized) {
          const { isAdmin } = await import("~/lib/auth/utils/admin-check");
          authorized = await isAdmin(user.id);
        }

        if (!authorized) {
          return {
            success: false,
            errors: [
              {
                code: "FORBIDDEN",
                message: "You cannot cancel this event",
              },
            ],
          };
        }

        await db
          .update(events)
          .set({
            status: "cancelled",
            updatedAt: now,
            metadata: atomicJsonbMerge(events.metadata, {
              cancelledAt: nowIso,
              cancelledBy: user.id,
              cancellationReason: data.reason ?? null,
            }),
          })
          .where(eq(events.id, data.eventId));

        const registrations = await db
          .select()
          .from(eventRegistrations)
          .where(eq(eventRegistrations.eventId, data.eventId));

        const paymentSessions = await db
          .select()
          .from(eventPaymentSessions)
          .where(eq(eventPaymentSessions.eventId, data.eventId));

        const latestSessionByRegistration = new Map<
          string,
          (typeof paymentSessions)[number]
        >();
        for (const session of paymentSessions) {
          const current = latestSessionByRegistration.get(session.registrationId);
          if (!current || (session.createdAt ?? now) > (current.createdAt ?? now)) {
            latestSessionByRegistration.set(session.registrationId, session);
          }
        }

        const result: CancelEventResult = {
          eventId: data.eventId,
          affected: {
            totalRegistrations: registrations.length,
            cancelled: 0,
            alreadyCancelled: 0,
            squareRefunded: 0,
            etransferMarkedForRefund: 0,
            freeOrUnpaid: 0,
          },
          errors: [],
        };

        const squareService =
          data.refundMode === "auto" ? await getSquarePaymentService() : null;

        for (const registration of registrations) {
          if (registration.status === "cancelled") {
            result.affected.alreadyCancelled += 1;
            continue;
          }

          const existingMetadata = (registration.paymentMetadata ??
            {}) as EventPaymentMetadata;
          const noteParts = [`Event cancelled by ${user.id} at ${nowIso}`];
          if (data.reason) {
            noteParts.push(`Reason: ${data.reason}`);
          }
          const cancellationNote = noteParts.join(" — ");

          const paymentMetadata = appendCancellationNote(
            existingMetadata,
            cancellationNote,
          );
          const existingNotes = registration.internalNotes ?? "";
          const hasNoteAlready = existingNotes.split("\n").includes(cancellationNote);
          const internalNotes = hasNoteAlready
            ? existingNotes
            : [cancellationNote, existingNotes].filter(Boolean).join("\n");

          const baseUpdate: Partial<typeof eventRegistrations.$inferInsert> = {
            status: "cancelled",
            cancelledAt: now,
            updatedAt: now,
            internalNotes,
            paymentMetadata,
          };

          let finalPaymentStatus = registration.paymentStatus;
          let sessionUpdated = false;
          const session = latestSessionByRegistration.get(registration.id);
          const amountPaid = registration.amountPaidCents ?? 0;
          const amountDue = registration.amountDueCents ?? 0;
          const amountToRefund = amountPaid > 0 ? amountPaid : amountDue;

          if (registration.paymentMethod === "square" && amountToRefund > 0) {
            if (data.refundMode === "none") {
              result.affected.freeOrUnpaid += 1;
            } else if (!squareService || data.refundMode === "manual") {
              finalPaymentStatus = "refund_required";
              result.affected.etransferMarkedForRefund += 1;
            } else {
              let paymentId = session?.squarePaymentId ?? null;

              if (!paymentId && session?.squareCheckoutId) {
                const verification = await squareService.verifyPayment(
                  session.squareCheckoutId,
                );
                if (verification.success && verification.paymentId) {
                  paymentId = verification.paymentId;
                  await db
                    .update(eventPaymentSessions)
                    .set({
                      squarePaymentId: paymentId,
                      updatedAt: now,
                    })
                    .where(eq(eventPaymentSessions.id, session.id));
                }
              }

              if (!paymentId) {
                finalPaymentStatus = "refund_required";
                result.affected.etransferMarkedForRefund += 1;
                result.errors.push({
                  registrationId: registration.id,
                  code: "NO_PAYMENT_SESSION",
                  message:
                    "Square payment could not be resolved; flagged for manual refund.",
                });
              } else {
                try {
                  const refund = await squareService.createRefund(
                    paymentId,
                    amountToRefund,
                    "Event cancelled",
                  );

                  if (refund.success) {
                    finalPaymentStatus = "refunded";
                    result.affected.squareRefunded += 1;
                    if (session) {
                      await db
                        .update(eventPaymentSessions)
                        .set({
                          status: "refunded",
                          metadata: atomicJsonbMerge(eventPaymentSessions.metadata, {
                            refundedAt: nowIso,
                            refundId: refund.refundId ?? null,
                            cancelledBy: user.id,
                          }),
                          updatedAt: now,
                        })
                        .where(eq(eventPaymentSessions.id, session.id));
                      sessionUpdated = true;
                    }
                  } else {
                    finalPaymentStatus = "refund_required";
                    result.affected.etransferMarkedForRefund += 1;
                    result.errors.push({
                      registrationId: registration.id,
                      code: "REFUND_FAILED",
                      message: refund.error ?? "Square refund failed",
                      paymentId,
                    });
                  }
                } catch (refundError) {
                  finalPaymentStatus = "refund_required";
                  result.affected.etransferMarkedForRefund += 1;
                  result.errors.push({
                    registrationId: registration.id,
                    code: "REFUND_FAILED",
                    message:
                      refundError instanceof Error
                        ? refundError.message
                        : "Square refund threw an unexpected error",
                    paymentId,
                  });
                }
              }
            }
          } else if (registration.paymentMethod === "etransfer" && amountToRefund > 0) {
            finalPaymentStatus = "refund_required";
            result.affected.etransferMarkedForRefund += 1;
          } else {
            result.affected.freeOrUnpaid += 1;
          }

          const update = {
            ...baseUpdate,
            paymentStatus: finalPaymentStatus,
          } satisfies Partial<typeof eventRegistrations.$inferInsert>;

          await db
            .update(eventRegistrations)
            .set(update)
            .where(eq(eventRegistrations.id, registration.id));

          if (session && !sessionUpdated) {
            await db
              .update(eventPaymentSessions)
              .set({
                status: "cancelled",
                metadata: atomicJsonbMerge(eventPaymentSessions.metadata, {
                  cancelledAt: nowIso,
                  cancelledBy: user.id,
                }),
                updatedAt: now,
              })
              .where(eq(eventPaymentSessions.id, session.id));
          }

          result.affected.cancelled += 1;
        }

        if (data.notify !== false) {
          try {
            const { sendEventCancellationNotifications } = await import(
              "~/lib/server/notifications/events/cancellation"
            );
            await sendEventCancellationNotifications({
              db,
              event: eventRecord,
              ...(data.reason ? { reason: data.reason } : {}),
            });
          } catch (notificationError) {
            console.warn("Failed to send cancellation notifications:", notificationError);
          }
        }

        return {
          success: true,
          data: result,
        };
      } catch (error) {
        console.error("Error cancelling event:", error);
        return {
          success: false,
          errors: [
            {
              code: "DATABASE_ERROR",
              message: "Failed to cancel event",
            },
          ],
        };
      }
    },
  );

/**
 * Create a new event
 */
export const createEvent = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(createEventSchema))
  .handler(async ({ data, context }): Promise<EventOperationResult<EventWithDetails>> => {
    try {
      // Import server-only modules inside the handler
      const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);

      const db = await getDb();
      const user = requireUser(context);

      // Validate input
      const validationResult = createEventInputSchema.safeParse(data);
      if (!validationResult.success) {
        return {
          success: false,
          errors: validationResult.error.issues.map((issue) => ({
            code: "VALIDATION_ERROR" as const,
            message: issue.message,
            field: issue.path.join("."),
          })),
        };
      }

      // Check for duplicate slug
      const [existingEvent] = await db
        .select({ id: events.id })
        .from(events)
        .where(eq(events.slug, data.slug))
        .limit(1);

      if (existingEvent) {
        return {
          success: false,
          errors: [
            {
              code: "DUPLICATE_SLUG",
              message: "An event with this slug already exists",
              field: "slug",
            },
          ],
        };
      }

      // Validate dates
      const startDate = new Date(data.startDate);
      const endDate = new Date(data.endDate);

      if (startDate > endDate) {
        return {
          success: false,
          errors: [
            {
              code: "INVALID_DATES",
              message: "Start date must be before end date",
            },
          ],
        };
      }

      const [newEvent] = await db
        .insert(events)
        .values({
          ...data,
          organizerId: user.id,
          startDate: data.startDate,
          endDate: data.endDate,
        })
        .returning();

      return {
        success: true,
        data: castEventJsonbFields(newEvent),
      };
    } catch (error) {
      console.error("Error creating event:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to create event",
          },
        ],
      };
    }
  });

/**
 * Update an event
 */
export const updateEvent = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(updateEventSchema))
  .handler(async ({ data, context }): Promise<EventOperationResult<EventWithDetails>> => {
    try {
      // Import server-only modules inside the handler
      const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);

      const db = await getDb();
      const user = requireUser(context);

      // Check if event exists and user is organizer
      const [existingEvent] = await db
        .select()
        .from(events)
        .where(eq(events.id, data.eventId))
        .limit(1);

      if (!existingEvent) {
        return {
          success: false,
          errors: [
            {
              code: "NOT_FOUND",
              message: "Event not found",
            },
          ],
        };
      }

      // Check if user is organizer or admin
      const { isAdmin } = await import("~/lib/auth/utils/admin-check");
      const userIsAdmin = await isAdmin(user.id);

      if (existingEvent.organizerId !== user.id && !userIsAdmin) {
        return {
          success: false,
          errors: [
            {
              code: "FORBIDDEN",
              message: "Only the event organizer or an admin can update this event",
            },
          ],
        };
      }

      // Check for duplicate slug if updating
      if (data.data.slug && data.data.slug !== existingEvent.slug) {
        const [duplicateEvent] = await db
          .select({ id: events.id })
          .from(events)
          .where(
            and(eq(events.slug, data.data.slug), sql`${events.id} != ${data.eventId}`),
          )
          .limit(1);

        if (duplicateEvent) {
          return {
            success: false,
            errors: [
              {
                code: "DUPLICATE_SLUG",
                message: "An event with this slug already exists",
                field: "slug",
              },
            ],
          };
        }
      }

      // Validate dates if provided
      if (data.data.startDate || data.data.endDate) {
        const startDate = new Date(data.data.startDate || existingEvent.startDate);
        const endDate = new Date(data.data.endDate || existingEvent.endDate);

        if (startDate > endDate) {
          return {
            success: false,
            errors: [
              {
                code: "INVALID_DATES",
                message: "Start date must be before end date",
              },
            ],
          };
        }
      }

      // Update event
      const [updatedEvent] = await db
        .update(events)
        .set({
          ...data.data,
          updatedAt: new Date(),
        })
        .where(eq(events.id, data.eventId))
        .returning();

      return {
        success: true,
        data: castEventJsonbFields(updatedEvent),
      };
    } catch (error) {
      console.error("Error updating event:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to update event",
          },
        ],
      };
    }
  });

const getSquarePaymentService = async () => {
  const { getSquarePaymentService: loadSquareService } = await import(
    "~/lib/payments/square"
  );
  return loadSquareService();
};

/**
 * Register for an event
 */
export const registerForEvent = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(registerForEventSchema))
  .handler(
    async ({
      data,
      context,
    }): Promise<EventOperationResult<EventRegistrationResultPayload>> => {
      try {
        const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);

        const db = await getDb();
        const user = requireUser(context);
        const clock = getClockFromContext(context);

        const [event] = await db
          .select()
          .from(events)
          .where(eq(events.id, data.eventId))
          .limit(1);

        if (!event) {
          return {
            success: false,
            errors: [
              {
                code: "NOT_FOUND",
                message: "Event not found",
              },
            ],
          };
        }

        if (event.status !== "registration_open") {
          return {
            success: false,
            errors: [
              {
                code: "REGISTRATION_CLOSED",
                message: "Registration is not open for this event",
              },
            ],
          };
        }

        const now = currentTimestamp(clock);
        const registrationOpens = event.registrationOpensAt;
        const registrationCloses = event.registrationClosesAt;

        if (registrationOpens && now < registrationOpens) {
          return {
            success: false,
            errors: [
              {
                code: "REGISTRATION_CLOSED",
                message: "Registration has not opened yet",
              },
            ],
          };
        }

        if (registrationCloses && now > registrationCloses) {
          return {
            success: false,
            errors: [
              {
                code: "REGISTRATION_CLOSED",
                message: "Registration has closed",
              },
            ],
          };
        }

        const paymentMethod = data.paymentMethod ?? "square";
        if (paymentMethod === "etransfer" && !event.allowEtransfer) {
          return {
            success: false,
            errors: [
              {
                code: "FORBIDDEN",
                message: "E-transfer is not available for this event",
              },
            ],
          };
        }

        const registrationType: EventRegistration["registrationType"] = data.teamId
          ? "team"
          : "individual";

        if (event.registrationType === "team" && registrationType !== "team") {
          return {
            success: false,
            errors: [
              {
                code: "FORBIDDEN",
                message: "Only team registrations are allowed for this event",
              },
            ],
          };
        }

        if (
          event.registrationType === "individual" &&
          registrationType !== "individual"
        ) {
          return {
            success: false,
            errors: [
              {
                code: "FORBIDDEN",
                message: "Only individual registrations are allowed for this event",
              },
            ],
          };
        }

        // Check for existing registration with any active status (pending, confirmed, waitlisted)
        // This prevents duplicate registrations and checkout sessions
        const existingRegistration = await db
          .select()
          .from(eventRegistrations)
          .where(
            and(
              eq(eventRegistrations.eventId, data.eventId),
              or(
                eq(eventRegistrations.userId, user.id),
                data.teamId ? eq(eventRegistrations.teamId, data.teamId) : undefined,
              ),
              inArray(eventRegistrations.status, ["pending", "confirmed", "waitlisted"]),
            ),
          )
          .limit(1);

        if (existingRegistration.length > 0) {
          const status = existingRegistration[0].status;
          const message =
            status === "pending"
              ? "You have a pending registration. Please complete payment or cancel it first."
              : "You or your team are already registered for this event";
          return {
            success: false,
            errors: [
              {
                code: "ALREADY_REGISTERED",
                message,
              },
            ],
          };
        }

        const registrationCount = await db
          .select({ count: sql<number>`count(*)::int` })
          .from(eventRegistrations)
          .where(
            and(
              eq(eventRegistrations.eventId, data.eventId),
              eq(eventRegistrations.status, "confirmed"),
            ),
          );

        const confirmedCount = registrationCount[0].count;

        if (
          event.registrationType === "team" &&
          event.maxTeams &&
          confirmedCount >= event.maxTeams
        ) {
          return {
            success: false,
            errors: [
              {
                code: "EVENT_FULL",
                message: "This event is full",
              },
            ],
          };
        }

        if (
          event.registrationType === "individual" &&
          event.maxParticipants &&
          confirmedCount >= event.maxParticipants
        ) {
          return {
            success: false,
            errors: [
              {
                code: "EVENT_FULL",
                message: "This event is full",
              },
            ],
          };
        }

        if (data.teamId) {
          const [membership] = await db
            .select()
            .from(teamMembers)
            .where(
              and(
                eq(teamMembers.teamId, data.teamId),
                eq(teamMembers.userId, user.id),
                eq(teamMembers.status, "active"),
              ),
            )
            .limit(1);

          if (!membership) {
            return {
              success: false,
              errors: [
                {
                  code: "FORBIDDEN",
                  message: "You must be an active member of the team to register",
                },
              ],
            };
          }

          if (membership.role !== "captain" && membership.role !== "coach") {
            return {
              success: false,
              errors: [
                {
                  code: "FORBIDDEN",
                  message:
                    "Only team captains and coaches can register the team for events",
                },
              ],
            };
          }
        }

        const amountDueCents = calculateRegistrationAmountCents(
          event,
          registrationType,
          now,
        );

        let paymentStatus: EventRegistration["paymentStatus"] = "pending";
        let amountPaidCents: number | null = null;
        let paymentCompletedAt: Date | null = null;

        if (amountDueCents === 0) {
          paymentStatus = "paid";
          amountPaidCents = 0;
          paymentCompletedAt = now;
        } else if (paymentMethod === "etransfer") {
          paymentStatus = "awaiting_etransfer";
        }

        const paymentMetadata =
          paymentMethod === "etransfer"
            ? buildEtransferSnapshot(
                event.etransferInstructions,
                event.etransferRecipient,
              )
            : null;

        const [registration] = await db
          .insert(eventRegistrations)
          .values({
            eventId: data.eventId,
            userId: user.id,
            teamId: data.teamId,
            registrationType,
            division: data.division,
            notes: data.notes,
            // Store directly as JSONB - Drizzle handles serialization
            // Normalize to object format if array is passed
            roster: data.roster
              ? Array.isArray(data.roster)
                ? { players: data.roster }
                : data.roster
              : null,
            status: amountDueCents === 0 ? "confirmed" : "pending",
            paymentStatus,
            paymentMethod,
            paymentId: null,
            amountDueCents,
            amountPaidCents,
            paymentCompletedAt,
            paymentMetadata,
          })
          .returning();

        let paymentResponse: EventRegistrationResultPayload["payment"];

        if (paymentMethod === "square" && amountDueCents > 0) {
          const squareService = await getSquarePaymentService();
          const checkoutSession = await squareService.createEventCheckoutSession({
            eventId: event.id,
            registrationId: registration.id,
            userId: user.id,
            amount: amountDueCents,
            eventName: event.name,
          });

          await db
            .insert(eventPaymentSessions)
            .values({
              registrationId: registration.id,
              eventId: event.id,
              userId: user.id,
              squareCheckoutId: checkoutSession.id,
              squarePaymentLinkUrl: checkoutSession.checkoutUrl,
              squareOrderId: checkoutSession.orderId ?? null,
              amountCents: amountDueCents,
              currency: checkoutSession.currency,
              metadata: {
                eventName: event.name,
                registrationType,
                paymentMethod,
              },
            })
            .onConflictDoUpdate({
              target: eventPaymentSessions.squareCheckoutId,
              set: {
                registrationId: registration.id,
                eventId: event.id,
                userId: user.id,
                squarePaymentLinkUrl: checkoutSession.checkoutUrl,
                squareOrderId: checkoutSession.orderId ?? null,
                amountCents: amountDueCents,
                currency: checkoutSession.currency,
                metadata: {
                  eventName: event.name,
                  registrationType,
                  paymentMethod,
                },
                updatedAt: currentTimestamp(clock),
              },
            });

          paymentResponse = {
            method: "square",
            checkoutUrl: checkoutSession.checkoutUrl,
            sessionId: checkoutSession.id,
          };
        } else if (amountDueCents === 0) {
          paymentResponse = { method: "free" };
        } else {
          paymentResponse = {
            method: "etransfer",
            instructions: event.etransferInstructions ?? null,
            recipient: event.etransferRecipient ?? null,
          };
        }

        const parsedRegistration = castRegistrationJsonbFields(registration);

        const registrationWithDetails: EventRegistrationWithDetails = {
          ...parsedRegistration,
          event: castEventJsonbFields(event),
          user: {
            id: user.id,
            name: user.name ?? user.email ?? "",
            email: user.email ?? "",
          },
        };

        return {
          success: true,
          data: {
            registration: registrationWithDetails,
            payment: paymentResponse,
          },
        };
      } catch (error) {
        console.error("Error registering for event:", error);
        return {
          success: false,
          errors: [
            {
              code: "DATABASE_ERROR",
              message: "Failed to register for event",
            },
          ],
        };
      }
    },
  );

export const markEventEtransferPaid = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(markEtransferPaidSchema))
  .handler(
    async ({
      data,
      context,
    }): Promise<EventOperationResult<EventRegistrationWithRoster>> => {
      try {
        const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);

        const db = await getDb();
        const user = requireUser(context);
        const clock = getClockFromContext(context);

        const registrationWithEvent = await db
          .select({
            registration: eventRegistrations,
            event: events,
          })
          .from(eventRegistrations)
          .innerJoin(events, eq(eventRegistrations.eventId, events.id))
          .where(eq(eventRegistrations.id, data.registrationId))
          .limit(1);

        if (registrationWithEvent.length === 0) {
          return {
            success: false,
            errors: [
              {
                code: "NOT_FOUND",
                message: "Registration not found",
              },
            ],
          };
        }

        const [{ registration, event }] = registrationWithEvent;

        const isOrganizer = event.organizerId === user.id;
        let isGlobalAdmin = false;
        if (!isOrganizer) {
          const { isAdmin } = await import("~/lib/auth/utils/admin-check");
          isGlobalAdmin = await isAdmin(user.id);
        }

        if (!isOrganizer && !isGlobalAdmin) {
          return {
            success: false,
            errors: [
              {
                code: "FORBIDDEN",
                message: "You do not have permission to update this registration",
              },
            ],
          };
        }

        if (registration.paymentMethod !== "etransfer") {
          return {
            success: false,
            errors: [
              {
                code: "VALIDATION_ERROR",
                message: "Only e-transfer registrations can be marked as paid manually",
              },
            ],
          };
        }

        const now = currentTimestamp(clock);
        const existingMetadata = (registration.paymentMetadata ||
          {}) as EventPaymentMetadata;
        const updatedMetadata = markEtransferPaidMetadata(
          existingMetadata,
          user.id,
          clock,
        );

        const [updatedRegistration] = await db
          .update(eventRegistrations)
          .set({
            paymentStatus: "paid",
            status:
              registration.status === "cancelled" ? registration.status : "confirmed",
            paymentCompletedAt: now,
            amountPaidCents: registration.amountDueCents,
            paymentMetadata: updatedMetadata,
            updatedAt: now,
          })
          .where(eq(eventRegistrations.id, data.registrationId))
          .returning();

        return {
          success: true,
          data: castRegistrationJsonbFields(updatedRegistration),
        };
      } catch (error) {
        console.error("Error marking e-transfer as paid:", error);
        return {
          success: false,
          errors: [
            {
              code: "DATABASE_ERROR",
              message: "Failed to update registration",
            },
          ],
        };
      }
    },
  );

export const markEventEtransferReminder = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(markEtransferReminderSchema))
  .handler(
    async ({
      data,
      context,
    }): Promise<EventOperationResult<EventRegistrationWithRoster>> => {
      try {
        const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);

        const db = await getDb();
        const user = requireUser(context);
        const clock = getClockFromContext(context);

        const registrationWithEvent = await db
          .select({
            registration: eventRegistrations,
            event: events,
          })
          .from(eventRegistrations)
          .innerJoin(events, eq(eventRegistrations.eventId, events.id))
          .where(eq(eventRegistrations.id, data.registrationId))
          .limit(1);

        if (registrationWithEvent.length === 0) {
          return {
            success: false,
            errors: [
              {
                code: "NOT_FOUND",
                message: "Registration not found",
              },
            ],
          };
        }

        const [{ registration, event }] = registrationWithEvent;

        const isOrganizer = event.organizerId === user.id;
        let isGlobalAdmin = false;
        if (!isOrganizer) {
          const { isAdmin } = await import("~/lib/auth/utils/admin-check");
          isGlobalAdmin = await isAdmin(user.id);
        }

        if (!isOrganizer && !isGlobalAdmin) {
          return {
            success: false,
            errors: [
              {
                code: "FORBIDDEN",
                message: "You do not have permission to update this registration",
              },
            ],
          };
        }

        if (registration.paymentMethod !== "etransfer") {
          return {
            success: false,
            errors: [
              {
                code: "VALIDATION_ERROR",
                message: "Only e-transfer registrations can receive reminders",
              },
            ],
          };
        }

        const now = currentTimestamp(clock);
        const existingMetadata = (registration.paymentMetadata ||
          {}) as EventPaymentMetadata;
        const updatedMetadata = markEtransferReminderMetadata(
          existingMetadata,
          user.id,
          clock,
        );

        const [updatedRegistration] = await db
          .update(eventRegistrations)
          .set({
            paymentMetadata: updatedMetadata,
            updatedAt: now,
          })
          .where(eq(eventRegistrations.id, data.registrationId))
          .returning();

        return {
          success: true,
          data: castRegistrationJsonbFields(updatedRegistration),
        };
      } catch (error) {
        console.error("Error marking e-transfer reminder:", error);
        return {
          success: false,
          errors: [
            {
              code: "DATABASE_ERROR",
              message: "Failed to update registration",
            },
          ],
        };
      }
    },
  );

/**
 * Cancel event registration
 */
export const cancelEventRegistration = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(cancelEventRegistrationSchema))
  .handler(
    async ({
      data,
      context,
    }): Promise<EventOperationResult<EventRegistrationWithRoster>> => {
      try {
        const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);

        const db = await getDb();
        const user = requireUser(context);

        // Get registration
        const [registration] = await db
          .select()
          .from(eventRegistrations)
          .where(eq(eventRegistrations.id, data.registrationId))
          .limit(1);

        if (!registration) {
          return {
            success: false,
            errors: [
              {
                code: "NOT_FOUND",
                message: "Registration not found",
              },
            ],
          };
        }

        // Check if user can cancel
        if (registration.userId !== user.id) {
          // Check if user is team captain/coach
          if (registration.teamId) {
            const [membership] = await db
              .select()
              .from(teamMembers)
              .where(
                and(
                  eq(teamMembers.teamId, registration.teamId),
                  eq(teamMembers.userId, user.id),
                  eq(teamMembers.status, "active"),
                ),
              )
              .limit(1);

            if (
              !membership ||
              (membership.role !== "captain" && membership.role !== "coach")
            ) {
              return {
                success: false,
                errors: [
                  {
                    code: "FORBIDDEN",
                    message:
                      "Only the registrant or team leaders can cancel this registration",
                  },
                ],
              };
            }
          } else {
            return {
              success: false,
              errors: [
                {
                  code: "FORBIDDEN",
                  message: "You can only cancel your own registration",
                },
              ],
            };
          }
        }

        // Update registration
        const [cancelledRegistration] = await db
          .update(eventRegistrations)
          .set({
            status: "cancelled",
            cancelledAt: new Date(),
            internalNotes: data.reason,
            updatedAt: new Date(),
          })
          .where(eq(eventRegistrations.id, data.registrationId))
          .returning();

        return {
          success: true,
          data: castRegistrationJsonbFields(cancelledRegistration),
        };
      } catch (error) {
        console.error("Error cancelling registration:", error);
        return {
          success: false,
          errors: [
            {
              code: "DATABASE_ERROR",
              message: "Failed to cancel registration",
            },
          ],
        };
      }
    },
  );
</file>

<file path="src/features/events/events.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { and, asc, desc, eq, gte, inArray, lte, sql } from "drizzle-orm";
import { z } from "zod";
import type { EventRegistration } from "~/db/schema";
import { eventRegistrations, events, teams, user } from "~/db/schema";
import { getAuthMiddleware, requireUser } from "~/lib/server/auth";
import { forbidden } from "~/lib/server/errors";
import { zod$ } from "~/lib/server/fn-utils";
import type {
  EventAmenities,
  EventDivisions,
  EventMetadata,
  EventPaymentMetadata,
  EventRequirements,
  EventRules,
  EventSchedule,
} from "./events.db-types";
import {
  checkEventRegistrationSchema,
  getEventSchema,
  getUpcomingEventsSchema,
  listEventsSchema,
} from "./events.schemas";
import type {
  EventListResult,
  EventOperationResult,
  EventPaymentMethod,
  EventPaymentStatus,
  EventWithDetails,
} from "./events.types";
import { castRegistrationJsonbFields, type EventRegistrationWithRoster } from "./utils";

export type EventRegistrationSummary = {
  id: string;
  userId: string | null;
  teamId: string | null;
  eventId: string;
  registrationType: EventRegistration["registrationType"];
  status: EventRegistration["status"];
  paymentStatus: EventPaymentStatus;
  paymentMethod: EventPaymentMethod;
  paymentId: string | null;
  amountDueCents: number;
  amountPaidCents: number | null;
  paymentCompletedAt: Date | null;
  paymentMetadata: EventPaymentMetadata | null;
  createdAt: Date;
  userName: string | null;
  userEmail: string | null;
  teamName: string | null;
};

/**
 * List events with filters and pagination
 */
export const listEvents = createServerFn({ method: "GET" })
  .inputValidator(zod$(listEventsSchema))
  .handler(async ({ data }): Promise<EventListResult> => {
    // Import server-only modules inside the handler
    const { getDb } = await import("~/db/server-helpers");
    const db = await getDb();

    const filters = data.filters || {};
    const page = Math.max(1, data.page || 1);
    const pageSize = Math.min(100, Math.max(1, data.pageSize || 20));
    const offset = (page - 1) * pageSize;
    const sortBy = data.sortBy || "startDate";
    const sortOrder = data.sortOrder || "asc";

    // Build filter conditions
    const conditions: ReturnType<typeof eq>[] = [];

    if (filters.status) {
      const statuses = Array.isArray(filters.status) ? filters.status : [filters.status];
      conditions.push(
        inArray(events.status, statuses as (typeof events.status._.data)[]),
      );
    }

    if (filters.type) {
      const types = Array.isArray(filters.type) ? filters.type : [filters.type];
      conditions.push(inArray(events.type, types as (typeof events.type._.data)[]));
    }

    if (filters.organizerId) {
      conditions.push(eq(events.organizerId, filters.organizerId));
    }

    if (filters.startDateFrom) {
      conditions.push(
        gte(events.startDate, filters.startDateFrom.toISOString().split("T")[0]),
      );
    }

    if (filters.startDateTo) {
      conditions.push(
        lte(events.startDate, filters.startDateTo.toISOString().split("T")[0]),
      );
    }

    if (filters.city) {
      conditions.push(eq(events.city, filters.city));
    }

    if (filters.province) {
      conditions.push(eq(events.province, filters.province));
    }

    const whereClause = conditions.length > 0 ? and(...conditions) : undefined;

    // Get total count
    const [{ count }] = await db
      .select({ count: sql<number>`count(*)::int` })
      .from(events)
      .where(whereClause);

    // Get events with details
    const orderByColumn =
      sortBy === "name"
        ? events.name
        : sortBy === "createdAt"
          ? events.createdAt
          : events.startDate;

    const eventsList = await db
      .select({
        event: events,
        organizer: {
          id: user.id,
          name: user.name,
          email: user.email,
        },
        registrationCount: sql<number>`(
          SELECT COUNT(*)::int 
          FROM ${eventRegistrations} 
          WHERE ${eventRegistrations.eventId} = ${events.id}
          AND ${eventRegistrations.status} != 'cancelled'
        )`,
      })
      .from(events)
      .leftJoin(user, eq(events.organizerId, user.id))
      .where(whereClause)
      .orderBy(sortOrder === "desc" ? desc(orderByColumn) : asc(orderByColumn))
      .limit(pageSize)
      .offset(offset);

    // Transform results
    const eventsWithDetails: EventWithDetails[] = eventsList.map(
      ({ event, organizer, registrationCount }) => {
        const now = new Date();
        const registrationOpens = event.registrationOpensAt
          ? new Date(event.registrationOpensAt)
          : null;
        const registrationCloses = event.registrationClosesAt
          ? new Date(event.registrationClosesAt)
          : null;

        const isRegistrationOpen =
          event.status === "registration_open" &&
          (!registrationOpens || now >= registrationOpens) &&
          (!registrationCloses || now <= registrationCloses);

        let availableSpots: number | undefined;
        if (event.registrationType === "team" && event.maxTeams) {
          availableSpots = Math.max(0, event.maxTeams - registrationCount);
        } else if (event.registrationType === "individual" && event.maxParticipants) {
          availableSpots = Math.max(0, event.maxParticipants - registrationCount);
        }

        return {
          ...event,
          rules: (event.rules as EventRules) || {},
          schedule: (event.schedule as EventSchedule) || {},
          divisions: (event.divisions as EventDivisions) || {},
          amenities: (event.amenities as EventAmenities) || {},
          requirements: (event.requirements as EventRequirements) || {},
          metadata: (event.metadata as EventMetadata) || {},
          organizer: organizer!,
          registrationCount,
          isRegistrationOpen,
          availableSpots,
        };
      },
    );

    const totalPages = Math.ceil(count / pageSize);

    return {
      events: eventsWithDetails,
      totalCount: count,
      pageInfo: {
        currentPage: page,
        pageSize,
        totalPages,
        hasNextPage: page < totalPages,
        hasPreviousPage: page > 1,
      },
    };
  });

/**
 * Get a single event by ID or slug
 */
export const getEvent = createServerFn({ method: "GET" })
  .inputValidator(zod$(getEventSchema))
  .handler(async ({ data }): Promise<EventOperationResult<EventWithDetails>> => {
    try {
      if (!data.id && !data.slug) {
        return {
          success: false,
          errors: [
            {
              code: "VALIDATION_ERROR",
              message: "Either id or slug must be provided",
            },
          ],
        };
      }

      // Import server-only modules inside the handler
      const { getDb } = await import("~/db/server-helpers");
      const db = await getDb();

      const condition = data.id ? eq(events.id, data.id) : eq(events.slug, data.slug!);

      const result = await db
        .select({
          event: events,
          organizer: {
            id: user.id,
            name: user.name,
            email: user.email,
          },
          registrationCount: sql<number>`(
            SELECT COUNT(*)::int 
            FROM ${eventRegistrations} 
            WHERE ${eventRegistrations.eventId} = ${events.id}
            AND ${eventRegistrations.status} != 'cancelled'
          )`,
        })
        .from(events)
        .leftJoin(user, eq(events.organizerId, user.id))
        .where(condition)
        .limit(1);

      if (result.length === 0) {
        return {
          success: false,
          errors: [
            {
              code: "NOT_FOUND",
              message: "Event not found",
            },
          ],
        };
      }

      const { event, organizer, registrationCount } = result[0];
      const now = new Date();
      const registrationOpens = event.registrationOpensAt
        ? new Date(event.registrationOpensAt)
        : null;
      const registrationCloses = event.registrationClosesAt
        ? new Date(event.registrationClosesAt)
        : null;

      const isRegistrationOpen =
        event.status === "registration_open" &&
        (!registrationOpens || now >= registrationOpens) &&
        (!registrationCloses || now <= registrationCloses);

      let availableSpots: number | undefined;
      if (event.registrationType === "team" && event.maxTeams) {
        availableSpots = Math.max(0, event.maxTeams - registrationCount);
      } else if (event.registrationType === "individual" && event.maxParticipants) {
        availableSpots = Math.max(0, event.maxParticipants - registrationCount);
      }

      return {
        success: true,
        data: {
          ...event,
          rules: (event.rules as EventRules) || {},
          schedule: (event.schedule as EventSchedule) || {},
          divisions: (event.divisions as EventDivisions) || {},
          amenities: (event.amenities as EventAmenities) || {},
          requirements: (event.requirements as EventRequirements) || {},
          metadata: (event.metadata as EventMetadata) || {},
          organizer: organizer!,
          registrationCount,
          isRegistrationOpen,
          availableSpots,
        },
      };
    } catch (error) {
      console.error("Error fetching event:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to fetch event",
          },
        ],
      };
    }
  });

/**
 * Get upcoming events for the dashboard
 */
export const getUpcomingEvents = createServerFn({ method: "GET" })
  .inputValidator(zod$(getUpcomingEventsSchema))
  .handler(async ({ data }): Promise<EventWithDetails[]> => {
    const limit = Math.min(10, data.limit || 3);

    const result = (await listEvents({
      data: {
        filters: {
          status: ["published", "registration_open"],
          startDateFrom: new Date(),
        },
        pageSize: limit,
        sortBy: "startDate",
        sortOrder: "asc",
      },
    })) as EventListResult;

    return result.events;
  });

/**
 * Get all registrations for an event (organizer or admin only)
 * Returns user emails and payment data - must be protected
 */
export const getEventRegistrations = createServerFn({ method: "GET" })
  .middleware(getAuthMiddleware())
  .inputValidator(z.object({ eventId: z.uuid() }).parse)
  .handler(async ({ data, context }): Promise<EventRegistrationSummary[]> => {
    const authUser = requireUser(context);
    const { getDb } = await import("~/db/server-helpers");
    const { isAdmin } = await import("~/lib/auth/utils/admin-check");
    const db = await getDb();

    // Check if user is organizer or admin
    const [event] = await db
      .select({ organizerId: events.organizerId })
      .from(events)
      .where(eq(events.id, data.eventId))
      .limit(1);

    if (!event) {
      throw forbidden("Event not found");
    }

    const userIsAdmin = await isAdmin(authUser.id);
    if (event.organizerId !== authUser.id && !userIsAdmin) {
      throw forbidden("Only event organizers or admins can view registrations");
    }

    const registrations = await db
      .select({
        id: eventRegistrations.id,
        userId: eventRegistrations.userId,
        teamId: eventRegistrations.teamId,
        eventId: eventRegistrations.eventId,
        registrationType: eventRegistrations.registrationType,
        status: eventRegistrations.status,
        paymentStatus: eventRegistrations.paymentStatus,
        paymentMethod: eventRegistrations.paymentMethod,
        paymentId: eventRegistrations.paymentId,
        amountDueCents: eventRegistrations.amountDueCents,
        amountPaidCents: eventRegistrations.amountPaidCents,
        paymentCompletedAt: eventRegistrations.paymentCompletedAt,
        paymentMetadata: eventRegistrations.paymentMetadata,
        createdAt: eventRegistrations.createdAt,
        userName: user.name,
        userEmail: user.email,
        teamName: teams.name,
      })
      .from(eventRegistrations)
      .leftJoin(user, eq(eventRegistrations.userId, user.id))
      .leftJoin(teams, eq(eventRegistrations.teamId, teams.id))
      .where(eq(eventRegistrations.eventId, data.eventId))
      .orderBy(desc(eventRegistrations.createdAt));

    return registrations.map((registration) => ({
      ...registration,
      userName: registration.userName ?? null,
      userEmail: registration.userEmail ?? null,
      teamName: registration.teamName ?? null,
      paymentMetadata: registration.paymentMetadata
        ? (registration.paymentMetadata as EventPaymentMetadata)
        : null,
    }));
  });

/**
 * Check if a user is registered for an event
 */
export const checkEventRegistration = createServerFn({ method: "GET" })
  .inputValidator(zod$(checkEventRegistrationSchema))
  .handler(
    async ({
      data,
    }): Promise<{
      isRegistered: boolean;
      registration?: EventRegistrationWithRoster;
    }> => {
      // Get user from session - not from client input
      const { getRequest } = await import("@tanstack/react-start/server");
      const { getAuth } = await import("~/lib/auth/server-helpers");
      const auth = await getAuth();
      const { headers } = getRequest();
      const session = await auth.api.getSession({ headers });
      const userId = session?.user?.id;

      if (!userId && !data.teamId) {
        return { isRegistered: false };
      }

      // Import server-only modules inside the handler
      const { getDb } = await import("~/db/server-helpers");
      const db = await getDb();

      const conditions: ReturnType<typeof eq>[] = [
        eq(eventRegistrations.eventId, data.eventId),
        eq(eventRegistrations.status, "confirmed"),
      ];

      if (userId) {
        conditions.push(eq(eventRegistrations.userId, userId));
      }

      if (data.teamId) {
        conditions.push(eq(eventRegistrations.teamId, data.teamId));
      }

      const [registration] = await db
        .select()
        .from(eventRegistrations)
        .where(and(...conditions))
        .limit(1);

      if (!registration) {
        return { isRegistered: false };
      }

      return {
        isRegistered: true,
        registration: castRegistrationJsonbFields(registration),
      };
    },
  );
</file>

</files>
