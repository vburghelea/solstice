This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/features/**/*.ts, src/features/**/*.tsx, src/routes/**/*.ts, src/routes/**/*.tsx, src/components/**/*.ts, src/components/**/*.tsx
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  components/
    form-fields/
      __tests__/
        validated-inputs.test.tsx
      FormSubmitButton.tsx
      ValidatedCheckbox.tsx
      ValidatedColorPicker.tsx
      ValidatedCombobox.tsx
      ValidatedDatePicker.tsx
      ValidatedFileUpload.tsx
      ValidatedInput.tsx
      ValidatedPhoneInput.tsx
      ValidatedSelect.tsx
    ui/
      admin-sidebar.tsx
      alert-dialog.tsx
      alert.tsx
      avatar.tsx
      badge.tsx
      breadcrumbs.tsx
      button.tsx
      card.tsx
      checkbox.tsx
      command.tsx
      data-state.tsx
      data-table.tsx
      dialog.tsx
      dropdown-menu.tsx
      icons.tsx
      input.tsx
      label.tsx
      logo.tsx
      mobile-admin-header.tsx
      popover.tsx
      radio-group.tsx
      SafeLink.tsx
      select.tsx
      separator.tsx
      skeleton.tsx
      sonner.tsx
      table.tsx
      tabs.tsx
      textarea.tsx
      TypedLink.tsx
    DefaultCatchBoundary.tsx
    NotFound.tsx
    ThemeToggle.tsx
  features/
    auth/
      __tests__/
        login-with-router.test.tsx
        login.test.tsx
        signup-with-router.test.tsx
      components/
        login.tsx
        signup.tsx
      hooks/
        useAuth.ts
        useAuthForm.ts
      auth.queries.ts
      auth.schemas.ts
      index.ts
    dashboard/
      index.ts
      MemberDashboard.tsx
      PublicPortalPage.tsx
    events/
      __tests__/
        events.base-schemas.test.ts
        events.registration.integration.test.ts
        events.schemas.test.ts
        payment-metadata.test.ts
        registration-pricing.test.ts
      components/
        event-create-form-minimal.tsx
        event-create-form.tsx
        event-list.tsx
      utils/
        index.ts
        jsonb.ts
        payment-metadata.ts
        pricing.ts
        time.ts
      events.db-types.ts
      events.mutations.ts
      events.queries.ts
      events.schemas.ts
      events.types.ts
      index.ts
    layouts/
      __tests__/
        admin-layout.test.tsx
      admin-layout.tsx
      admin-nav.ts
    members/
      index.ts
      members.queries.ts
      members.schemas.ts
      members.types.ts
    membership/
      __tests__/
        membership.finalize.integration.test.ts
        membership.schemas.test.ts
        membership.validation.test.ts
        square.webhook.test.ts
      components/
        admin-memberships-report.tsx
      hooks/
        usePaymentReturn.ts
      index.ts
      membership.admin-queries.ts
      membership.db-types.ts
      membership.finalize.ts
      membership.mutations.ts
      membership.queries.ts
      membership.schemas.ts
      membership.types.ts
    profile/
      __tests__/
        profile.queries.test.ts
        profile.schemas.test.ts
        profile.validation.test.ts
      components/
        complete-profile-form-simple.tsx
        profile-view.tsx
      hooks/
        useProfileFormReducer.ts
      index.ts
      profile-guard.ts
      profile.mutations.ts
      profile.queries.ts
      profile.schemas.ts
      profile.types.ts
      profile.utils.ts
    roles/
      __tests__/
        permission.service.test.ts
      components/
        __tests__/
          role-management-dashboard.test.tsx
        role-management-dashboard.tsx
      permission.server.ts
      permission.service.ts
      roles.mutations.ts
      roles.queries.ts
      roles.types.ts
    settings/
      components/
        settings-view.tsx
      index.ts
      settings.mutations.ts
      settings.queries.ts
      settings.schemas.ts
      settings.types.ts
    teams/
      __tests__/
        teams.schemas.test.ts
      components/
        __tests__/
          team-invitations.test.tsx
        team-invitations.tsx
      teams.cleanup.ts
      teams.db-types.ts
      teams.mutations.ts
      teams.queries.ts
      teams.schemas.ts
  routes/
    admin/
      roles.tsx
    api/
      auth/
        $action/
          $provider.ts
        $.ts
      payments/
        square/
          callback.ts
      test/
        cleanup.ts
      webhooks/
        square.ts
      debug-square.ts
      health.ts
      test-square.ts
    auth/
      login.tsx
      route.tsx
      signup.tsx
    dashboard/
      admin/
        roles.tsx
        route.tsx
      events/
        $eventId.manage.tsx
        $slug.index.tsx
        $slug.register.tsx
        $slug.tsx
        create.tsx
        index.tsx
      teams/
        $teamId.index.tsx
        $teamId.manage.tsx
        $teamId.members.tsx
        $teamId.tsx
        browse.tsx
        create.tsx
        index.tsx
      events.tsx
      forbidden.tsx
      index.tsx
      members.tsx
      membership.tsx
      profile.tsx
      reports.tsx
      route.tsx
      settings.tsx
      teams.tsx
    onboarding/
      index.tsx
      route.tsx
    __root.tsx
    index.tsx
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/features/membership/index.ts">
// Export queries
export {
  getMembershipType,
  getUserMembershipStatus,
  listMembershipTypes,
} from "./membership.queries";

// Export mutations
export { confirmMembershipPurchase, createCheckoutSession } from "./membership.mutations";

// Export types
export type {
  CheckoutSessionResult,
  MembershipOperationResult,
  MembershipPurchaseInput,
  MembershipStatus,
  UserMembership,
} from "./membership.types";
</file>

<file path="src/features/profile/__tests__/profile.queries.test.ts">
import { describe, expect, it } from "vitest";
import type { UserProfile } from "../profile.types";
import { isProfileComplete } from "../profile.utils";

describe("Profile Queries", () => {
  describe("isProfileComplete", () => {
    const baseProfile: UserProfile = {
      id: "user-123",
      name: "Test User",
      email: "test@example.com",
      profileComplete: false,
      profileVersion: 1,
    };

    it("returns false when dateOfBirth is missing", () => {
      const profile: UserProfile = {
        ...baseProfile,
        emergencyContact: {
          name: "John Doe",
          relationship: "Friend",
          phone: "123-456-7890",
        },
      };

      expect(isProfileComplete(profile)).toBe(false);
    });

    it("returns true when emergency contact is not provided (optional)", () => {
      const profile: UserProfile = {
        ...baseProfile,
        dateOfBirth: new Date("1990-01-01"),
        // No emergency contact provided
      };

      expect(isProfileComplete(profile)).toBe(true);
    });

    it("returns true when emergency contact is undefined (optional)", () => {
      const profile: UserProfile = {
        ...baseProfile,
        dateOfBirth: new Date("1990-01-01"),
        emergencyContact: undefined,
      };

      expect(isProfileComplete(profile)).toBe(true);
    });

    it("returns true even with partial emergency contact (validation handled elsewhere)", () => {
      const profile: UserProfile = {
        ...baseProfile,
        dateOfBirth: new Date("1990-01-01"),
        emergencyContact: {
          name: "John Doe",
          relationship: "Friend",
        },
      };

      expect(isProfileComplete(profile)).toBe(true);
    });

    it("returns true when all required fields are present with phone", () => {
      const profile: UserProfile = {
        ...baseProfile,
        dateOfBirth: new Date("1990-01-01"),
        emergencyContact: {
          name: "John Doe",
          relationship: "Friend",
          phone: "123-456-7890",
        },
      };

      expect(isProfileComplete(profile)).toBe(true);
    });

    it("returns true when all required fields are present with email", () => {
      const profile: UserProfile = {
        ...baseProfile,
        dateOfBirth: new Date("1990-01-01"),
        emergencyContact: {
          name: "John Doe",
          relationship: "Friend",
          email: "john@example.com",
        },
      };

      expect(isProfileComplete(profile)).toBe(true);
    });

    it("returns true when all required fields are present with both phone and email", () => {
      const profile: UserProfile = {
        ...baseProfile,
        dateOfBirth: new Date("1990-01-01"),
        emergencyContact: {
          name: "John Doe",
          relationship: "Friend",
          phone: "123-456-7890",
          email: "john@example.com",
        },
      };

      expect(isProfileComplete(profile)).toBe(true);
    });

    it("ignores optional fields when determining completion", () => {
      const profile: UserProfile = {
        ...baseProfile,
        dateOfBirth: new Date("1990-01-01"),
        emergencyContact: {
          name: "John Doe",
          relationship: "Friend",
          phone: "123-456-7890",
        },
        // Optional fields not set
        gender: undefined,
        pronouns: undefined,
        phone: undefined,
        privacySettings: undefined,
      };

      expect(isProfileComplete(profile)).toBe(true);
    });
  });
});
</file>

<file path="src/features/profile/profile-guard.ts">
import { redirect } from "@tanstack/react-router";
import type { User } from "~/lib/auth/types";

/**
 * Route guard that ensures user has completed their profile.
 * Redirects to onboarding if profile is incomplete.
 *
 * @param user - The authenticated user object
 * @throws Redirect to /onboarding if profile is incomplete
 */
export function requireCompleteProfile(user: User | null | undefined) {
  if (!user) {
    throw redirect({ to: "/auth/login" });
  }

  if (!user.profileComplete) {
    throw redirect({ to: "/onboarding" });
  }
}

/**
 * Check if a user needs to complete their profile
 */
export function needsProfileCompletion(user: User | null | undefined): boolean {
  return !!user && !user.profileComplete;
}
</file>

<file path="src/features/profile/profile.types.ts">
export interface EmergencyContact {
  name: string;
  relationship: string;
  phone?: string;
  email?: string;
}

export interface PrivacySettings {
  showEmail: boolean;
  showPhone: boolean;
  showBirthYear: boolean;
  allowTeamInvitations: boolean;
}

export interface UserProfile {
  id: string;
  name: string;
  email: string;
  profileComplete: boolean;
  dateOfBirth?: Date | undefined;
  emergencyContact?: EmergencyContact | undefined;
  gender?: string | undefined;
  pronouns?: string | undefined;
  phone?: string | undefined;
  privacySettings?: PrivacySettings | undefined;
  profileVersion: number;
  profileUpdatedAt?: Date | undefined;
}

export interface ProfileInput {
  dateOfBirth: Date;
  emergencyContact?: EmergencyContact;
  gender?: string;
  pronouns?: string;
  phone?: string;
  privacySettings?: PrivacySettings;
}

export interface ProfileError {
  field?: string;
  message: string;
  code:
    | "VALIDATION_ERROR"
    | "MISSING_REQUIRED_FIELD"
    | "INVALID_FORMAT"
    | "DATABASE_ERROR";
}

export interface ProfileOperationResult {
  success: boolean;
  data?: UserProfile;
  errors?: ProfileError[];
}

export const defaultPrivacySettings: PrivacySettings = {
  showEmail: false,
  showPhone: false,
  showBirthYear: true,
  allowTeamInvitations: true,
};
</file>

<file path="src/features/profile/profile.utils.ts">
import type { UserProfile } from "./profile.types";

export function isProfileComplete(profile: UserProfile): boolean {
  // Only date of birth is required for profile completion
  return !!profile.dateOfBirth;
}
</file>

<file path="src/routes/auth/signup.tsx">
import { createFileRoute } from "@tanstack/react-router";
import SignupForm from "~/features/auth/components/signup";

export const Route = createFileRoute("/auth/signup")({
  component: SignupForm,
});
</file>

<file path="src/routes/onboarding/index.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { CompleteProfileForm } from "~/features/profile/components/complete-profile-form-simple";

export const Route = createFileRoute("/onboarding/")({
  component: OnboardingPage,
});

function OnboardingPage() {
  return (
    <div className="container mx-auto max-w-2xl py-8">
      <div className="mb-8">
        <h1 className="text-3xl font-bold">Complete Your Profile</h1>
        <p className="text-muted-foreground mt-2">
          Please provide the following information to complete your membership
          registration.
        </p>
      </div>
      <CompleteProfileForm />
    </div>
  );
}
</file>

<file path="src/routes/onboarding/route.tsx">
import { createFileRoute, redirect } from "@tanstack/react-router";
import { AdminLayout } from "~/features/layouts/admin-layout";

export const Route = createFileRoute("/onboarding")({
  component: OnboardingLayout,
  beforeLoad: async ({ context }) => {
    // First check if user is authenticated
    if (!context.user) {
      throw redirect({ to: "/auth/login" });
    }

    // Check if profile is already complete
    if (context.user.profileComplete) {
      throw redirect({ to: "/dashboard" });
    }
  },
});

function OnboardingLayout() {
  return <AdminLayout />;
}
</file>

<file path="src/components/form-fields/__tests__/validated-inputs.test.tsx">
import { render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";
import { FormSubmitButton } from "~/components/form-fields/FormSubmitButton";
import { ValidatedFileUpload } from "~/components/form-fields/ValidatedFileUpload";
import { ValidatedPhoneInput } from "~/components/form-fields/ValidatedPhoneInput";
import { useAppForm } from "~/lib/hooks/useAppForm";

function PhoneForm() {
  const form = useAppForm({
    defaultValues: { phone: "" },
    onSubmit: () => undefined,
  });

  return (
    <form
      onSubmit={(event) => {
        event.preventDefault();
        void form.handleSubmit();
      }}
    >
      <form.Field name="phone">
        {(field) => (
          <div className="space-y-2">
            <ValidatedPhoneInput
              field={field}
              label="Phone"
              placeholder="(555) 123-4567"
            />
            <div data-testid="raw-value">
              {String(field.form.state.values.phone ?? "")}
            </div>
          </div>
        )}
      </form.Field>
      <FormSubmitButton isSubmitting={false}>Submit</FormSubmitButton>
    </form>
  );
}

function FileForm() {
  const form = useAppForm({
    defaultValues: { logo: null as File | null },
    onSubmit: () => undefined,
  });

  return (
    <form
      onSubmit={(event) => {
        event.preventDefault();
        void form.handleSubmit();
      }}
    >
      <form.Field name="logo">
        {(field) => (
          <div className="space-y-2">
            <ValidatedFileUpload
              field={field}
              label="Team logo"
              accept="image/png"
              maxSizeMb={1}
              description="Upload a PNG under 1MB"
            />
            <div data-testid="file-value">
              {(() => {
                const value = field.form.state.values.logo;
                if (value instanceof File) return value.name;
                if (typeof value === "string") return value;
                return "";
              })()}
            </div>
          </div>
        )}
      </form.Field>
    </form>
  );
}

const originalCreateObjectURL = URL.createObjectURL;
const originalRevokeObjectURL = URL.revokeObjectURL;

describe("form field components", () => {
  beforeEach(() => {
    Object.defineProperty(URL, "createObjectURL", {
      configurable: true,
      writable: true,
      value: vi.fn(() => "blob:preview"),
    });
    Object.defineProperty(URL, "revokeObjectURL", {
      configurable: true,
      writable: true,
      value: vi.fn(),
    });
  });

  afterEach(() => {
    Object.defineProperty(URL, "createObjectURL", {
      configurable: true,
      writable: true,
      value: originalCreateObjectURL,
    });
    Object.defineProperty(URL, "revokeObjectURL", {
      configurable: true,
      writable: true,
      value: originalRevokeObjectURL,
    });
  });

  it("formats phone numbers while storing canonical value", async () => {
    render(<PhoneForm />);
    const input = screen.getByLabelText(/phone/i) as HTMLInputElement;
    const user = userEvent.setup();

    await user.type(input, "6045551234");

    expect(input.value).toBe("(604) 555-1234");
    expect(screen.getByTestId("raw-value").textContent).toBe("+16045551234");

    await user.clear(input);
    expect(screen.getByTestId("raw-value").textContent).toBe("");
  });

  it("prevents files larger than the limit and shows an error", async () => {
    render(<FileForm />);
    const input = screen.getByLabelText(/team logo/i) as HTMLInputElement;
    const user = userEvent.setup();

    const oversized = new File([new Uint8Array(2 * 1024 * 1024)], "huge.png", {
      type: "image/png",
    });

    await user.upload(input, oversized);

    expect(screen.getByText(/maximum size is 1MB/i)).toBeInTheDocument();
    expect(screen.getByTestId("file-value").textContent).toBe("");

    const validFile = new File([new Uint8Array(200_000)], "logo.png", {
      type: "image/png",
    });
    await user.upload(input, validFile);

    expect(screen.queryByText(/maximum size is 1MB/i)).not.toBeInTheDocument();
    expect(screen.getByTestId("file-value").textContent).toBe("logo.png");
  });
});
</file>

<file path="src/components/form-fields/FormSubmitButton.tsx">
import React from "react";
import { Button } from "~/components/ui/button";
import { Loader2 } from "~/components/ui/icons";
import { cn } from "~/shared/lib/utils";

interface FormSubmitButtonProps extends React.ComponentProps<typeof Button> {
  isSubmitting?: boolean;
  loadingText?: string;
}

export const FormSubmitButton: React.FC<FormSubmitButtonProps> = ({
  isSubmitting = false,
  loadingText,
  children,
  disabled,
  className,
  ...props
}) => {
  return (
    <Button
      type="submit"
      disabled={disabled || isSubmitting}
      className={cn(className)}
      {...props}
    >
      {isSubmitting ? (
        <>
          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
          {loadingText || "Loading..."}
        </>
      ) : (
        children
      )}
    </Button>
  );
};
</file>

<file path="src/components/form-fields/ValidatedColorPicker.tsx">
import React from "react";
import { Label } from "~/components/ui/label";
import { FieldComponentProps, isFieldApi } from "~/lib/form";
import { cn } from "~/shared/lib/utils";

interface ValidatedColorPickerProps extends FieldComponentProps {
  description?: string;
}

export const ValidatedColorPicker: React.FC<ValidatedColorPickerProps> = (props) => {
  const { field, label, className, description } = props;

  if (!isFieldApi(field)) {
    console.error("ValidatedColorPicker requires a valid field prop.", { field, props });
    return null;
  }

  const inputId = `${field.name}-color-picker`;
  const meta = field.state.meta;

  // Preset colors for quick selection
  const presetColors = [
    "#E2E2E2", // Light gray
    "#ff75c3", // Pink
    "#ffa647", // Orange
    "#ffe83f", // Yellow
    "#9fff5b", // Light green
    "#70e2ff", // Light blue
    "#cd93ff", // Purple
    "#09203f", // Dark blue
  ];

  return (
    <div className={cn("space-y-2", className)}>
      <Label htmlFor={inputId}>{label}</Label>
      {description && <p className="text-muted-foreground text-sm">{description}</p>}
      <div className="flex flex-col gap-3">
        {/* Color input with visual preview */}
        <div className="flex items-center gap-2">
          <input
            type="color"
            id={inputId}
            name={field.name}
            value={field.state.value || "#000000"}
            onChange={(e) => field.handleChange(e.target.value)}
            onBlur={field.handleBlur}
            className="border-input h-10 w-20 cursor-pointer rounded border"
            aria-invalid={!!meta.errors.length}
            aria-describedby={meta.errors.length ? `${inputId}-errors` : undefined}
          />
          <input
            type="text"
            value={field.state.value || "#000000"}
            onChange={(e) => field.handleChange(e.target.value)}
            onBlur={field.handleBlur}
            placeholder="#000000"
            className={cn(
              "border-input bg-background ring-offset-background placeholder:text-muted-foreground focus-visible:ring-ring flex h-10 w-32 rounded-md border px-3 py-2 text-sm focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
              meta.isTouched && meta.errors.length > 0 && "border-destructive",
            )}
            disabled={field.form.state.isSubmitting}
          />
          <span className="text-muted-foreground text-sm">
            {field.state.value || "#000000"}
          </span>
        </div>

        {/* Preset color palette */}
        <div className="flex flex-wrap gap-1">
          {presetColors.map((color) => (
            <button
              key={color}
              type="button"
              className={cn(
                "h-6 w-6 rounded-md border border-neutral-200 shadow-sm transition-all hover:scale-110 dark:border-neutral-800",
                field.state.value === color &&
                  "ring-2 ring-neutral-900 ring-offset-1 dark:ring-neutral-400",
              )}
              style={{ backgroundColor: color }}
              onClick={() => field.handleChange(color)}
              aria-label={`Select color ${color}`}
            />
          ))}
        </div>
      </div>
      {meta.isTouched && meta.errors.length > 0 && (
        <div id={`${inputId}-errors`} className="text-destructive text-sm font-medium">
          {meta.errors.join(", ")}
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/components/form-fields/ValidatedCombobox.tsx">
import React, { useState } from "react";
import { Button } from "~/components/ui/button";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "~/components/ui/command";
import { CheckIcon, ChevronsUpDownIcon } from "~/components/ui/icons";
import { Label } from "~/components/ui/label";
import { Popover, PopoverContent, PopoverTrigger } from "~/components/ui/popover";
import { FieldComponentProps, isFieldApi } from "~/lib/form";
import { cn } from "~/shared/lib/utils";

interface ValidatedComboboxProps extends FieldComponentProps {
  options: Array<{ value: string; label: string }>;
  searchPlaceholder?: string;
  emptyText?: string;
}

export const ValidatedCombobox: React.FC<ValidatedComboboxProps> = (props) => {
  const {
    field,
    label,
    placeholder = "Select an option...",
    className,
    options,
    searchPlaceholder = "Search...",
    emptyText = "No option found.",
  } = props;

  const [open, setOpen] = useState(false);

  if (!isFieldApi(field)) {
    console.error("ValidatedCombobox requires a valid field prop.", { field, props });
    return null;
  }

  const inputId = `${field.name}-combobox`;
  const meta = field.state.meta;
  const selectedOption = options.find((option) => option.value === field.state.value);

  return (
    <div className={cn("space-y-2", className)}>
      <Label htmlFor={inputId}>{label}</Label>
      <Popover open={open} onOpenChange={setOpen}>
        <PopoverTrigger asChild>
          <Button
            id={inputId}
            variant="outline"
            role="combobox"
            aria-expanded={open}
            aria-invalid={!!meta.errors.length}
            aria-describedby={meta.errors.length ? `${inputId}-errors` : undefined}
            className={cn(
              "w-full justify-between",
              !selectedOption && "text-muted-foreground",
            )}
            disabled={field.form.state.isSubmitting}
          >
            {selectedOption ? selectedOption.label : placeholder}
            <ChevronsUpDownIcon className="ml-2 h-4 w-4 shrink-0 opacity-50" />
          </Button>
        </PopoverTrigger>
        <PopoverContent className="w-[--radix-popover-trigger-width] p-0" align="start">
          <Command>
            <CommandInput placeholder={searchPlaceholder} />
            <CommandList>
              <CommandEmpty>{emptyText}</CommandEmpty>
              <CommandGroup>
                {options.map((option) => (
                  <CommandItem
                    key={option.value}
                    value={option.label}
                    onSelect={() => {
                      field.handleChange(option.value);
                      setOpen(false);
                    }}
                  >
                    <CheckIcon
                      className={cn(
                        "mr-2 h-4 w-4",
                        field.state.value === option.value ? "opacity-100" : "opacity-0",
                      )}
                    />
                    {option.label}
                  </CommandItem>
                ))}
              </CommandGroup>
            </CommandList>
          </Command>
        </PopoverContent>
      </Popover>
      {meta.isTouched && meta.errors.length > 0 && (
        <div id={`${inputId}-errors`} className="text-destructive text-sm font-medium">
          {meta.errors.join(", ")}
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/components/form-fields/ValidatedFileUpload.tsx">
import { useEffect, useMemo, useState } from "react";
import { Button } from "~/components/ui/button";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";
import { FieldComponentProps } from "~/lib/form";
import { cn } from "~/shared/lib/utils";

interface ValidatedFileUploadProps extends FieldComponentProps {
  accept?: string;
  maxSizeMb?: number;
  description?: string;
  helperText?: string;
  previewAlt?: string;
}

export function ValidatedFileUpload(props: ValidatedFileUploadProps) {
  const {
    field,
    label,
    placeholder,
    className,
    accept = "image/*",
    maxSizeMb = 5,
    description,
    helperText,
    previewAlt = "Uploaded file preview",
  } = props;

  const inputId = `${field.name}-file-input`;
  const meta = field.state.meta;
  const currentValue = field.state.value as File | string | null | undefined;

  const [sizeError, setSizeError] = useState<string | null>(null);

  const objectUrl = useMemo(() => {
    if (currentValue instanceof File) {
      return URL.createObjectURL(currentValue);
    }
    if (typeof currentValue === "string" && currentValue.length > 0) {
      return currentValue;
    }
    return null;
  }, [currentValue]);

  useEffect(() => {
    if (currentValue instanceof File && objectUrl) {
      const revoke =
        typeof URL.revokeObjectURL === "function" ? URL.revokeObjectURL.bind(URL) : null;
      if (revoke) {
        return () => revoke(objectUrl);
      }
    }
    return undefined;
  }, [currentValue, objectUrl]);

  const humanReadableSize = useMemo(() => {
    if (currentValue instanceof File) {
      return formatFileSize(currentValue.size);
    }
    return null;
  }, [currentValue]);

  return (
    <div className={cn("space-y-3", className)}>
      <Label htmlFor={inputId}>{label}</Label>
      <div className="flex flex-col gap-3">
        <Input
          id={inputId}
          type="file"
          accept={accept}
          placeholder={placeholder}
          onBlur={field.handleBlur}
          disabled={field.form.state.isSubmitting}
          onChange={(event) => {
            const file = event.target.files?.[0];
            if (!file) {
              field.handleChange(null);
              setSizeError(null);
              return;
            }

            if (maxSizeMb && file.size > maxSizeMb * 1024 * 1024) {
              setSizeError(`File is too large. Maximum size is ${maxSizeMb}MB.`);
              event.target.value = "";
              return;
            }

            setSizeError(null);
            field.handleChange(file);
          }}
        />
        {helperText && <p className="text-xs text-gray-500">{helperText}</p>}
        {sizeError && <p className="text-destructive text-sm font-medium">{sizeError}</p>}

        {objectUrl && (
          <div className="rounded-lg border border-dashed border-gray-300 bg-gray-50 p-4">
            <p className="text-sm font-semibold text-gray-900">Selected file</p>
            <p className="text-xs text-gray-500">
              {currentValue instanceof File ? currentValue.name : "Existing upload"}
              {humanReadableSize ? ` Â· ${humanReadableSize}` : ""}
            </p>
            {accept.startsWith("image") && (
              <img
                src={objectUrl}
                alt={previewAlt}
                className="mt-3 max-h-48 w-full rounded-md object-cover"
                loading="lazy"
              />
            )}
            <div className="mt-3 flex justify-end">
              <Button
                type="button"
                variant="ghost"
                size="sm"
                onClick={() => {
                  field.handleChange(null);
                  setSizeError(null);
                }}
              >
                Remove file
              </Button>
            </div>
          </div>
        )}
      </div>
      {description && <p className="text-muted-foreground text-sm">{description}</p>}
      {meta.isTouched && meta.errors.length > 0 && (
        <div className="text-destructive text-sm font-medium">
          {meta.errors.join(", ")}
        </div>
      )}
    </div>
  );
}

function formatFileSize(bytes: number) {
  if (bytes < 1024) return `${bytes} bytes`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}
</file>

<file path="src/components/form-fields/ValidatedPhoneInput.tsx">
import { useMemo } from "react";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";
import { FieldComponentProps } from "~/lib/form";
import { cn } from "~/shared/lib/utils";

interface ValidatedPhoneInputProps extends FieldComponentProps {
  countryCode?: string;
  description?: string;
  disabled?: boolean;
  required?: boolean;
}

const DEFAULT_COUNTRY_CODE = "+1";

export function ValidatedPhoneInput(props: ValidatedPhoneInputProps) {
  const {
    field,
    label,
    placeholder = "(555) 123-4567",
    className,
    countryCode = DEFAULT_COUNTRY_CODE,
    description,
    disabled,
    required,
  } = props;

  const inputId = `${field.name}-phone-input`;
  const meta = field.state.meta;
  const normalizedDigits = useMemo(
    () => extractDigits(field.state.value as string | null, countryCode),
    [field.state.value, countryCode],
  );
  const formattedValue = formatForDisplay(normalizedDigits);

  return (
    <div className={cn("space-y-2", className)}>
      <Label htmlFor={inputId}>{label}</Label>
      <Input
        id={inputId}
        name={field.name}
        type="tel"
        inputMode="tel"
        autoComplete="tel"
        value={formattedValue}
        placeholder={placeholder}
        onBlur={field.handleBlur}
        onChange={(event) => {
          const digits = event.target.value.replace(/\D/g, "");
          const canonical =
            digits.length === 0 ? "" : ensureCountryCode(digits, countryCode);
          field.handleChange(canonical);
        }}
        disabled={field.form.state.isSubmitting || disabled}
        aria-invalid={!!meta.errors.length}
        aria-describedby={meta.errors.length ? `${inputId}-errors` : undefined}
        required={required}
      />
      {description && <p className="text-muted-foreground text-sm">{description}</p>}
      {meta.isTouched && meta.errors.length > 0 && (
        <div id={`${inputId}-errors`} className="text-destructive text-sm font-medium">
          {meta.errors.join(", ")}
        </div>
      )}
    </div>
  );
}

function extractDigits(value: string | null | undefined, countryCode: string) {
  if (!value) return "";
  const digitsOnly = value.replace(/\D/g, "");
  const normalizedCountry = countryCode.replace(/\D/g, "");
  if (digitsOnly.startsWith(normalizedCountry)) {
    return digitsOnly.slice(normalizedCountry.length).slice(0, 10);
  }
  return digitsOnly.slice(0, 10);
}

function ensureCountryCode(digits: string, countryCode: string) {
  const normalizedCountry = countryCode.replace(/\D/g, "");
  const trimmed = digits.startsWith(normalizedCountry)
    ? digits.slice(normalizedCountry.length)
    : digits;
  const limited = trimmed.slice(0, 10);
  return `${countryCode}${limited}`;
}

function formatForDisplay(digits: string) {
  if (!digits) return "";
  const part1 = digits.slice(0, 3);
  const part2 = digits.slice(3, 6);
  const part3 = digits.slice(6, 10);

  if (digits.length <= 3) {
    return `(${part1}`;
  }

  if (digits.length <= 6) {
    return `(${part1}) ${part2}`;
  }

  return `(${part1}) ${part2}-${part3}`;
}
</file>

<file path="src/components/ui/alert-dialog.tsx">
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog";
import * as React from "react";

import { buttonVariants } from "~/components/ui/button";
import { cn } from "~/shared/lib/utils";

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />;
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />;
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />;
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className,
      )}
      {...props}
    />
  );
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className,
        )}
        {...props}
      />
    </AlertDialogPortal>
  );
}

function AlertDialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  );
}

function AlertDialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn("flex flex-col-reverse gap-2 sm:flex-row sm:justify-end", className)}
      {...props}
    />
  );
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  );
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  );
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action className={cn(buttonVariants(), className)} {...props} />
  );
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  );
}

export {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogOverlay,
  AlertDialogPortal,
  AlertDialogTitle,
  AlertDialogTrigger,
};
</file>

<file path="src/components/ui/alert.tsx">
import { cva, type VariantProps } from "class-variance-authority";
import * as React from "react";

import { cn } from "~/shared/lib/utils";

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-card text-card-foreground",
        destructive:
          "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

function Alert({
  className,
  variant,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof alertVariants>) {
  return (
    <div
      data-slot="alert"
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props}
    />
  );
}

function AlertTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-title"
      className={cn(
        "col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight",
        className,
      )}
      {...props}
    />
  );
}

function AlertDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-description"
      className={cn(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        className,
      )}
      {...props}
    />
  );
}

export { Alert, AlertDescription, AlertTitle };
</file>

<file path="src/components/ui/avatar.tsx">
import * as AvatarPrimitive from "@radix-ui/react-avatar";
import * as React from "react";

import { cn } from "~/shared/lib/utils";

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className,
      )}
      {...props}
    />
  );
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  );
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className,
      )}
      {...props}
    />
  );
}

export { Avatar, AvatarFallback, AvatarImage };
</file>

<file path="src/components/ui/badge.tsx">
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import * as React from "react";

import { cn } from "~/shared/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline: "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span";

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  );
}

export { Badge, badgeVariants };
</file>

<file path="src/components/ui/button.tsx">
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import * as React from "react";

import { cn } from "~/shared/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean;
  }) {
  const Comp = asChild ? Slot : "button";

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  );
}

export { Button, buttonVariants };
</file>

<file path="src/components/ui/card.tsx">
import * as React from "react";

import { cn } from "~/shared/lib/utils";

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className,
      )}
      {...props}
    />
  );
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className,
      )}
      {...props}
    />
  );
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  );
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  );
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className,
      )}
      {...props}
    />
  );
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return <div data-slot="card-content" className={cn("px-6", className)} {...props} />;
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  );
}

export {
  Card,
  CardAction,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
};
</file>

<file path="src/components/ui/checkbox.tsx">
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { CheckIcon } from "lucide-react";
import * as React from "react";

import { cn } from "~/shared/lib/utils";

function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="flex items-center justify-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  );
}

export { Checkbox };
</file>

<file path="src/components/ui/command.tsx">
"use client";

import { Command as CommandPrimitive } from "cmdk";
import { SearchIcon } from "lucide-react";
import * as React from "react";

import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "~/components/ui/dialog";
import { cn } from "~/shared/lib/utils";

function Command({ className, ...props }: React.ComponentProps<typeof CommandPrimitive>) {
  return (
    <CommandPrimitive
      data-slot="command"
      className={cn(
        "bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md",
        className,
      )}
      {...props}
    />
  );
}

function CommandDialog({
  title = "Command Palette",
  description = "Search for a command to run...",
  children,
  className,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof Dialog> & {
  title?: string;
  description?: string;
  className?: string;
  showCloseButton?: boolean;
}) {
  return (
    <Dialog {...props}>
      <DialogHeader className="sr-only">
        <DialogTitle>{title}</DialogTitle>
        <DialogDescription>{description}</DialogDescription>
      </DialogHeader>
      <DialogContent
        className={cn("overflow-hidden p-0", className)}
        showCloseButton={showCloseButton}
      >
        <Command className="[&_[cmdk-group-heading]]:text-muted-foreground **:data-[slot=command-input-wrapper]:h-12 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group]]:px-2 [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  );
}

function CommandInput({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Input>) {
  return (
    <div
      data-slot="command-input-wrapper"
      className="flex h-9 items-center gap-2 border-b px-3"
    >
      <SearchIcon className="size-4 shrink-0 opacity-50" />
      <CommandPrimitive.Input
        data-slot="command-input"
        className={cn(
          "placeholder:text-muted-foreground flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-hidden disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        {...props}
      />
    </div>
  );
}

function CommandList({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.List>) {
  return (
    <CommandPrimitive.List
      data-slot="command-list"
      className={cn(
        "max-h-[300px] scroll-py-1 overflow-x-hidden overflow-y-auto",
        className,
      )}
      {...props}
    />
  );
}

function CommandEmpty({ ...props }: React.ComponentProps<typeof CommandPrimitive.Empty>) {
  return (
    <CommandPrimitive.Empty
      data-slot="command-empty"
      className="py-6 text-center text-sm"
      {...props}
    />
  );
}

function CommandGroup({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Group>) {
  return (
    <CommandPrimitive.Group
      data-slot="command-group"
      className={cn(
        "text-foreground [&_[cmdk-group-heading]]:text-muted-foreground overflow-hidden p-1 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium",
        className,
      )}
      {...props}
    />
  );
}

function CommandSeparator({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Separator>) {
  return (
    <CommandPrimitive.Separator
      data-slot="command-separator"
      className={cn("bg-border -mx-1 h-px", className)}
      {...props}
    />
  );
}

function CommandItem({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Item>) {
  return (
    <CommandPrimitive.Item
      data-slot="command-item"
      className={cn(
        "data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    />
  );
}

function CommandShortcut({ className, ...props }: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="command-shortcut"
      className={cn("text-muted-foreground ml-auto text-xs tracking-widest", className)}
      {...props}
    />
  );
}

export {
  Command,
  CommandDialog,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
  CommandSeparator,
  CommandShortcut,
};
</file>

<file path="src/components/ui/data-state.tsx">
import { AlertCircle } from "lucide-react";
import { Button } from "~/components/ui/button";

interface DataErrorStateProps {
  title?: string;
  description?: string | undefined;
  retryLabel?: string;
  onRetry?: () => void;
}

export function DataErrorState({
  title = "Something went wrong",
  description = "We couldnât load this data. Please try again in a moment.",
  retryLabel = "Retry",
  onRetry,
}: DataErrorStateProps) {
  return (
    <div className="border-destructive/20 bg-destructive/10 flex flex-col items-center justify-center gap-4 rounded-xl border p-6 text-center">
      <div className="text-destructive flex items-center gap-2">
        <AlertCircle className="h-5 w-5" />
        <span className="text-sm font-semibold tracking-wide uppercase">Error</span>
      </div>
      <div className="space-y-2">
        <h3 className="text-lg font-semibold text-gray-900">{title}</h3>
        <p className="text-sm text-gray-600">{description}</p>
      </div>
      {onRetry && (
        <Button
          variant="outline"
          onClick={onRetry}
          className="border-destructive text-destructive hover:bg-destructive/10"
        >
          {retryLabel}
        </Button>
      )}
    </div>
  );
}
</file>

<file path="src/components/ui/dialog.tsx">
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { XIcon } from "lucide-react";
import * as React from "react";

import { cn } from "~/shared/lib/utils";

function Dialog({ ...props }: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />;
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />;
}

function DialogPortal({ ...props }: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />;
}

function DialogClose({ ...props }: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />;
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className,
      )}
      {...props}
    />
  );
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean;
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className,
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  );
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  );
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn("flex flex-col-reverse gap-2 sm:flex-row sm:justify-end", className)}
      {...props}
    />
  );
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  );
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  );
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
};
</file>

<file path="src/components/ui/dropdown-menu.tsx">
"use client";

import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react";
import * as React from "react";

import { cn } from "~/shared/lib/utils";

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />;
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />;
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return <DropdownMenuPrimitive.Trigger data-slot="dropdown-menu-trigger" {...props} />;
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className,
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  );
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />;
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean;
  variant?: "default" | "destructive";
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    />
  );
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      checked={checked ?? false}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  );
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup data-slot="dropdown-menu-radio-group" {...props} />
  );
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  );
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean;
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn("px-2 py-1.5 text-sm font-medium data-[inset]:pl-8", className)}
      {...props}
    />
  );
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  );
}

function DropdownMenuShortcut({ className, ...props }: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn("text-muted-foreground ml-auto text-xs tracking-widest", className)}
      {...props}
    />
  );
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />;
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean;
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className,
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  );
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className,
      )}
      {...props}
    />
  );
}

export {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuPortal,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
};
</file>

<file path="src/components/ui/input.tsx">
import * as React from "react";

import { cn } from "~/shared/lib/utils";

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className,
      )}
      {...props}
    />
  );
}

export { Input };
</file>

<file path="src/components/ui/label.tsx">
import * as LabelPrimitive from "@radix-ui/react-label";
import * as React from "react";

import { cn } from "~/shared/lib/utils";

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className,
      )}
      {...props}
    />
  );
}

export { Label };
</file>

<file path="src/components/ui/logo.tsx">
import { useState } from "react";

interface LogoProps {
  className?: string;
  alt?: string;
}

export function Logo({ className, alt = "Quadball Canada logo" }: LogoProps) {
  const [src, setSrc] = useState<string>("/quadball-canada-logo.svg");

  return (
    <img
      src={src}
      alt={alt}
      className={"object-contain " + (className ?? "")}
      onError={() => setSrc("/quadball-canada-logo.jpg")}
    />
  );
}
</file>

<file path="src/components/ui/mobile-admin-header.tsx">
import { Menu } from "lucide-react";
import { Button } from "./button";

interface MobileAdminHeaderProps {
  onMenuClick: () => void;
}

export function MobileAdminHeader({ onMenuClick }: MobileAdminHeaderProps) {
  return (
    <header className="sticky top-0 z-40 border-b border-gray-200 bg-white lg:hidden">
      <div className="flex h-16 items-center justify-between px-4">
        <div className="flex items-center gap-3">
          <Button variant="ghost" size="icon" onClick={onMenuClick}>
            <Menu className="h-6 w-6" />
          </Button>
          <div>
            <h1 className="text-admin-text-primary text-lg font-bold">Quadball Canada</h1>
            <p className="text-admin-text-secondary text-xs">Admin Panel</p>
          </div>
        </div>
      </div>
    </header>
  );
}
</file>

<file path="src/components/ui/popover.tsx">
import * as PopoverPrimitive from "@radix-ui/react-popover";
import * as React from "react";

import { cn } from "~/shared/lib/utils";

function Popover({ ...props }: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />;
}

function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />;
}

function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden",
          className,
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  );
}

function PopoverAnchor({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />;
}

export { Popover, PopoverAnchor, PopoverContent, PopoverTrigger };
</file>

<file path="src/components/ui/radio-group.tsx">
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group";
import { CircleIcon } from "lucide-react";
import * as React from "react";

import { cn } from "~/shared/lib/utils";

function RadioGroup({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Root>) {
  return (
    <RadioGroupPrimitive.Root
      data-slot="radio-group"
      className={cn("grid gap-3", className)}
      {...props}
    />
  );
}

function RadioGroupItem({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Item>) {
  return (
    <RadioGroupPrimitive.Item
      data-slot="radio-group-item"
      className={cn(
        "border-input text-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 aspect-square size-4 shrink-0 rounded-full border shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator
        data-slot="radio-group-indicator"
        className="relative flex items-center justify-center"
      >
        <CircleIcon className="fill-primary absolute top-1/2 left-1/2 size-2 -translate-x-1/2 -translate-y-1/2" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  );
}

export { RadioGroup, RadioGroupItem };
</file>

<file path="src/components/ui/select.tsx">
import * as SelectPrimitive from "@radix-ui/react-select";
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react";
import * as React from "react";

import { cn } from "~/shared/lib/utils";

function Select({ ...props }: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />;
}

function SelectGroup({ ...props }: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />;
}

function SelectValue({ ...props }: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />;
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default";
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  );
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className,
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1",
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  );
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  );
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className,
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  );
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  );
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn("flex cursor-default items-center justify-center py-1", className)}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  );
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn("flex cursor-default items-center justify-center py-1", className)}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  );
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
};
</file>

<file path="src/components/ui/separator.tsx">
"use client";

import * as SeparatorPrimitive from "@radix-ui/react-separator";
import * as React from "react";

import { cn } from "~/shared/lib/utils";

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className,
      )}
      {...props}
    />
  );
}

export { Separator };
</file>

<file path="src/components/ui/skeleton.tsx">
import { cn } from "~/shared/lib/utils";

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  );
}

export { Skeleton };
</file>

<file path="src/components/ui/sonner.tsx">
import { Toaster as Sonner, type ToasterProps } from "sonner";
import { useTheme } from "~/shared/hooks/useTheme";

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme();

  return (
    <Sonner
      theme={theme}
      className="toaster group"
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
        } as React.CSSProperties
      }
      {...props}
    />
  );
};

export { Toaster };
</file>

<file path="src/components/ui/table.tsx">
import * as React from "react";

import { cn } from "~/shared/lib/utils";

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div data-slot="table-container" className="relative w-full overflow-x-auto">
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  );
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  );
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  );
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn("bg-muted/50 border-t font-medium [&>tr]:last:border-b-0", className)}
      {...props}
    />
  );
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className,
      )}
      {...props}
    />
  );
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className,
      )}
      {...props}
    />
  );
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className,
      )}
      {...props}
    />
  );
}

function TableCaption({ className, ...props }: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  );
}

export {
  Table,
  TableBody,
  TableCaption,
  TableCell,
  TableFooter,
  TableHead,
  TableHeader,
  TableRow,
};
</file>

<file path="src/components/ui/tabs.tsx">
import * as TabsPrimitive from "@radix-ui/react-tabs";
import * as React from "react";

import { cn } from "~/shared/lib/utils";

function Tabs({ className, ...props }: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  );
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className,
      )}
      {...props}
    />
  );
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    />
  );
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  );
}

export { Tabs, TabsContent, TabsList, TabsTrigger };
</file>

<file path="src/components/ui/textarea.tsx">
import * as React from "react";

import { cn } from "~/shared/lib/utils";

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className,
      )}
      {...props}
    />
  );
}

export { Textarea };
</file>

<file path="src/components/ThemeToggle.tsx">
import { Button } from "~/components/ui/button";
import { MoonIcon, SunIcon } from "~/components/ui/icons";
import { useTheme } from "~/shared/hooks/useTheme";

export default function ThemeToggle() {
  const { toggleTheme } = useTheme();

  return (
    <Button variant="outline" size="icon" type="button" onClick={toggleTheme}>
      <SunIcon className="size-4 scale-100 rotate-0 transition-all dark:scale-0 dark:-rotate-90" />
      <MoonIcon className="absolute size-4 scale-0 rotate-90 transition-all dark:scale-100 dark:rotate-0" />
      <span className="sr-only">Toggle theme</span>
    </Button>
  );
}
</file>

<file path="src/features/auth/__tests__/login-with-router.test.tsx">
import userEvent from "@testing-library/user-event";
import { beforeEach, describe, expect, it, vi } from "vitest";
import { auth } from "~/lib/auth-client";
import { renderWithRouter, screen, waitFor } from "~/tests/utils";
import LoginForm from "../components/login";

// Mock auth client
vi.mock("~/lib/auth-client", () => ({
  auth: {
    signIn: {
      email: vi.fn(),
    },
    signInWithOAuth: vi.fn(),
  },
}));

describe("LoginForm with TanStack Router", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("renders login form in router context", async () => {
    await renderWithRouter(<LoginForm />);

    expect(screen.getByLabelText("Email")).toBeInTheDocument();
    expect(screen.getByLabelText("Password")).toBeInTheDocument();
    expect(screen.getByRole("button", { name: "Login" })).toBeInTheDocument();
  });

  it("handles navigation with router context", async () => {
    const user = userEvent.setup();

    // Mock successful login
    vi.mocked(auth.signIn.email).mockImplementation((data, handlers) => {
      handlers?.onSuccess?.({ data: { user: {}, session: {} } } as Parameters<
        NonNullable<typeof handlers.onSuccess>
      >[0]);
      return Promise.resolve({ data: { user: {}, session: {} }, error: null });
    });

    const { router } = await renderWithRouter(<LoginForm />);

    // Fill and submit form
    await user.type(screen.getByLabelText("Email"), "test@example.com");
    await user.type(screen.getByLabelText("Password"), "password123");
    await user.click(screen.getByRole("button", { name: "Login" }));

    await waitFor(() => {
      expect(auth.signIn.email).toHaveBeenCalled();
    });

    // In a real router test, we would check navigation
    // But since LoginForm uses router hooks that we need to mock,
    // we'll verify the router exists
    expect(router).toBeDefined();
  });

  it("renders with custom user context", async () => {
    const customUser = {
      id: "custom-user",
      name: "Custom User",
      email: "custom@example.com",
      emailVerified: true,
      image: null,
      createdAt: new Date(),
      updatedAt: new Date(),
      profileComplete: true,
      dateOfBirth: new Date("1990-01-01"),
      phone: "+1234567890",
      gender: "male" as const,
      pronouns: "he/him",
      emergencyContact: JSON.stringify({
        name: "Emergency Contact",
        phone: "+0987654321",
        relationship: "spouse",
      }),
      privacySettings: JSON.stringify({
        showEmail: false,
        showPhone: false,
        showDateOfBirth: false,
      }),
      profileVersion: 1,
      profileUpdatedAt: new Date(),
    };

    await renderWithRouter(<LoginForm />, { user: customUser });

    // Component should still render
    expect(screen.getByLabelText("Email")).toBeInTheDocument();
  });

  it("has access to query client", async () => {
    const { queryClient } = await renderWithRouter(<LoginForm />);

    expect(queryClient).toBeDefined();
    expect(queryClient?.getDefaultOptions()).toBeDefined();
  });
});
</file>

<file path="src/features/auth/hooks/useAuth.ts">
import { useRouteContext } from "@tanstack/react-router";
import type { User } from "better-auth";

/**
 * Hook to access authentication state from route context
 *
 * @example
 * const { user, isAuthenticated } = useAuth();
 *
 * if (isAuthenticated) {
 *   // User is logged in
 * }
 */
export function useAuth() {
  const context = useRouteContext({ from: "__root__" });
  const user = context.user as User | null;

  return {
    user,
    isAuthenticated: !!user,
  };
}

/**
 * Hook that requires authentication and returns the user
 * Should only be used in components that are already protected by route guards
 *
 * @example
 * const user = useAuthenticatedUser(); // Will never be null
 */
export function useAuthenticatedUser(): User {
  const { user } = useAuth();

  if (!user) {
    throw new Error(
      "useAuthenticatedUser must be used within an authenticated route. " +
        "Make sure the route has proper auth guards in place.",
    );
  }

  return user;
}
</file>

<file path="src/features/dashboard/index.ts">
export { MemberDashboard } from "./MemberDashboard";
export type { MemberDashboardProps } from "./MemberDashboard";
export { PublicPortalPage } from "./PublicPortalPage";
</file>

<file path="src/features/dashboard/PublicPortalPage.tsx">
import { Link } from "@tanstack/react-router";
import { ExternalLink, LogIn, UserPlus } from "lucide-react";
import { Button } from "~/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";

/**
 * Public portal page shown to unauthenticated visitors.
 * Directs them to login/signup or the public marketing site.
 */
export function PublicPortalPage() {
  return (
    <div className="flex min-h-screen flex-col items-center justify-center bg-gray-50 px-4">
      <div className="w-full max-w-md space-y-8">
        {/* Logo/Brand */}
        <div className="text-center">
          <h1 className="text-3xl font-bold tracking-tight text-gray-900">
            Quadball Canada
          </h1>
          <p className="mt-2 text-lg text-gray-600">Members Portal</p>
        </div>

        {/* Main Card */}
        <Card>
          <CardHeader className="text-center">
            <CardTitle>Welcome</CardTitle>
            <CardDescription>
              This is the member management system for registered players, teams, and
              officials.
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            {/* Login Button */}
            <Button asChild className="w-full" size="lg">
              <Link to="/auth/login">
                <LogIn className="mr-2 h-4 w-4" />
                Log in
              </Link>
            </Button>

            {/* Sign Up Button */}
            <Button asChild variant="outline" className="w-full" size="lg">
              <Link to="/auth/signup">
                <UserPlus className="mr-2 h-4 w-4" />
                Create an account
              </Link>
            </Button>

            {/* Divider */}
            <div className="relative py-4">
              <div className="absolute inset-0 flex items-center">
                <span className="w-full border-t" />
              </div>
              <div className="relative flex justify-center text-xs uppercase">
                <span className="bg-white px-2 text-gray-500">or</span>
              </div>
            </div>

            {/* Marketing Site Link */}
            <div className="text-center">
              <p className="mb-3 text-sm text-gray-600">
                Looking for general information about Quadball Canada?
              </p>
              <Button asChild variant="ghost" className="text-primary">
                <a
                  href="https://quadballcanada.ca"
                  target="_blank"
                  rel="noopener noreferrer"
                >
                  Visit quadballcanada.ca
                  <ExternalLink className="ml-2 h-3 w-3" />
                </a>
              </Button>
            </div>
          </CardContent>
        </Card>

        {/* Footer */}
        <p className="text-center text-xs text-gray-500">
          &copy; {new Date().getFullYear()} Quadball Canada. All rights reserved.
        </p>
      </div>
    </div>
  );
}
</file>

<file path="src/features/events/__tests__/events.registration.integration.test.ts">
import { beforeEach, describe, expect, it, vi } from "vitest";

/**
 * Integration tests for event registration business logic.
 * Tests registration eligibility, pricing calculations, and state transitions.
 */

// Mock types matching the actual schema
interface MockEvent {
  id: string;
  name: string;
  slug: string;
  status:
    | "draft"
    | "published"
    | "registration_open"
    | "registration_closed"
    | "in_progress"
    | "completed"
    | "cancelled";
  registrationType: "individual" | "team" | "both";
  maxParticipants: number | null;
  maxTeams: number | null;
  individualFee: number | null;
  teamFee: number | null;
  memberDiscount: number | null;
  earlyBirdDiscount: number | null;
  earlyBirdDeadline: string | null;
  organizerId: string;
  metadata: Record<string, unknown>;
}

interface MockRegistration {
  id: string;
  eventId: string;
  userId: string | null;
  teamId: string | null;
  status: "pending" | "confirmed" | "cancelled" | "waitlisted";
  paymentStatus: "pending" | "paid" | "refunded" | "waived";
  amountPaidCents: number;
  division: string | null;
  notes: string | null;
  metadata: Record<string, unknown>;
  createdAt: Date;
}

interface MockMembership {
  id: string;
  userId: string;
  status: "active" | "expired" | "cancelled";
  endDate: string;
}

describe("Event Registration Integration", () => {
  let mockRegistrations: MockRegistration[];
  let mockMemberships: MockMembership[];

  beforeEach(() => {
    vi.clearAllMocks();
    mockRegistrations = [];
    mockMemberships = [];
  });

  describe("Registration Eligibility", () => {
    it("allows registration when event status is registration_open", () => {
      const event: MockEvent = {
        id: "event-1",
        name: "Summer Tournament",
        slug: "summer-tournament-2025",
        status: "registration_open",
        registrationType: "individual",
        maxParticipants: 100,
        maxTeams: null,
        individualFee: 2500, // $25.00
        teamFee: null,
        memberDiscount: 500, // $5.00 off for members
        earlyBirdDiscount: null,
        earlyBirdDeadline: null,
        organizerId: "org-1",
        metadata: {},
      };

      const canRegister = event.status === "registration_open";
      expect(canRegister).toBe(true);
    });

    it("blocks registration when event is draft", () => {
      const event: MockEvent = {
        id: "event-1",
        name: "Summer Tournament",
        slug: "summer-tournament-2025",
        status: "draft",
        registrationType: "individual",
        maxParticipants: 100,
        maxTeams: null,
        individualFee: 2500,
        teamFee: null,
        memberDiscount: null,
        earlyBirdDiscount: null,
        earlyBirdDeadline: null,
        organizerId: "org-1",
        metadata: {},
      };

      const canRegister = event.status === "registration_open";
      expect(canRegister).toBe(false);
    });

    it("blocks registration when event is cancelled", () => {
      const event: MockEvent = {
        id: "event-1",
        name: "Summer Tournament",
        slug: "summer-tournament-2025",
        status: "cancelled",
        registrationType: "individual",
        maxParticipants: 100,
        maxTeams: null,
        individualFee: 2500,
        teamFee: null,
        memberDiscount: null,
        earlyBirdDiscount: null,
        earlyBirdDeadline: null,
        organizerId: "org-1",
        metadata: {},
      };

      const canRegister = event.status === "registration_open";
      expect(canRegister).toBe(false);
    });

    it("blocks duplicate registration for same user", () => {
      const userId = "user-123";
      const eventId = "event-1";

      mockRegistrations.push({
        id: "reg-1",
        eventId,
        userId,
        teamId: null,
        status: "confirmed",
        paymentStatus: "paid",
        amountPaidCents: 2500,
        division: null,
        notes: null,
        metadata: {},
        createdAt: new Date(),
      });

      const existingRegistration = mockRegistrations.find(
        (r) => r.eventId === eventId && r.userId === userId && r.status !== "cancelled",
      );

      expect(existingRegistration).toBeDefined();
      const canRegister = !existingRegistration;
      expect(canRegister).toBe(false);
    });
  });

  describe("Capacity Management", () => {
    it("allows registration when under capacity", () => {
      const event: MockEvent = {
        id: "event-1",
        name: "Small Tournament",
        slug: "small-tournament",
        status: "registration_open",
        registrationType: "individual",
        maxParticipants: 10,
        maxTeams: null,
        individualFee: 2500,
        teamFee: null,
        memberDiscount: null,
        earlyBirdDiscount: null,
        earlyBirdDeadline: null,
        organizerId: "org-1",
        metadata: {},
      };

      // 5 existing registrations
      for (let i = 0; i < 5; i++) {
        mockRegistrations.push({
          id: `reg-${i}`,
          eventId: event.id,
          userId: `user-${i}`,
          teamId: null,
          status: "confirmed",
          paymentStatus: "paid",
          amountPaidCents: 2500,
          division: null,
          notes: null,
          metadata: {},
          createdAt: new Date(),
        });
      }

      const confirmedCount = mockRegistrations.filter(
        (r) => r.eventId === event.id && r.status === "confirmed",
      ).length;

      const hasCapacity =
        event.maxParticipants === null || confirmedCount < event.maxParticipants;
      expect(hasCapacity).toBe(true);
      expect(confirmedCount).toBe(5);
    });

    it("blocks registration when at capacity", () => {
      const event: MockEvent = {
        id: "event-1",
        name: "Small Tournament",
        slug: "small-tournament",
        status: "registration_open",
        registrationType: "individual",
        maxParticipants: 5,
        maxTeams: null,
        individualFee: 2500,
        teamFee: null,
        memberDiscount: null,
        earlyBirdDiscount: null,
        earlyBirdDeadline: null,
        organizerId: "org-1",
        metadata: {},
      };

      // Fill to capacity
      for (let i = 0; i < 5; i++) {
        mockRegistrations.push({
          id: `reg-${i}`,
          eventId: event.id,
          userId: `user-${i}`,
          teamId: null,
          status: "confirmed",
          paymentStatus: "paid",
          amountPaidCents: 2500,
          division: null,
          notes: null,
          metadata: {},
          createdAt: new Date(),
        });
      }

      const confirmedCount = mockRegistrations.filter(
        (r) => r.eventId === event.id && r.status === "confirmed",
      ).length;

      const hasCapacity =
        event.maxParticipants === null || confirmedCount < event.maxParticipants;
      expect(hasCapacity).toBe(false);
    });

    it("does not count cancelled registrations toward capacity", () => {
      const event: MockEvent = {
        id: "event-1",
        name: "Small Tournament",
        slug: "small-tournament",
        status: "registration_open",
        registrationType: "individual",
        maxParticipants: 5,
        maxTeams: null,
        individualFee: 2500,
        teamFee: null,
        memberDiscount: null,
        earlyBirdDiscount: null,
        earlyBirdDeadline: null,
        organizerId: "org-1",
        metadata: {},
      };

      // 3 confirmed, 2 cancelled
      for (let i = 0; i < 3; i++) {
        mockRegistrations.push({
          id: `reg-${i}`,
          eventId: event.id,
          userId: `user-${i}`,
          teamId: null,
          status: "confirmed",
          paymentStatus: "paid",
          amountPaidCents: 2500,
          division: null,
          notes: null,
          metadata: {},
          createdAt: new Date(),
        });
      }
      for (let i = 3; i < 5; i++) {
        mockRegistrations.push({
          id: `reg-${i}`,
          eventId: event.id,
          userId: `user-${i}`,
          teamId: null,
          status: "cancelled",
          paymentStatus: "refunded",
          amountPaidCents: 0,
          division: null,
          notes: null,
          metadata: {},
          createdAt: new Date(),
        });
      }

      const confirmedCount = mockRegistrations.filter(
        (r) => r.eventId === event.id && r.status === "confirmed",
      ).length;

      expect(confirmedCount).toBe(3);
      const hasCapacity =
        event.maxParticipants === null || confirmedCount < event.maxParticipants;
      expect(hasCapacity).toBe(true);
    });
  });

  describe("Pricing Calculations", () => {
    it("calculates base price for non-members", () => {
      const event: MockEvent = {
        id: "event-1",
        name: "Tournament",
        slug: "tournament",
        status: "registration_open",
        registrationType: "individual",
        maxParticipants: null,
        maxTeams: null,
        individualFee: 2500, // $25.00
        teamFee: null,
        memberDiscount: 500, // $5.00 off
        earlyBirdDiscount: null,
        earlyBirdDeadline: null,
        organizerId: "org-1",
        metadata: {},
      };

      const isMember = false;
      const basePrice = event.individualFee ?? 0;
      const discount = isMember ? (event.memberDiscount ?? 0) : 0;
      const finalPrice = Math.max(0, basePrice - discount);

      expect(finalPrice).toBe(2500);
    });

    it("applies member discount correctly", () => {
      const event: MockEvent = {
        id: "event-1",
        name: "Tournament",
        slug: "tournament",
        status: "registration_open",
        registrationType: "individual",
        maxParticipants: null,
        maxTeams: null,
        individualFee: 2500, // $25.00
        teamFee: null,
        memberDiscount: 500, // $5.00 off
        earlyBirdDiscount: null,
        earlyBirdDeadline: null,
        organizerId: "org-1",
        metadata: {},
      };

      // User has active membership
      mockMemberships.push({
        id: "membership-1",
        userId: "user-123",
        status: "active",
        endDate: "2025-12-31",
      });

      const userId = "user-123";
      const userMembership = mockMemberships.find(
        (m) => m.userId === userId && m.status === "active",
      );
      const isMember = !!userMembership;

      const basePrice = event.individualFee ?? 0;
      const discount = isMember ? (event.memberDiscount ?? 0) : 0;
      const finalPrice = Math.max(0, basePrice - discount);

      expect(isMember).toBe(true);
      expect(finalPrice).toBe(2000); // $25 - $5 = $20
    });

    it("applies early bird discount when before deadline", () => {
      const now = new Date("2025-01-15");
      const event: MockEvent = {
        id: "event-1",
        name: "Tournament",
        slug: "tournament",
        status: "registration_open",
        registrationType: "individual",
        maxParticipants: null,
        maxTeams: null,
        individualFee: 2500,
        teamFee: null,
        memberDiscount: null,
        earlyBirdDiscount: 300, // $3.00 off
        earlyBirdDeadline: "2025-02-01", // Deadline is after now
        organizerId: "org-1",
        metadata: {},
      };

      const isEarlyBird = event.earlyBirdDeadline
        ? now < new Date(event.earlyBirdDeadline)
        : false;

      const basePrice = event.individualFee ?? 0;
      const discount = isEarlyBird ? (event.earlyBirdDiscount ?? 0) : 0;
      const finalPrice = Math.max(0, basePrice - discount);

      expect(isEarlyBird).toBe(true);
      expect(finalPrice).toBe(2200); // $25 - $3 = $22
    });

    it("does not apply early bird discount after deadline", () => {
      const now = new Date("2025-03-01");
      const event: MockEvent = {
        id: "event-1",
        name: "Tournament",
        slug: "tournament",
        status: "registration_open",
        registrationType: "individual",
        maxParticipants: null,
        maxTeams: null,
        individualFee: 2500,
        teamFee: null,
        memberDiscount: null,
        earlyBirdDiscount: 300,
        earlyBirdDeadline: "2025-02-01", // Deadline has passed
        organizerId: "org-1",
        metadata: {},
      };

      const isEarlyBird = event.earlyBirdDeadline
        ? now < new Date(event.earlyBirdDeadline)
        : false;

      const basePrice = event.individualFee ?? 0;
      const discount = isEarlyBird ? (event.earlyBirdDiscount ?? 0) : 0;
      const finalPrice = Math.max(0, basePrice - discount);

      expect(isEarlyBird).toBe(false);
      expect(finalPrice).toBe(2500); // Full price
    });

    it("stacks member and early bird discounts", () => {
      const now = new Date("2025-01-15");
      const event: MockEvent = {
        id: "event-1",
        name: "Tournament",
        slug: "tournament",
        status: "registration_open",
        registrationType: "individual",
        maxParticipants: null,
        maxTeams: null,
        individualFee: 2500,
        teamFee: null,
        memberDiscount: 500,
        earlyBirdDiscount: 300,
        earlyBirdDeadline: "2025-02-01",
        organizerId: "org-1",
        metadata: {},
      };

      mockMemberships.push({
        id: "membership-1",
        userId: "user-123",
        status: "active",
        endDate: "2025-12-31",
      });

      const userId = "user-123";
      const userMembership = mockMemberships.find(
        (m) => m.userId === userId && m.status === "active",
      );
      const isMember = !!userMembership;
      const isEarlyBird = event.earlyBirdDeadline
        ? now < new Date(event.earlyBirdDeadline)
        : false;

      const basePrice = event.individualFee ?? 0;
      const memberDiscount = isMember ? (event.memberDiscount ?? 0) : 0;
      const earlyBirdDiscount = isEarlyBird ? (event.earlyBirdDiscount ?? 0) : 0;
      const finalPrice = Math.max(0, basePrice - memberDiscount - earlyBirdDiscount);

      expect(finalPrice).toBe(1700); // $25 - $5 - $3 = $17
    });
  });

  describe("Registration Cancellation", () => {
    it("updates status to cancelled and preserves metadata", () => {
      const registration: MockRegistration = {
        id: "reg-1",
        eventId: "event-1",
        userId: "user-123",
        teamId: null,
        status: "confirmed",
        paymentStatus: "paid",
        amountPaidCents: 2500,
        division: "competitive",
        notes: null,
        metadata: { registeredAt: "2025-01-15T10:00:00Z" },
        createdAt: new Date("2025-01-15"),
      };

      const cancellationReason = "Unable to attend due to schedule conflict";
      const cancelledAt = new Date("2025-01-20T15:00:00Z");

      // Simulate cancellation
      const updatedRegistration: MockRegistration = {
        ...registration,
        status: "cancelled",
        metadata: {
          ...registration.metadata,
          cancelledAt: cancelledAt.toISOString(),
          cancellationReason,
        },
      };

      expect(updatedRegistration.status).toBe("cancelled");
      expect(updatedRegistration.metadata).toMatchObject({
        registeredAt: "2025-01-15T10:00:00Z",
        cancelledAt: cancelledAt.toISOString(),
        cancellationReason,
      });
    });
  });
});
</file>

<file path="src/features/events/__tests__/payment-metadata.test.ts">
import { describe, expect, it } from "vitest";
import {
  appendCancellationNote,
  buildEtransferSnapshot,
  fixedClock,
  markEtransferPaidMetadata,
  markEtransferReminderMetadata,
} from "~/features/events/utils";

describe("payment metadata utilities", () => {
  const clock = fixedClock("2025-01-01T12:00:00.000Z");

  it("builds snapshot with instructions and recipient", () => {
    expect(buildEtransferSnapshot("send to x", "pay@club.ca")).toEqual({
      instructionsSnapshot: "send to x",
      recipient: "pay@club.ca",
    });
  });

  it("marks e-transfer paid with actor + timestamp", () => {
    const meta = markEtransferPaidMetadata(undefined, "user-123", clock);
    expect(meta.markedPaidBy).toBe("user-123");
    expect(meta.markedPaidAt).toBe("2025-01-01T12:00:00.000Z");
  });

  it("marks e-transfer reminder with actor + timestamp", () => {
    const meta = markEtransferReminderMetadata({ notes: "pending" }, "admin-1", clock);
    expect(meta.lastReminderBy).toBe("admin-1");
    expect(meta.lastReminderAt).toBe("2025-01-01T12:00:00.000Z");
    expect(meta.notes).toBe("pending");
  });

  it("appends cancellation notes only once", () => {
    const note = "Event cancelled by admin";
    const first = appendCancellationNote({}, note);
    const second = appendCancellationNote(first, note);
    expect(second.notes).toBe(note);
  });
});
</file>

<file path="src/features/events/__tests__/registration-pricing.test.ts">
import { describe, expect, it } from "vitest";
import { calculateRegistrationAmountCents } from "~/features/events/utils";

const baseEvent = {
  teamRegistrationFee: 20000,
  individualRegistrationFee: 5000,
  earlyBirdDiscount: 0,
  earlyBirdDeadline: null,
} as unknown as Parameters<typeof calculateRegistrationAmountCents>[0];

function makeEvent(
  overrides: Partial<Parameters<typeof calculateRegistrationAmountCents>[0]> = {},
) {
  const event = { ...baseEvent, ...overrides } as Record<string, unknown>;
  for (const key of Object.keys(event)) {
    if (event[key] === undefined) {
      delete event[key];
    }
  }
  return event as Parameters<typeof calculateRegistrationAmountCents>[0];
}

describe("calculateRegistrationAmountCents", () => {
  const referenceDate = new Date("2025-05-01T00:00:00Z");

  it("returns team base fee when no discount configured", () => {
    const amount = calculateRegistrationAmountCents(makeEvent(), "team", referenceDate);
    expect(amount).toBe(20000);
  });

  it("returns individual base fee when no discount configured", () => {
    const amount = calculateRegistrationAmountCents(
      makeEvent(),
      "individual",
      referenceDate,
    );
    expect(amount).toBe(5000);
  });

  it("returns 0 for zero or negative fees", () => {
    expect(
      calculateRegistrationAmountCents(
        makeEvent({ teamRegistrationFee: 0 }),
        "team",
        referenceDate,
      ),
    ).toBe(0);

    expect(
      calculateRegistrationAmountCents(
        makeEvent({ teamRegistrationFee: -1 }),
        "team",
        referenceDate,
      ),
    ).toBe(0);

    expect(
      calculateRegistrationAmountCents(
        makeEvent({ teamRegistrationFee: null }),
        "team",
        referenceDate,
      ),
    ).toBe(0);
  });

  it("applies early-bird discount when now is before the deadline", () => {
    const deadline = new Date("2025-06-01T00:00:00Z");
    const amount = calculateRegistrationAmountCents(
      makeEvent({ earlyBirdDiscount: 25, earlyBirdDeadline: deadline }),
      "team",
      new Date("2025-05-31T00:00:00Z"),
    );
    expect(amount).toBe(15000);
  });

  it("applies early-bird discount when now equals the deadline", () => {
    const deadline = new Date("2025-06-01T00:00:00Z");
    const amount = calculateRegistrationAmountCents(
      makeEvent({ earlyBirdDiscount: 25, earlyBirdDeadline: deadline }),
      "team",
      new Date("2025-06-01T00:00:00Z"),
    );
    expect(amount).toBe(15000);
  });

  it("does not apply early-bird discount after the deadline", () => {
    const deadline = new Date("2025-06-01T00:00:00Z");
    const amount = calculateRegistrationAmountCents(
      makeEvent({ earlyBirdDiscount: 25, earlyBirdDeadline: deadline }),
      "team",
      new Date("2025-06-01T00:00:00.001Z"),
    );
    expect(amount).toBe(20000);
  });

  it("clamps negative discounts to zero", () => {
    const deadline = new Date("2025-06-01T00:00:00Z");
    const amount = calculateRegistrationAmountCents(
      makeEvent({ earlyBirdDiscount: -20, earlyBirdDeadline: deadline }),
      "team",
      new Date("2025-05-15T00:00:00Z"),
    );
    expect(amount).toBe(20000);
  });

  it("clamps discounts above 100 to a free registration", () => {
    const deadline = new Date("2025-06-01T00:00:00Z");
    const amount = calculateRegistrationAmountCents(
      makeEvent({ earlyBirdDiscount: 150, earlyBirdDeadline: deadline }),
      "team",
      new Date("2025-05-15T00:00:00Z"),
    );
    expect(amount).toBe(0);
  });

  it("rounds correctly for fractional discounts", () => {
    const deadline = new Date("2025-06-01T00:00:00Z");
    const amount = calculateRegistrationAmountCents(
      makeEvent({
        teamRegistrationFee: 999,
        earlyBirdDiscount: 33,
        earlyBirdDeadline: deadline,
      }),
      "team",
      new Date("2025-05-15T00:00:00Z"),
    );
    expect(amount).toBe(669);
  });

  it("applies discount logic for individual registrations", () => {
    const deadline = new Date("2025-06-01T00:00:00Z");
    const amount = calculateRegistrationAmountCents(
      makeEvent({ earlyBirdDiscount: 10, earlyBirdDeadline: deadline }),
      "individual",
      new Date("2025-05-20T00:00:00Z"),
    );
    expect(amount).toBe(4500);
  });

  it("ignores discounts when no deadline provided", () => {
    const amount = calculateRegistrationAmountCents(
      makeEvent({ earlyBirdDiscount: 50, earlyBirdDeadline: null }),
      "team",
      referenceDate,
    );
    expect(amount).toBe(20000);
  });
});
</file>

<file path="src/features/events/components/event-create-form-minimal.tsx">
import { Button } from "~/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";

export function EventCreateFormMinimal() {
  return (
    <Card className="mx-auto max-w-2xl">
      <CardHeader>
        <CardTitle>Create New Event (Test)</CardTitle>
      </CardHeader>
      <CardContent>
        <p>This is a minimal test form to isolate the rendering issue.</p>
        <Button>Test Button</Button>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/events/utils/index.ts">
export * from "./jsonb";
export * from "./payment-metadata";
export * from "./pricing";
export * from "./time";
</file>

<file path="src/features/events/utils/payment-metadata.ts">
import type { EventPaymentMetadata } from "../events.db-types";
import type { Clock } from "./time";
import { isoTimestamp } from "./time";

export type ActorId = string;

/**
 * Capture a snapshot of the e-transfer instructions that were visible when the
 * registration was created. Keeps downstream finance emails consistent.
 */
export function buildEtransferSnapshot(
  instructions?: string | null,
  recipient?: string | null,
): EventPaymentMetadata {
  const metadata: EventPaymentMetadata = {};
  if (instructions) metadata.instructionsSnapshot = instructions;
  if (recipient) metadata.recipient = recipient;
  return metadata;
}

/** Record that an e-transfer was marked paid by a specific actor at a specific time. */
export function markEtransferPaidMetadata(
  existing: EventPaymentMetadata | undefined,
  actorId: ActorId,
  clock?: Clock,
): EventPaymentMetadata {
  const metadata: EventPaymentMetadata = { ...(existing ?? {}) };
  metadata.markedPaidAt = isoTimestamp(clock);
  metadata.markedPaidBy = actorId;
  return metadata;
}

/** Record that a reminder email was sent for an outstanding e-transfer. */
export function markEtransferReminderMetadata(
  existing: EventPaymentMetadata | undefined,
  actorId: ActorId,
  clock?: Clock,
): EventPaymentMetadata {
  const metadata: EventPaymentMetadata = { ...(existing ?? {}) };
  metadata.lastReminderAt = isoTimestamp(clock);
  metadata.lastReminderBy = actorId;
  return metadata;
}

/**
 * Optionally attach cancellation notes so finance/admin teams have context when
 * reviewing payment metadata.
 */
export function appendCancellationNote(
  existing: EventPaymentMetadata | undefined,
  note: string | undefined,
): EventPaymentMetadata {
  const metadata: EventPaymentMetadata = { ...(existing ?? {}) };
  if (note) {
    const existingNotes = metadata.notes ? metadata.notes.split("\n") : [];
    if (!existingNotes.includes(note)) {
      metadata.notes = existingNotes.length > 0 ? `${metadata.notes}\n${note}` : note;
    }
  }
  return metadata;
}
</file>

<file path="src/features/events/utils/pricing.ts">
import type { Event as DbEvent } from "~/db/schema";

/**
 * Calculate the registration amount in cents for a given event/registration type.
 * Applies early-bird discounts when eligible and handles zero/negative pricing.
 */
export function calculateRegistrationAmountCents(
  event: DbEvent,
  registrationType: "team" | "individual",
  now: Date,
): number {
  const baseFee =
    registrationType === "team"
      ? (event.teamRegistrationFee ?? 0)
      : (event.individualRegistrationFee ?? 0);

  if (!baseFee || baseFee <= 0) {
    return 0;
  }

  const discountPercentage = event.earlyBirdDiscount ?? 0;
  const deadline = event.earlyBirdDeadline ? new Date(event.earlyBirdDeadline) : null;

  if (discountPercentage > 0 && deadline && now <= deadline) {
    const clampedDiscount = Math.min(100, Math.max(0, discountPercentage));
    const discounted = Math.round(baseFee - (baseFee * clampedDiscount) / 100);
    return Math.max(0, discounted);
  }

  return baseFee;
}
</file>

<file path="src/features/events/utils/time.ts">
export interface Clock {
  now(): Date;
}

export const systemClock: Clock = {
  now: () => new Date(),
};

/** Returns the current Date using the provided or system clock. */
export const currentTimestamp = (clock: Clock = systemClock): Date => clock.now();

/** Returns an ISO string timestamp using the provided or system clock. */
export const isoTimestamp = (clock: Clock = systemClock): string =>
  clock.now().toISOString();

/** Retrieves a test clock from the server-fn context, falling back to the system clock. */
export const getClockFromContext = (context: unknown): Clock => {
  const candidate = (context as Record<string, unknown> | undefined)?.["clock"];
  if (candidate && typeof (candidate as Partial<Clock>).now === "function") {
    return candidate as Clock;
  }
  return systemClock;
};

/** Creates a clock that always returns the provided fixed instant. */
export const fixedClock = (at: Date | string | number): Clock => {
  const fixedDate = at instanceof Date ? at : new Date(at);
  return {
    now: () => fixedDate,
  };
};

/**
 * Creates a clock whose value can change. Useful for deterministic tests that need to
 * advance time in steps.
 */
export const mutableClock = (start: Date = new Date()) => {
  let current = start;
  return {
    now: () => current,
    set: (next: Date | string | number) => {
      current = next instanceof Date ? next : new Date(next);
    },
  } as Clock & { set: (next: Date | string | number) => void };
};
</file>

<file path="src/features/events/index.ts">
// Event queries
export {
  checkEventRegistration,
  getEvent,
  getUpcomingEvents,
  listEvents,
} from "./events.queries";

// Event mutations
export {
  cancelEvent,
  cancelEventRegistration,
  createEvent,
  registerForEvent,
  updateEvent,
} from "./events.mutations";

// Event types
export type {
  CreateEventInput,
  EventError,
  EventErrorCode,
  EventFilters,
  EventListResult,
  EventOperationResult,
  EventRegistrationInput,
  EventRegistrationWithDetails,
  EventStatus,
  EventType,
  EventWithDetails,
  RegistrationType,
  UpdateEventInput,
} from "./events.types";
</file>

<file path="src/features/members/index.ts">
export * from "./members.queries";
export * from "./members.schemas";
export * from "./members.types";
</file>

<file path="src/features/members/members.types.ts">
export type MemberDirectoryErrorCode = "NOT_AUTHENTICATED" | "DATABASE_ERROR";

export interface MemberDirectoryError {
  code: MemberDirectoryErrorCode;
  message: string;
}

export interface MemberDirectoryMembershipSummary {
  status: "active" | "expired" | "cancelled";
  membershipType: string | null;
  startDate: string | null;
  endDate: string | null;
}

export interface MemberDirectoryMember {
  id: string;
  name: string;
  email: string | null;
  emailVisible: boolean;
  phone: string | null;
  phoneVisible: boolean;
  pronouns: string | null;
  teams: string[];
  membershipStatus: "active" | "expired" | "cancelled" | "none";
  membershipType: string | null;
  membershipEndDate: string | null;
  hasActiveMembership: boolean;
  allowTeamInvitations: boolean;
  birthYear: number | null;
  birthYearVisible: boolean;
  profileUpdatedAt: string | null;
  membershipHistory: MemberDirectoryMembershipSummary[];
}

export interface MemberDirectoryPagination {
  total: number;
  limit: number;
  offset: number;
  hasMore: boolean;
}

export interface MemberDirectoryResponse {
  members: MemberDirectoryMember[];
  pagination: MemberDirectoryPagination;
}

export interface MemberDirectoryOperationResult<TData> {
  success: boolean;
  data?: TData;
  errors?: MemberDirectoryError[];
}
</file>

<file path="src/features/membership/__tests__/membership.finalize.integration.test.ts">
import { beforeEach, describe, expect, it, vi } from "vitest";
import type { MembershipDbClient } from "../membership.finalize";
import { finalizeMembershipForSession } from "../membership.finalize";

/**
 * Integration tests for membership finalization logic.
 * These tests verify the business logic of membership creation
 * including idempotency and transaction handling.
 */
describe("Membership Finalization Integration", () => {
  // Mock database client that simulates real transaction behavior
  let mockTx: ReturnType<typeof createMockTransaction>;
  let mockDb: MembershipDbClient;

  function createMockTransaction() {
    const membershipsTable: Array<{
      id: string;
      userId: string;
      membershipTypeId: string;
      paymentId: string;
      startDate: string;
      endDate: string;
      status: string;
      paymentProvider: string;
      metadata: Record<string, unknown>;
    }> = [];

    const sessionsTable: Array<{
      id: string;
      status: string;
      squarePaymentId: string | null;
      squareOrderId: string | null;
      metadata: Record<string, unknown>;
      updatedAt: Date;
    }> = [];

    return {
      membershipsTable,
      sessionsTable,
      select: vi.fn().mockReturnThis(),
      from: vi.fn().mockReturnThis(),
      where: vi.fn().mockImplementation(() => ({
        limit: vi.fn().mockImplementation(() => {
          // Return existing membership if payment ID matches
          const existingMembership = membershipsTable.find((m) => m.paymentId);
          return Promise.resolve(existingMembership ? [existingMembership] : []);
        }),
      })),
      insert: vi.fn().mockImplementation(() => ({
        values: vi.fn().mockImplementation((values) => {
          const newMembership = {
            id: `membership-${Date.now()}`,
            ...values,
          };
          membershipsTable.push(newMembership);
          return {
            returning: vi.fn().mockResolvedValue([newMembership]),
          };
        }),
      })),
      update: vi.fn().mockImplementation(() => ({
        set: vi.fn().mockImplementation((values) => ({
          where: vi.fn().mockImplementation(() => {
            sessionsTable.push({
              id: "session-1",
              ...values,
            });
            return Promise.resolve();
          }),
        })),
      })),
    };
  }

  beforeEach(() => {
    vi.clearAllMocks();
    mockTx = createMockTransaction();
    mockDb = {
      transaction: vi.fn().mockImplementation(async (callback) => {
        return callback(mockTx);
      }),
    } as unknown as MembershipDbClient;
  });

  describe("New Membership Creation", () => {
    it("creates a new membership when none exists for payment", async () => {
      const paymentSession = {
        id: "session-123",
        userId: "user-456",
        membershipTypeId: "type-789",
        squareCheckoutId: "checkout-1",
        squarePaymentId: null,
        squareOrderId: "order-1",
        squarePaymentLinkUrl: "https://square.link/test-payment",
        amountCents: 4500,
        currency: "CAD",
        status: "pending" as const,
        metadata: {},
        expiresAt: null,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const membershipType = {
        id: "type-789",
        name: "Annual Player Membership",
        description: null,
        priceCents: 4500,
        durationMonths: 12,
        status: "active" as const,
        metadata: {},
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const result = await finalizeMembershipForSession({
        db: mockDb,
        paymentSession,
        membershipType,
        paymentId: "pay-123",
        orderId: "order-1",
        sessionId: "session-123",
        now: new Date("2025-01-15"),
      });

      expect(result.wasCreated).toBe(true);
      expect(result.membership).toMatchObject({
        userId: "user-456",
        membershipTypeId: "type-789",
        paymentId: "pay-123",
        status: "active",
        paymentProvider: "square",
      });
    });

    it("calculates correct end date based on membership duration", async () => {
      const now = new Date("2025-01-15");
      const paymentSession = {
        id: "session-123",
        userId: "user-456",
        membershipTypeId: "type-789",
        squareCheckoutId: "checkout-1",
        squarePaymentId: null,
        squareOrderId: null,
        squarePaymentLinkUrl: "https://square.link/test-payment",
        amountCents: 4500,
        currency: "CAD",
        status: "pending" as const,
        metadata: {},
        expiresAt: null,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const membershipType = {
        id: "type-789",
        name: "Annual Player Membership",
        description: null,
        priceCents: 4500,
        durationMonths: 12, // 12 months
        status: "active" as const,
        metadata: {},
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const result = await finalizeMembershipForSession({
        db: mockDb,
        paymentSession,
        membershipType,
        paymentId: "pay-123",
        sessionId: "session-123",
        now,
      });

      // End date should be 12 months from start
      expect(result.membership.startDate).toBe("2025-01-15");
      expect(result.membership.endDate).toBe("2026-01-15");
    });
  });

  describe("Idempotency", () => {
    it("returns existing membership when payment already processed", async () => {
      // Pre-populate with existing membership
      const existingMembership = {
        id: "existing-membership-1",
        userId: "user-456",
        membershipTypeId: "type-789",
        paymentId: "pay-123",
        startDate: "2025-01-01",
        endDate: "2026-01-01",
        status: "active",
        paymentProvider: "square",
        metadata: {},
      };

      // Override the mock to return existing membership
      const mockTxWithExisting = {
        ...mockTx,
        select: vi.fn().mockReturnThis(),
        from: vi.fn().mockReturnThis(),
        where: vi.fn().mockImplementation(() => ({
          limit: vi.fn().mockResolvedValue([existingMembership]),
        })),
        update: vi.fn().mockImplementation(() => ({
          set: vi.fn().mockImplementation(() => ({
            where: vi.fn().mockResolvedValue(undefined),
          })),
        })),
      };

      const mockDbWithExisting = {
        transaction: vi.fn().mockImplementation(async (callback) => {
          return callback(mockTxWithExisting);
        }),
      } as unknown as MembershipDbClient;

      const paymentSession = {
        id: "session-123",
        userId: "user-456",
        membershipTypeId: "type-789",
        squareCheckoutId: "checkout-1",
        squarePaymentId: null,
        squareOrderId: null,
        squarePaymentLinkUrl: "https://square.link/test-payment",
        amountCents: 4500,
        currency: "CAD",
        status: "pending" as const,
        metadata: {},
        expiresAt: null,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const membershipType = {
        id: "type-789",
        name: "Annual Player Membership",
        description: null,
        priceCents: 4500,
        durationMonths: 12,
        status: "active" as const,
        metadata: {},
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const result = await finalizeMembershipForSession({
        db: mockDbWithExisting,
        paymentSession,
        membershipType,
        paymentId: "pay-123",
        sessionId: "session-123",
        now: new Date("2025-01-15"),
      });

      expect(result.wasCreated).toBe(false);
      expect(result.membership.id).toBe("existing-membership-1");
    });
  });

  describe("Metadata Handling", () => {
    it("preserves existing session metadata when finalizing", async () => {
      const existingMetadata = {
        referralCode: "FRIEND2025",
        utmSource: "email",
      };

      const paymentSession = {
        id: "session-123",
        userId: "user-456",
        membershipTypeId: "type-789",
        squareCheckoutId: "checkout-1",
        squarePaymentId: null,
        squareOrderId: null,
        squarePaymentLinkUrl: "https://square.link/test-payment",
        amountCents: 4500,
        currency: "CAD",
        status: "pending" as const,
        metadata: existingMetadata,
        expiresAt: null,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const membershipType = {
        id: "type-789",
        name: "Annual Player Membership",
        description: null,
        priceCents: 4500,
        durationMonths: 12,
        status: "active" as const,
        metadata: {},
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const result = await finalizeMembershipForSession({
        db: mockDb,
        paymentSession,
        membershipType,
        paymentId: "pay-123",
        orderId: "order-1",
        sessionId: "session-123",
        now: new Date("2025-01-15"),
      });

      expect(result.membership.metadata).toMatchObject({
        referralCode: "FRIEND2025",
        utmSource: "email",
        sessionId: "session-123",
        squareTransactionId: "pay-123",
        squareOrderId: "order-1",
      });
    });
  });
});
</file>

<file path="src/features/membership/__tests__/membership.schemas.test.ts">
import { describe, expect, it } from "vitest";
import {
  cancelMembershipSchema,
  confirmMembershipPurchaseSchema,
  getMembershipTypeSchema,
  purchaseMembershipSchema,
} from "../membership.schemas";

describe("Membership Schemas", () => {
  describe("getMembershipTypeSchema", () => {
    it("validates valid membership type ID", () => {
      const validInput = {
        membershipTypeId: "membership-123",
      };

      const result = getMembershipTypeSchema.safeParse(validInput);
      expect(result.success).toBe(true);
    });

    it("fails without membership type ID", () => {
      const invalidInput = {};

      const result = getMembershipTypeSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });

    it("fails with non-string membership type ID", () => {
      const invalidInput = {
        membershipTypeId: 123,
      };

      const result = getMembershipTypeSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });
  });

  describe("purchaseMembershipSchema", () => {
    it("validates valid purchase input", () => {
      const validInput = {
        membershipTypeId: "membership-123",
        autoRenew: true,
      };

      const result = purchaseMembershipSchema.safeParse(validInput);
      expect(result.success).toBe(true);
      expect(result.data?.autoRenew).toBe(true);
    });

    it("validates purchase input without autoRenew (defaults to false)", () => {
      const validInput = {
        membershipTypeId: "membership-123",
      };

      const result = purchaseMembershipSchema.safeParse(validInput);
      expect(result.success).toBe(true);
      expect(result.data?.autoRenew).toBe(false);
    });

    it("fails without membership type ID", () => {
      const invalidInput = {
        autoRenew: true,
      };

      const result = purchaseMembershipSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });

    it("fails with invalid autoRenew type", () => {
      const invalidInput = {
        membershipTypeId: "membership-123",
        autoRenew: "yes", // Should be boolean
      };

      const result = purchaseMembershipSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });
  });

  describe("cancelMembershipSchema", () => {
    it("validates valid cancellation with all fields", () => {
      const validInput = {
        membershipId: "membership-123",
        reason: "Moving to another country",
        immediate: true,
      };

      const result = cancelMembershipSchema.safeParse(validInput);
      expect(result.success).toBe(true);
      expect(result.data?.reason).toBe("Moving to another country");
      expect(result.data?.immediate).toBe(true);
    });

    it("validates cancellation without optional fields", () => {
      const validInput = {
        membershipId: "membership-123",
      };

      const result = cancelMembershipSchema.safeParse(validInput);
      expect(result.success).toBe(true);
      expect(result.data?.reason).toBeUndefined();
      expect(result.data?.immediate).toBe(false);
    });

    it("validates cancellation with only reason", () => {
      const validInput = {
        membershipId: "membership-123",
        reason: "No longer playing",
      };

      const result = cancelMembershipSchema.safeParse(validInput);
      expect(result.success).toBe(true);
      expect(result.data?.reason).toBe("No longer playing");
      expect(result.data?.immediate).toBe(false);
    });

    it("fails without membership ID", () => {
      const invalidInput = {
        reason: "No longer playing",
        immediate: true,
      };

      const result = cancelMembershipSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });

    it("accepts empty string as reason", () => {
      const validInput = {
        membershipId: "membership-123",
        reason: "",
        immediate: false,
      };

      const result = cancelMembershipSchema.safeParse(validInput);
      expect(result.success).toBe(true);
      expect(result.data?.reason).toBe("");
    });
  });

  describe("confirmMembershipPurchaseSchema", () => {
    it("validates valid confirmation with all fields", () => {
      const validInput = {
        membershipTypeId: "membership-123",
        sessionId: "session-456",
        paymentId: "payment-789",
      };

      const result = confirmMembershipPurchaseSchema.safeParse(validInput);
      expect(result.success).toBe(true);
      expect(result.data?.paymentId).toBe("payment-789");
    });

    it("validates confirmation without optional payment ID", () => {
      const validInput = {
        membershipTypeId: "membership-123",
        sessionId: "session-456",
      };

      const result = confirmMembershipPurchaseSchema.safeParse(validInput);
      expect(result.success).toBe(true);
      expect(result.data?.paymentId).toBeUndefined();
    });

    it("fails without membership type ID", () => {
      const invalidInput = {
        sessionId: "session-456",
        paymentId: "payment-789",
      };

      const result = confirmMembershipPurchaseSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });

    it("fails without session ID", () => {
      const invalidInput = {
        membershipTypeId: "membership-123",
        paymentId: "payment-789",
      };

      const result = confirmMembershipPurchaseSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });

    it("fails with non-string IDs", () => {
      const invalidInput = {
        membershipTypeId: 123,
        sessionId: 456,
        paymentId: 789,
      };

      const result = confirmMembershipPurchaseSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });
  });
});
</file>

<file path="src/features/membership/__tests__/membership.validation.test.ts">
import { describe, expect, it } from "vitest";
import {
  confirmMembershipPurchaseSchema,
  purchaseMembershipSchema,
} from "../membership.schemas";

describe("Membership Server Function Validation", () => {
  describe("createCheckoutSession validation", () => {
    it("validates membership purchase input correctly", () => {
      // The actual server function uses omit({ autoRenew: true })
      const schema = purchaseMembershipSchema.omit({ autoRenew: true });

      const validInput = {
        data: {
          membershipTypeId: "membership-123",
        },
      };

      const result = schema.safeParse(validInput.data);
      expect(result.success).toBe(true);
    });

    it("fails without membership type ID", () => {
      const schema = purchaseMembershipSchema.omit({ autoRenew: true });

      const invalidInput = {
        data: {},
      };

      const result = schema.safeParse(invalidInput.data);
      expect(result.success).toBe(false);
    });
  });

  describe("confirmMembershipPurchase validation", () => {
    it("validates confirmation input correctly", () => {
      const validInput = {
        data: {
          membershipTypeId: "membership-123",
          sessionId: "session-456",
          paymentId: "payment-789",
        },
      };

      const result = confirmMembershipPurchaseSchema.safeParse(validInput.data);
      expect(result.success).toBe(true);
    });

    it("validates without optional payment ID", () => {
      const validInput = {
        data: {
          membershipTypeId: "membership-123",
          sessionId: "session-456",
        },
      };

      const result = confirmMembershipPurchaseSchema.safeParse(validInput.data);
      expect(result.success).toBe(true);
    });

    it("fails without required fields", () => {
      const invalidInput = {
        data: {
          membershipTypeId: "membership-123",
          // Missing sessionId
        },
      };

      const result = confirmMembershipPurchaseSchema.safeParse(invalidInput.data);
      expect(result.success).toBe(false);
    });
  });

  describe("Membership Types", () => {
    it("validates membership type structure", () => {
      // This is more of a type check than a runtime validation
      const membershipType = {
        id: "annual-player-2025",
        name: "Annual Player Membership 2025",
        description: "Full player membership for 2025 season",
        priceCents: 4500,
        currency: "CAD",
        durationMonths: 12,
        benefits: [
          "Tournament participation",
          "League play",
          "Insurance coverage",
          "Voting rights",
        ],
        status: "active" as const,
        maxPurchases: 1,
        validFrom: new Date("2025-01-01"),
        validUntil: new Date("2025-12-31"),
      };

      expect(membershipType).toMatchObject({
        id: expect.any(String),
        name: expect.any(String),
        priceCents: expect.any(Number),
        durationMonths: expect.any(Number),
        status: expect.stringMatching(/active|inactive|archived/),
      });
    });
  });

  describe("Membership Record", () => {
    it("validates membership record structure", () => {
      const membership = {
        id: "membership-123",
        userId: "user-456",
        membershipTypeId: "annual-player-2025",
        startDate: "2025-01-01",
        endDate: "2025-12-31",
        status: "active" as const,
        paymentProvider: "square" as const,
        paymentId: "payment-789",
        autoRenew: false,
        metadata: {
          sessionId: "session-123",
          purchasedAt: new Date().toISOString(),
        },
      };

      expect(membership).toMatchObject({
        id: expect.any(String),
        userId: expect.any(String),
        membershipTypeId: expect.any(String),
        startDate: expect.stringMatching(/^\d{4}-\d{2}-\d{2}$/),
        endDate: expect.stringMatching(/^\d{4}-\d{2}-\d{2}$/),
        status: expect.stringMatching(/active|expired|cancelled/),
        paymentProvider: expect.stringMatching(/square|etransfer|cash|other/),
      });
    });
  });
});
</file>

<file path="src/features/membership/components/admin-memberships-report.tsx">
import { useQuery } from "@tanstack/react-query";
import { type ColumnDef } from "@tanstack/react-table";
import { useState } from "react";
import { DataTable } from "~/components/ui/data-table";
import { exportToCSV, formatCurrency, formatDate } from "~/lib/utils/csv-export";
import { getAllMemberships, type MembershipReportRow } from "../membership.admin-queries";

const columns: ColumnDef<MembershipReportRow>[] = [
  {
    accessorKey: "userName",
    header: "User Name",
  },
  {
    accessorKey: "userEmail",
    header: "Email",
  },
  {
    accessorKey: "membershipType",
    header: "Membership Type",
  },
  {
    accessorKey: "startDate",
    header: "Start Date",
    cell: ({ row }) => formatDate(row.getValue("startDate")),
  },
  {
    accessorKey: "endDate",
    header: "End Date",
    cell: ({ row }) => formatDate(row.getValue("endDate")),
  },
  {
    accessorKey: "status",
    header: "Status",
    cell: ({ row }) => {
      const status = row.getValue("status") as string;
      return (
        <span
          className={`inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-medium ${
            status === "active"
              ? "bg-green-100 text-green-800"
              : status === "expired"
                ? "bg-gray-100 text-gray-800"
                : "bg-red-100 text-red-800"
          }`}
        >
          {status}
        </span>
      );
    },
  },
  {
    accessorKey: "priceCents",
    header: "Price",
    cell: ({ row }) => formatCurrency(row.getValue("priceCents")),
  },
  {
    accessorKey: "paymentId",
    header: "Payment ID",
    cell: ({ row }) => row.getValue("paymentId") || "-",
  },
  {
    accessorKey: "createdAt",
    header: "Created At",
    cell: ({ row }) => formatDate(row.getValue("createdAt")),
  },
];

export function AdminMembershipsReport() {
  const [statusFilter, setStatusFilter] = useState<
    "all" | "active" | "expired" | "cancelled"
  >("all");

  const { data, isLoading, error } = useQuery({
    queryKey: ["admin-memberships", statusFilter],
    queryFn: async () => {
      const result = await getAllMemberships({ data: { status: statusFilter } });
      return result;
    },
  });

  const handleExport = () => {
    if (data?.data) {
      const exportData = data.data.map((row) => ({
        "User Name": row.userName,
        Email: row.userEmail,
        "Membership Type": row.membershipType,
        "Start Date": formatDate(row.startDate),
        "End Date": formatDate(row.endDate),
        Status: row.status,
        Price: formatCurrency(row.priceCents),
        "Payment ID": row.paymentId || "-",
        "Created At": formatDate(row.createdAt),
      }));

      const filename = `memberships-report-${new Date().toISOString().split("T")[0]}.csv`;
      exportToCSV(exportData, filename);
    }
  };

  if (isLoading) {
    return (
      <div className="flex h-64 items-center justify-center">
        <div className="text-muted-foreground">Loading memberships...</div>
      </div>
    );
  }

  if (error || !data?.success) {
    const errorMessage = data?.errors?.[0]?.message || "Failed to load memberships";

    // Check if it's an admin access error
    if (errorMessage === "Admin access required") {
      return (
        <div className="border-destructive/50 bg-destructive/10 rounded-lg border p-6">
          <h3 className="text-destructive text-lg font-semibold">Access Denied</h3>
          <p className="text-muted-foreground mt-2">
            You do not have permission to view this report. Admin access is required.
          </p>
        </div>
      );
    }

    return (
      <div className="border-destructive/50 bg-destructive/10 rounded-lg border p-6">
        <h3 className="text-destructive text-lg font-semibold">Error Loading Report</h3>
        <p className="text-muted-foreground mt-2">{errorMessage}</p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-2xl font-bold tracking-tight">Memberships Report</h2>
          <p className="text-muted-foreground">
            View and export all membership data across the platform
          </p>
        </div>
        <div className="flex items-center gap-4">
          <select
            value={statusFilter}
            onChange={(e) =>
              setStatusFilter(
                e.target.value as "all" | "active" | "expired" | "cancelled",
              )
            }
            className="border-input bg-background ring-offset-background focus-visible:ring-ring rounded-md border px-3 py-2 text-sm focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:outline-none"
          >
            <option value="all">All Status</option>
            <option value="active">Active</option>
            <option value="expired">Expired</option>
            <option value="cancelled">Cancelled</option>
          </select>
        </div>
      </div>

      <DataTable
        columns={columns}
        data={data.data || []}
        pageSize={20}
        onExport={handleExport}
      />
    </div>
  );
}
</file>

<file path="src/features/profile/__tests__/profile.schemas.test.ts">
import { describe, expect, it } from "vitest";
import {
  emergencyContactSchema,
  privacySettingsSchema,
  profileInputSchema,
} from "../profile.schemas";

describe("Profile Schemas", () => {
  describe("emergencyContactSchema", () => {
    it("validates valid emergency contact with phone", () => {
      const validContact = {
        name: "John Doe",
        relationship: "Friend",
        phone: "123-456-7890",
      };

      const result = emergencyContactSchema.safeParse(validContact);
      expect(result.success).toBe(true);
    });

    it("validates valid emergency contact with email", () => {
      const validContact = {
        name: "Jane Doe",
        relationship: "Mother",
        email: "jane@example.com",
      };

      const result = emergencyContactSchema.safeParse(validContact);
      expect(result.success).toBe(true);
    });

    it("validates valid emergency contact with both phone and email", () => {
      const validContact = {
        name: "John Doe",
        relationship: "Friend",
        phone: "123-456-7890",
        email: "john@example.com",
      };

      const result = emergencyContactSchema.safeParse(validContact);
      expect(result.success).toBe(true);
    });

    it("fails when name is missing", () => {
      const invalidContact = {
        relationship: "Friend",
        phone: "123-456-7890",
      };

      const result = emergencyContactSchema.safeParse(invalidContact);
      expect(result.success).toBe(false);
    });

    it("fails when relationship is missing", () => {
      const invalidContact = {
        name: "John Doe",
        phone: "123-456-7890",
      };

      const result = emergencyContactSchema.safeParse(invalidContact);
      expect(result.success).toBe(false);
    });

    it("fails when neither phone nor email is provided", () => {
      const invalidContact = {
        name: "John Doe",
        relationship: "Friend",
      };

      const result = emergencyContactSchema.safeParse(invalidContact);
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.issues[0].message).toBe(
          "Please provide at least one contact method (phone or email)",
        );
      }
    });

    it("fails with invalid email format", () => {
      const invalidContact = {
        name: "John Doe",
        relationship: "Friend",
        email: "not-an-email",
      };

      const result = emergencyContactSchema.safeParse(invalidContact);
      expect(result.success).toBe(false);
    });
  });

  describe("privacySettingsSchema", () => {
    it("validates valid privacy settings", () => {
      const validSettings = {
        showEmail: true,
        showPhone: false,
        showBirthYear: true,
        allowTeamInvitations: true,
      };

      const result = privacySettingsSchema.safeParse(validSettings);
      expect(result.success).toBe(true);
    });

    it("fails when missing required fields", () => {
      const invalidSettings = {
        showEmail: true,
        showPhone: false,
        // Missing showBirthYear and allowTeamInvitations
      };

      const result = privacySettingsSchema.safeParse(invalidSettings);
      expect(result.success).toBe(false);
    });
  });

  describe("profileInputSchema", () => {
    it("validates valid profile input", () => {
      const validInput = {
        dateOfBirth: new Date("1990-01-01"),
        emergencyContact: {
          name: "John Doe",
          relationship: "Friend",
          phone: "123-456-7890",
        },
        gender: "Male",
        pronouns: "he/him",
        phone: "987-654-3210",
        privacySettings: {
          showEmail: true,
          showPhone: false,
          showBirthYear: true,
          allowTeamInvitations: true,
        },
      };

      const result = profileInputSchema.safeParse(validInput);
      expect(result.success).toBe(true);
    });

    it("validates profile input with only required fields", () => {
      const minimalInput = {
        dateOfBirth: new Date("1990-01-01"),
        emergencyContact: {
          name: "John Doe",
          relationship: "Friend",
          phone: "123-456-7890",
        },
      };

      const result = profileInputSchema.safeParse(minimalInput);
      expect(result.success).toBe(true);
    });

    it("fails with age less than 13", () => {
      const tooYoung = new Date();
      tooYoung.setFullYear(tooYoung.getFullYear() - 10);

      const invalidInput = {
        dateOfBirth: tooYoung,
        emergencyContact: {
          name: "John Doe",
          relationship: "Parent",
          phone: "123-456-7890",
        },
      };

      const result = profileInputSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.issues[0].message).toBe(
          "You must be between 13 and 120 years old",
        );
      }
    });

    it("fails with age greater than 120", () => {
      const tooOld = new Date("1800-01-01");

      const invalidInput = {
        dateOfBirth: tooOld,
        emergencyContact: {
          name: "John Doe",
          relationship: "Descendant",
          phone: "123-456-7890",
        },
      };

      const result = profileInputSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.issues[0].message).toBe(
          "You must be between 13 and 120 years old",
        );
      }
    });

    it("fails with invalid emergency contact", () => {
      const invalidInput = {
        dateOfBirth: new Date("1990-01-01"),
        emergencyContact: {
          name: "John Doe",
          relationship: "Friend",
          // Missing phone and email
        },
      };

      const result = profileInputSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });
  });
});
</file>

<file path="src/features/profile/hooks/useProfileFormReducer.ts">
import { useReducer } from "react";
import type { ProfileInputType } from "~/features/profile/profile.schemas";

export type StepId = "personal" | "emergency" | "privacy";

interface ProfileFormState {
  currentStep: StepId;
  isSubmitting: boolean;
  error: string | null;
  formData: ProfileInputType;
  emergencyContactStarted: boolean;
}

type ProfileFormAction =
  | { type: "SET_STEP"; step: StepId }
  | { type: "SET_SUBMITTING"; isSubmitting: boolean }
  | { type: "SET_ERROR"; error: string | null }
  | { type: "UPDATE_FORM_DATA"; data: Partial<ProfileInputType> }
  | { type: "SET_EMERGENCY_STARTED"; started: boolean }
  | { type: "RESET_FORM" }
  | { type: "SUBMIT_START" }
  | { type: "SUBMIT_SUCCESS" }
  | { type: "SUBMIT_ERROR"; error: string };

const initialState: ProfileFormState = {
  currentStep: "personal",
  isSubmitting: false,
  error: null,
  formData: {
    dateOfBirth: new Date(),
    gender: "",
    pronouns: "",
    phone: "",
    emergencyContact: undefined,
    privacySettings: {
      showEmail: false,
      showPhone: false,
      showBirthYear: false,
      allowTeamInvitations: true,
    },
  },
  emergencyContactStarted: false,
};

function profileFormReducer(
  state: ProfileFormState,
  action: ProfileFormAction,
): ProfileFormState {
  switch (action.type) {
    case "SET_STEP":
      return { ...state, currentStep: action.step, error: null };

    case "SET_SUBMITTING":
      return { ...state, isSubmitting: action.isSubmitting };

    case "SET_ERROR":
      return { ...state, error: action.error };

    case "UPDATE_FORM_DATA":
      return {
        ...state,
        formData: { ...state.formData, ...action.data },
      };

    case "SET_EMERGENCY_STARTED":
      return { ...state, emergencyContactStarted: action.started };

    case "RESET_FORM":
      return initialState;

    case "SUBMIT_START":
      return { ...state, isSubmitting: true, error: null };

    case "SUBMIT_SUCCESS":
      return { ...state, isSubmitting: false, error: null };

    case "SUBMIT_ERROR":
      return { ...state, isSubmitting: false, error: action.error };

    default:
      return state;
  }
}

/**
 * Custom hook for managing profile form state with a reducer
 * Groups related state together and provides consistent update patterns
 */
export function useProfileFormReducer() {
  const [state, dispatch] = useReducer(profileFormReducer, initialState);

  return {
    state,
    dispatch,
    // Convenience methods
    setStep: (step: StepId) => dispatch({ type: "SET_STEP", step }),
    updateFormData: (data: Partial<ProfileInputType>) =>
      dispatch({ type: "UPDATE_FORM_DATA", data }),
    setEmergencyStarted: (started: boolean) =>
      dispatch({ type: "SET_EMERGENCY_STARTED", started }),
    submitStart: () => dispatch({ type: "SUBMIT_START" }),
    submitSuccess: () => dispatch({ type: "SUBMIT_SUCCESS" }),
    submitError: (error: string) => dispatch({ type: "SUBMIT_ERROR", error }),
    resetForm: () => dispatch({ type: "RESET_FORM" }),
  };
}
</file>

<file path="src/features/profile/index.ts">
export { CompleteProfileForm } from "./components/complete-profile-form-simple";
export { ProfileView } from "./components/profile-view";
export * from "./profile-guard";
export * from "./profile.mutations";
export * from "./profile.queries";
export * from "./profile.schemas";
export * from "./profile.types";
export * from "./profile.utils";
</file>

<file path="src/features/roles/__tests__/permission.service.test.ts">
import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";
import { isAnyAdmin, PermissionService, userHasRole } from "../permission.service";

// Mock the database
const mockDbInstance = {
  select: vi.fn().mockReturnThis(),
  from: vi.fn().mockReturnThis(),
  innerJoin: vi.fn().mockReturnThis(),
  where: vi.fn().mockReturnThis(),
  limit: vi.fn().mockResolvedValue([]),
};

vi.mock("~/db", () => ({
  db: vi.fn(() => mockDbInstance),
}));

describe("PermissionService", () => {
  beforeEach(() => {
    vi.clearAllMocks();
    // Reset the mock chain
    mockDbInstance.select.mockReturnThis();
    mockDbInstance.from.mockReturnThis();
    mockDbInstance.innerJoin.mockReturnThis();
    mockDbInstance.where.mockReturnThis();
    mockDbInstance.limit.mockResolvedValue([]);
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe("isGlobalAdmin", () => {
    it("should return true for Solstice Admin", async () => {
      const mockResult = [{ id: "role-1", name: "Solstice Admin" }];
      mockDbInstance.limit.mockResolvedValueOnce(mockResult);

      const result = await PermissionService.isGlobalAdmin("user-123");
      expect(result).toBe(true);
    });

    it("should return true for Quadball Canada Admin", async () => {
      const mockResult = [{ id: "role-2", name: "Quadball Canada Admin" }];
      mockDbInstance.limit.mockResolvedValueOnce(mockResult);

      const result = await PermissionService.isGlobalAdmin("user-123");
      expect(result).toBe(true);
    });

    it("should return false for non-admin users", async () => {
      mockDbInstance.limit.mockResolvedValueOnce([]);

      const result = await PermissionService.isGlobalAdmin("user-123");
      expect(result).toBe(false);
    });
  });

  describe("canManageTeam", () => {
    it("should return true for global admins", async () => {
      // Mock isGlobalAdmin to return true
      vi.spyOn(PermissionService, "isGlobalAdmin").mockResolvedValue(true);

      const result = await PermissionService.canManageTeam("user-123", "team-456");
      expect(result).toBe(true);
    });

    it("should return true for team-specific admin", async () => {
      // Mock isGlobalAdmin to return false
      vi.spyOn(PermissionService, "isGlobalAdmin").mockResolvedValue(false);

      // Mock team admin query
      const mockResult = [{ id: "role-3", name: "Team Admin", teamId: "team-456" }];
      mockDbInstance.limit.mockResolvedValueOnce(mockResult);

      const result = await PermissionService.canManageTeam("user-123", "team-456");
      expect(result).toBe(true);
    });

    it("should return false for non-admin users", async () => {
      vi.spyOn(PermissionService, "isGlobalAdmin").mockResolvedValue(false);
      mockDbInstance.limit.mockResolvedValueOnce([]);

      const result = await PermissionService.canManageTeam("user-123", "team-456");
      expect(result).toBe(false);
    });
  });

  describe("getUserRoles", () => {
    it("should return all roles for a user", async () => {
      const mockRoles = [
        {
          id: "ur-1",
          userId: "user-123",
          roleId: "role-1",
          teamId: null,
          eventId: null,
          assignedBy: "admin-123",
          assignedAt: new Date(),
          expiresAt: null,
          notes: null,
          role: {
            id: "role-1",
            name: "Solstice Admin",
            description: "Platform admin",
            permissions: { "*": true },
          },
        },
      ];

      // Mock the where method to return the roles
      mockDbInstance.where.mockResolvedValueOnce(mockRoles);

      const result = await PermissionService.getUserRoles("user-123");
      expect(result).toEqual(mockRoles);
    });
  });
});

describe("Client-side helpers", () => {
  describe("userHasRole", () => {
    const mockUser = {
      roles: [
        {
          role: { name: "Solstice Admin" },
          teamId: null,
          eventId: null,
        },
        {
          role: { name: "Team Admin" },
          teamId: "team-123",
          eventId: null,
        },
      ],
    };

    it("should return true when user has global role", () => {
      expect(userHasRole(mockUser, "Solstice Admin")).toBe(true);
    });

    it("should return true when user has team-specific role", () => {
      expect(userHasRole(mockUser, "Team Admin", { teamId: "team-123" })).toBe(true);
    });

    it("should return false when user lacks role", () => {
      expect(userHasRole(mockUser, "Event Admin")).toBe(false);
    });

    it("should return false when user lacks scoped role", () => {
      expect(userHasRole(mockUser, "Team Admin", { teamId: "team-999" })).toBe(false);
    });

    it("should return false when user has no roles", () => {
      expect(userHasRole({ roles: [] }, "Solstice Admin")).toBe(false);
      expect(userHasRole({}, "Solstice Admin")).toBe(false);
    });
  });

  describe("isAnyAdmin", () => {
    it("should return true for users with admin roles", () => {
      const adminUser = {
        roles: [{ role: { name: "Team Admin" } }],
      };
      expect(isAnyAdmin(adminUser)).toBe(true);
    });

    it("should return false for users without admin roles", () => {
      const regularUser = {
        roles: [{ role: { name: "Player" } }],
      };
      expect(isAnyAdmin(regularUser)).toBe(false);
    });

    it("should return false for users with no roles", () => {
      expect(isAnyAdmin({ roles: [] })).toBe(false);
      expect(isAnyAdmin({})).toBe(false);
    });
  });
});
</file>

<file path="src/features/roles/components/__tests__/role-management-dashboard.test.tsx">
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { render, screen, waitFor } from "@testing-library/react";
import { beforeEach, describe, expect, it, vi } from "vitest";
import type { RoleManagementData } from "~/features/roles/roles.types";

vi.mock("~/features/roles/roles.queries", () => ({
  getRoleManagementData: vi.fn(),
  searchRoleEligibleUsers: vi.fn(),
}));

vi.mock("~/features/roles/roles.mutations", () => ({
  assignRoleToUser: vi.fn(async () => ({ success: true })),
  removeRoleAssignment: vi.fn(async () => ({ success: true })),
}));

vi.mock("sonner", () => ({
  toast: {
    success: vi.fn(),
    error: vi.fn(),
  },
}));

const { RoleManagementDashboard } = await import("../role-management-dashboard");
const { getRoleManagementData } = await import("~/features/roles/roles.queries");

const getRoleManagementDataMock = vi.mocked(getRoleManagementData);

function renderDashboard() {
  const client = new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
      },
    },
  });

  return render(
    <QueryClientProvider client={client}>
      <RoleManagementDashboard />
    </QueryClientProvider>,
  );
}

describe("RoleManagementDashboard", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("renders role summaries and assignments", async () => {
    const sampleData: RoleManagementData = {
      roles: [
        {
          id: "solstice-admin",
          name: "Solstice Admin",
          description: "Platform administrator",
          permissions: { "system:*": true },
          assignmentCount: 2,
          createdAt: new Date("2024-01-01"),
          updatedAt: new Date("2024-01-02"),
        },
      ],
      assignments: [
        {
          id: "assignment-1",
          roleId: "solstice-admin",
          roleName: "Solstice Admin",
          roleDescription: "Platform administrator",
          userId: "user-1",
          userName: "Admin User",
          userEmail: "admin@example.com",
          teamId: null,
          eventId: null,
          assignedBy: "assigner-1",
          assignedByName: "Seeder",
          assignedByEmail: "seeder@example.com",
          assignedAt: new Date("2024-02-01T12:00:00Z"),
          expiresAt: null,
          notes: "Seeded",
        },
      ],
    };

    getRoleManagementDataMock.mockResolvedValue({ success: true, data: sampleData });

    renderDashboard();

    await waitFor(() => {
      expect(screen.getAllByText("Solstice Admin").length).toBeGreaterThan(0);
    });

    expect(screen.getAllByText("Platform administrator").length).toBeGreaterThan(0);
    expect(screen.getByText("Admin User")).toBeInTheDocument();
    expect(screen.getByText("admin@example.com")).toBeInTheDocument();
    expect(screen.getByText("2 assigned")).toBeInTheDocument();
  });

  it("shows an error alert when loading fails", async () => {
    getRoleManagementDataMock.mockRejectedValue(new Error("boom"));

    renderDashboard();

    await waitFor(() => {
      expect(screen.getByText("Could not load roles")).toBeInTheDocument();
    });
  });
});
</file>

<file path="src/features/roles/components/role-management-dashboard.tsx">
import { useForm, useStore } from "@tanstack/react-form";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { Loader2, Search, ShieldCheck, UsersRound, XCircle } from "lucide-react";
import { useMemo, useState } from "react";
import { toast } from "sonner";
import { Alert, AlertDescription, AlertTitle } from "~/components/ui/alert";
import { Badge } from "~/components/ui/badge";
import { Button } from "~/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "~/components/ui/command";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "~/components/ui/dialog";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";
import { Popover, PopoverContent, PopoverTrigger } from "~/components/ui/popover";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "~/components/ui/table";
import { Textarea } from "~/components/ui/textarea";
import { assignRoleToUser, removeRoleAssignment } from "~/features/roles/roles.mutations";
import {
  getRoleManagementData,
  searchRoleEligibleUsers,
} from "~/features/roles/roles.queries";
import type {
  RoleAssignmentRow,
  RoleManagementData,
  RoleSummary,
  RoleUserSearchResult,
} from "~/features/roles/roles.types";

function useRoleManagementData() {
  return useQuery<RoleManagementData>({
    queryKey: ["role-management"],
    queryFn: async () => {
      const result = await getRoleManagementData();
      if (!result.success || !result.data) {
        throw new Error(
          result.errors?.[0]?.message || "Failed to load role management data",
        );
      }

      const normalized: RoleManagementData = {
        roles: result.data.roles.map((role) => ({
          ...role,
          assignmentCount: Number(role.assignmentCount),
        })),
        assignments: result.data.assignments.map((assignment) => ({
          ...assignment,
          assignedAt: new Date(assignment.assignedAt),
          expiresAt: assignment.expiresAt ? new Date(assignment.expiresAt) : null,
        })),
      };

      return normalized;
    },
  });
}

function useRoleAssignmentForm(
  roles: RoleSummary[],
  onSuccess: (assignment: RoleAssignmentRow) => void,
) {
  const form = useForm({
    defaultValues: {
      userId: "",
      roleId: "",
      teamId: "",
      eventId: "",
      notes: "",
      expiresAt: "",
    },
    onSubmit: async ({ value }) => {
      try {
        const result = await assignRoleToUser({
          data: {
            userId: value.userId,
            roleId: value.roleId,
            teamId: value.teamId || undefined,
            eventId: value.eventId || undefined,
            notes: value.notes || undefined,
            expiresAt: value.expiresAt
              ? new Date(value.expiresAt).toISOString()
              : undefined,
          },
        });

        if (!result.success || !result.data) {
          throw new Error(result.errors?.[0]?.message || "Failed to assign role");
        }

        onSuccess(result.data);
        form.reset();
        toast.success("Role assigned successfully");
      } catch (error) {
        const message = error instanceof Error ? error.message : "Failed to assign role";
        toast.error(message);
      }
    },
  });

  const selectedRoleId = useStore(form.store, (state) => state.values.roleId);
  const selectedRole = roles.find((role) => role.id === selectedRoleId) ?? null;

  const scopeType = useMemo(() => {
    if (!selectedRole) return "none" as const;
    if (selectedRole.name === "Team Admin") return "team" as const;
    if (selectedRole.name === "Event Admin") return "event" as const;
    return "none" as const;
  }, [selectedRole]);

  return { form, selectedRole, scopeType };
}

export function RoleManagementDashboard() {
  const queryClient = useQueryClient();
  const { data, isLoading, isError, error } = useRoleManagementData();
  const [assignDialogOpen, setAssignDialogOpen] = useState(false);
  const [userSearchTerm, setUserSearchTerm] = useState("");
  const [userSearchOpen, setUserSearchOpen] = useState(false);
  const [userResults, setUserResults] = useState<RoleUserSearchResult[]>([]);
  const [isSearchingUsers, setIsSearchingUsers] = useState(false);
  const [assignmentToRemove, setAssignmentToRemove] = useState<RoleAssignmentRow | null>(
    null,
  );

  const removeMutation = useMutation({
    mutationFn: removeRoleAssignment,
    onSuccess: (result) => {
      if (!result.success || !result.data) {
        toast.error(result.errors?.[0]?.message || "Failed to remove role assignment");
        return;
      }

      toast.success("Role assignment removed");
      queryClient.invalidateQueries({ queryKey: ["role-management"] });
    },
    onError: (mutationError) => {
      const message =
        mutationError instanceof Error
          ? mutationError.message
          : "Failed to remove role assignment";
      toast.error(message);
    },
    onSettled: () => {
      setAssignmentToRemove(null);
    },
  });

  const { form, scopeType } = useRoleAssignmentForm(data?.roles ?? [], () => {
    queryClient.invalidateQueries({ queryKey: ["role-management"] });
    setAssignDialogOpen(false);
    setUserSearchTerm("");
    setUserResults([]);
    setUserSearchOpen(false);
  });

  const handleDialogOpenChange = (open: boolean) => {
    setAssignDialogOpen(open);
    if (!open) {
      form.reset();
      setUserSearchTerm("");
      setUserResults([]);
      setUserSearchOpen(false);
    }
  };

  const roleOptions = useMemo(
    () =>
      (data?.roles ?? []).map((role) => ({
        value: role.id,
        label: role.name,
      })),
    [data?.roles],
  );

  const selectedUserId = useStore(form.store, (state) => state.values.userId);
  const selectedUser = useMemo(
    () => userResults.find((user) => user.id === selectedUserId) ?? null,
    [selectedUserId, userResults],
  );

  async function runUserSearch(term: string) {
    if (term.trim().length < 2) {
      setUserResults([]);
      return;
    }

    setIsSearchingUsers(true);
    try {
      const result = await searchRoleEligibleUsers({ data: { query: term.trim() } });
      if (result.success && result.data) {
        setUserResults(result.data);
      } else {
        toast.error(result.errors?.[0]?.message || "Failed to search users");
      }
    } catch (searchError) {
      const message =
        searchError instanceof Error ? searchError.message : "Failed to search users";
      toast.error(message);
    } finally {
      setIsSearchingUsers(false);
    }
  }

  function handleUserSearchChange(term: string) {
    setUserSearchTerm(term);
    if (term.trim().length >= 2) {
      void runUserSearch(term);
    } else {
      setUserResults([]);
    }
  }

  if (isLoading) {
    return (
      <div className="flex h-64 items-center justify-center">
        <div className="text-muted-foreground flex items-center gap-2">
          <Loader2 className="h-5 w-5 animate-spin" />
          Loading role management data...
        </div>
      </div>
    );
  }

  if (isError || !data) {
    return (
      <div className="container mx-auto p-6">
        <Alert variant="destructive">
          <AlertTitle>Could not load roles</AlertTitle>
          <AlertDescription>
            {error instanceof Error
              ? error.message
              : "Unknown error. Please try again later."}
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  const assignments = data.assignments;

  return (
    <div className="space-y-8">
      <section>
        <div className="mb-6 flex flex-col gap-4 lg:flex-row lg:items-center lg:justify-between">
          <div>
            <h1 className="text-3xl font-bold tracking-tight">Role Management</h1>
            <p className="text-muted-foreground mt-1">
              Assign and revoke administrator access across Solstice and teams.
            </p>
          </div>
          <Dialog open={assignDialogOpen} onOpenChange={handleDialogOpenChange}>
            <DialogTrigger asChild>
              <Button>
                <ShieldCheck className="mr-2 h-4 w-4" />
                Assign Role
              </Button>
            </DialogTrigger>
            <DialogContent className="sm:max-w-lg">
              <DialogHeader>
                <DialogTitle>Assign a Role</DialogTitle>
                <DialogDescription>
                  Search for a user and grant them a role. Scoped roles require either a
                  team or event context.
                </DialogDescription>
              </DialogHeader>

              <form
                className="space-y-5"
                onSubmit={(event) => {
                  event.preventDefault();
                  event.stopPropagation();
                  form.handleSubmit();
                }}
              >
                <form.Field
                  name="userId"
                  validators={{
                    onChange: ({ value }) => (!value ? "Select a user" : undefined),
                  }}
                >
                  {(field) => {
                    const selected =
                      userResults.find((user) => user.id === field.state.value) ??
                      selectedUser;

                    return (
                      <div className="space-y-2">
                        <Label>User</Label>
                        <Popover
                          open={userSearchOpen}
                          onOpenChange={(open) => setUserSearchOpen(open)}
                        >
                          <PopoverTrigger asChild>
                            <Button
                              type="button"
                              variant="outline"
                              role="combobox"
                              aria-expanded={userSearchOpen}
                              className="w-full justify-between"
                              disabled={form.state.isSubmitting}
                            >
                              {selected ? (
                                <span>
                                  {selected.name}
                                  <span className="text-muted-foreground ml-1 text-xs">
                                    ({selected.email})
                                  </span>
                                </span>
                              ) : (
                                <span className="text-muted-foreground">
                                  Search by name or email
                                </span>
                              )}
                              <Search className="ml-2 h-4 w-4 shrink-0 opacity-60" />
                            </Button>
                          </PopoverTrigger>
                          <PopoverContent
                            className="w-[--radix-popover-trigger-width] p-0"
                            align="start"
                          >
                            <Command shouldFilter={false}>
                              <CommandInput
                                placeholder="Search users..."
                                value={userSearchTerm}
                                onValueChange={handleUserSearchChange}
                              />
                              <CommandListWithResults
                                isSearching={isSearchingUsers}
                                results={userResults}
                                onSelect={(user) => {
                                  field.handleChange(user.id);
                                  setUserResults([
                                    user,
                                    ...userResults.filter((item) => item.id !== user.id),
                                  ]);
                                  setUserSearchOpen(false);
                                }}
                              />
                            </Command>
                          </PopoverContent>
                        </Popover>
                        {field.state.meta.isTouched &&
                          field.state.meta.errors.length > 0 && (
                            <p className="text-destructive text-sm font-medium">
                              {field.state.meta.errors.join(", ")}
                            </p>
                          )}
                      </div>
                    );
                  }}
                </form.Field>

                <form.Field
                  name="roleId"
                  validators={{
                    onChange: ({ value }) => (!value ? "Select a role" : undefined),
                  }}
                >
                  {(field) => (
                    <div className="space-y-2">
                      <Label htmlFor="role-select">Role</Label>
                      <select
                        id="role-select"
                        className="border-input focus-visible:border-ring focus-visible:ring-ring/50 flex h-10 w-full rounded-md border bg-transparent px-3 py-2 text-sm outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50"
                        value={field.state.value}
                        onChange={(event) => field.handleChange(event.target.value)}
                        disabled={form.state.isSubmitting}
                      >
                        <option value="" disabled>
                          Select a role
                        </option>
                        {roleOptions.map((role) => (
                          <option key={role.value} value={role.value}>
                            {role.label}
                          </option>
                        ))}
                      </select>
                      {field.state.meta.isTouched &&
                        field.state.meta.errors.length > 0 && (
                          <p className="text-destructive text-sm font-medium">
                            {field.state.meta.errors.join(", ")}
                          </p>
                        )}
                    </div>
                  )}
                </form.Field>

                <div className="grid gap-4 md:grid-cols-2">
                  <form.Field name="teamId">
                    {(field) => (
                      <div className="space-y-2">
                        <Label htmlFor="role-team">Team Scope</Label>
                        <Input
                          id="role-team"
                          placeholder="Team ID"
                          value={field.state.value}
                          onChange={(event) => field.handleChange(event.target.value)}
                          disabled={form.state.isSubmitting || scopeType !== "team"}
                        />
                        <FieldHint>
                          Use for assigning <strong>Team Admin</strong>. Leave blank for
                          global roles.
                        </FieldHint>
                      </div>
                    )}
                  </form.Field>

                  <form.Field name="eventId">
                    {(field) => (
                      <div className="space-y-2">
                        <Label htmlFor="role-event">Event Scope</Label>
                        <Input
                          id="role-event"
                          placeholder="Event ID"
                          value={field.state.value}
                          onChange={(event) => field.handleChange(event.target.value)}
                          disabled={form.state.isSubmitting || scopeType !== "event"}
                        />
                        <FieldHint>
                          Use for assigning <strong>Event Admin</strong>. Leave blank for
                          global roles.
                        </FieldHint>
                      </div>
                    )}
                  </form.Field>
                </div>

                <form.Field name="expiresAt">
                  {(field) => (
                    <div className="space-y-2">
                      <Label htmlFor="role-expiration">Expiration</Label>
                      <Input
                        id="role-expiration"
                        type="datetime-local"
                        value={field.state.value}
                        onChange={(event) => field.handleChange(event.target.value)}
                        disabled={form.state.isSubmitting}
                      />
                      <FieldHint>Optional â leave blank for no expiration.</FieldHint>
                    </div>
                  )}
                </form.Field>

                <form.Field name="notes">
                  {(field) => (
                    <div className="space-y-2">
                      <Label htmlFor="role-notes">Notes</Label>
                      <Textarea
                        id="role-notes"
                        placeholder="Add context for this assignment (optional)"
                        value={field.state.value}
                        onChange={(event) => field.handleChange(event.target.value)}
                        disabled={form.state.isSubmitting}
                      />
                    </div>
                  )}
                </form.Field>

                <DialogFooter>
                  <Button type="submit" disabled={form.state.isSubmitting}>
                    {form.state.isSubmitting && (
                      <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    )}
                    Assign Role
                  </Button>
                </DialogFooter>
              </form>
            </DialogContent>
          </Dialog>
        </div>

        <RoleSummaryGrid roles={data.roles} />
      </section>

      <section>
        <Card>
          <CardHeader>
            <CardTitle>Current Role Assignments</CardTitle>
            <CardDescription>
              Audit log of who has access, when it was granted, and by whom.
            </CardDescription>
          </CardHeader>
          <CardContent className="overflow-x-auto">
            {assignments.length === 0 ? (
              <div className="text-muted-foreground flex items-center gap-2 rounded-md border border-dashed p-6 text-sm">
                <UsersRound className="h-4 w-4" />
                No role assignments yet. Use âAssign Roleâ to get started.
              </div>
            ) : (
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>User</TableHead>
                    <TableHead>Role</TableHead>
                    <TableHead>Scope</TableHead>
                    <TableHead>Assigned By</TableHead>
                    <TableHead>Assigned At</TableHead>
                    <TableHead>Expires</TableHead>
                    <TableHead>Notes</TableHead>
                    <TableHead className="w-[120px] text-right">Actions</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {assignments.map((assignment) => (
                    <TableRow key={assignment.id}>
                      <TableCell>
                        <div className="flex flex-col">
                          <span className="font-medium">{assignment.userName}</span>
                          <span className="text-muted-foreground text-xs">
                            {assignment.userEmail}
                          </span>
                        </div>
                      </TableCell>
                      <TableCell>
                        <Badge variant="secondary">{assignment.roleName}</Badge>
                        {assignment.roleDescription && (
                          <p className="text-muted-foreground mt-1 text-xs">
                            {assignment.roleDescription}
                          </p>
                        )}
                      </TableCell>
                      <TableCell>
                        {assignment.teamId ? (
                          <Badge variant="outline">Team: {assignment.teamId}</Badge>
                        ) : assignment.eventId ? (
                          <Badge variant="outline">Event: {assignment.eventId}</Badge>
                        ) : (
                          <span className="text-muted-foreground text-xs">Global</span>
                        )}
                      </TableCell>
                      <TableCell>
                        {assignment.assignedByName ? (
                          <div className="flex flex-col">
                            <span>{assignment.assignedByName}</span>
                            <span className="text-muted-foreground text-xs">
                              {assignment.assignedByEmail}
                            </span>
                          </div>
                        ) : (
                          <span className="text-muted-foreground text-xs">System</span>
                        )}
                      </TableCell>
                      <TableCell>
                        <time dateTime={assignment.assignedAt.toISOString()}>
                          {new Date(assignment.assignedAt).toLocaleString()}
                        </time>
                      </TableCell>
                      <TableCell>
                        {assignment.expiresAt ? (
                          <time dateTime={assignment.expiresAt.toISOString()}>
                            {new Date(assignment.expiresAt).toLocaleString()}
                          </time>
                        ) : (
                          <span className="text-muted-foreground text-xs">
                            No expiration
                          </span>
                        )}
                      </TableCell>
                      <TableCell className="max-w-xs text-sm whitespace-pre-line">
                        {assignment.notes || (
                          <span className="text-muted-foreground">â</span>
                        )}
                      </TableCell>
                      <TableCell className="text-right">
                        <Dialog
                          open={assignmentToRemove?.id === assignment.id}
                          onOpenChange={(open) =>
                            open
                              ? setAssignmentToRemove(assignment)
                              : setAssignmentToRemove(null)
                          }
                        >
                          <DialogTrigger asChild>
                            <Button variant="destructive" size="sm">
                              <XCircle className="mr-2 h-4 w-4" />
                              Remove
                            </Button>
                          </DialogTrigger>
                          <DialogContent>
                            <DialogHeader>
                              <DialogTitle>Remove role assignment</DialogTitle>
                              <DialogDescription>
                                This will revoke â{assignment.roleName}â from{" "}
                                {assignment.userName}. This action cannot be undone.
                              </DialogDescription>
                            </DialogHeader>
                            <DialogFooter className="flex items-center justify-end gap-2">
                              <Button
                                variant="outline"
                                onClick={() => setAssignmentToRemove(null)}
                              >
                                Cancel
                              </Button>
                              <Button
                                variant="destructive"
                                disabled={removeMutation.isPending}
                                onClick={() => {
                                  setAssignmentToRemove(assignment);
                                  removeMutation.mutate({
                                    data: { assignmentId: assignment.id },
                                  });
                                }}
                              >
                                {removeMutation.isPending && (
                                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                                )}
                                Remove access
                              </Button>
                            </DialogFooter>
                          </DialogContent>
                        </Dialog>
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            )}
          </CardContent>
        </Card>
      </section>
    </div>
  );
}

function RoleSummaryGrid({ roles }: { roles: RoleSummary[] }) {
  if (!roles.length) return null;

  return (
    <div className="grid gap-4 md:grid-cols-2 xl:grid-cols-3">
      {roles.map((role) => (
        <Card key={role.id}>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">{role.name}</CardTitle>
            <Badge variant="outline">{role.assignmentCount} assigned</Badge>
          </CardHeader>
          <CardContent className="space-y-3 text-sm">
            <p className="text-muted-foreground text-sm">
              {role.description || "No description provided."}
            </p>
            <div>
              <p className="text-muted-foreground mb-1 text-xs uppercase">Permissions</p>
              <div className="flex flex-wrap gap-2">
                {Object.keys(role.permissions).length === 0 ? (
                  <Badge variant="secondary">None configured</Badge>
                ) : (
                  Object.keys(role.permissions)
                    .filter((key) => role.permissions[key])
                    .map((key) => (
                      <Badge key={key} variant="secondary">
                        {key}
                      </Badge>
                    ))
                )}
              </div>
            </div>
          </CardContent>
        </Card>
      ))}
    </div>
  );
}

function FieldHint({ children }: { children: React.ReactNode }) {
  return <p className="text-muted-foreground text-xs">{children}</p>;
}

function CommandListWithResults({
  isSearching,
  results,
  onSelect,
}: {
  isSearching: boolean;
  results: RoleUserSearchResult[];
  onSelect: (result: RoleUserSearchResult) => void;
}) {
  return (
    <CommandList className="relative">
      <CommandEmpty>
        {isSearching ? (
          <div className="text-muted-foreground flex items-center gap-2 text-sm">
            <Loader2 className="h-4 w-4 animate-spin" /> Searching users...
          </div>
        ) : (
          "No users found."
        )}
      </CommandEmpty>
      <CommandGroup>
        {results.map((result) => (
          <CommandItem
            key={result.id}
            value={`${result.name} ${result.email}`}
            onSelect={() => onSelect(result)}
          >
            <div className="flex flex-col">
              <span className="font-medium">{result.name}</span>
              <span className="text-muted-foreground text-xs">{result.email}</span>
              {result.roleNames.length > 0 && (
                <span className="text-muted-foreground text-[11px]">
                  Roles: {result.roleNames.join(", ")}
                </span>
              )}
            </div>
          </CommandItem>
        ))}
      </CommandGroup>
    </CommandList>
  );
}
</file>

<file path="src/features/roles/roles.types.ts">
export type RoleOperationErrorCode =
  | "VALIDATION_ERROR"
  | "UNAUTHORIZED"
  | "NOT_FOUND"
  | "DATABASE_ERROR";

export interface RoleOperationError {
  code: RoleOperationErrorCode;
  message: string;
}

export interface RoleOperationResult<T> {
  success: boolean;
  data?: T;
  errors?: RoleOperationError[];
}

export interface RoleSummary {
  id: string;
  name: string;
  description: string | null;
  permissions: Record<string, boolean>;
  assignmentCount: number;
  createdAt: Date;
  updatedAt: Date;
}

export interface RoleAssignmentRow {
  id: string;
  roleId: string;
  roleName: string;
  roleDescription: string | null;
  userId: string;
  userName: string;
  userEmail: string;
  teamId: string | null;
  eventId: string | null;
  assignedBy: string;
  assignedByName: string | null;
  assignedByEmail: string | null;
  assignedAt: Date;
  expiresAt: Date | null;
  notes: string | null;
}

export interface RoleManagementData {
  roles: RoleSummary[];
  assignments: RoleAssignmentRow[];
}

export interface RoleUserSearchResult {
  id: string;
  name: string;
  email: string;
  roleNames: string[];
}
</file>

<file path="src/features/settings/index.ts">
export * from "./settings.mutations";
export * from "./settings.queries";
export * from "./settings.schemas";
export * from "./settings.types";
</file>

<file path="src/features/settings/settings.types.ts">
import type { z } from "zod";
import type {
  changePasswordInputSchema,
  revokeSessionInputSchema,
  unlinkAccountInputSchema,
} from "./settings.schemas";

export type ChangePasswordInput = z.infer<typeof changePasswordInputSchema>;
export type RevokeSessionInput = z.infer<typeof revokeSessionInputSchema>;
export type UnlinkAccountInput = z.infer<typeof unlinkAccountInputSchema>;

export interface SessionInfo {
  id: string;
  token: string;
  createdAt: string;
  updatedAt: string;
  expiresAt: string;
  ipAddress?: string | null;
  userAgent?: string | null;
  isCurrent: boolean;
}

export interface SessionsOverview {
  sessions: SessionInfo[];
  currentSessionToken: string | null;
}

export interface ConnectedAccount {
  id: string;
  providerId: string;
  accountId: string;
  createdAt: string;
  updatedAt: string;
  scopes: string[];
}

export interface LinkedAccountsOverview {
  accounts: ConnectedAccount[];
}

export interface ApiResult<T> {
  success: boolean;
  data?: T;
  errors?: { code: string; message: string }[];
}
</file>

<file path="src/features/teams/components/__tests__/team-invitations.test.tsx">
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { render, screen, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { beforeEach, describe, expect, it, vi } from "vitest";
import type { PendingTeamInvite } from "~/features/teams/teams.queries";
import { TeamInvitationsSection } from "../team-invitations";

const acceptTeamInviteMock = vi.fn();
const declineTeamInviteMock = vi.fn();

vi.mock("~/features/teams/teams.mutations", () => ({
  acceptTeamInvite: (input: unknown) => acceptTeamInviteMock(input),
  declineTeamInvite: (input: unknown) => declineTeamInviteMock(input),
}));

describe("TeamInvitationsSection", () => {
  beforeEach(() => {
    acceptTeamInviteMock.mockResolvedValue({});
    declineTeamInviteMock.mockResolvedValue({});
    acceptTeamInviteMock.mockClear();
    declineTeamInviteMock.mockClear();
  });

  const baseInvite: PendingTeamInvite = {
    membership: {
      id: "invite-1",
      teamId: "team-1",
      role: "player",
      invitedAt: new Date("2025-01-01T00:00:00Z"),
      requestedAt: null,
      invitedBy: "captain-1",
    },
    team: {
      id: "team-1",
      name: "Test Thunder",
      slug: "test-thunder",
    },
    inviter: {
      id: "captain-1",
      name: "Captain Casey",
      email: "captain@example.com",
    },
  };

  function renderComponent(invites: PendingTeamInvite[]) {
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: { retry: false },
        mutations: { retry: false },
      },
    });

    return render(
      <QueryClientProvider client={queryClient}>
        <TeamInvitationsSection invites={invites} />
      </QueryClientProvider>,
    );
  }

  it("renders nothing when there are no invites", () => {
    const { container } = renderComponent([]);
    expect(container).toBeEmptyDOMElement();
  });

  it("allows accepting an invitation", async () => {
    renderComponent([baseInvite]);
    const user = userEvent.setup();

    await user.click(screen.getByRole("button", { name: /accept/i }));

    await waitFor(() => {
      expect(acceptTeamInviteMock).toHaveBeenCalledWith({ data: { teamId: "team-1" } });
    });

    expect(await screen.findByText(/Invitation accepted/i)).toBeInTheDocument();
  });

  it("allows declining an invitation", async () => {
    renderComponent([baseInvite]);
    const user = userEvent.setup();

    await user.click(screen.getByRole("button", { name: /decline/i }));

    await waitFor(() => {
      expect(declineTeamInviteMock).toHaveBeenCalledWith({ data: { teamId: "team-1" } });
    });

    expect(await screen.findByText(/Invitation declined/i)).toBeInTheDocument();
  });
});
</file>

<file path="src/features/teams/teams.db-types.ts">
/**
 * Type definitions for teams database fields
 */

export interface TeamSocialLinks {
  facebook?: string;
  twitter?: string;
  instagram?: string;
  discord?: string;
  youtube?: string;
  [key: string]: string | undefined;
}
</file>

<file path="src/routes/auth/login.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { z } from "zod";
import LoginForm from "~/features/auth/components/login";

const searchSchema = z.object({
  redirect: z.string().optional(),
});

export const Route = createFileRoute("/auth/login")({
  validateSearch: (search) => searchSchema.parse(search),
  component: LoginRoute,
});

function LoginRoute() {
  const { redirect } = Route.useSearch();

  return <LoginForm redirectPath={redirect} />;
}
</file>

<file path="src/routes/dashboard/admin/roles.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { RoleManagementDashboard } from "~/features/roles/components/role-management-dashboard";

export const Route = createFileRoute("/dashboard/admin/roles")({
  component: AdminRolesPage,
});

function AdminRolesPage() {
  return (
    <div className="container mx-auto space-y-8 p-6">
      <RoleManagementDashboard />
    </div>
  );
}
</file>

<file path="src/routes/dashboard/admin/route.tsx">
import { createFileRoute, Outlet, redirect } from "@tanstack/react-router";
import { isAdminClient } from "~/lib/auth/utils/admin-check";

export const Route = createFileRoute("/dashboard/admin")({
  beforeLoad: async ({ context, location }) => {
    const { user } = context;

    if (!user) {
      throw redirect({ to: "/auth/login", search: { redirect: location.href } });
    }

    if (!isAdminClient(user)) {
      throw redirect({ to: "/dashboard/forbidden", search: { from: location.href } });
    }
  },
  component: AdminSectionLayout,
});

function AdminSectionLayout() {
  return <Outlet />;
}
</file>

<file path="src/routes/dashboard/events/$slug.register.tsx">
import type { CheckedState } from "@radix-ui/react-checkbox";
import { useMutation, useQuery } from "@tanstack/react-query";
import {
  createFileRoute,
  Link,
  redirect,
  useNavigate,
  useRouteContext,
} from "@tanstack/react-router";
import { format } from "date-fns";
import {
  ArrowLeftIcon,
  CalendarIcon,
  CheckCircleIcon,
  MapPinIcon,
  UsersIcon,
} from "lucide-react";
import { useMemo, useState } from "react";
import { toast } from "sonner";
import { Alert, AlertDescription, AlertTitle } from "~/components/ui/alert";
import { Badge } from "~/components/ui/badge";
import { Button } from "~/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";
import { Checkbox } from "~/components/ui/checkbox";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";
import { RadioGroup, RadioGroupItem } from "~/components/ui/radio-group";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";
import { Separator } from "~/components/ui/separator";
import { Skeleton } from "~/components/ui/skeleton";
import { Textarea } from "~/components/ui/textarea";
import { registerForEvent } from "~/features/events/events.mutations";
import { checkEventRegistration, getEvent } from "~/features/events/events.queries";
import type {
  EventOperationResult,
  EventRegistrationResultPayload,
  EventWithDetails,
} from "~/features/events/events.types";
import { getUserTeams } from "~/features/teams/teams.queries";
import { callServerFn, unwrapServerFnResult } from "~/lib/server/fn-utils";

type EmergencyContact = {
  name: string;
  phone: string;
  relationship: string;
};

type UserTeamEntry = {
  team: {
    id: string;
    name: string;
    slug: string;
  };
  membership: {
    role: string | null;
  } | null;
  memberCount: number;
};

export const Route = createFileRoute("/dashboard/events/$slug/register")({
  beforeLoad: async ({ context, location }) => {
    if (!context.user) {
      throw redirect({
        to: "/auth/login",
        search: { redirect: location.pathname },
      });
    }
  },
  component: EventRegistrationPage,
});

function EventRegistrationPage() {
  const { slug } = Route.useParams();
  const { user } = useRouteContext({ from: "/dashboard/events/$slug/register" });
  const navigate = useNavigate();
  const [registrationType, setRegistrationType] = useState<"team" | "individual">(
    "individual",
  );

  const [selectedTeamId, setSelectedTeamId] = useState<string>("");
  const [additionalInfo, setAdditionalInfo] = useState("");
  const [emergencyContact, setEmergencyContact] = useState<EmergencyContact>({
    name: "",
    phone: "",
    relationship: "",
  });
  const [termsAccepted, setTermsAccepted] = useState(false);
  const [waiverAccepted, setWaiverAccepted] = useState(false);
  const [paymentMethod, setPaymentMethod] = useState<"square" | "etransfer">("square");
  const [confirmation, setConfirmation] = useState<
    EventRegistrationResultPayload["payment"] | null
  >(null);

  const { data: eventResult, isLoading: eventLoading } = useQuery<
    EventOperationResult<EventWithDetails>,
    Error
  >({
    queryKey: ["event", slug],
    queryFn: () => callServerFn(getEvent, { slug }),
  });

  const eventData = eventResult?.success ? eventResult.data : null;

  // Compute effective registration type based on event's allowed types
  // This prevents wrong fee calculation for team-only or individual-only events
  const effectiveRegistrationType = useMemo(() => {
    if (!eventData) return registrationType;
    if (eventData.registrationType === "team") return "team";
    if (eventData.registrationType === "individual") return "individual";
    return registrationType; // "both" - user choice
  }, [eventData, registrationType]);

  const { data: registrationStatus, isLoading: registrationLoading } = useQuery<
    { isRegistered: boolean } | undefined,
    Error
  >({
    // Include user.id in key for cache invalidation when user changes
    queryKey: ["event-registration", eventData?.id, user?.id],
    queryFn: () =>
      callServerFn(checkEventRegistration, {
        eventId: eventData!.id,
        // userId is now inferred from session on server
      }),
    enabled: Boolean(eventData?.id && user?.id),
  });

  const userProfile = user;

  const { data: userTeams } = useQuery<UserTeamEntry[] | undefined, Error>({
    queryKey: ["user-teams", user?.id],
    queryFn: () => callServerFn(getUserTeams, { includeInactive: false }),
    enabled: Boolean(user?.id && effectiveRegistrationType === "team"),
  });

  const registrationMutation = useMutation<
    EventOperationResult<EventRegistrationResultPayload>,
    Error,
    {
      eventId: string;
      teamId?: string;
      division?: string;
      notes?: string;
      roster?: { emergencyContact?: EmergencyContact };
      paymentMethod: "square" | "etransfer";
    }
  >({
    mutationFn: (payload) =>
      unwrapServerFnResult(callServerFn(registerForEvent, payload)),
    onSuccess: (result) => {
      if (!result.success) {
        toast.error(result.errors?.[0]?.message || "Registration failed");
        return;
      }

      const payment = result.data.payment;

      if (payment?.method === "square") {
        toast.success("Redirecting to Square checkout...");
        window.location.assign(payment.checkoutUrl);
        return;
      }

      if (payment?.method === "etransfer") {
        setConfirmation(payment);
        toast.success(
          "Registration submitted! Follow the e-transfer instructions below.",
        );
        return;
      }

      toast.success("Registration completed!");
      navigate({ to: "/dashboard/events" });
    },
    onError: (error) => {
      toast.error("An error occurred during registration");
      console.error(error);
    },
  });

  const fee = useMemo(() => {
    if (!eventData) {
      return {
        original: 0,
        discounted: 0,
        hasDiscount: false,
        discountPercentage: 0,
      };
    }

    // Use effectiveRegistrationType to calculate correct fee for team-only/individual-only events
    const baseFeeCents =
      effectiveRegistrationType === "team"
        ? (eventData.teamRegistrationFee ?? 0)
        : (eventData.individualRegistrationFee ?? 0);

    const baseFee = baseFeeCents / 100;

    if (eventData.earlyBirdDiscount && eventData.earlyBirdDeadline) {
      const deadline = new Date(eventData.earlyBirdDeadline);
      if (new Date() < deadline) {
        const discountAmount = baseFee * (eventData.earlyBirdDiscount / 100);
        return {
          original: baseFee,
          discounted: baseFee - discountAmount,
          hasDiscount: true,
          discountPercentage: eventData.earlyBirdDiscount,
        };
      }
    }

    return {
      original: baseFee,
      discounted: baseFee,
      hasDiscount: false,
      discountPercentage: 0,
    };
  }, [eventData, effectiveRegistrationType]);

  const requiresPayment = fee.discounted > 0;

  if (eventLoading || registrationLoading) {
    return <RegistrationSkeleton />;
  }

  if (!eventData) {
    return (
      <div className="container mx-auto p-6">
        <Alert variant="destructive">
          <AlertTitle>Event Not Found</AlertTitle>
          <AlertDescription>
            The event you're trying to register for doesn't exist.
          </AlertDescription>
        </Alert>
        <Button asChild className="mt-4">
          <Link to="/dashboard/events">
            <ArrowLeftIcon className="mr-2 h-4 w-4" />
            Back to Events
          </Link>
        </Button>
      </div>
    );
  }

  const event = eventData;
  const effectivePaymentMethod =
    event.allowEtransfer && requiresPayment ? paymentMethod : "square";
  const submitDisabled =
    registrationMutation.isPending || confirmation?.method === "etransfer";

  const handleSubmit = () => {
    if (confirmation?.method === "etransfer") {
      toast.info("You've already submitted this registration.");
      return;
    }

    if (!termsAccepted || !waiverAccepted) {
      toast.error("Please accept all terms and conditions");
      return;
    }

    if (effectiveRegistrationType === "team" && !selectedTeamId) {
      toast.error("Please select a team");
      return;
    }

    const payload: {
      eventId: string;
      teamId?: string;
      notes?: string;
      roster?: { emergencyContact?: EmergencyContact };
      paymentMethod: "square" | "etransfer";
    } = {
      eventId: event.id,
      paymentMethod: effectivePaymentMethod,
    };

    if (effectiveRegistrationType === "team" && selectedTeamId) {
      payload.teamId = selectedTeamId;
    }

    if (additionalInfo.trim().length > 0) {
      payload.notes = additionalInfo.trim();
    }

    if (emergencyContact.name.trim().length > 0) {
      payload.roster = { emergencyContact };
    }

    setConfirmation(null);
    registrationMutation.mutate(payload);
  };

  if (registrationStatus?.isRegistered) {
    return (
      <div className="container mx-auto p-6">
        <Alert>
          <CheckCircleIcon className="h-4 w-4" />
          <AlertTitle>Already Registered</AlertTitle>
          <AlertDescription>You are already registered for this event.</AlertDescription>
        </Alert>
        <div className="mt-4 flex gap-2">
          <Button asChild>
            <Link to="/dashboard/events/$slug" params={{ slug }}>
              View Event Details
            </Link>
          </Button>
          <Button asChild variant="outline">
            <Link to="/dashboard/events">Back to Events</Link>
          </Button>
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto space-y-6 p-6">
      <div className="flex items-center gap-4">
        <Button asChild variant="ghost" size="sm">
          <Link to="/dashboard/events/$slug" params={{ slug }}>
            <ArrowLeftIcon className="mr-2 h-4 w-4" />
            Back to Event Details
          </Link>
        </Button>
      </div>

      <div className="grid gap-6 lg:grid-cols-3">
        <div className="space-y-6 lg:col-span-2">
          <Card>
            <CardHeader>
              <CardTitle>Register for {event.name}</CardTitle>
              <CardDescription>
                Complete the form below to register for this event
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-6">
              {(event.registrationType === "individual" ||
                event.registrationType === "team" ||
                event.registrationType === "both") && (
                <div className="space-y-3">
                  <Label>Registration Type</Label>
                  <RadioGroup
                    value={effectiveRegistrationType}
                    onValueChange={(value) =>
                      setRegistrationType(value as "team" | "individual")
                    }
                    disabled={event.registrationType !== "both"}
                  >
                    {(event.registrationType === "individual" ||
                      event.registrationType === "both") && (
                      <div className="flex items-start space-x-2">
                        <RadioGroupItem value="individual" id="individual" />
                        <div className="grid gap-1.5 leading-none">
                          <Label
                            htmlFor="individual"
                            className="cursor-pointer font-normal"
                          >
                            Individual Registration
                            <span className="text-muted-foreground ml-2 text-sm">
                              ${fee.discounted.toFixed(2)}
                              {fee.hasDiscount && (
                                <span className="ml-1 line-through">
                                  ${fee.original.toFixed(2)}
                                </span>
                              )}
                            </span>
                          </Label>
                          <p className="text-muted-foreground text-sm">
                            Register as an individual player
                          </p>
                        </div>
                      </div>
                    )}

                    {(event.registrationType === "team" ||
                      event.registrationType === "both") && (
                      <div className="flex items-start space-x-2">
                        <RadioGroupItem value="team" id="team" />
                        <div className="grid gap-1.5 leading-none">
                          <Label htmlFor="team" className="cursor-pointer font-normal">
                            Team Registration
                            <span className="text-muted-foreground ml-2 text-sm">
                              ${((event.teamRegistrationFee ?? 0) / 100).toFixed(2)}
                            </span>
                          </Label>
                          <p className="text-muted-foreground text-sm">
                            Register your entire team
                          </p>
                        </div>
                      </div>
                    )}
                  </RadioGroup>
                </div>
              )}

              {effectiveRegistrationType === "team" && (
                <div className="space-y-3">
                  <Label>Select Team</Label>
                  {userTeams && userTeams.length > 0 ? (
                    <Select
                      value={selectedTeamId}
                      onValueChange={(value) => setSelectedTeamId(value)}
                    >
                      <SelectTrigger>
                        <SelectValue placeholder="Select a team" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="">Select a team</SelectItem>
                        {userTeams.map((entry) => (
                          <SelectItem key={entry.team.id} value={entry.team.id}>
                            {entry.team.name}
                            {entry.membership?.role ? ` (${entry.membership.role})` : ""}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  ) : (
                    <Alert>
                      <AlertDescription>
                        You need to be part of a team to register as a team. {""}
                        <Link to="/dashboard/teams" className="underline">
                          Join or create a team
                        </Link>
                      </AlertDescription>
                    </Alert>
                  )}
                </div>
              )}

              <Separator />

              <div className="space-y-3">
                <h3 className="font-semibold">Emergency Contact</h3>
                <div className="grid gap-4 md:grid-cols-3">
                  <div className="space-y-2">
                    <Label htmlFor="emergency-name">Name</Label>
                    <Input
                      id="emergency-name"
                      value={emergencyContact.name}
                      onChange={(event) =>
                        setEmergencyContact((prev) => ({
                          ...prev,
                          name: event.target.value,
                        }))
                      }
                      placeholder="Contact name"
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="emergency-phone">Phone</Label>
                    <Input
                      id="emergency-phone"
                      value={emergencyContact.phone}
                      onChange={(event) =>
                        setEmergencyContact((prev) => ({
                          ...prev,
                          phone: event.target.value,
                        }))
                      }
                      placeholder="(555) 123-4567"
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="emergency-relationship">Relationship</Label>
                    <Input
                      id="emergency-relationship"
                      value={emergencyContact.relationship}
                      onChange={(event) =>
                        setEmergencyContact((prev) => ({
                          ...prev,
                          relationship: event.target.value,
                        }))
                      }
                      placeholder="Parent, spouse, etc."
                    />
                  </div>
                </div>
              </div>

              <Separator />

              <div className="space-y-3">
                <Label htmlFor="additional-info">Additional Information (optional)</Label>
                <Textarea
                  id="additional-info"
                  className="min-h-[100px]"
                  placeholder="Any dietary restrictions, accessibility needs, or other information..."
                  value={additionalInfo}
                  onChange={(event) => setAdditionalInfo(event.target.value)}
                />
              </div>

              <Separator />

              {requiresPayment ? (
                <div className="space-y-3">
                  <h3 className="font-semibold">Payment Method</h3>
                  <RadioGroup
                    value={effectivePaymentMethod}
                    onValueChange={(value) =>
                      setPaymentMethod(value as "square" | "etransfer")
                    }
                    className="space-y-2"
                  >
                    <div className="flex items-start space-x-2">
                      <RadioGroupItem value="square" id="payment-square" />
                      <div className="grid gap-1.5 leading-none">
                        <Label
                          htmlFor="payment-square"
                          className="cursor-pointer font-normal"
                        >
                          Square Checkout
                          <span className="text-muted-foreground ml-2 text-sm">
                            ${fee.discounted.toFixed(2)}
                          </span>
                        </Label>
                        <p className="text-muted-foreground text-sm">
                          Pay securely online with credit or debit card.
                        </p>
                      </div>
                    </div>

                    {event.allowEtransfer && (
                      <div className="flex items-start space-x-2">
                        <RadioGroupItem value="etransfer" id="payment-etransfer" />
                        <div className="grid gap-1.5 leading-none">
                          <Label
                            htmlFor="payment-etransfer"
                            className="cursor-pointer font-normal"
                          >
                            Interac e-Transfer
                            <span className="text-muted-foreground ml-2 text-sm">
                              ${fee.discounted.toFixed(2)}
                            </span>
                          </Label>
                          <p className="text-muted-foreground text-sm">
                            Submit now and send payment manually after this form.
                          </p>
                        </div>
                      </div>
                    )}
                  </RadioGroup>

                  {effectivePaymentMethod === "etransfer" && event.allowEtransfer && (
                    <Alert>
                      <AlertTitle>E-transfer Instructions</AlertTitle>
                      <AlertDescription className="space-y-2">
                        <p>
                          Send payment to
                          <span className="font-semibold">
                            {" "}
                            {event.etransferRecipient ?? "the designated email"}
                          </span>
                          . Include your name and the event in the message.
                        </p>
                        {event.etransferInstructions && (
                          <p>{event.etransferInstructions}</p>
                        )}
                      </AlertDescription>
                    </Alert>
                  )}
                </div>
              ) : (
                <Alert>
                  <AlertTitle>No Payment Required</AlertTitle>
                  <AlertDescription>
                    This registration does not require payment. Submit the form to finish.
                  </AlertDescription>
                </Alert>
              )}

              <Separator />

              <div className="space-y-3">
                <h3 className="font-semibold">Terms and Conditions</h3>

                <div className="flex items-start space-x-2">
                  <Checkbox
                    id="terms"
                    checked={termsAccepted}
                    onCheckedChange={(checked: CheckedState) =>
                      setTermsAccepted(Boolean(checked))
                    }
                  />
                  <div className="grid gap-1.5 leading-none">
                    <Label htmlFor="terms" className="cursor-pointer font-normal">
                      I agree to the event terms and code of conduct
                    </Label>
                    <p className="text-muted-foreground text-sm">
                      You must agree to these terms to participate in the event.
                    </p>
                  </div>
                </div>

                <div className="flex items-start space-x-2">
                  <Checkbox
                    id="waiver"
                    checked={waiverAccepted}
                    onCheckedChange={(checked: CheckedState) =>
                      setWaiverAccepted(Boolean(checked))
                    }
                  />
                  <div className="grid gap-1.5 leading-none">
                    <Label htmlFor="waiver" className="cursor-pointer font-normal">
                      I have read and accepted the liability waiver
                    </Label>
                    <p className="text-muted-foreground text-sm">
                      Every participant must accept the waiver before registering.
                    </p>
                  </div>
                </div>
              </div>

              <div className="flex justify-end">
                <Button onClick={handleSubmit} disabled={submitDisabled}>
                  {registrationMutation.isPending
                    ? "Submitting..."
                    : confirmation?.method === "etransfer"
                      ? "Awaiting E-Transfer"
                      : "Complete Registration"}
                </Button>
              </div>
            </CardContent>
          </Card>
        </div>

        <aside className="space-y-6">
          {confirmation?.method === "etransfer" && (
            <Card>
              <CardHeader>
                <CardTitle>Finish Your E-transfer</CardTitle>
                <CardDescription>
                  Send your payment to finalize the registration.
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-4 text-sm">
                <div>
                  <p className="font-medium">Recipient Email</p>
                  <p className="text-muted-foreground">
                    {event.etransferRecipient ?? "See event instructions"}
                  </p>
                </div>
                {event.etransferInstructions && (
                  <div>
                    <p className="font-medium">Instructions</p>
                    <p className="text-muted-foreground whitespace-pre-line">
                      {event.etransferInstructions}
                    </p>
                  </div>
                )}
                <Alert>
                  <AlertDescription>
                    Once the payment is received, an administrator will mark your
                    registration as paid.
                  </AlertDescription>
                </Alert>
                <Button asChild variant="outline">
                  <Link to="/dashboard/events">Return to Dashboard</Link>
                </Button>
              </CardContent>
            </Card>
          )}
          <Card>
            <CardHeader>
              <CardTitle>Event Overview</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4 text-sm">
              <div className="space-y-3">
                <div className="flex items-center gap-2">
                  <CalendarIcon className="text-muted-foreground h-4 w-4" />
                  <span>
                    {format(new Date(event.startDate), "MMM d, yyyy")}
                    {event.endDate !== event.startDate &&
                      ` - ${format(new Date(event.endDate), "MMM d, yyyy")}`}
                  </span>
                </div>

                {event.city && (
                  <div className="flex items-center gap-2">
                    <MapPinIcon className="text-muted-foreground h-4 w-4" />
                    <span>
                      {event.city}
                      {event.province && `, ${event.province}`}
                    </span>
                  </div>
                )}

                <div className="flex items-center gap-2">
                  <UsersIcon className="text-muted-foreground h-4 w-4" />
                  <span className="capitalize">
                    {event.registrationType} registration
                  </span>
                </div>
              </div>

              <Separator />

              <div className="space-y-2">
                <div className="flex items-center justify-between">
                  <span>Status</span>
                  <Badge variant={event.isRegistrationOpen ? "outline" : "secondary"}>
                    {event.isRegistrationOpen
                      ? "Registration open"
                      : "Registration closed"}
                  </Badge>
                </div>

                <div className="flex items-center justify-between">
                  <span>Registered</span>
                  <span>{event.registrationCount}</span>
                </div>

                {event.availableSpots !== undefined && (
                  <div className="flex items-center justify-between">
                    <span>Spots remaining</span>
                    <span>{event.availableSpots}</span>
                  </div>
                )}
              </div>

              <Separator />

              <div className="space-y-2">
                <h4 className="font-medium">Registration Fees</h4>
                <div className="flex items-center justify-between">
                  <span>Current Fee</span>
                  <span className="font-semibold">${fee.discounted.toFixed(2)}</span>
                </div>
                {fee.hasDiscount && (
                  <p className="text-muted-foreground text-sm">
                    Early bird discount applied ({fee.discountPercentage}% off)
                  </p>
                )}
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle>Participant Information</CardTitle>
            </CardHeader>
            <CardContent className="space-y-2 text-sm">
              <div>
                {userProfile?.name ?? userProfile?.email ?? "Unknown participant"}
              </div>
              <div className="text-muted-foreground">
                {userProfile?.email ?? user?.email ?? "No email available"}
              </div>
            </CardContent>
          </Card>
        </aside>
      </div>
    </div>
  );
}

function RegistrationSkeleton() {
  return (
    <div className="container mx-auto space-y-6 p-6">
      <Skeleton className="h-6 w-32" />
      <div className="grid gap-6 lg:grid-cols-3">
        <div className="space-y-6 lg:col-span-2">
          <Card>
            <CardHeader>
              <Skeleton className="h-6 w-1/2" />
              <Skeleton className="h-4 w-1/3" />
            </CardHeader>
            <CardContent className="space-y-4">
              <Skeleton className="h-40 w-full" />
            </CardContent>
          </Card>
        </div>
        <div className="space-y-6">
          <Card>
            <CardHeader>
              <Skeleton className="h-6 w-24" />
            </CardHeader>
            <CardContent className="space-y-4">
              <Skeleton className="h-16 w-full" />
              <Skeleton className="h-10 w-full" />
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/routes/dashboard/events/$slug.tsx">
import { Outlet, createFileRoute } from "@tanstack/react-router";

export const Route = createFileRoute("/dashboard/events/$slug")({
  component: EventLayout,
});

function EventLayout() {
  return <Outlet />;
}
</file>

<file path="src/routes/dashboard/events/create.tsx">
import { createFileRoute, Link, redirect } from "@tanstack/react-router";
import { ArrowLeftIcon } from "lucide-react";
import { Button } from "~/components/ui/button";
import { EventCreateForm } from "~/features/events/components/event-create-form";

export const Route = createFileRoute("/dashboard/events/create")({
  beforeLoad: async ({ context, location }) => {
    const { user } = context;
    if (!user) {
      throw redirect({
        to: "/auth/login",
        search: { redirect: location.pathname },
      });
    }
  },
  component: CreateEventPage,
});

function CreateEventPage() {
  return (
    <div className="container mx-auto space-y-6 p-6">
      <div className="flex items-center gap-4">
        <Button asChild variant="ghost" size="sm">
          <Link to="/dashboard/events">
            <ArrowLeftIcon className="mr-2 h-4 w-4" />
            Back to Events
          </Link>
        </Button>
      </div>

      <EventCreateForm />
    </div>
  );
}
</file>

<file path="src/routes/dashboard/events/index.tsx">
import { createFileRoute, Link, useRouteContext } from "@tanstack/react-router";
import { PlusIcon } from "lucide-react";
import { Button } from "~/components/ui/button";
import { EventList } from "~/features/events/components/event-list";

export const Route = createFileRoute("/dashboard/events/")({
  component: EventsPage,
});

function EventsPage() {
  const { user } = useRouteContext({ from: "/dashboard/events" });

  return (
    <div className="container mx-auto space-y-8 p-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold tracking-tight">Events</h1>
          <p className="text-muted-foreground">
            Browse and manage Quadball events across Canada
          </p>
        </div>
        {user && (
          <Button asChild>
            <Link to="/dashboard/events/create">
              <PlusIcon className="mr-2 h-4 w-4" />
              Create Event
            </Link>
          </Button>
        )}
      </div>

      <EventList />
    </div>
  );
}
</file>

<file path="src/routes/dashboard/forbidden.tsx">
import { createFileRoute, Link } from "@tanstack/react-router";
import { AlertTriangle } from "lucide-react";
import { Button } from "~/components/ui/button";

export const Route = createFileRoute("/dashboard/forbidden")({
  component: ForbiddenPage,
});

function ForbiddenPage() {
  return (
    <div className="border-border bg-card mx-auto flex max-w-3xl flex-col items-center gap-6 rounded-lg border p-12 text-center shadow-sm">
      <div className="bg-destructive/10 text-destructive flex h-16 w-16 items-center justify-center rounded-full">
        <AlertTriangle className="h-8 w-8" />
      </div>
      <div className="space-y-2">
        <h1 className="text-3xl font-semibold tracking-tight">Access restricted</h1>
        <p className="text-muted-foreground">
          You donât have permission to view this section. If you believe this is a
          mistake, reach out to an administrator or head back to your dashboard.
        </p>
      </div>
      <div className="flex flex-wrap items-center justify-center gap-3">
        <Button asChild variant="secondary">
          <Link to="/dashboard">Return to dashboard</Link>
        </Button>
        <Button asChild variant="outline">
          <a href="mailto:info@quadball.ca">Contact support</a>
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="src/routes/dashboard/profile.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { ProfileView } from "~/features/profile/components/profile-view";

export const Route = createFileRoute("/dashboard/profile")({
  component: ProfilePage,
});

function ProfilePage() {
  return (
    <div className="container mx-auto space-y-8 p-6">
      <div>
        <h1 className="text-3xl font-bold tracking-tight">My Profile</h1>
        <p className="text-muted-foreground mt-2">
          View and manage your personal information
        </p>
      </div>

      <ProfileView />
    </div>
  );
}
</file>

<file path="src/routes/dashboard/route.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { AdminLayout } from "~/features/layouts/admin-layout";
import { requireAuthAndProfile } from "~/lib/auth/guards/route-guards";

export const Route = createFileRoute("/dashboard")({
  component: DashboardLayout,
  beforeLoad: async ({ context, location }) => {
    // â  Redirect unauthenticated visitors to `/auth/login`
    // â  Redirect authenticated but incomplete profiles to `/onboarding`
    requireAuthAndProfile({ user: context.user, location });
  },
});

function DashboardLayout() {
  return <AdminLayout />;
}
</file>

<file path="src/routes/dashboard/teams.tsx">
import { createFileRoute, Outlet } from "@tanstack/react-router";

export const Route = createFileRoute("/dashboard/teams")({
  component: TeamsLayout,
});

function TeamsLayout() {
  return <Outlet />;
}
</file>

<file path="src/components/form-fields/ValidatedCheckbox.tsx">
import React from "react";
import { Checkbox } from "~/components/ui/checkbox";
import { Label } from "~/components/ui/label";
import { FieldComponentProps, isFieldApi } from "~/lib/form";
import { cn } from "~/shared/lib/utils";

interface ValidatedCheckboxProps extends FieldComponentProps {
  description?: string;
  disabled?: boolean;
}

export const ValidatedCheckbox: React.FC<ValidatedCheckboxProps> = (props) => {
  const { field, label, description, className, disabled = false } = props;

  if (!isFieldApi(field)) {
    console.error("ValidatedCheckbox requires a valid field prop.");
    return null;
  }

  const inputId = `${field.name}-checkbox`;
  const meta = field.state.meta;

  return (
    <div className={cn("space-y-2", className)}>
      <div className="flex items-center space-x-2">
        <Checkbox
          id={inputId}
          checked={!!field.state.value}
          onCheckedChange={(checked) => field.handleChange(!!checked)}
          onBlur={field.handleBlur}
          disabled={disabled || field.form.state.isSubmitting}
          aria-invalid={!!meta.errors.length}
          aria-describedby={
            [
              description ? `${inputId}-description` : null,
              meta.isTouched && meta.errors.length ? `${inputId}-errors` : null,
            ]
              .filter(Boolean)
              .join(" ") || undefined
          }
        />
        <Label
          htmlFor={inputId}
          className="cursor-pointer text-sm leading-none font-normal peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
        >
          {label}
        </Label>
      </div>
      {description && (
        <p id={`${inputId}-description`} className="text-muted-foreground ml-6 text-sm">
          {description}
        </p>
      )}
      {meta.isTouched && meta.errors.length > 0 && (
        <div
          id={`${inputId}-errors`}
          className="text-destructive ml-6 text-sm font-medium"
        >
          {meta.errors.join(", ")}
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/components/form-fields/ValidatedDatePicker.tsx">
import React from "react";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";
import { FieldComponentProps, isFieldApi } from "~/lib/form";
import { cn } from "~/shared/lib/utils";

interface ValidatedDatePickerProps extends FieldComponentProps {
  minAge?: number;
  maxAge?: number;
}

export const ValidatedDatePicker: React.FC<ValidatedDatePickerProps> = (props) => {
  const { field, label, minAge = 13, maxAge = 120, className } = props;

  if (!isFieldApi(field)) {
    console.error("ValidatedDatePicker requires a valid field prop.");
    return null;
  }

  const inputId = `${field.name}-date`;
  const meta = field.state.meta;

  // Calculate min and max dates based on age restrictions, using UTC for consistency
  const today = new Date();
  const maxDate = new Date(
    Date.UTC(today.getUTCFullYear() - minAge, today.getUTCMonth(), today.getUTCDate()),
  );
  const minDate = new Date(
    Date.UTC(today.getUTCFullYear() - maxAge, today.getUTCMonth(), today.getUTCDate()),
  );

  // Format date for input value using UTC components
  const formatDate = (date: Date | string | undefined): string => {
    if (!date) return "";
    const d = typeof date === "string" ? new Date(date) : date;
    if (isNaN(d.getTime())) return "";
    const year = d.getUTCFullYear();
    const month = String(d.getUTCMonth() + 1).padStart(2, "0");
    const day = String(d.getUTCDate()).padStart(2, "0");
    return `${year}-${month}-${day}`;
  };

  return (
    <div className={cn("space-y-2", className)}>
      <Label htmlFor={inputId}>{label}</Label>
      <Input
        id={inputId}
        type="date"
        value={formatDate(field.state.value)}
        onChange={(e) => {
          const value = e.target.value;
          if (value) {
            // Parse the date string as UTC to prevent timezone shifts
            const [year, month, day] = value.split("-").map(Number);
            const date = new Date(Date.UTC(year, month - 1, day));
            // Always store a UTC midnight ISO string so client & server match
            field.handleChange(date.toISOString().split("T")[0]);
          } else {
            field.handleChange(undefined);
          }
        }}
        onBlur={field.handleBlur}
        min={formatDate(minDate)}
        max={formatDate(maxDate)}
        disabled={field.form.state.isSubmitting}
        aria-invalid={!!meta.errors.length}
        aria-describedby={meta.errors.length ? `${inputId}-errors` : undefined}
      />
      <p className="text-muted-foreground text-sm">
        You must be between {minAge} and {maxAge} years old
      </p>
      {meta.isTouched && meta.errors.length > 0 && (
        <div id={`${inputId}-errors`} className="text-destructive text-sm font-medium">
          {meta.errors.join(", ")}
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/components/ui/breadcrumbs.tsx">
import { Link, useRouterState } from "@tanstack/react-router";

const LABEL_OVERRIDES: Record<string, string> = {
  dashboard: "Dashboard",
  admin: "Admin",
  teams: "Teams",
  events: "Events",
  members: "Members",
  membership: "Membership",
  profile: "Profile",
  settings: "Settings",
  reports: "Reports",
  roles: "Roles",
  forbidden: "Forbidden",
  manage: "Manage",
};

function formatSegment(segment: string): string {
  if (LABEL_OVERRIDES[segment]) {
    return LABEL_OVERRIDES[segment];
  }

  const clean = segment.replace(/[-_]/g, " ");
  return clean.charAt(0).toUpperCase() + clean.slice(1);
}

export function Breadcrumbs() {
  const location = useRouterState({ select: (state) => state.location });
  const segments = location.pathname.split("/").filter(Boolean);

  if (segments.length <= 1) {
    return null;
  }

  const crumbs = segments
    .map((segment, index) => ({ segment, index }))
    .filter(({ index }) => index !== 0) // skip the root dashboard node; rendered separately below
    .map(({ segment, index }) => {
      const href = `/${segments.slice(0, index + 1).join("/")}`;
      const label = formatSegment(segment);
      const isLast = index === segments.length - 1;

      const node = isLast ? (
        <span className="text-muted-foreground">{label}</span>
      ) : (
        <Link to={href} className="text-muted-foreground hover:text-foreground">
          {label}
        </Link>
      );

      return { key: href, node };
    });

  return (
    <nav aria-label="Breadcrumb" className="text-sm">
      <ol className="text-muted-foreground flex flex-wrap items-center gap-2">
        <li>
          <Link to="/dashboard" className="hover:text-foreground">
            Dashboard
          </Link>
        </li>
        {crumbs.map((crumb) => (
          <li key={crumb.key} className="flex items-center gap-2">
            <span aria-hidden="true">/</span>
            {crumb.node}
          </li>
        ))}
      </ol>
    </nav>
  );
}
</file>

<file path="src/components/ui/data-table.tsx">
import {
  ColumnDef,
  flexRender,
  getCoreRowModel,
  getPaginationRowModel,
  getSortedRowModel,
  SortingState,
  useReactTable,
  VisibilityState,
} from "@tanstack/react-table";
import { ArrowUpDown } from "lucide-react";
import { useState } from "react";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "~/components/ui/table";
import { Button } from "./button";
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuTrigger,
} from "./dropdown-menu";

interface DataTableProps<TData, TValue> {
  columns: ColumnDef<TData, TValue>[];
  data: TData[];
  pageSize?: number;
  onExport?: () => void;
  enableColumnToggle?: boolean;
}

export function DataTable<TData, TValue>({
  columns,
  data,
  pageSize = 10,
  onExport,
  enableColumnToggle = true,
}: DataTableProps<TData, TValue>) {
  const [sorting, setSorting] = useState<SortingState>([]);
  const [columnVisibility, setColumnVisibility] = useState<VisibilityState>({});

  const table = useReactTable({
    data,
    columns,
    getCoreRowModel: getCoreRowModel(),
    getPaginationRowModel: getPaginationRowModel(),
    onSortingChange: setSorting,
    getSortedRowModel: getSortedRowModel(),
    onColumnVisibilityChange: setColumnVisibility,
    state: {
      sorting,
      columnVisibility,
    },
    initialState: {
      pagination: {
        pageSize,
      },
    },
  });

  const canRenderToolbar = enableColumnToggle || Boolean(onExport);

  return (
    <div className="space-y-4">
      {canRenderToolbar && (
        <div className="flex items-center justify-between">
          {enableColumnToggle ? (
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="outline" className="ml-auto">
                  Columns
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                {table
                  .getAllColumns()
                  .filter((column) => column.getCanHide())
                  .map((column) => {
                    return (
                      <DropdownMenuCheckboxItem
                        key={column.id}
                        className="capitalize"
                        checked={column.getIsVisible()}
                        onCheckedChange={(value) => column.toggleVisibility(!!value)}
                      >
                        {column.id}
                      </DropdownMenuCheckboxItem>
                    );
                  })}
              </DropdownMenuContent>
            </DropdownMenu>
          ) : (
            <span />
          )}
          {onExport && (
            <Button onClick={onExport} variant="outline">
              Export CSV
            </Button>
          )}
        </div>
      )}
      <div className="rounded-md border">
        <Table>
          <TableHeader>
            {table.getHeaderGroups().map((headerGroup) => (
              <TableRow key={headerGroup.id}>
                {headerGroup.headers.map((header) => {
                  return (
                    <TableHead key={header.id}>
                      {header.isPlaceholder ? null : (
                        <div className="flex items-center space-x-2">
                          {flexRender(
                            header.column.columnDef.header,
                            header.getContext(),
                          )}
                          {header.column.getCanSort() && (
                            <Button
                              variant="ghost"
                              size="sm"
                              className="data-[state=open]:bg-accent -ml-3 h-8"
                              onClick={header.column.getToggleSortingHandler()}
                            >
                              <ArrowUpDown className="h-4 w-4" />
                            </Button>
                          )}
                        </div>
                      )}
                    </TableHead>
                  );
                })}
              </TableRow>
            ))}
          </TableHeader>
          <TableBody>
            {table.getRowModel().rows?.length ? (
              table.getRowModel().rows.map((row) => (
                <TableRow key={row.id} data-state={row.getIsSelected() && "selected"}>
                  {row.getVisibleCells().map((cell) => (
                    <TableCell key={cell.id}>
                      {flexRender(cell.column.columnDef.cell, cell.getContext())}
                    </TableCell>
                  ))}
                </TableRow>
              ))
            ) : (
              <TableRow>
                <TableCell colSpan={columns.length} className="h-24 text-center">
                  No results.
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </Table>
      </div>
      <div className="flex items-center justify-end space-x-2">
        <Button
          variant="outline"
          size="sm"
          onClick={() => table.previousPage()}
          disabled={!table.getCanPreviousPage()}
        >
          Previous
        </Button>
        <Button
          variant="outline"
          size="sm"
          onClick={() => table.nextPage()}
          disabled={!table.getCanNextPage()}
        >
          Next
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/ui/icons.tsx">
import type { SVGProps } from "react";

export function GoogleIcon(props: SVGProps<SVGSVGElement>) {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" {...props}>
      <path
        d="M12.48 10.92v3.28h7.84c-.24 1.84-.853 3.187-1.787 4.133-1.147 1.147-2.933 2.4-6.053 2.4-4.827 0-8.6-3.893-8.6-8.72s3.773-8.72 8.6-8.72c2.6 0 4.507 1.027 5.907 2.347l2.307-2.307C18.747 1.44 16.133 0 12.48 0 5.867 0 .307 5.387.307 12s5.56 12 12.173 12c3.573 0 6.267-1.173 8.373-3.36 2.16-2.16 2.84-5.213 2.84-7.667 0-.76-.053-1.467-.173-2.053H12.48z"
        fill="currentColor"
      />
    </svg>
  );
}

// Re-export commonly used Lucide icons for consistency
export {
  AlertCircle,
  ArrowLeft as ArrowLeftIcon,
  Calendar,
  Calendar as CalendarIcon,
  CheckCircle2,
  Check as CheckIcon,
  ChevronsUpDown as ChevronsUpDownIcon,
  Clock,
  CreditCard,
  Download as DownloadIcon,
  Link as LinkIcon,
  Loader2,
  LoaderCircle as LoaderIcon,
  GalleryVerticalEnd as LogoIcon,
  MapPin as MapPinIcon,
  MoonIcon,
  Palette as PaletteIcon,
  Plus as PlusIcon,
  Search as SearchIcon,
  SunIcon,
  Trophy,
  User,
  UserPlus,
  Users,
  Users as UsersIcon,
  XCircle,
} from "lucide-react";
</file>

<file path="src/features/auth/__tests__/login.test.tsx">
import userEvent from "@testing-library/user-event";
import { beforeEach, describe, expect, it, vi } from "vitest";

// Setup mocks before imports
const mockNavigate = vi.fn();
const mockInvalidateQueries = vi.fn();

// Mock auth client
vi.mock("~/lib/auth-client", () => ({
  auth: {
    signIn: {
      email: vi.fn(),
    },
    signUp: {
      email: vi.fn(),
    },
    signInWithOAuth: vi.fn(),
    signOut: vi.fn(),
    getSession: vi.fn(),
  },
  default: {
    signIn: {
      email: vi.fn(),
      social: vi.fn(),
    },
    signUp: {
      email: vi.fn(),
    },
    signOut: vi.fn(),
    getSession: vi.fn(),
  },
}));

// Mock TanStack Router
vi.mock("@tanstack/react-router", () => ({
  // eslint-disable-next-line @eslint-react/hooks-extra/no-unnecessary-use-prefix
  useNavigate: () => mockNavigate,
  // eslint-disable-next-line @eslint-react/hooks-extra/no-unnecessary-use-prefix
  useRouteContext: () => ({ redirectUrl: "/dashboard" }),
  // eslint-disable-next-line @eslint-react/hooks-extra/no-unnecessary-use-prefix
  useRouterState: () => ({ location: { pathname: "/auth/login" } }),
  // eslint-disable-next-line @eslint-react/hooks-extra/no-unnecessary-use-prefix
  useRouter: () => ({ invalidate: vi.fn() }),
  Link: ({
    to,
    children,
    ...props
  }: {
    to: string;
    children: React.ReactNode;
  } & React.AnchorHTMLAttributes<HTMLAnchorElement>) => (
    <a href={to} {...props}>
      {children}
    </a>
  ),
}));

// Mock SafeLink
vi.mock("~/components/ui/SafeLink", () => ({
  SafeLink: ({
    to,
    children,
    ...props
  }: {
    to: string;
    children: React.ReactNode;
  } & React.AnchorHTMLAttributes<HTMLAnchorElement>) => (
    <a href={to} {...props}>
      {children}
    </a>
  ),
}));

vi.mock("@tanstack/react-query", async (importOriginal) => {
  const actual = await importOriginal<typeof import("@tanstack/react-query")>();
  return {
    ...actual,
    // eslint-disable-next-line @eslint-react/hooks-extra/no-unnecessary-use-prefix
    useQueryClient: () => ({ invalidateQueries: mockInvalidateQueries }),
  };
});

import { auth } from "~/lib/auth-client";
import { createAuthMocks } from "~/tests/mocks/auth";
import { render, screen, waitFor } from "~/tests/utils";
import LoginForm from "../components/login";

describe("LoginForm", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("renders login form with all elements", () => {
    render(<LoginForm />);

    // Check for form elements
    expect(screen.getByLabelText("Email")).toBeInTheDocument();
    expect(screen.getByLabelText("Password")).toBeInTheDocument();
    expect(screen.getByRole("button", { name: "Login" })).toBeInTheDocument();

    // Check for social login button
    expect(screen.getByRole("button", { name: "Login with Google" })).toBeInTheDocument();

    // Check for signup link
    expect(screen.getByText("Don't have an account?")).toBeInTheDocument();
    expect(screen.getByRole("link", { name: "Sign up" })).toHaveAttribute(
      "href",
      "/auth/signup",
    );
  });

  it("handles successful email login", async () => {
    const user = userEvent.setup();
    const { mockUser, mockSession } = createAuthMocks();

    // Setup successful login response
    vi.mocked(auth.signIn.email).mockResolvedValueOnce({
      data: { user: mockUser, session: mockSession },
      error: null,
    });

    render(<LoginForm />);

    // Fill in form
    await user.type(screen.getByLabelText("Email"), "test@example.com");
    await user.type(screen.getByLabelText("Password"), "password123");

    // Submit form
    await user.click(screen.getByRole("button", { name: "Login" }));

    await waitFor(() => {
      // Verify auth client was called
      expect(auth.signIn.email).toHaveBeenCalledWith({
        email: "test@example.com",
        password: "password123",
      });

      // Verify queries were invalidated
      expect(mockInvalidateQueries).toHaveBeenCalledWith({ queryKey: ["user"] });

      // Verify navigation
      expect(mockNavigate).toHaveBeenCalledWith({ to: "/dashboard" });
    });
  });

  it("displays error message on failed login", async () => {
    const user = userEvent.setup();
    const errorMessage = "Invalid email or password";

    // Setup failed login response
    vi.mocked(auth.signIn.email).mockResolvedValueOnce({
      data: null,
      error: {
        message: errorMessage,
      },
    });

    render(<LoginForm />);

    // Fill in form
    await user.type(screen.getByLabelText("Email"), "test@example.com");
    await user.type(screen.getByLabelText("Password"), "wrongpassword");

    // Submit form
    await user.click(screen.getByRole("button", { name: "Login" }));

    await waitFor(() => {
      // Verify error message is displayed
      expect(screen.getByText(errorMessage)).toBeInTheDocument();
    });
  });

  it("disables form during submission", async () => {
    const user = userEvent.setup();

    // Setup delayed login response
    vi.mocked(auth.signIn.email).mockImplementationOnce(() => {
      return new Promise(() => {}); // Never resolves
    });

    render(<LoginForm />);

    // Fill in form
    await user.type(screen.getByLabelText("Email"), "test@example.com");
    await user.type(screen.getByLabelText("Password"), "password123");

    // Submit form
    await user.click(screen.getByRole("button", { name: "Login" }));

    // Check loading state
    expect(screen.getByRole("button", { name: "Logging in..." })).toBeDisabled();
    expect(screen.getByLabelText("Email")).toBeDisabled();
    expect(screen.getByLabelText("Password")).toBeDisabled();

    // Social login button should also be disabled
    expect(screen.getByRole("button", { name: "Login with Google" })).toBeDisabled();
  });

  it("handles Google social login", async () => {
    const user = userEvent.setup();
    const { mockUser } = createAuthMocks();

    vi.mocked(auth.signInWithOAuth).mockResolvedValueOnce({
      redirect: true,
      token: "mock-token",
      url: undefined,
      user: mockUser,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } as any);

    render(<LoginForm />);

    await user.click(screen.getByRole("button", { name: "Login with Google" }));

    expect(auth.signInWithOAuth).toHaveBeenCalledWith(
      {
        provider: "google",
        callbackURL: "/dashboard",
      },
      expect.objectContaining({
        onRequest: expect.any(Function),
        onError: expect.any(Function),
      }),
    );
  });

  it("validates required fields", async () => {
    const user = userEvent.setup();

    render(<LoginForm />);

    // Try to submit empty form
    await user.click(screen.getByRole("button", { name: "Login" }));

    // Auth client should not be called
    expect(auth.signIn.email).not.toHaveBeenCalled();
  });
});
</file>

<file path="src/features/auth/__tests__/signup-with-router.test.tsx">
import userEvent from "@testing-library/user-event";
import { beforeEach, describe, expect, it, vi } from "vitest";
import { auth } from "~/lib/auth-client";
import { renderWithRouter, screen, waitFor } from "~/tests/utils";
import SignupForm from "../components/signup";

// Mock auth client
vi.mock("~/lib/auth-client", () => ({
  auth: {
    signUp: {
      email: vi.fn(),
    },
    signInWithOAuth: vi.fn(),
  },
}));

describe("SignupForm with Router", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("renders signup form with all fields", async () => {
    await renderWithRouter(<SignupForm />);

    expect(screen.getByLabelText("Name")).toBeInTheDocument();
    expect(screen.getByLabelText("Email")).toBeInTheDocument();
    expect(screen.getByLabelText("Password")).toBeInTheDocument();
    expect(screen.getByLabelText("Confirm Password")).toBeInTheDocument();
    expect(screen.getByRole("button", { name: "Sign up" })).toBeInTheDocument();
  });

  it("validates password confirmation", async () => {
    const user = userEvent.setup();

    await renderWithRouter(<SignupForm />);

    // Fill form with mismatched passwords
    await user.type(screen.getByLabelText("Name"), "Test User");
    await user.type(screen.getByLabelText("Email"), "test@example.com");
    await user.type(screen.getByLabelText("Password"), "password123");
    await user.type(screen.getByLabelText("Confirm Password"), "password456");

    await user.click(screen.getByRole("button", { name: "Sign up" }));

    // Should show password mismatch error
    await waitFor(() => {
      expect(screen.getByText(/passwords do not match/i)).toBeInTheDocument();
    });

    // Auth should not be called
    expect(auth.signUp.email).not.toHaveBeenCalled();
  });

  it("handles successful signup", async () => {
    const user = userEvent.setup();

    vi.mocked(auth.signUp.email).mockImplementation((data, handlers) => {
      handlers?.onSuccess?.({ data: { user: {}, session: {} } } as Parameters<
        NonNullable<typeof handlers.onSuccess>
      >[0]);
      return Promise.resolve({ data: { user: {}, session: {} }, error: null });
    });

    const { router } = await renderWithRouter(<SignupForm />);

    // Fill form correctly
    await user.type(screen.getByLabelText("Name"), "New User");
    await user.type(screen.getByLabelText("Email"), "newuser@example.com");
    await user.type(screen.getByLabelText("Password"), "securepassword123");
    await user.type(screen.getByLabelText("Confirm Password"), "securepassword123");

    await user.click(screen.getByRole("button", { name: "Sign up" }));

    await waitFor(() => {
      expect(auth.signUp.email).toHaveBeenCalledWith(
        expect.objectContaining({
          email: "newuser@example.com",
          password: "securepassword123",
          name: "New User",
          callbackURL: "/dashboard",
        }),
      );
    });

    // Verify router exists for navigation
    expect(router).toBeDefined();
  });

  it("displays login link", async () => {
    await renderWithRouter(<SignupForm />);

    const loginLink = screen.getByRole("link", { name: "Login" });
    expect(loginLink).toHaveAttribute("href", "/auth/login");
  });

  it("handles OAuth signup", async () => {
    const user = userEvent.setup();

    vi.mocked(auth.signInWithOAuth).mockResolvedValue(
      {} as ReturnType<typeof auth.signInWithOAuth>,
    );

    await renderWithRouter(<SignupForm />);

    const googleButton = screen.getByRole("button", { name: /sign up with google/i });
    await user.click(googleButton);

    expect(auth.signInWithOAuth).toHaveBeenCalledWith(
      expect.objectContaining({
        provider: "google",
      }),
      expect.any(Object),
    );
  });
});
</file>

<file path="src/features/auth/hooks/useAuthForm.ts">
import { useQueryClient } from "@tanstack/react-query";
import { useNavigate, useRouter } from "@tanstack/react-router";
import { useState } from "react";
import { authQueryKey } from "../auth.queries";

interface UseAuthFormOptions {
  redirectUrl?: string;
}

/**
 * Custom hook for handling authentication form state and navigation
 * Reduces repetitive code in login and signup components
 *
 * @example
 * const { isLoading, errorMessage, handleAuth } = useAuthForm();
 *
 * const onSubmit = async (e) => {
 *   await handleAuth(async () => {
 *     // Your auth logic here
 *   });
 * };
 */
export function useAuthForm(options: UseAuthFormOptions = {}) {
  const { redirectUrl = "/dashboard" } = options;
  const [isLoading, setIsLoading] = useState(false);
  const [errorMessage, setErrorMessage] = useState("");
  const queryClient = useQueryClient();
  const navigate = useNavigate();
  const router = useRouter();

  const handleAuth = async (
    authFunction: () => Promise<void>,
    onError?: (error: unknown) => void,
  ) => {
    setIsLoading(true);
    setErrorMessage("");

    try {
      await authFunction();
      // Success is handled by the auth function's onSuccess callback
    } catch (error) {
      const message = error instanceof Error ? error.message : "Authentication failed";
      setErrorMessage(message);
      onError?.(error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleAuthSuccess = async () => {
    queryClient.invalidateQueries({ queryKey: authQueryKey });
    await router.invalidate();
    navigate({ to: redirectUrl });
  };

  const resetError = () => setErrorMessage("");

  return {
    isLoading,
    errorMessage,
    handleAuth,
    handleAuthSuccess,
    resetError,
    setErrorMessage,
    setIsLoading,
  };
}
</file>

<file path="src/features/auth/index.ts">
// Export auth hooks
export { useAuth, useAuthenticatedUser } from "./hooks/useAuth";

// Export components (default exports)
export { default as Login } from "./components/login";
export { default as Signup } from "./components/signup";

// Route guard utilities are available in ~/lib/auth/guards/route-guards
</file>

<file path="src/features/events/utils/jsonb.ts">
import type { Event as DbEvent, EventRegistration } from "~/db/schema";
import type {
  EventAmenities,
  EventDivisions,
  EventMetadata,
  EventPaymentMetadata,
  EventRegistrationRoster,
  EventRequirements,
  EventRules,
  EventSchedule,
} from "../events.db-types";
import type { EventWithDetails } from "../events.types";

export type EventRegistrationWithRoster = Omit<
  EventRegistration,
  "roster" | "paymentMetadata"
> & {
  roster: EventRegistrationRoster;
  paymentMetadata: EventPaymentMetadata | null;
};

export function castEventJsonbFields(event: DbEvent): EventWithDetails {
  return {
    ...event,
    rules: (event.rules || {}) as EventRules,
    schedule: (event.schedule || {}) as EventSchedule,
    divisions: (event.divisions || {}) as EventDivisions,
    amenities: (event.amenities || {}) as EventAmenities,
    requirements: (event.requirements || {}) as EventRequirements,
    metadata: (event.metadata || {}) as EventMetadata,
  } as EventWithDetails;
}

export function castRegistrationJsonbFields(
  registration: EventRegistration,
): EventRegistrationWithRoster {
  return {
    ...registration,
    roster: (registration.roster || {}) as EventRegistrationRoster,
    paymentMetadata: registration.paymentMetadata
      ? (registration.paymentMetadata as EventPaymentMetadata)
      : null,
  };
}
</file>

<file path="src/features/events/events.db-types.ts">
/**
 * Type definitions for events database jsonb fields
 */

/* eslint-disable @typescript-eslint/no-explicit-any */

export interface EventRules {
  [key: string]: any;
}

export interface EventScheduleItem {
  time: string;
  activity: string;
  location?: string;
  notes?: string;
}

export interface EventSchedule {
  items?: EventScheduleItem[];
  [key: string]: any;
}

export interface EventDivision {
  name: string;
  maxTeams?: number;
  description?: string;
  [key: string]: any;
}

export interface EventDivisions {
  divisions?: EventDivision[];
  [key: string]: any;
}

export type EventAmenity = string;

export interface EventAmenities {
  amenities?: EventAmenity[];
  [key: string]: any;
}

export type EventRequirement = string;

export interface EventRequirements {
  requirements?: EventRequirement[];
  [key: string]: any;
}

export interface EventMetadata {
  [key: string]: any;
}

export interface EventRegistrationRosterPlayer {
  userId: string;
  name?: string;
  role?: string;
  jerseyNumber?: string;
  [key: string]: any;
}

export interface EventRegistrationRoster {
  players?: EventRegistrationRosterPlayer[];
  [key: string]: any;
}

export interface EventPaymentMetadata {
  instructionsSnapshot?: string;
  recipient?: string;
  lastReminderAt?: string;
  lastReminderBy?: string;
  markedPaidAt?: string;
  markedPaidBy?: string;
  notes?: string;
  [key: string]: any;
}
</file>

<file path="src/features/layouts/__tests__/admin-layout.test.tsx">
import { beforeEach, describe, expect, it, vi } from "vitest";
import { renderWithRouter, screen } from "~/tests/utils";
import { AdminLayout } from "../admin-layout";

// Mock auth signOut
vi.mock("~/lib/auth-client", () => ({
  auth: {
    signOut: vi.fn(),
  },
}));

describe("AdminLayout with Router", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("renders admin layout with navigation", async () => {
    await renderWithRouter(<AdminLayout />);

    // Check navigation elements - Dashboard appears multiple times
    const dashboardTexts = screen.getAllByText("Dashboard");
    expect(dashboardTexts.length).toBeGreaterThanOrEqual(2);
    expect(screen.getByText("Teams")).toBeInTheDocument();
    expect(screen.getByText("Events")).toBeInTheDocument();

    // Check admin panel header - use getAllByText since it appears in both desktop and mobile views
    const quadballTexts = screen.getAllByText("Quadball Canada");
    expect(quadballTexts).toHaveLength(2); // One for desktop, one for mobile

    // "Admin Panel" text was changed to "Dashboard" in mobile view
    expect(screen.getByText("Admin Panel")).toBeInTheDocument(); // Mobile header still shows Admin Panel
  });

  it("renders with user context", async () => {
    const customUser = {
      id: "admin-user",
      name: "Admin User",
      email: "admin@example.com",
      emailVerified: true,
      image: null,
      createdAt: new Date(),
      updatedAt: new Date(),
      profileComplete: true,
      dateOfBirth: new Date("1990-01-01"),
      phone: "+1234567890",
      gender: "male" as const,
      pronouns: "he/him",
      emergencyContact: JSON.stringify({
        name: "Emergency Contact",
        phone: "+0987654321",
        relationship: "spouse",
      }),
      privacySettings: JSON.stringify({
        showEmail: false,
        showPhone: false,
        showDateOfBirth: false,
      }),
      profileVersion: 1,
      profileUpdatedAt: new Date(),
    };

    await renderWithRouter(<AdminLayout />, { user: customUser });

    // Navigation should still render with custom user
    // Multiple "Dashboard" texts appear (sidebar subtitle and nav link)
    const dashboardTexts = screen.getAllByText("Dashboard");
    expect(dashboardTexts.length).toBeGreaterThanOrEqual(2);

    // Admin Panel still appears in mobile view
    expect(screen.getByText("Admin Panel")).toBeInTheDocument();
  });

  it("handles mobile menu toggle", async () => {
    await renderWithRouter(<AdminLayout />);

    // Mobile menu is hidden by default on desktop
    // The test would need to mock window size to test mobile behavior
    expect(screen.getAllByText("Dashboard")[0]).toBeInTheDocument();
  });

  it("displays all navigation links with correct hrefs", async () => {
    await renderWithRouter(<AdminLayout />);

    const dashboardLinks = screen.getAllByRole("link", { name: /dashboard/i });
    const teamsLinks = screen.getAllByRole("link", { name: /teams/i });
    const eventsLinks = screen.getAllByRole("link", { name: /events/i });

    // Find the navigation links (not header links)
    const dashboardLink = dashboardLinks.find(
      (link) => link.getAttribute("href") === "/dashboard",
    );
    const teamsLink = teamsLinks.find(
      (link) => link.getAttribute("href") === "/dashboard/teams",
    );
    const eventsLink = eventsLinks.find(
      (link) => link.getAttribute("href") === "/dashboard/events",
    );

    expect(dashboardLink).toBeTruthy();
    expect(teamsLink).toBeTruthy();
    expect(eventsLink).toBeTruthy();
  });
});
</file>

<file path="src/features/layouts/admin-layout.tsx">
import { Outlet } from "@tanstack/react-router";
import { X } from "lucide-react";
import { useState } from "react";
import { AdminSidebar } from "~/components/ui/admin-sidebar";
import { Breadcrumbs } from "~/components/ui/breadcrumbs";
import { Button } from "~/components/ui/button";
import { MobileAdminHeader } from "~/components/ui/mobile-admin-header";

export function AdminLayout() {
  const [sidebarOpen, setSidebarOpen] = useState(false);

  return (
    <div className="flex min-h-screen bg-gray-50">
      {/* Desktop Sidebar */}
      <div className="hidden lg:block">
        <AdminSidebar />
      </div>

      {/* Mobile Sidebar Overlay */}
      {sidebarOpen && (
        <div className="fixed inset-0 z-50 lg:hidden">
          <div
            className="fixed inset-0 bg-black/50"
            onClick={() => setSidebarOpen(false)}
          />
          <div className="fixed inset-y-0 left-0 flex w-full max-w-xs flex-col bg-white">
            <div className="flex h-16 items-center justify-between border-b border-gray-200 px-4">
              <h2 className="text-lg font-bold">Menu</h2>
              <Button variant="ghost" size="icon" onClick={() => setSidebarOpen(false)}>
                <X className="h-5 w-5" />
              </Button>
            </div>
            <div className="flex-1 overflow-y-auto">
              <AdminSidebar />
            </div>
          </div>
        </div>
      )}

      {/* Main Content */}
      <div className="flex flex-1 flex-col">
        <MobileAdminHeader onMenuClick={() => setSidebarOpen(true)} />
        <main className="flex-1 p-4 sm:p-6 lg:p-8">
          <div className="mx-auto flex max-w-7xl flex-col gap-6">
            <Breadcrumbs />
            <Outlet />
          </div>
        </main>
      </div>
    </div>
  );
}
</file>

<file path="src/features/layouts/admin-nav.ts">
import type { LucideIcon } from "lucide-react";
import {
  BarChart3,
  Calendar,
  Home,
  Settings,
  ShieldCheck,
  User,
  UserCheck,
  Users,
} from "lucide-react";
import { GLOBAL_ADMIN_ROLE_NAMES } from "~/lib/auth/utils/admin-check";

export type AdminNavItem = {
  label: string;
  to: string;
  icon: LucideIcon;
  exact?: boolean;
  roles?: string[];
};

export const ADMIN_PRIMARY_NAV: AdminNavItem[] = [
  { icon: Home, label: "Dashboard", to: "/dashboard", exact: true },
  { icon: Users, label: "Teams", to: "/dashboard/teams" },
  { icon: Calendar, label: "Events", to: "/dashboard/events" },
  { icon: UserCheck, label: "Members", to: "/dashboard/members" },
  {
    icon: BarChart3,
    label: "Reports",
    to: "/dashboard/reports",
    roles: GLOBAL_ADMIN_ROLE_NAMES,
  },
  {
    icon: ShieldCheck,
    label: "Roles",
    to: "/dashboard/admin/roles",
    roles: GLOBAL_ADMIN_ROLE_NAMES,
  },
];

export const ADMIN_SECONDARY_NAV: AdminNavItem[] = [
  { icon: User, label: "Profile", to: "/dashboard/profile", exact: true },
  { icon: Settings, label: "Settings", to: "/dashboard/settings", exact: true },
];
</file>

<file path="src/features/members/members.schemas.ts">
import { z } from "zod";

export const listMembersSchema = z.object({
  search: z.string().optional(),
  limit: z.int().min(1).max(100).optional().prefault(50),
  offset: z.int().min(0).optional().prefault(0),
});

export type ListMembersInput = z.infer<typeof listMembersSchema>;
</file>

<file path="src/features/membership/__tests__/square.webhook.test.ts">
import { beforeEach, describe, expect, it, vi } from "vitest";
import { __squareWebhookTestUtils } from "~/routes/api/webhooks/square";

const sendMembershipPurchaseReceiptMock = vi.fn();
const getEmailServiceMock = vi.fn();

const finalizeMembershipForSessionMock = vi.fn();
const getDbMock = vi.fn();

vi.mock("~/db/server-helpers", () => ({
  getDb: getDbMock,
}));

vi.mock("~/features/membership/membership.finalize", () => ({
  finalizeMembershipForSession: finalizeMembershipForSessionMock,
}));

vi.mock("~/lib/email/sendgrid", () => ({
  sendMembershipPurchaseReceipt: sendMembershipPurchaseReceiptMock,
  getEmailService: getEmailServiceMock,
}));

describe("square webhook helpers", () => {
  let limit: ReturnType<typeof vi.fn>;
  let from: ReturnType<typeof vi.fn>;
  let where: ReturnType<typeof vi.fn>;
  let select: ReturnType<typeof vi.fn>;
  let updateRecords: Array<{ table: unknown; values: unknown }>;
  let update: ReturnType<typeof vi.fn>;

  const sessionBase = {
    id: "session-1",
    userId: "user-1",
    membershipTypeId: "type-1",
    squareCheckoutId: "checkout-1",
    squarePaymentId: "pay-1",
    squareOrderId: "order-1",
    amountCents: 4500,
    currency: "CAD",
    status: "pending" as const,
    metadata: {},
    updatedAt: new Date(),
    createdAt: new Date(),
  };

  const membershipType = {
    id: "type-1",
    name: "Annual Player Membership",
    description: null,
    priceCents: 4500,
    durationMonths: 12,
    status: "active" as const,
    metadata: {},
    createdAt: new Date(),
    updatedAt: new Date(),
  };

  const chainFactory = () => ({
    from,
    where,
    limit,
  });

  beforeEach(() => {
    limit = vi.fn();
    from = vi.fn(() => chainFactory());
    where = vi.fn(() => chainFactory());
    select = vi.fn(() => chainFactory());

    updateRecords = [];
    update = vi.fn((table: unknown) => ({
      set: (values: unknown) => {
        updateRecords.push({ table, values });
        return {
          where: vi.fn(async () => undefined),
        };
      },
    }));

    sendMembershipPurchaseReceiptMock.mockReset();
    getEmailServiceMock.mockReset();
    finalizeMembershipForSessionMock.mockReset();

    getDbMock.mockResolvedValue({
      select,
      update,
    });

    delete process.env["SUPPORT_EMAIL"];
  });

  it("finalizes membership and sends receipt on completed payment", async () => {
    const membershipSession = { ...sessionBase };

    limit
      .mockResolvedValueOnce([membershipSession]) // find session by payment id
      .mockResolvedValueOnce([membershipType]) // fetch membership type
      .mockResolvedValueOnce([{ email: "member@example.com", name: "Jess" }]); // fetch user

    finalizeMembershipForSessionMock.mockResolvedValue({
      membership: {
        id: "membership-1",
        userId: membershipSession.userId,
        membershipTypeId: membershipType.id,
        startDate: "2025-09-20",
        endDate: "2026-09-20",
        status: "active" as const,
        paymentProvider: "square",
        paymentId: "pay-1",
        metadata: {},
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      wasCreated: true,
    });

    await __squareWebhookTestUtils.finalizeMembershipFromWebhook({
      paymentId: "pay-1",
      orderId: "order-1",
      eventType: "payment.updated",
    });

    expect(finalizeMembershipForSessionMock).toHaveBeenCalledWith(
      expect.objectContaining({
        paymentId: "pay-1",
        orderId: "order-1",
      }),
    );

    expect(sendMembershipPurchaseReceiptMock).toHaveBeenCalledWith(
      expect.objectContaining({
        to: expect.objectContaining({ email: "member@example.com" }),
        membershipType: membershipType.name,
      }),
    );

    expect(updateRecords.length).toBeGreaterThanOrEqual(1);
    // With atomic JSONB merge, metadata is a SQL expression, not a plain object
    // Verify the update was called with updatedAt set
    expect(updateRecords.at(-1)?.values).toMatchObject({
      updatedAt: expect.any(Date),
    });
    // Verify metadata field exists (will be SQL expression)
    expect(
      (updateRecords.at(-1)?.values as Record<string, unknown>)?.["metadata"],
    ).toBeDefined();
  });

  it("cancels membership and notifies support on refund", async () => {
    process.env["SUPPORT_EMAIL"] = "ops@example.com";

    const membership = {
      id: "membership-1",
      userId: sessionBase.userId,
      membershipTypeId: membershipType.id,
      startDate: "2025-09-20",
      endDate: "2026-09-20",
      status: "active" as const,
      paymentProvider: "square",
      paymentId: "pay-1",
      metadata: {},
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    limit.mockResolvedValueOnce([membership]);

    const sendSpy = vi.fn();
    getEmailServiceMock.mockResolvedValue({ send: sendSpy });

    await __squareWebhookTestUtils.handleRefundEvent({
      paymentId: "pay-1",
      refundId: "refund-1",
      status: "COMPLETED",
      eventType: "refund.updated",
    });

    expect(updateRecords.length).toBe(1);
    // With atomic JSONB merge, metadata is a SQL expression, not a plain object
    expect(updateRecords[0].values).toMatchObject({
      status: "cancelled",
      updatedAt: expect.any(Date),
    });
    // Verify metadata field exists (will be SQL expression)
    expect(
      (updateRecords[0].values as Record<string, unknown>)?.["metadata"],
    ).toBeDefined();

    expect(getEmailServiceMock).toHaveBeenCalled();
    expect(sendSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        to: { email: "ops@example.com" },
        subject: expect.stringContaining("Membership refund"),
      }),
    );
  });
});
</file>

<file path="src/features/membership/hooks/usePaymentReturn.ts">
import { useMemo } from "react";

export interface PaymentReturnParams {
  isMockCheckout: boolean;
  sessionId: string | null;
  success: boolean;
  error: string | null;
  paymentId: string | null;
  membershipTypeId: string | null;
}

/**
 * Parse payment return parameters from URL without using useEffect
 * This hook extracts payment-related query parameters for processing
 */
export function usePaymentReturn(): PaymentReturnParams {
  return useMemo(() => {
    if (typeof window === "undefined") {
      return {
        isMockCheckout: false,
        sessionId: null,
        success: false,
        error: null,
        paymentId: null,
        membershipTypeId: null,
      };
    }

    const searchParams = new URLSearchParams(window.location.search);

    const parseParam = (value: string | null): string | boolean | null => {
      if (value === null) return null;
      try {
        return JSON.parse(value);
      } catch {
        // If the value isn't JSON-encoded, fall back to the raw string
        return value;
      }
    };

    const asString = (value: string | boolean | null): string | null => {
      if (typeof value === "string") return value;
      if (typeof value === "boolean") return value ? "true" : "false";
      return null;
    };

    const successRaw = parseParam(searchParams.get("success"));
    const paymentIdRaw = parseParam(searchParams.get("payment_id"));
    const sessionRaw = parseParam(searchParams.get("session"));
    const typeRaw = parseParam(searchParams.get("type"));
    const errorRaw = parseParam(searchParams.get("error"));
    const mockCheckoutRaw = parseParam(searchParams.get("mock_checkout"));

    return {
      isMockCheckout: mockCheckoutRaw === true || mockCheckoutRaw === "true",
      sessionId: asString(sessionRaw),
      success: successRaw === true || successRaw === "true",
      error: asString(errorRaw),
      paymentId: asString(paymentIdRaw),
      membershipTypeId: asString(typeRaw),
    };
  }, []); // Empty deps since URL doesn't change after mount
}

/**
 * Get appropriate error message for payment errors
 */
export function getPaymentErrorMessage(error: string | null): string | null {
  if (!error) return null;

  const errorMessages: Record<string, string> = {
    cancelled: "Payment was cancelled",
    verification_failed: "Payment verification failed",
    processing_error: "An error occurred while processing your payment",
  };

  return errorMessages[error] || "Payment failed";
}

/**
 * Clear payment-related query parameters from URL
 */
export function clearPaymentParams(): void {
  if (typeof window !== "undefined") {
    window.history.replaceState({}, document.title, window.location.pathname);
  }
}
</file>

<file path="src/features/membership/membership.db-types.ts">
/**
 * Type definitions for membership database jsonb fields
 */

/* eslint-disable @typescript-eslint/no-explicit-any */

export interface MembershipMetadata {
  [key: string]: any;
  paymentDetails?: Record<string, any>;
  notes?: string;
}
</file>

<file path="src/features/membership/membership.finalize.ts">
import { eq } from "drizzle-orm";
import type {
  Membership,
  MembershipPaymentSession,
  MembershipType,
} from "~/db/schema/membership.schema";
import { membershipPaymentSessions, memberships } from "~/db/schema/membership.schema";
import type { getDb } from "~/db/server-helpers";
import { atomicJsonbMerge } from "~/lib/db/jsonb-utils";

export type MembershipPaymentSessionRow = MembershipPaymentSession;
export type MembershipTypeRow = MembershipType;
export type MembershipRow = Membership;

export type MembershipDbClient = Awaited<ReturnType<typeof getDb>>;

export interface FinalizeMembershipParams {
  db: MembershipDbClient;
  paymentSession: MembershipPaymentSessionRow;
  membershipType: MembershipTypeRow;
  paymentId: string;
  orderId?: string | null;
  sessionId: string;
  now: Date;
}

export interface FinalizeMembershipResult {
  membership: MembershipRow;
  wasCreated: boolean;
}

export async function finalizeMembershipForSession({
  db,
  paymentSession,
  membershipType,
  paymentId,
  orderId,
  sessionId,
  now,
}: FinalizeMembershipParams): Promise<FinalizeMembershipResult> {
  const nowIso = now.toISOString();
  const resolvedOrderId = orderId ?? paymentSession.squareOrderId ?? null;

  return db.transaction(async (tx) => {
    const [existingMembershipByPayment] = await tx
      .select()
      .from(memberships)
      .where(eq(memberships.paymentId, paymentId))
      .limit(1);

    if (existingMembershipByPayment) {
      await tx
        .update(membershipPaymentSessions)
        .set({
          status: "completed",
          squarePaymentId: paymentId,
          squareOrderId: resolvedOrderId,
          metadata: atomicJsonbMerge(membershipPaymentSessions.metadata, {
            membershipId: existingMembershipByPayment.id,
            paymentConfirmedAt: nowIso,
            squareOrderId: resolvedOrderId,
            squareTransactionId: paymentId,
          }),
          updatedAt: now,
        })
        .where(eq(membershipPaymentSessions.id, paymentSession.id));

      return {
        membership: existingMembershipByPayment,
        wasCreated: false,
      } satisfies FinalizeMembershipResult;
    }

    const startDate = new Date(now);
    const endDate = new Date(now);
    endDate.setMonth(endDate.getMonth() + membershipType.durationMonths);

    const membershipMetadata: Record<string, unknown> = {
      ...(paymentSession.metadata ?? {}),
      sessionId,
      purchasedAt: nowIso,
      squareTransactionId: paymentId,
    };

    if (resolvedOrderId) {
      membershipMetadata["squareOrderId"] = resolvedOrderId;
    }

    const [newMembership] = await tx
      .insert(memberships)
      .values({
        userId: paymentSession.userId,
        membershipTypeId: membershipType.id,
        startDate: startDate.toISOString().split("T")[0],
        endDate: endDate.toISOString().split("T")[0],
        status: "active",
        paymentProvider: "square",
        paymentId,
        metadata: membershipMetadata,
      })
      .returning();

    await tx
      .update(membershipPaymentSessions)
      .set({
        status: "completed",
        squarePaymentId: paymentId,
        squareOrderId: resolvedOrderId,
        metadata: atomicJsonbMerge(membershipPaymentSessions.metadata, {
          membershipId: newMembership.id,
          paymentConfirmedAt: nowIso,
          squareOrderId: resolvedOrderId,
          squareTransactionId: paymentId,
        }),
        updatedAt: now,
      })
      .where(eq(membershipPaymentSessions.id, paymentSession.id));

    return {
      membership: newMembership,
      wasCreated: true,
    } satisfies FinalizeMembershipResult;
  });
}
</file>

<file path="src/features/membership/membership.schemas.ts">
import { z } from "zod";

// Query schemas
export const getMembershipTypeSchema = z.object({
  membershipTypeId: z.string(),
});
export type GetMembershipTypeInput = z.infer<typeof getMembershipTypeSchema>;

// Mutation schemas
export const purchaseMembershipSchema = z.object({
  membershipTypeId: z.string(),
  autoRenew: z.boolean().prefault(false),
});
export type PurchaseMembershipInput = z.infer<typeof purchaseMembershipSchema>;

export const cancelMembershipSchema = z.object({
  membershipId: z.string(),
  reason: z.string().optional(),
  immediate: z.boolean().prefault(false),
});
export type CancelMembershipInput = z.infer<typeof cancelMembershipSchema>;

export const confirmMembershipPurchaseSchema = z.object({
  membershipTypeId: z.string(),
  sessionId: z.string(),
  paymentId: z.string().optional(),
});
export type ConfirmMembershipPurchaseInput = z.infer<
  typeof confirmMembershipPurchaseSchema
>;
</file>

<file path="src/features/membership/membership.types.ts">
// Define types manually since we can't import from schema at top level
import type { MembershipMetadata } from "./membership.db-types";
export interface MembershipType {
  id: string;
  name: string;
  description: string | null;
  priceCents: number;
  durationMonths: number;
  status: "active" | "inactive";
  metadata: MembershipMetadata | null;
  createdAt: Date;
  updatedAt: Date;
}

export interface Membership {
  id: string;
  userId: string;
  membershipTypeId: string;
  /** ISO date string (YYYY-MM-DD) from database date column */
  startDate: string;
  /** ISO date string (YYYY-MM-DD) from database date column */
  endDate: string;
  status: "active" | "cancelled" | "expired";
  paymentId: string | null;
  metadata: MembershipMetadata | null;
  createdAt: Date;
  updatedAt: Date;
}

export interface MembershipOperationResult<T = unknown> {
  success: boolean;
  data?: T;
  errors?: Array<{
    code: "VALIDATION_ERROR" | "DATABASE_ERROR" | "PAYMENT_ERROR" | "NOT_FOUND";
    field?: string;
    message: string;
  }>;
}

export interface CheckoutSessionResult {
  checkoutUrl: string;
  sessionId: string;
}

export interface MembershipPurchaseInput {
  membershipTypeId: string;
  sessionId: string;
  paymentId?: string;
}

export interface UserMembership extends Membership {
  membershipType: MembershipType;
}

export interface MembershipStatus {
  hasMembership: boolean;
  currentMembership?: UserMembership;
  expiresAt?: Date;
  daysRemaining?: number;
}
</file>

<file path="src/features/roles/permission.server.ts">
import { createServerOnlyFn } from "@tanstack/react-start";
import { and, eq, inArray } from "drizzle-orm";
import { roles, userRoles } from "~/db/schema";

/**
 * Server-side permission service
 * All methods here use database queries and should only be called on the server
 */
export class PermissionService {
  /**
   * Check if a user has global admin permissions
   */
  static isGlobalAdmin = createServerOnlyFn(async (userId: string): Promise<boolean> => {
    const { getDb } = await import("~/db/server-helpers");
    const db = await getDb();

    const [row] = await db
      .select()
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(
        and(
          eq(userRoles.userId, userId),
          inArray(roles.name, ["Solstice Admin", "Quadball Canada Admin"]),
        ),
      )
      .limit(1);

    return !!row;
  });

  /**
   * Check if a user can manage a specific team
   */
  static canManageTeam = createServerOnlyFn(
    async (userId: string, teamId: string): Promise<boolean> => {
      // Global admins can manage any team
      if (await PermissionService.isGlobalAdmin(userId)) return true;

      const { getDb } = await import("~/db/server-helpers");
      const db = await getDb();

      // Check for team-specific admin role
      const [row] = await db
        .select()
        .from(userRoles)
        .innerJoin(roles, eq(userRoles.roleId, roles.id))
        .where(
          and(
            eq(userRoles.userId, userId),
            eq(roles.name, "Team Admin"),
            eq(userRoles.teamId, teamId),
          ),
        )
        .limit(1);

      return !!row;
    },
  );

  /**
   * Check if a user can manage a specific event
   */
  static canManageEvent = createServerOnlyFn(
    async (userId: string, eventId: string): Promise<boolean> => {
      // Global admins can manage any event
      if (await PermissionService.isGlobalAdmin(userId)) return true;

      const { getDb } = await import("~/db/server-helpers");
      const db = await getDb();

      // Check for event-specific admin role
      const [row] = await db
        .select()
        .from(userRoles)
        .innerJoin(roles, eq(userRoles.roleId, roles.id))
        .where(
          and(
            eq(userRoles.userId, userId),
            eq(roles.name, "Event Admin"),
            eq(userRoles.eventId, eventId),
          ),
        )
        .limit(1);

      return !!row;
    },
  );

  /**
   * Get all roles for a user including scope information
   */
  static getUserRoles = createServerOnlyFn(async (userId: string) => {
    const { getDb } = await import("~/db/server-helpers");
    const db = await getDb();

    const userRolesList = await db
      .select({
        id: userRoles.id,
        userId: userRoles.userId,
        roleId: userRoles.roleId,
        teamId: userRoles.teamId,
        eventId: userRoles.eventId,
        assignedBy: userRoles.assignedBy,
        assignedAt: userRoles.assignedAt,
        expiresAt: userRoles.expiresAt,
        notes: userRoles.notes,
        role: {
          id: roles.id,
          name: roles.name,
          description: roles.description,
          permissions: roles.permissions,
        },
      })
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(eq(userRoles.userId, userId));

    return userRolesList;
  });
}
</file>

<file path="src/features/roles/permission.service.ts">
import { and, eq, inArray } from "drizzle-orm";
import { roles, userRoles } from "~/db/schema";

export class PermissionService {
  /**
   * Check if a user has global admin permissions
   */
  static async isGlobalAdmin(userId: string): Promise<boolean> {
    const { db } = await import("~/db");
    const database = await db();
    const [row] = await database
      .select()
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(
        and(
          eq(userRoles.userId, userId),
          inArray(roles.name, ["Solstice Admin", "Quadball Canada Admin"]),
        ),
      )
      .limit(1);

    return !!row;
  }

  /**
   * Check if a user can manage a specific team
   */
  static async canManageTeam(userId: string, teamId: string): Promise<boolean> {
    // Global admins can manage any team
    if (await this.isGlobalAdmin(userId)) return true;

    // Check for team-specific admin role
    const { db } = await import("~/db");
    const database = await db();
    const [row] = await database
      .select()
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(
        and(
          eq(userRoles.userId, userId),
          eq(roles.name, "Team Admin"),
          eq(userRoles.teamId, teamId),
        ),
      )
      .limit(1);

    return !!row;
  }

  /**
   * Check if a user can manage a specific event
   */
  static async canManageEvent(userId: string, eventId: string): Promise<boolean> {
    // Global admins can manage any event
    if (await this.isGlobalAdmin(userId)) return true;

    // Check for event-specific admin role
    const { db } = await import("~/db");
    const database = await db();
    const [row] = await database
      .select()
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(
        and(
          eq(userRoles.userId, userId),
          eq(roles.name, "Event Admin"),
          eq(userRoles.eventId, eventId),
        ),
      )
      .limit(1);

    return !!row;
  }

  /**
   * Get all roles for a user including scope information
   */
  static async getUserRoles(userId: string) {
    const { db } = await import("~/db");
    const database = await db();
    const userRolesList = await database
      .select({
        id: userRoles.id,
        userId: userRoles.userId,
        roleId: userRoles.roleId,
        teamId: userRoles.teamId,
        eventId: userRoles.eventId,
        assignedBy: userRoles.assignedBy,
        assignedAt: userRoles.assignedAt,
        expiresAt: userRoles.expiresAt,
        notes: userRoles.notes,
        role: {
          id: roles.id,
          name: roles.name,
          description: roles.description,
          permissions: roles.permissions,
        },
      })
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(eq(userRoles.userId, userId));

    return userRolesList;
  }
}

/**
 * Client-side helper to check if a user has a specific role
 * This is for UI display purposes only - actual authorization happens server-side
 */
export function userHasRole(
  user: {
    roles?: Array<{
      role: { name: string };
      teamId?: string | null;
      eventId?: string | null;
    }>;
  },
  roleName: string,
  options?: { teamId?: string; eventId?: string },
): boolean {
  if (!user.roles) return false;

  return user.roles.some((userRole) => {
    if (userRole.role.name !== roleName) return false;

    // For global roles
    if (!options?.teamId && !options?.eventId) {
      return !userRole.teamId && !userRole.eventId;
    }

    // For team-specific roles
    if (options.teamId) {
      return userRole.teamId === options.teamId;
    }

    // For event-specific roles
    if (options.eventId) {
      return userRole.eventId === options.eventId;
    }

    return false;
  });
}

/**
 * Client-side helper to check if user is any kind of admin
 */
export function isAnyAdmin(user: { roles?: Array<{ role: { name: string } }> }): boolean {
  if (!user.roles) return false;

  return user.roles.some((userRole) =>
    ["Solstice Admin", "Quadball Canada Admin", "Team Admin", "Event Admin"].includes(
      userRole.role.name,
    ),
  );
}
</file>

<file path="src/features/settings/components/settings-view.tsx">
import { useForm } from "@tanstack/react-form";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { formatDistanceToNow } from "date-fns";
import {
  AlertCircle,
  CheckCircle2,
  ExternalLink,
  Loader2,
  LogOut,
  Shield,
  Trash2,
} from "lucide-react";
import { useMemo, useState } from "react";
import { toast } from "sonner";
import { ValidatedCheckbox } from "~/components/form-fields/ValidatedCheckbox";
import { ValidatedInput } from "~/components/form-fields/ValidatedInput";
import { Alert, AlertDescription, AlertTitle } from "~/components/ui/alert";
import { Badge } from "~/components/ui/badge";
import { Button } from "~/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";
import { Skeleton } from "~/components/ui/skeleton";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "~/components/ui/table";
import type {
  ChangePasswordInput,
  LinkedAccountsOverview,
  SessionsOverview,
} from "~/features/settings";
import {
  changePassword,
  getAccountOverview,
  getSessionsOverview,
  revokeOtherSessions,
  revokeSession,
  unlinkAccount,
} from "~/features/settings";
import { auth } from "~/lib/auth-client";
import {
  getPasswordStrength,
  getPasswordStrengthLabel,
  validatePassword,
} from "~/lib/security/utils/password-validator";

interface AccountOverviewResult extends LinkedAccountsOverview {
  user: { id: string; name: string; email: string; emailVerified: boolean };
  hasPassword: boolean;
  availableProviders: string[];
}

type ChangePasswordFormValues = ChangePasswordInput & {
  confirmPassword: string;
};

function formatUserAgent(agent: string | null | undefined) {
  if (!agent) return "Unknown device";
  if (agent.toLowerCase().includes("mobile")) return "Mobile device";
  if (agent.toLowerCase().includes("mac")) return "macOS";
  if (agent.toLowerCase().includes("windows")) return "Windows";
  if (agent.toLowerCase().includes("linux")) return "Linux";
  return agent.split(" ")[0] ?? "Unknown";
}

function maskToken(token: string) {
  if (token.length <= 8) return "â¢â¢â¢â¢";
  return `${token.slice(0, 4)}â¢â¢â¢â¢${token.slice(-4)}`;
}

export function SettingsView() {
  const queryClient = useQueryClient();
  const [passwordError, setPasswordError] = useState<string | null>(null);

  const {
    data: accountOverview,
    isLoading: accountLoading,
    isFetching: accountFetching,
    error: accountError,
  } = useQuery({
    queryKey: ["account-overview"],
    queryFn: async (): Promise<AccountOverviewResult> => {
      const result = await getAccountOverview();
      if (!result.success || !result.data) {
        throw new Error(result.errors?.[0]?.message || "Failed to load account overview");
      }
      return result.data;
    },
    staleTime: 60_000,
  });

  const {
    data: sessionsData,
    isLoading: sessionsLoading,
    isFetching: sessionsFetching,
    error: sessionsError,
  } = useQuery({
    queryKey: ["sessions-overview"],
    queryFn: async (): Promise<SessionsOverview> => {
      const result = await getSessionsOverview();
      if (!result.success || !result.data) {
        throw new Error(result.errors?.[0]?.message || "Failed to load sessions");
      }
      return result.data;
    },
    refetchInterval: 60_000,
  });

  const changePasswordMutation = useMutation({
    mutationFn: async (input: ChangePasswordInput) => changePassword({ data: input }),
    onSuccess: (result) => {
      if (result.success) {
        toast.success("Password updated");
        queryClient.invalidateQueries({ queryKey: ["account-overview"] });
      } else {
        const message = result.errors?.[0]?.message || "Failed to update password";
        toast.error(message);
        throw new Error(message);
      }
    },
    onError: (error: unknown) => {
      const message =
        error instanceof Error ? error.message : "Failed to update password";
      toast.error(message);
    },
  });

  const revokeSessionMutation = useMutation({
    mutationFn: async (token: string) => revokeSession({ data: { token } }),
    onSuccess: async (result) => {
      if (!result.success) {
        const message = result.errors?.[0]?.message || "Failed to revoke session";
        toast.error(message);
        throw new Error(message);
      }
      toast.success("Session revoked");
      await queryClient.invalidateQueries({ queryKey: ["sessions-overview"] });
    },
    onError: (error: unknown) => {
      const message = error instanceof Error ? error.message : "Failed to revoke session";
      toast.error(message);
    },
  });

  const revokeOthersMutation = useMutation({
    mutationFn: async () => revokeOtherSessions(),
    onSuccess: async (result) => {
      if (!result.success) {
        const message = result.errors?.[0]?.message || "Failed to revoke other sessions";
        toast.error(message);
        throw new Error(message);
      }
      toast.success("Other sessions revoked");
      await queryClient.invalidateQueries({ queryKey: ["sessions-overview"] });
    },
    onError: (error: unknown) => {
      const message =
        error instanceof Error ? error.message : "Failed to revoke other sessions";
      toast.error(message);
    },
  });

  const unlinkAccountMutation = useMutation({
    mutationFn: async (variables: { providerId: string; accountId?: string }) =>
      unlinkAccount({ data: variables }),
    onSuccess: async (result) => {
      if (!result.success) {
        const message = result.errors?.[0]?.message || "Failed to unlink account";
        toast.error(message);
        throw new Error(message);
      }
      toast.success("Account disconnected");
      await queryClient.invalidateQueries({ queryKey: ["account-overview"] });
    },
    onError: (error: unknown) => {
      const message = error instanceof Error ? error.message : "Failed to unlink account";
      toast.error(message);
    },
  });

  const changePasswordForm = useForm({
    defaultValues: {
      currentPassword: "",
      newPassword: "",
      confirmPassword: "",
      revokeOtherSessions: true,
    } as ChangePasswordFormValues,
    onSubmit: async ({ value, formApi }) => {
      const formValues = value as ChangePasswordFormValues;
      setPasswordError(null);

      if (formValues.newPassword !== formValues.confirmPassword) {
        setPasswordError("New password and confirmation do not match");
        return;
      }

      const validation = validatePassword(formValues.newPassword);
      if (!validation.isValid) {
        setPasswordError(validation.errors[0] ?? "Password does not meet requirements");
        return;
      }

      try {
        await changePasswordMutation.mutateAsync({
          currentPassword: formValues.currentPassword,
          newPassword: formValues.newPassword,
          revokeOtherSessions: formValues.revokeOtherSessions,
        });

        formApi.reset();
      } catch (error) {
        const message =
          error instanceof Error
            ? error.message
            : "Failed to update password. Please try again.";
        setPasswordError(message);
      }
    },
  });

  const pendingChangePassword = changePasswordMutation.isPending;
  const passwordStrength = (() => {
    const password = (changePasswordForm.state.values as ChangePasswordFormValues)
      .newPassword;
    if (!password) return null;
    const score = getPasswordStrength(password);
    return {
      score,
      label: getPasswordStrengthLabel(score),
    };
  })();

  const otherSessions = useMemo(() => {
    if (!sessionsData) return [];
    return sessionsData.sessions.filter((session) => !session.isCurrent);
  }, [sessionsData]);

  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-3xl font-bold tracking-tight">Account Settings</h1>
        <p className="text-muted-foreground mt-2">
          Manage your account security, sessions, and connected services
        </p>
      </div>

      <div className="grid gap-6 lg:grid-cols-[1.4fr,1fr]">
        <div className="space-y-6">
          <Card>
            <CardHeader>
              <CardTitle>Change Password</CardTitle>
              <CardDescription>
                Update your password to keep your account secure.
              </CardDescription>
            </CardHeader>
            <CardContent>
              {accountLoading ? (
                <div className="space-y-3">
                  <Skeleton className="h-10 w-full" />
                  <Skeleton className="h-10 w-full" />
                  <Skeleton className="h-5 w-32" />
                </div>
              ) : (
                <form
                  className="space-y-4"
                  onSubmit={(event) => {
                    event.preventDefault();
                    changePasswordForm.handleSubmit();
                  }}
                >
                  {accountOverview?.user.email ? (
                    <input
                      type="email"
                      name="username"
                      autoComplete="username"
                      value={accountOverview.user.email}
                      readOnly
                      tabIndex={-1}
                      className="sr-only"
                    />
                  ) : null}

                  <changePasswordForm.Field name="currentPassword">
                    {(field) => (
                      <ValidatedInput
                        field={field}
                        type="password"
                        label="Current password"
                        autoComplete="current-password"
                        placeholder="Enter your current password"
                      />
                    )}
                  </changePasswordForm.Field>

                  <changePasswordForm.Field name="newPassword">
                    {(field) => (
                      <ValidatedInput
                        field={field}
                        type="password"
                        label="New password"
                        autoComplete="new-password"
                        placeholder="Create a strong password"
                      />
                    )}
                  </changePasswordForm.Field>

                  {passwordStrength ? (
                    <div className="text-muted-foreground text-sm">
                      Password strength:{" "}
                      <span className="font-medium">{passwordStrength.label}</span>
                    </div>
                  ) : null}

                  <changePasswordForm.Field name="confirmPassword">
                    {(field) => (
                      <ValidatedInput
                        field={field}
                        type="password"
                        label="Confirm new password"
                        autoComplete="new-password"
                        placeholder="Re-enter your new password"
                      />
                    )}
                  </changePasswordForm.Field>

                  <changePasswordForm.Field name="revokeOtherSessions">
                    {(field) => (
                      <ValidatedCheckbox
                        field={field}
                        label="Sign out of other devices"
                        description="End active sessions on other browsers and devices"
                      />
                    )}
                  </changePasswordForm.Field>

                  {passwordError ? (
                    <Alert variant="destructive">
                      <AlertCircle className="h-4 w-4" />
                      <AlertTitle>Unable to update password</AlertTitle>
                      <AlertDescription>{passwordError}</AlertDescription>
                    </Alert>
                  ) : null}

                  <div className="flex items-center justify-end gap-2">
                    <Button
                      type="submit"
                      disabled={pendingChangePassword}
                      className="min-w-[140px]"
                    >
                      {pendingChangePassword ? (
                        <>
                          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                          Updating...
                        </>
                      ) : (
                        "Update password"
                      )}
                    </Button>
                  </div>
                </form>
              )}
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle>Active Sessions</CardTitle>
              <CardDescription>
                Review browsers and devices that are currently signed in.
              </CardDescription>
            </CardHeader>
            <CardContent>
              {sessionsLoading ? (
                <div className="space-y-3">
                  <Skeleton className="h-10 w-full" />
                  <Skeleton className="h-10 w-full" />
                  <Skeleton className="h-10 w-full" />
                </div>
              ) : sessionsError ? (
                <Alert variant="destructive">
                  <AlertCircle className="h-4 w-4" />
                  <AlertTitle>Unable to load sessions</AlertTitle>
                  <AlertDescription>
                    {(sessionsError as Error).message ||
                      "Please refresh the page and try again."}
                  </AlertDescription>
                </Alert>
              ) : sessionsData ? (
                <div className="space-y-4">
                  <Table>
                    <TableHeader>
                      <TableRow>
                        <TableHead>Device</TableHead>
                        <TableHead>Location</TableHead>
                        <TableHead>Last active</TableHead>
                        <TableHead className="text-right">Actions</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {sessionsData.sessions.map((session) => (
                        <TableRow
                          key={session.id}
                          data-state={session.isCurrent ? "selected" : undefined}
                        >
                          <TableCell>
                            <div className="flex flex-col">
                              <span className="font-medium">
                                {session.isCurrent
                                  ? "This device"
                                  : formatUserAgent(session.userAgent)}
                              </span>
                              <span className="text-muted-foreground text-xs">
                                Session ID: {maskToken(session.token)}
                              </span>
                            </div>
                          </TableCell>
                          <TableCell>{session.ipAddress ?? "Unknown"}</TableCell>
                          <TableCell>
                            {formatDistanceToNow(new Date(session.updatedAt), {
                              addSuffix: true,
                            })}
                          </TableCell>
                          <TableCell className="text-right">
                            {session.isCurrent ? (
                              <Badge
                                variant="secondary"
                                className="bg-green-100 text-green-800"
                              >
                                Current
                              </Badge>
                            ) : (
                              <Button
                                variant="ghost"
                                size="sm"
                                onClick={() =>
                                  revokeSessionMutation.mutate(session.token)
                                }
                                disabled={revokeSessionMutation.isPending}
                              >
                                {revokeSessionMutation.isPending ? (
                                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                                ) : (
                                  <LogOut className="mr-2 h-4 w-4" />
                                )}
                                Revoke
                              </Button>
                            )}
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>

                  {otherSessions.length > 0 ? (
                    <Button
                      variant="outline"
                      onClick={() => revokeOthersMutation.mutate()}
                      disabled={revokeOthersMutation.isPending}
                    >
                      {revokeOthersMutation.isPending ? (
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                      ) : (
                        <Shield className="mr-2 h-4 w-4" />
                      )}
                      Sign out of all other sessions
                    </Button>
                  ) : (
                    <div className="text-muted-foreground text-sm">
                      Only your current session is active.
                    </div>
                  )}

                  {sessionsFetching ? (
                    <div className="text-muted-foreground flex items-center gap-2 text-xs">
                      <Loader2 className="h-3 w-3 animate-spin" />
                      Refreshing session data...
                    </div>
                  ) : null}
                </div>
              ) : null}
            </CardContent>
          </Card>
        </div>

        <div className="space-y-6">
          <Card>
            <CardHeader>
              <CardTitle>Account status</CardTitle>
              <CardDescription>Overview of your primary account details.</CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              {accountLoading ? (
                <div className="space-y-3">
                  <Skeleton className="h-4 w-2/3" />
                  <Skeleton className="h-4 w-1/2" />
                  <Skeleton className="h-4 w-1/3" />
                </div>
              ) : accountError ? (
                <Alert variant="destructive">
                  <AlertCircle className="h-4 w-4" />
                  <AlertTitle>Unable to load account</AlertTitle>
                  <AlertDescription>
                    {(accountError as Error).message ||
                      "Please refresh the page and try again."}
                  </AlertDescription>
                </Alert>
              ) : accountOverview ? (
                <div className="space-y-3">
                  <div>
                    <div className="text-muted-foreground text-sm font-medium">Name</div>
                    <div className="text-sm">{accountOverview.user.name}</div>
                  </div>
                  <div>
                    <div className="text-muted-foreground text-sm font-medium">Email</div>
                    <div className="flex items-center gap-2 text-sm">
                      <span>{accountOverview.user.email}</span>
                      {accountOverview.user.emailVerified ? (
                        <Badge
                          variant="secondary"
                          className="bg-green-100 text-green-800"
                        >
                          <CheckCircle2 className="mr-1 h-3 w-3" /> Verified
                        </Badge>
                      ) : (
                        <Badge
                          variant="outline"
                          className="border-amber-400 text-amber-700"
                        >
                          <AlertCircle className="mr-1 h-3 w-3" /> Not verified
                        </Badge>
                      )}
                    </div>
                  </div>
                  <div>
                    <div className="text-muted-foreground text-sm font-medium">
                      Password
                    </div>
                    <div className="flex items-center gap-2 text-sm">
                      <span>
                        {accountOverview.hasPassword ? "Set" : "Not configured"}
                      </span>
                      {!accountOverview.hasPassword ? (
                        <Badge variant="outline" className="border-red-400 text-red-700">
                          Required
                        </Badge>
                      ) : null}
                    </div>
                  </div>

                  {accountFetching ? (
                    <div className="text-muted-foreground flex items-center gap-2 text-xs">
                      <Loader2 className="h-3 w-3 animate-spin" />
                      Refreshing account info...
                    </div>
                  ) : null}
                </div>
              ) : null}
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle>Connected accounts</CardTitle>
              <CardDescription>Manage social logins and linked services.</CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              {accountLoading ? (
                <div className="space-y-3">
                  <Skeleton className="h-12 w-full" />
                  <Skeleton className="h-12 w-full" />
                </div>
              ) : accountOverview ? (
                <div className="space-y-3">
                  {accountOverview.availableProviders.map((providerId) => {
                    if (providerId === "email") {
                      return (
                        <div
                          key={providerId}
                          className="border-border flex items-center justify-between rounded-lg border p-3"
                        >
                          <div className="space-y-1">
                            <div className="font-medium">Email &amp; password</div>
                            <p className="text-muted-foreground text-sm">
                              {accountOverview.hasPassword
                                ? "You can sign in with your email and password."
                                : "Set a password to allow email-based sign in."}
                            </p>
                          </div>
                          <Button
                            variant="outline"
                            onClick={() => {
                              const focusElement = document.querySelector(
                                'input[name="currentPassword"]',
                              ) as HTMLInputElement | null;
                              focusElement?.focus();
                            }}
                          >
                            Update password
                          </Button>
                        </div>
                      );
                    }

                    const account = accountOverview.accounts.find(
                      (item) => item.providerId === providerId,
                    );

                    const isLinked = Boolean(account);

                    return (
                      <div
                        key={providerId}
                        className="border-border flex items-center justify-between rounded-lg border p-3"
                      >
                        <div className="space-y-1">
                          <div className="flex items-center gap-2">
                            <span className="font-medium capitalize">{providerId}</span>
                            {isLinked ? (
                              <Badge
                                variant="secondary"
                                className="bg-green-100 text-green-800"
                              >
                                Connected
                              </Badge>
                            ) : (
                              <Badge variant="outline">Not connected</Badge>
                            )}
                          </div>
                          <p className="text-muted-foreground text-sm">
                            {isLinked
                              ? "You can sign in using this provider."
                              : "Connect this provider to sign in without a password."}
                          </p>
                        </div>
                        {isLinked ? (
                          <Button
                            variant="ghost"
                            onClick={() => {
                              if (account?.accountId) {
                                unlinkAccountMutation.mutate({
                                  providerId,
                                  accountId: account.accountId,
                                });
                              } else {
                                unlinkAccountMutation.mutate({ providerId });
                              }
                            }}
                            disabled={unlinkAccountMutation.isPending}
                          >
                            {unlinkAccountMutation.isPending ? (
                              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                            ) : (
                              <Trash2 className="mr-2 h-4 w-4" />
                            )}
                            Disconnect
                          </Button>
                        ) : (
                          <Button
                            variant="outline"
                            onClick={() =>
                              auth.signInWithOAuth(
                                {
                                  provider: providerId as "google",
                                  callbackURL: window.location.href,
                                },
                                {
                                  onRequest: () => {
                                    toast.message("Redirecting to provider...");
                                  },
                                  onError: (ctx: unknown) => {
                                    const errorContext =
                                      ctx && typeof ctx === "object" && "error" in ctx
                                        ? (ctx as { error?: { message?: string } })
                                        : undefined;
                                    const errorMessage =
                                      errorContext?.error?.message ||
                                      "Failed to connect account";
                                    toast.error(errorMessage);
                                  },
                                },
                              )
                            }
                          >
                            <ExternalLink className="mr-2 h-4 w-4" />
                            Connect
                          </Button>
                        )}
                      </div>
                    );
                  })}
                </div>
              ) : null}
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/features/settings/settings.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import type {
  ApiResult,
  LinkedAccountsOverview,
  SessionsOverview,
} from "./settings.types";

const AVAILABLE_PROVIDERS = ["email", "google"] as const;

export const getSessionsOverview = createServerFn({ method: "GET" }).handler(
  async (): Promise<ApiResult<SessionsOverview>> => {
    try {
      const [{ getAuth }, { getRequest }] = await Promise.all([
        import("~/lib/auth/server-helpers"),
        import("@tanstack/react-start/server"),
      ]);

      const auth = await getAuth();
      const { headers } = getRequest();

      const [sessionResult, sessions] = await Promise.all([
        auth.api.getSession({ headers }),
        auth.api.listSessions({ headers }),
      ]);

      if (!sessionResult?.session?.token) {
        return {
          success: false,
          errors: [{ code: "UNAUTHENTICATED", message: "User not authenticated" }],
        };
      }

      const currentToken = sessionResult.session.token;

      const data: SessionsOverview = {
        currentSessionToken: currentToken,
        sessions: sessions.map((session) => ({
          id: session.id,
          token: session.token,
          createdAt: session.createdAt.toISOString(),
          updatedAt: session.updatedAt.toISOString(),
          expiresAt: session.expiresAt.toISOString(),
          ipAddress: session.ipAddress ?? null,
          userAgent: session.userAgent ?? null,
          isCurrent: session.token === currentToken,
        })),
      };

      return { success: true, data };
    } catch (error) {
      console.error("Failed to load sessions overview", error);
      return {
        success: false,
        errors: [
          {
            code: "UNKNOWN_ERROR",
            message: "Failed to load active sessions",
          },
        ],
      };
    }
  },
);

export const getAccountOverview = createServerFn({ method: "GET" }).handler(
  async (): Promise<
    ApiResult<
      LinkedAccountsOverview & {
        user: { id: string; name: string; email: string; emailVerified: boolean };
        hasPassword: boolean;
        availableProviders: string[];
      }
    >
  > => {
    try {
      const [{ getAuth }, { getRequest }] = await Promise.all([
        import("~/lib/auth/server-helpers"),
        import("@tanstack/react-start/server"),
      ]);

      const auth = await getAuth();
      const { headers } = getRequest();

      const sessionResult = await auth.api.getSession({ headers });
      if (!sessionResult?.user?.id) {
        return {
          success: false,
          errors: [{ code: "UNAUTHENTICATED", message: "User not authenticated" }],
        };
      }

      const accounts = await auth.api.listUserAccounts({ headers });

      const normalizedAccounts = accounts.map((account) => ({
        id: account.id,
        providerId: account.providerId,
        accountId: account.accountId,
        createdAt: account.createdAt.toISOString(),
        updatedAt: account.updatedAt.toISOString(),
        scopes: account.scopes ?? [],
      }));

      const hasPassword = normalizedAccounts.some(
        (account) => account.providerId.toLowerCase() === "email",
      );

      return {
        success: true,
        data: {
          user: {
            id: sessionResult.user.id,
            name: sessionResult.user.name,
            email: sessionResult.user.email,
            emailVerified: sessionResult.user.emailVerified ?? false,
          },
          accounts: normalizedAccounts,
          hasPassword,
          availableProviders: Array.from(AVAILABLE_PROVIDERS),
        },
      };
    } catch (error) {
      console.error("Failed to load account overview", error);
      return {
        success: false,
        errors: [
          {
            code: "UNKNOWN_ERROR",
            message: "Failed to load account settings",
          },
        ],
      };
    }
  },
);
</file>

<file path="src/features/settings/settings.schemas.ts">
import { z } from "zod";
import { PASSWORD_CONFIG } from "~/lib/security/password-config";

const passwordRequirements = z
  .string({
    error: (issue) => (issue.input === undefined ? "Password is required" : undefined),
  })
  .min(
    PASSWORD_CONFIG.minLength,
    `Password must be at least ${PASSWORD_CONFIG.minLength} characters long`,
  )
  .superRefine((value, ctx) => {
    if (PASSWORD_CONFIG.requireUppercase && !/[A-Z]/.test(value)) {
      ctx.addIssue({
        code: "custom",
        message: "Password must include at least one uppercase letter",
      });
    }

    if (PASSWORD_CONFIG.requireLowercase && !/[a-z]/.test(value)) {
      ctx.addIssue({
        code: "custom",
        message: "Password must include at least one lowercase letter",
      });
    }

    if (PASSWORD_CONFIG.requireNumbers && !/\d/.test(value)) {
      ctx.addIssue({
        code: "custom",
        message: "Password must include at least one number",
      });
    }

    if (PASSWORD_CONFIG.requireSpecialChars && !/[!@#$%^&*(),.?":{}|<>]/.test(value)) {
      ctx.addIssue({
        code: "custom",
        message: "Password must include at least one special character",
      });
    }
  });

export const changePasswordInputSchema = z.object({
  currentPassword: z
    .string({
      error: (issue) =>
        issue.input === undefined ? "Current password is required" : undefined,
    })
    .min(1, "Current password is required"),
  newPassword: passwordRequirements,
  revokeOtherSessions: z.boolean().optional(),
});

export const revokeSessionInputSchema = z.object({
  token: z
    .string({
      error: (issue) =>
        issue.input === undefined ? "Session token is required" : undefined,
    })
    .min(1),
});

export const unlinkAccountInputSchema = z.object({
  providerId: z
    .string({
      error: (issue) => (issue.input === undefined ? "Provider is required" : undefined),
    })
    .min(1, "Provider is required"),
  accountId: z.string().optional(),
});
</file>

<file path="src/routes/admin/roles.tsx">
import { createFileRoute, redirect } from "@tanstack/react-router";

export const Route = createFileRoute("/admin/roles")({
  beforeLoad: () => {
    throw redirect({ to: "/dashboard/admin/roles" });
  },
});
</file>

<file path="src/routes/api/health.ts">
import { createFileRoute } from "@tanstack/react-router";
import { sql } from "drizzle-orm";
import { membershipTypes } from "~/db/schema";

export const Route = createFileRoute("/api/health")({
  server: {
    handlers: {
      GET: async () => {
        const checks = {
          status: "healthy",
          timestamp: new Date().toISOString(),
          services: {} as Record<string, unknown>,
        };

        try {
          // Import server-only modules inside the handler
          const { getDb } = await import("~/db/server-helpers");

          // Check database connection
          const db = await getDb();

          await db.execute(sql`SELECT 1`);
          checks.services["database"] = { status: "connected" };
        } catch {
          checks.status = "unhealthy";
          checks.services["database"] = {
            status: "error",
            message: "Database connection failed",
          };
        }

        try {
          // Check membership types
          const { getDb } = await import("~/db/server-helpers");
          const db = await getDb();

          const types = await db
            .select({ count: sql<number>`count(*)` })
            .from(membershipTypes);

          checks.services["membershipTypes"] = {
            status: "available",
            count: types[0]?.count || 0,
          };
        } catch {
          checks.services["membershipTypes"] = {
            status: "error",
            message: "Failed to query membership types",
          };
        }

        // Check Square configuration
        checks.services["square"] = {
          status: process.env["SQUARE_ACCESS_TOKEN"] ? "configured" : "not_configured",
          environment: process.env["SQUARE_ENV"] || "not_set",
          hasApplicationId: !!process.env["SQUARE_APPLICATION_ID"],
          hasLocationId: !!process.env["SQUARE_LOCATION_ID"],
          hasWebhookKey: !!process.env["SQUARE_WEBHOOK_SIGNATURE_KEY"],
        };

        const statusCode = checks.status === "healthy" ? 200 : 503;

        return new Response(JSON.stringify(checks, null, 2), {
          status: statusCode,
          headers: {
            "Content-Type": "application/json",
            "Cache-Control": "no-cache",
          },
        });
      },
    },
  },
});
</file>

<file path="src/routes/dashboard/events/$slug.index.tsx">
import { useQuery } from "@tanstack/react-query";
import { createFileRoute, Link, useRouteContext } from "@tanstack/react-router";
import { format, isSameDay } from "date-fns";
import {
  ArrowLeftIcon,
  CalendarIcon,
  CheckCircleIcon,
  ClockIcon,
  InfoIcon,
  MapPinIcon,
  UserIcon,
  UsersIcon,
  XCircleIcon,
} from "lucide-react";
import { toast } from "sonner";
import { Alert, AlertDescription, AlertTitle } from "~/components/ui/alert";
import { Badge } from "~/components/ui/badge";
import { Button } from "~/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";
import { Separator } from "~/components/ui/separator";
import { Skeleton } from "~/components/ui/skeleton";
import { checkEventRegistration, getEvent } from "~/features/events/events.queries";
import type {
  EventOperationResult,
  EventWithDetails,
} from "~/features/events/events.types";
import { isAdminClient } from "~/lib/auth/utils/admin-check";
import { cn } from "~/shared/lib/utils";

export const Route = createFileRoute("/dashboard/events/$slug/")({
  component: EventDetailPage,
});

function EventDetailPage() {
  const { slug } = Route.useParams();
  const { user } = useRouteContext({ from: "/dashboard/events/$slug" });

  const {
    data: eventResult,
    isLoading,
    error,
  } = useQuery<EventOperationResult<EventWithDetails>, Error>({
    queryKey: ["event", slug],
    queryFn: () => getEvent({ data: { slug } }),
  });

  const eventData = eventResult?.success ? eventResult.data : null;

  const { data: registrationStatus, isLoading: registrationLoading } = useQuery<
    { isRegistered: boolean } | undefined,
    Error
  >({
    // Include user.id in key for cache invalidation when user changes
    queryKey: ["event-registration", eventData?.id, user?.id],
    queryFn: () =>
      checkEventRegistration({
        data: {
          eventId: eventData!.id,
          // userId is now inferred from session on server
        },
      }),
    enabled: Boolean(eventData?.id && user?.id),
  });

  if (isLoading) {
    return <EventDetailSkeleton />;
  }

  if (error || !eventData) {
    return (
      <div className="container mx-auto p-6">
        <Alert variant="destructive">
          <AlertTitle>Event Not Found</AlertTitle>
          <AlertDescription>
            The event you're looking for doesn't exist or has been removed.
          </AlertDescription>
        </Alert>
        <Button asChild className="mt-4">
          <Link to="/dashboard/events">
            <ArrowLeftIcon className="mr-2 h-4 w-4" />
            Back to Events
          </Link>
        </Button>
      </div>
    );
  }

  const event = eventData;
  const isRegistrationOpen = event.isRegistrationOpen;
  const hasSpots = event.availableSpots === undefined || event.availableSpots > 0;
  const eventStatusBadge = getEventStatusBadge(event.status);
  const registrationBadge = getRegistrationAvailabilityBadge(
    isRegistrationOpen,
    hasSpots,
  );
  const maxTeamsValue = typeof event.maxTeams === "number" ? event.maxTeams : undefined;
  const maxParticipantsValue =
    typeof event.maxParticipants === "number" ? event.maxParticipants : undefined;
  const showEarlyBirdDiscount = shouldShowEarlyBirdDiscount(event);
  const registrationClosesAtDate = event.registrationClosesAt
    ? new Date(event.registrationClosesAt)
    : null;
  const earlyBirdDeadlineDate = event.earlyBirdDeadline
    ? new Date(event.earlyBirdDeadline)
    : null;
  const registrationCapacityParts: string[] = [];
  if (maxTeamsValue !== undefined) {
    registrationCapacityParts.push(`${maxTeamsValue} teams`);
  }
  if (maxParticipantsValue !== undefined) {
    registrationCapacityParts.push(`${maxParticipantsValue} people`);
  }
  const registrationCapacitySuffix = registrationCapacityParts.length
    ? ` / ${registrationCapacityParts.join(" / ")}`
    : "";
  const canManageEvent = user
    ? user.id === event.organizer.id || isAdminClient(user)
    : false;
  const hasLocationAddress = Boolean(
    event.venueName ||
      event.venueAddress ||
      event.city ||
      event.province ||
      event.postalCode,
  );
  const hasLocationDetails = hasLocationAddress || Boolean(event.locationNotes);
  const locationLine = [event.city, event.province].filter(Boolean).join(", ");
  const locationWithPostal = event.postalCode
    ? `${locationLine}${locationLine ? " " : ""}${event.postalCode}`
    : locationLine;

  return (
    <div className="container mx-auto space-y-6 p-6">
      <div className="flex items-center gap-4">
        <Button asChild variant="ghost" size="sm">
          <Link to="/dashboard/events">
            <ArrowLeftIcon className="mr-2 h-4 w-4" />
            Back to Events
          </Link>
        </Button>
        {canManageEvent && (
          <Button asChild variant="outline" size="sm">
            <Link to="/dashboard/events/$eventId/manage" params={{ eventId: event.id }}>
              Manage Event
            </Link>
          </Button>
        )}
      </div>
      <div className="grid gap-6 lg:grid-cols-3">
        <div className="space-y-6 lg:col-span-2">
          {/* Header */}
          <Card>
            <CardHeader>
              <div className="flex items-start justify-between">
                <div className="space-y-2">
                  <CardTitle className="text-3xl">{event.name}</CardTitle>
                  <CardDescription>{event.shortDescription}</CardDescription>
                </div>
                <Badge
                  variant={eventStatusBadge.variant}
                  className={cn("capitalize", eventStatusBadge.className)}
                >
                  {event.status.replace("_", " ")}
                </Badge>
              </div>
            </CardHeader>
            <CardContent className="space-y-4">
              {event.description && (
                <div className="prose max-w-none">
                  <p className="whitespace-pre-wrap">{event.description}</p>
                </div>
              )}

              <Separator />

              <div className="grid gap-4 md:grid-cols-2">
                <div className="space-y-3">
                  <h3 className="font-semibold">Event Details</h3>

                  <div className="flex items-center gap-2 text-sm">
                    <CalendarIcon className="text-muted-foreground h-4 w-4" />
                    <span>
                      {format(new Date(event.startDate), "EEEE, MMMM d, yyyy")}
                      {!isSameDay(new Date(event.startDate), new Date(event.endDate)) &&
                        ` - ${format(new Date(event.endDate), "EEEE, MMMM d, yyyy")}`}
                    </span>
                  </div>

                  <div className="flex items-center gap-2 text-sm">
                    <ClockIcon className="text-muted-foreground h-4 w-4" />
                    <span className="capitalize">{event.type} Event</span>
                  </div>

                  <div className="flex items-center gap-2 text-sm">
                    <UsersIcon className="text-muted-foreground h-4 w-4" />
                    <span className="capitalize">
                      {event.registrationType} Registration
                    </span>
                  </div>

                  {maxTeamsValue !== undefined && (
                    <div className="flex items-center gap-2 text-sm">
                      <InfoIcon className="text-muted-foreground h-4 w-4" />
                      <span>Max {maxTeamsValue} teams</span>
                    </div>
                  )}

                  {maxParticipantsValue !== undefined && (
                    <div className="flex items-center gap-2 text-sm">
                      <InfoIcon className="text-muted-foreground h-4 w-4" />
                      <span>Max {maxParticipantsValue} participants</span>
                    </div>
                  )}
                </div>

                <div className="space-y-3">
                  <h3 className="font-semibold">Location</h3>

                  {!hasLocationDetails && (
                    <p className="text-muted-foreground text-sm">Location TBD</p>
                  )}

                  {hasLocationAddress && (
                    <div className="flex items-start gap-2 text-sm">
                      <MapPinIcon className="text-muted-foreground mt-0.5 h-4 w-4" />
                      <div>
                        {event.venueName && (
                          <div className="font-medium">{event.venueName}</div>
                        )}
                        {event.venueAddress && <div>{event.venueAddress}</div>}
                        {locationWithPostal && <div>{locationWithPostal}</div>}
                      </div>
                    </div>
                  )}

                  {event.locationNotes && (
                    <div className="bg-muted rounded-lg p-3 text-sm">
                      <p className="mb-1 font-medium">Location Notes:</p>
                      <p>{event.locationNotes}</p>
                    </div>
                  )}
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Schedule */}
          {event.schedule && Object.keys(event.schedule).length > 0 && (
            <Card>
              <CardHeader>
                <CardTitle>Event Schedule</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="space-y-2">
                  {Object.entries(event.schedule).map(([key, value]) => (
                    <div
                      key={key}
                      className="flex justify-between border-b py-2 last:border-0"
                    >
                      <span className="font-medium capitalize">
                        {key.replace(/_/g, " ")}
                      </span>
                      <span className="text-muted-foreground">{value}</span>
                    </div>
                  ))}
                </div>
              </CardContent>
            </Card>
          )}

          {/* Rules */}
          {event.rules && Object.keys(event.rules).length > 0 && (
            <Card>
              <CardHeader>
                <CardTitle>Rules & Format</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="space-y-2">
                  {Object.entries(event.rules).map(([key, value]) => (
                    <div key={key} className="py-2">
                      <span className="font-medium capitalize">
                        {key.replace(/_/g, " ")}:
                      </span>{" "}
                      <span className="text-muted-foreground">{value}</span>
                    </div>
                  ))}
                </div>
              </CardContent>
            </Card>
          )}

          {/* Requirements */}
          {event.requirements && Object.keys(event.requirements).length > 0 && (
            <Card>
              <CardHeader>
                <CardTitle>Requirements</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="space-y-2">
                  {Object.entries(event.requirements).map(([key, value]) => (
                    <div key={key} className="flex items-center gap-2">
                      {value ? (
                        <CheckCircleIcon className="h-4 w-4 text-green-600" />
                      ) : (
                        <XCircleIcon className="text-muted-foreground h-4 w-4" />
                      )}
                      <span className="capitalize">{key.replace(/_/g, " ")}</span>
                    </div>
                  ))}
                </div>
              </CardContent>
            </Card>
          )}

          {/* Amenities */}
          {event.amenities && Object.keys(event.amenities).length > 0 && (
            <Card>
              <CardHeader>
                <CardTitle>Amenities</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="grid grid-cols-2 gap-2">
                  {Object.entries(event.amenities).map(([key, value]) => (
                    <div key={key} className="flex items-center gap-2">
                      {value ? (
                        <CheckCircleIcon className="h-4 w-4 text-green-600" />
                      ) : (
                        <XCircleIcon className="text-muted-foreground h-4 w-4" />
                      )}
                      <span className="text-sm capitalize">{key.replace(/_/g, " ")}</span>
                    </div>
                  ))}
                </div>
              </CardContent>
            </Card>
          )}
        </div>

        {/* Sidebar */}
        <div className="space-y-6">
          {/* Registration Card */}
          <Card>
            <CardHeader>
              <CardTitle>Registration</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="space-y-2">
                <div className="flex items-center justify-between">
                  <span className="text-sm font-medium">Status</span>
                  <Badge
                    variant={registrationBadge.variant}
                    className={cn("capitalize", registrationBadge.className)}
                  >
                    {isRegistrationOpen ? "Open" : "Closed"}
                  </Badge>
                </div>

                {registrationClosesAtDate && (
                  <div className="flex items-center justify-between">
                    <span className="text-sm font-medium">Closes</span>
                    <span className="text-muted-foreground text-sm">
                      {format(registrationClosesAtDate, "MMM d, yyyy")}
                    </span>
                  </div>
                )}

                <div className="flex items-center justify-between">
                  <span className="text-sm font-medium">Registered</span>
                  <span className="text-sm">
                    {event.registrationCount}
                    {registrationCapacitySuffix}
                  </span>
                </div>

                {event.availableSpots !== undefined && (
                  <div className="flex items-center justify-between">
                    <span className="text-sm font-medium">Available Spots</span>
                    <span
                      className={`text-sm font-bold ${
                        event.availableSpots > 0 ? "text-green-600" : "text-red-600"
                      }`}
                    >
                      {event.availableSpots}
                    </span>
                  </div>
                )}
              </div>

              <Separator />

              {/* Pricing */}
              <div className="space-y-2">
                <h4 className="font-medium">Registration Fees</h4>

                {event.registrationType === "team" ||
                event.registrationType === "both" ? (
                  <div className="flex items-center justify-between">
                    <span className="text-sm">Team Registration</span>
                    <span className="font-medium">
                      ${((event.teamRegistrationFee || 0) / 100).toFixed(2)}
                    </span>
                  </div>
                ) : null}

                {event.registrationType === "individual" ||
                event.registrationType === "both" ? (
                  <div className="flex items-center justify-between">
                    <span className="text-sm">Individual Registration</span>
                    <span className="font-medium">
                      ${((event.individualRegistrationFee || 0) / 100).toFixed(2)}
                    </span>
                  </div>
                ) : null}

                {showEarlyBirdDiscount && earlyBirdDeadlineDate && (
                  <Alert>
                    <InfoIcon className="h-4 w-4" />
                    <AlertDescription>
                      {event.earlyBirdDiscount}% early bird discount available until{" "}
                      {format(earlyBirdDeadlineDate, "MMM d")}
                    </AlertDescription>
                  </Alert>
                )}
              </div>

              <Separator />

              {/* Action Buttons */}
              {user && registrationLoading ? (
                <div className="w-full">
                  <Skeleton className="h-10 w-full" />
                </div>
              ) : registrationStatus?.isRegistered ? (
                <Alert>
                  <CheckCircleIcon className="h-4 w-4" />
                  <AlertTitle>You're Registered!</AlertTitle>
                  <AlertDescription>
                    You are already registered for this event.
                  </AlertDescription>
                </Alert>
              ) : (
                <>
                  {isRegistrationOpen && hasSpots ? (
                    <Button asChild className="w-full">
                      <Link
                        to="/dashboard/events/$slug/register"
                        params={{ slug: event.slug }}
                      >
                        Register Now
                      </Link>
                    </Button>
                  ) : !isRegistrationOpen ? (
                    <Button disabled className="w-full">
                      Registration Closed
                    </Button>
                  ) : (
                    <Button disabled className="w-full">
                      Event Full
                    </Button>
                  )}
                </>
              )}
            </CardContent>
          </Card>

          {/* Organizer Card */}
          <Card>
            <CardHeader>
              <CardTitle>Event Organizer</CardTitle>
            </CardHeader>
            <CardContent className="space-y-3">
              <div className="flex items-center gap-3">
                <div className="bg-primary/10 flex h-10 w-10 items-center justify-center rounded-full">
                  <UserIcon className="text-primary h-5 w-5" />
                </div>
                <div>
                  <div className="font-medium">{event.organizer.name}</div>
                  <div className="text-muted-foreground text-sm">
                    {event.contactEmail || event.organizer.email}
                  </div>
                </div>
              </div>

              {event.contactPhone && (
                <div className="text-sm">
                  <span className="font-medium">Phone:</span> {event.contactPhone}
                </div>
              )}
            </CardContent>
          </Card>

          {/* Share Card */}
          <Card>
            <CardHeader>
              <CardTitle>Share Event</CardTitle>
            </CardHeader>
            <CardContent>
              <Button
                variant="outline"
                className="w-full"
                onClick={async () => {
                  try {
                    await navigator.clipboard.writeText(window.location.href);
                    toast.success("Link copied to clipboard");
                  } catch {
                    toast.error("Failed to copy link");
                  }
                }}
              >
                Copy Link
              </Button>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
}

function EventDetailSkeleton() {
  return (
    <div className="container mx-auto space-y-6 p-6">
      <Skeleton className="h-8 w-32" />

      <div className="grid gap-6 lg:grid-cols-3">
        <div className="space-y-6 lg:col-span-2">
          <Card>
            <CardHeader>
              <Skeleton className="h-8 w-3/4" />
              <Skeleton className="h-4 w-1/2" />
            </CardHeader>
            <CardContent className="space-y-4">
              <Skeleton className="h-20 w-full" />
              <Skeleton className="h-20 w-full" />
            </CardContent>
          </Card>
        </div>

        <div className="space-y-6">
          <Card>
            <CardHeader>
              <Skeleton className="h-6 w-24" />
            </CardHeader>
            <CardContent className="space-y-4">
              <Skeleton className="h-32 w-full" />
              <Skeleton className="h-10 w-full" />
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
}

function getEventStatusBadge(status: EventWithDetails["status"]): {
  variant: "default" | "secondary" | "destructive" | "outline";
  className?: string;
} {
  switch (status) {
    case "draft":
      return { variant: "secondary" };
    case "published":
      return { variant: "default" };
    case "registration_open":
      return {
        variant: "outline",
        className: "border-emerald-200 bg-emerald-50 text-emerald-700",
      };
    case "registration_closed":
      return {
        variant: "outline",
        className: "border-amber-200 bg-amber-50 text-amber-700",
      };
    case "in_progress":
      return {
        variant: "outline",
        className: "border-sky-200 bg-sky-50 text-sky-700",
      };
    case "cancelled":
      return { variant: "destructive" };
    case "completed":
    default:
      return { variant: "default" };
  }
}

function getRegistrationAvailabilityBadge(
  isOpen: boolean,
  hasSpots: boolean,
): { variant: "default" | "secondary" | "destructive" | "outline"; className?: string } {
  if (!isOpen) {
    return { variant: "secondary" };
  }

  if (!hasSpots) {
    return {
      variant: "outline",
      className: "border-amber-200 bg-amber-50 text-amber-700",
    };
  }

  return {
    variant: "outline",
    className: "border-emerald-200 bg-emerald-50 text-emerald-700",
  };
}

function shouldShowEarlyBirdDiscount(event: EventWithDetails): boolean {
  if (!event.earlyBirdDiscount || !event.earlyBirdDeadline) {
    return false;
  }

  return new Date(event.earlyBirdDeadline) > new Date();
}
</file>

<file path="src/routes/dashboard/events.tsx">
import { createFileRoute, Outlet } from "@tanstack/react-router";

export const Route = createFileRoute("/dashboard/events")({
  component: EventsLayout,
});

function EventsLayout() {
  return <Outlet />;
}
</file>

<file path="src/routes/dashboard/members.tsx">
import { useQuery } from "@tanstack/react-query";
import { createFileRoute } from "@tanstack/react-router";
import type { ColumnDef } from "@tanstack/react-table";
import {
  CalendarCheck,
  Loader2,
  Mail,
  Phone,
  Search,
  ShieldCheck,
  Users,
} from "lucide-react";
import { useCallback, useDeferredValue, useMemo, useState, type ReactNode } from "react";
import { Alert, AlertDescription, AlertTitle } from "~/components/ui/alert";
import { Badge } from "~/components/ui/badge";
import { Button } from "~/components/ui/button";
import { DataTable } from "~/components/ui/data-table";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "~/components/ui/dialog";
import { Input } from "~/components/ui/input";
import {
  listMembers,
  type MemberDirectoryMember,
  type MemberDirectoryResponse,
} from "~/features/members";
import { exportToCSV, formatDate } from "~/lib/utils/csv-export";

export const Route = createFileRoute("/dashboard/members")({
  component: MembersPage,
});

function MembersPage() {
  const [searchTerm, setSearchTerm] = useState("");
  const deferredSearch = useDeferredValue(searchTerm);
  const [selectedMember, setSelectedMember] = useState<MemberDirectoryMember | null>(
    null,
  );

  const { data, isLoading, isFetching, error } = useQuery<
    MemberDirectoryResponse,
    Error,
    MemberDirectoryResponse
  >({
    queryKey: ["members-directory", { search: deferredSearch }],
    queryFn: async (): Promise<MemberDirectoryResponse> => {
      const payload = deferredSearch ? { search: deferredSearch } : {};
      const result = await listMembers({ data: payload });

      if (!result.success || !result.data) {
        throw new Error(
          result.errors?.[0]?.message || "Failed to fetch member directory",
        );
      }

      return result.data;
    },
  });

  const columns = useMemo<ColumnDef<MemberDirectoryMember>[]>(
    () => [
      {
        accessorKey: "name",
        header: "Member",
        cell: ({ row }) => {
          const member = row.original;
          return (
            <div className="space-y-1">
              <div className="leading-none font-medium">{member.name}</div>
              <div className="text-muted-foreground text-xs">
                {member.pronouns || "Pronouns not provided"}
              </div>
            </div>
          );
        },
      },
      {
        accessorKey: "teams",
        header: "Active Teams",
        cell: ({ row }) => {
          const teams = row.original.teams;

          if (!teams.length) {
            return <span className="text-muted-foreground text-sm">No active team</span>;
          }

          return (
            <div className="flex flex-wrap gap-1">
              {teams.map((team) => (
                <Badge key={team} variant="secondary" className="text-xs">
                  {team}
                </Badge>
              ))}
            </div>
          );
        },
      },
      {
        accessorKey: "membershipStatus",
        header: "Membership",
        cell: ({ row }) => {
          const { membershipStatus, hasActiveMembership, membershipType } = row.original;
          const badgeClass = hasActiveMembership
            ? "bg-green-100 text-green-800"
            : membershipStatus === "expired"
              ? "bg-amber-100 text-amber-800"
              : membershipStatus === "cancelled"
                ? "bg-red-100 text-red-800"
                : "bg-gray-200 text-gray-700";
          const label = hasActiveMembership
            ? "Active"
            : membershipStatus === "none"
              ? "No membership"
              : membershipStatus.charAt(0).toUpperCase() + membershipStatus.slice(1);

          return (
            <div className="flex flex-col gap-1">
              <Badge variant="secondary" className={`text-xs font-medium ${badgeClass}`}>
                {label}
              </Badge>
              {membershipType ? (
                <span className="text-muted-foreground text-xs">{membershipType}</span>
              ) : null}
            </div>
          );
        },
      },
      {
        accessorKey: "membershipEndDate",
        header: "Expires",
        cell: ({ row }) => {
          const { membershipEndDate, hasActiveMembership } = row.original;

          if (!membershipEndDate) {
            return <span className="text-muted-foreground text-sm">â</span>;
          }

          return (
            <span
              className={`text-sm ${hasActiveMembership ? "text-green-700" : "text-muted-foreground"}`}
            >
              {formatDate(membershipEndDate)}
            </span>
          );
        },
      },
      {
        id: "contact",
        header: "Contact",
        cell: ({ row }) => {
          const member = row.original;
          return (
            <div className="space-y-1 text-xs">
              <div className="flex items-center gap-1">
                <Mail className="text-muted-foreground h-3.5 w-3.5" />
                {member.emailVisible && member.email ? (
                  <a
                    href={`mailto:${member.email}`}
                    className="text-primary hover:underline"
                  >
                    {member.email}
                  </a>
                ) : (
                  <span className="text-muted-foreground">Hidden</span>
                )}
              </div>
              <div className="flex items-center gap-1">
                <Phone className="text-muted-foreground h-3.5 w-3.5" />
                {member.phoneVisible && member.phone ? (
                  <span>{member.phone}</span>
                ) : (
                  <span className="text-muted-foreground">Hidden</span>
                )}
              </div>
            </div>
          );
        },
      },
      {
        id: "actions",
        header: () => <span className="sr-only">Actions</span>,
        cell: ({ row }) => (
          <Button
            variant="outline"
            size="sm"
            onClick={() => setSelectedMember(row.original)}
          >
            View
          </Button>
        ),
        enableSorting: false,
        enableHiding: false,
      },
    ],
    [setSelectedMember],
  );

  const handleClearSearch = useCallback(() => {
    setSearchTerm("");
  }, []);

  const handleExport = useCallback(() => {
    const members = data?.members;
    if (!members?.length) {
      return;
    }

    const rows = members.map((member) => ({
      Name: member.name,
      Pronouns: member.pronouns || "",
      Email: member.emailVisible && member.email ? member.email : "Hidden",
      Phone: member.phoneVisible && member.phone ? member.phone : "Hidden",
      "Active Teams": member.teams.join(", "),
      "Membership Status": member.membershipStatus,
      "Membership Type": member.membershipType ?? "",
      "Membership Expires": member.membershipEndDate
        ? formatDate(member.membershipEndDate)
        : "",
      "Open to Invites": member.allowTeamInvitations ? "Yes" : "No",
      "Birth Year":
        member.birthYearVisible && member.birthYear ? String(member.birthYear) : "Hidden",
    }));

    const filename = `members-directory-${new Date().toISOString().split("T")[0]}.csv`;
    exportToCSV(rows, filename);
  }, [data]);

  const totalMembers = data?.pagination.total ?? 0;

  return (
    <div className="container mx-auto space-y-8 p-6">
      <div className="space-y-2">
        <h1 className="text-3xl font-bold tracking-tight">Members Directory</h1>
        <p className="text-muted-foreground">
          Browse Quadball Canada members, check membership status, and find players open
          to team invitations.
        </p>
      </div>

      <div className="flex flex-col gap-4 lg:flex-row lg:items-end lg:justify-between">
        <div className="flex w-full flex-col gap-2 lg:max-w-lg">
          <label htmlFor="member-search" className="text-sm font-medium">
            Search members
          </label>
          <div className="relative flex items-center">
            <Search className="text-muted-foreground absolute left-3 h-4 w-4" />
            <Input
              id="member-search"
              placeholder="Search by name, email, or team"
              value={searchTerm}
              onChange={(event) => setSearchTerm(event.target.value)}
              className="pl-9"
              autoComplete="off"
            />
            {searchTerm ? (
              <Button
                type="button"
                variant="ghost"
                size="sm"
                className="absolute top-1/2 right-1 -translate-y-1/2 px-2 text-xs"
                onClick={handleClearSearch}
              >
                Clear
              </Button>
            ) : null}
          </div>
        </div>
        <div className="flex items-center gap-3">
          <Badge variant="secondary" className="flex items-center gap-1 text-xs">
            <Users className="h-3.5 w-3.5" />
            <span>{totalMembers} members</span>
          </Badge>
          <Button
            variant="outline"
            onClick={handleExport}
            disabled={!data?.members?.length}
          >
            Export CSV
          </Button>
        </div>
      </div>

      {isLoading && !data ? (
        <div className="flex h-64 items-center justify-center">
          <Loader2 className="text-muted-foreground mr-2 h-6 w-6 animate-spin" />
          <span className="text-muted-foreground">Loading membersâ¦</span>
        </div>
      ) : error ? (
        <Alert variant="destructive">
          <AlertTitle>Unable to load members</AlertTitle>
          <AlertDescription>
            {(error as Error).message ||
              "An unexpected error occurred while loading the member directory."}
          </AlertDescription>
        </Alert>
      ) : (
        <div className="space-y-4">
          {isFetching && (
            <div className="text-muted-foreground flex items-center gap-2 text-sm">
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Refreshing directoryâ¦</span>
            </div>
          )}
          <DataTable
            columns={columns}
            data={data?.members ?? []}
            pageSize={10}
            enableColumnToggle={false}
          />
          {data?.members?.length === 0 && (
            <div className="border-border bg-muted/30 text-muted-foreground flex flex-col items-center gap-2 rounded-md border p-8 text-center">
              <ShieldCheck className="h-8 w-8" />
              <p>No members match your current search.</p>
            </div>
          )}
        </div>
      )}

      <MemberDetailDialog
        member={selectedMember}
        onClose={() => setSelectedMember(null)}
      />
    </div>
  );
}

interface MemberDetailDialogProps {
  member: MemberDirectoryMember | null;
  onClose: () => void;
}

function MemberDetailDialog({ member, onClose }: MemberDetailDialogProps) {
  const open = Boolean(member);

  return (
    <Dialog open={open} onOpenChange={(nextOpen) => !nextOpen && onClose()}>
      <DialogContent>
        {member ? (
          <div className="space-y-6">
            <DialogHeader className="space-y-1">
              <DialogTitle className="text-2xl">{member.name}</DialogTitle>
              <DialogDescription>View member profile details</DialogDescription>
            </DialogHeader>

            <div className="grid gap-4 md:grid-cols-2">
              <InfoBlock title="Membership" icon={<CalendarCheck className="h-4 w-4" />}>
                <div className="space-y-1 text-sm">
                  <div className="flex items-center gap-2">
                    <Badge
                      variant="secondary"
                      className={
                        member.hasActiveMembership
                          ? "bg-green-100 text-green-800"
                          : member.membershipStatus === "expired"
                            ? "bg-amber-100 text-amber-800"
                            : member.membershipStatus === "cancelled"
                              ? "bg-red-100 text-red-800"
                              : "bg-gray-200 text-gray-700"
                      }
                    >
                      {member.hasActiveMembership
                        ? "Active"
                        : member.membershipStatus === "none"
                          ? "No membership"
                          : member.membershipStatus.charAt(0).toUpperCase() +
                            member.membershipStatus.slice(1)}
                    </Badge>
                    {member.membershipType ? (
                      <span className="text-muted-foreground text-xs">
                        {member.membershipType}
                      </span>
                    ) : null}
                  </div>
                  {member.membershipEndDate ? (
                    <p className="text-muted-foreground text-xs">
                      Expires: {formatDate(member.membershipEndDate)}
                    </p>
                  ) : null}
                </div>
              </InfoBlock>

              <InfoBlock title="Contact" icon={<Mail className="h-4 w-4" />}>
                <div className="space-y-2 text-sm">
                  <div>
                    <p className="text-muted-foreground text-xs tracking-wide uppercase">
                      Email
                    </p>
                    {member.emailVisible && member.email ? (
                      <a
                        href={`mailto:${member.email}`}
                        className="text-primary hover:underline"
                      >
                        {member.email}
                      </a>
                    ) : (
                      <p className="text-muted-foreground">Hidden (privacy settings)</p>
                    )}
                  </div>
                  <div>
                    <p className="text-muted-foreground text-xs tracking-wide uppercase">
                      Phone
                    </p>
                    {member.phoneVisible && member.phone ? (
                      <p>{member.phone}</p>
                    ) : (
                      <p className="text-muted-foreground">Hidden (privacy settings)</p>
                    )}
                  </div>
                </div>
              </InfoBlock>

              <InfoBlock title="Teams" icon={<Users className="h-4 w-4" />}>
                {member.teams.length ? (
                  <ul className="space-y-1 text-sm">
                    {member.teams.map((team) => (
                      <li key={team}>{team}</li>
                    ))}
                  </ul>
                ) : (
                  <p className="text-muted-foreground text-sm">No active team</p>
                )}
              </InfoBlock>

              <InfoBlock title="Availability" icon={<ShieldCheck className="h-4 w-4" />}>
                <div className="space-y-2 text-sm">
                  <div>
                    <p className="text-muted-foreground text-xs tracking-wide uppercase">
                      Open to Team Invitations
                    </p>
                    <p>{member.allowTeamInvitations ? "Yes" : "No"}</p>
                  </div>
                  <div>
                    <p className="text-muted-foreground text-xs tracking-wide uppercase">
                      Birth Year
                    </p>
                    <p>
                      {member.birthYearVisible && member.birthYear
                        ? member.birthYear
                        : "Hidden (privacy settings)"}
                    </p>
                  </div>
                </div>
              </InfoBlock>
            </div>

            <div className="space-y-3">
              <h3 className="text-lg font-semibold">Membership history</h3>
              {member.membershipHistory.length ? (
                <div className="rounded-md border">
                  <div className="bg-muted/40 text-muted-foreground grid grid-cols-3 gap-2 border-b p-3 text-xs font-semibold uppercase">
                    <span>Status</span>
                    <span>Membership Type</span>
                    <span>Valid Dates</span>
                  </div>
                  <div className="divide-y text-sm">
                    {member.membershipHistory.map((entry, index) => (
                      <div
                        key={`${entry.status}-${entry.endDate ?? index}`}
                        className="grid grid-cols-3 gap-2 p-3"
                      >
                        <span className="font-medium">
                          {entry.status.charAt(0).toUpperCase() + entry.status.slice(1)}
                        </span>
                        <span className="text-muted-foreground">
                          {entry.membershipType || "â"}
                        </span>
                        <span className="text-muted-foreground">
                          {entry.startDate ? formatDate(entry.startDate) : "â"} â{" "}
                          {entry.endDate ? formatDate(entry.endDate) : "â"}
                        </span>
                      </div>
                    ))}
                  </div>
                </div>
              ) : (
                <p className="text-muted-foreground text-sm">
                  No membership records found for this member.
                </p>
              )}
            </div>
          </div>
        ) : null}
      </DialogContent>
    </Dialog>
  );
}

interface InfoBlockProps {
  title: string;
  icon?: ReactNode;
  children: ReactNode;
}

function InfoBlock({ title, icon, children }: InfoBlockProps) {
  return (
    <div className="rounded-lg border p-4 shadow-sm">
      <div className="mb-3 flex items-center gap-2 text-sm font-semibold">
        {icon}
        <span>{title}</span>
      </div>
      <div>{children}</div>
    </div>
  );
}
</file>

<file path="src/routes/dashboard/settings.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { SettingsView } from "~/features/settings/components/settings-view";

export const Route = createFileRoute("/dashboard/settings")({
  component: SettingsPage,
});

function SettingsPage() {
  return (
    <div className="container mx-auto space-y-8 p-6">
      <SettingsView />
    </div>
  );
}
</file>

<file path="src/components/form-fields/ValidatedSelect.tsx">
import React from "react";
import { Label } from "~/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";
import { FieldComponentProps, isFieldApi } from "~/lib/form";
import { cn } from "~/shared/lib/utils";

interface ValidatedSelectProps extends FieldComponentProps {
  options: Array<{ value: string; label: string }>;
  placeholderText?: string;
  required?: boolean;
}

export const ValidatedSelect: React.FC<ValidatedSelectProps> = (props) => {
  const {
    field,
    label,
    options,
    placeholderText = "Select an option",
    className,
    required,
  } = props;

  if (!isFieldApi(field)) {
    console.error("ValidatedSelect requires a valid field prop.");
    return null;
  }

  const selectId = `${field.name}-select`;
  const meta = field.state.meta;
  const EMPTY_OPTION_VALUE = "__empty_option__";
  const placeholderOption = options.find((option) => option.value === "");
  const normalizedOptions = options.map((option) =>
    option.value === "" ? { ...option, value: EMPTY_OPTION_VALUE } : option,
  );
  const selectValue = placeholderOption
    ? field.state.value === "" || field.state.value === undefined
      ? EMPTY_OPTION_VALUE
      : (field.state.value as string)
    : ((field.state.value as string | undefined) ?? undefined);

  return (
    <div className={cn("space-y-2", className)}>
      <Label htmlFor={selectId}>{label}</Label>
      <Select
        {...(selectValue !== undefined ? { value: selectValue } : {})}
        onValueChange={(value) => {
          const normalizedValue =
            placeholderOption && value === EMPTY_OPTION_VALUE ? "" : value;
          field.handleChange(normalizedValue);
        }}
        disabled={field.form.state.isSubmitting}
      >
        <SelectTrigger
          id={selectId}
          aria-invalid={!!meta.errors.length}
          aria-required={required}
          aria-describedby={meta.errors.length ? `${selectId}-errors` : undefined}
        >
          <SelectValue placeholder={placeholderOption?.label ?? placeholderText} />
        </SelectTrigger>
        <SelectContent>
          {normalizedOptions.map((option) => (
            <SelectItem key={option.value} value={option.value}>
              {option.label}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
      {meta.isTouched && meta.errors.length > 0 && (
        <div id={`${selectId}-errors`} className="text-destructive text-sm font-medium">
          {meta.errors.join(", ")}
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/components/ui/SafeLink.tsx">
import {
  Link,
  type NavigateOptions,
  useNavigate,
  useRouterState,
} from "@tanstack/react-router";

type Props = React.ComponentProps<typeof Link>;

export function SafeLink(props: Props) {
  const navigate = useNavigate();
  const routerState = useRouterState();
  const isWebKit =
    typeof navigator !== "undefined" &&
    /WebKit/.test(navigator.userAgent) &&
    !/Chrome|Edg|OPR/.test(navigator.userAgent);

  if (isWebKit) {
    // For WebKit, manually handle active state
    const { activeProps, ...restProps } = props;
    const linkProps = { ...restProps } as Record<string, unknown> & Props;
    delete linkProps.activeOptions;
    const isActive = routerState.location.pathname === props.to;

    const activeAttributes = isActive && activeProps ? activeProps : {};

    // Fallback to a real <a> so Safari's click semantics are 100% reliable
    return (
      <a
        href={props.to as string}
        {...(linkProps as Props)}
        {...activeAttributes}
        onClick={(e) => {
          e.preventDefault();
          navigate({ to: props.to, replace: false } as NavigateOptions);
        }}
      >
        {typeof props.children === "function"
          ? props.children({ isActive, isTransitioning: false })
          : props.children}
      </a>
    );
  }
  return <Link {...props} />;
}
</file>

<file path="src/components/ui/TypedLink.tsx">
import type { RegisteredRouter } from "@tanstack/react-router";
import {
  Link,
  useNavigate,
  useRouterState,
  type LinkComponentProps,
} from "@tanstack/react-router";
import type { AnchorHTMLAttributes } from "react";

// Properly typed Link component that preserves generic type parameters
export function TypedLink<
  TFrom extends string = string,
  TTo extends string | undefined = ".",
  TMaskFrom extends string = TFrom,
  TMaskTo extends string = ".",
>(props: LinkComponentProps<"a", RegisteredRouter, TFrom, TTo, TMaskFrom, TMaskTo>) {
  const navigate = useNavigate();
  const routerState = useRouterState();
  const isWebKit =
    typeof navigator !== "undefined" &&
    /WebKit/.test(navigator.userAgent) &&
    !/Chrome|Edg|OPR/.test(navigator.userAgent);

  if (isWebKit) {
    // For WebKit, manually handle active state
    const { activeProps, to, children, ...restProps } = props;
    const isActive = routerState.location.pathname === to;

    const activeAttributes = isActive && activeProps ? activeProps : {};
    const anchorProps = restProps as AnchorHTMLAttributes<HTMLAnchorElement>;
    const activeAnchorProps = activeAttributes as AnchorHTMLAttributes<HTMLAnchorElement>;

    // Fallback to a real <a> so Safari's click semantics are 100% reliable
    return (
      <a
        href={(to as string) ?? routerState.location.pathname}
        {...anchorProps}
        {...activeAnchorProps}
        onClick={(e) => {
          anchorProps.onClick?.(e);
          if (e.defaultPrevented) {
            return;
          }
          e.preventDefault();
          // Use navigate with proper typing
          navigate({ to: to as string });
        }}
      >
        {typeof children === "function"
          ? children({ isActive, isTransitioning: false })
          : children}
      </a>
    );
  }

  return <Link {...props} />;
}
</file>

<file path="src/components/NotFound.tsx">
import { Link } from "@tanstack/react-router";
import { Button } from "~/components/ui/button";
import { ArrowLeftIcon, SearchIcon } from "~/components/ui/icons";

export function NotFound() {
  return (
    <div className="from-brand-dark to-brand-red/40 relative flex min-h-screen items-center justify-center bg-gradient-to-br via-[#2b1a1a] px-6 py-24 text-white">
      <div className="relative z-10 w-full max-w-2xl text-center">
        <p className="text-brand-red/80 text-sm font-semibold tracking-[0.3em] uppercase">
          404 â page not found
        </p>
        <h1 className="mt-4 text-4xl font-bold sm:text-5xl">
          Looks like this play is out of bounds
        </h1>
        <p className="mt-4 text-sm leading-relaxed text-gray-200 sm:text-base">
          The page youâre after may have been renamed, archived, or never made the roster.
          Use the options below to jump back into the action or drop us a note so we can
          help you track it down.
        </p>
        <div className="mt-8 flex flex-wrap justify-center gap-3">
          <Button
            type="button"
            onClick={() => window.history.back()}
            className="btn-brand-primary"
          >
            <ArrowLeftIcon className="mr-2 h-4 w-4" />
            Go back
          </Button>
          <Button
            asChild
            variant="secondary"
            className="bg-white/10 text-white hover:bg-white/20"
          >
            <Link to="/">
              <SearchIcon className="mr-2 h-4 w-4" />
              Visit the homepage
            </Link>
          </Button>
          <Button
            asChild
            variant="outline"
            className="border-white/40 text-white hover:bg-white/10"
          >
            <Link to="/">Visit the portal</Link>
          </Button>
        </div>
        <p className="mt-8 text-xs tracking-[0.3em] text-gray-300 uppercase">
          Need support? Email{" "}
          <a className="underline" href="mailto:info@quadball.ca">
            info@quadball.ca
          </a>
        </p>
      </div>
      <div
        className="absolute inset-0 bg-[url('https://images.unsplash.com/photo-1529333166437-7750a6dd5a70?auto=format&fit=crop&w=1600&q=80')] opacity-15"
        aria-hidden="true"
      />
    </div>
  );
}
</file>

<file path="src/features/dashboard/MemberDashboard.tsx">
import { Link } from "@tanstack/react-router";
import {
  AlertCircle,
  Calendar,
  CheckCircle2,
  Clock,
  CreditCard,
  Settings,
  Shield,
  UserCircle,
  Users,
  XCircle,
} from "lucide-react";
import { Button } from "~/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";
import type { MembershipStatus } from "~/features/membership/membership.types";
import { isAnyAdmin } from "~/features/roles/permission.service";

// Types for the dashboard data
interface ProfileStatus {
  complete: boolean;
  missingFields: string[];
}

interface UserTeam {
  team: {
    id: string;
    name: string;
    slug: string;
    city: string | null;
    province: string | null;
  };
  membership: {
    role: string;
    status: string;
  };
  memberCount: number;
}

interface PendingInvite {
  team: {
    id: string;
    name: string;
    slug: string;
  };
  membership: {
    id: string;
    role: string;
  };
  inviter: {
    id: string;
    name: string | null;
    email: string;
  } | null;
}

interface UpcomingEvent {
  id: string;
  name: string;
  slug: string;
  startDate: Date | string;
  city: string | null;
  province: string | null;
  status: string;
}

interface User {
  id: string;
  name: string | null;
  email: string;
  roles?: Array<{ role: { name: string } }>;
}

export interface MemberDashboardProps {
  user: User;
  membershipStatus: MembershipStatus | null;
  profileStatus: ProfileStatus;
  userTeams: UserTeam[];
  pendingInvites: PendingInvite[];
  upcomingEvents: UpcomingEvent[];
}

export function MemberDashboard({
  user,
  membershipStatus,
  profileStatus,
  userTeams,
  pendingInvites,
  upcomingEvents,
}: MemberDashboardProps) {
  const isAdmin = isAnyAdmin(user);

  return (
    <div className="container mx-auto space-y-8 p-6">
      {/* Header */}
      <header>
        <h1 className="text-3xl font-bold tracking-tight">
          Welcome back, {user.name || "Member"}!
        </h1>
        <div className="mt-2 flex flex-wrap items-center gap-2">
          {membershipStatus?.hasMembership ? (
            <span className="inline-flex items-center rounded-full bg-green-100 px-2.5 py-0.5 text-xs font-medium text-green-800">
              <CheckCircle2 className="mr-1 h-3 w-3" />
              Active Member
            </span>
          ) : (
            <span className="inline-flex items-center rounded-full bg-yellow-100 px-2.5 py-0.5 text-xs font-medium text-yellow-800">
              <AlertCircle className="mr-1 h-3 w-3" />
              Membership Required
            </span>
          )}
          {isAdmin && (
            <span className="inline-flex items-center rounded-full bg-purple-100 px-2.5 py-0.5 text-xs font-medium text-purple-800">
              <Shield className="mr-1 h-3 w-3" />
              Admin
            </span>
          )}
        </div>
      </header>

      {/* Action Cards - Your Next Steps */}
      <ActionCards
        profileStatus={profileStatus}
        membershipStatus={membershipStatus}
        pendingInvites={pendingInvites}
      />

      {/* Main Content Grid */}
      <div className="grid gap-6 lg:grid-cols-2">
        {/* Teams Section */}
        <TeamsCard teams={userTeams} invites={pendingInvites} />

        {/* Membership Card */}
        <MembershipCard status={membershipStatus} />
      </div>

      {/* Upcoming Events */}
      <UpcomingEventsCard events={upcomingEvents} />

      {/* Admin Tools (conditional) */}
      {isAdmin && <AdminToolsCard />}

      {/* Quick Links */}
      <QuickLinksCard />
    </div>
  );
}

// Action Cards Component
function ActionCards({
  profileStatus,
  membershipStatus,
  pendingInvites,
}: {
  profileStatus: ProfileStatus;
  membershipStatus: MembershipStatus | null;
  pendingInvites: PendingInvite[];
}) {
  const actions: Array<{
    show: boolean;
    title: string;
    description: string;
    href: string;
    icon: typeof UserCircle;
    variant: "default" | "warning" | "info";
  }> = [];

  // Profile incomplete
  if (!profileStatus.complete) {
    actions.push({
      show: true,
      title: "Complete your profile",
      description: `Missing: ${profileStatus.missingFields.slice(0, 2).join(", ")}${profileStatus.missingFields.length > 2 ? "..." : ""}`,
      href: "/dashboard/profile",
      icon: UserCircle,
      variant: "warning",
    });
  }

  // No membership
  if (!membershipStatus?.hasMembership) {
    actions.push({
      show: true,
      title: "Activate membership",
      description: "Get your annual player membership to compete",
      href: "/dashboard/membership",
      icon: CreditCard,
      variant: "warning",
    });
  }

  // Membership expiring soon
  if (
    membershipStatus?.hasMembership &&
    membershipStatus.daysRemaining &&
    membershipStatus.daysRemaining < 30
  ) {
    actions.push({
      show: true,
      title: "Renew membership",
      description: `Expires in ${membershipStatus.daysRemaining} days`,
      href: "/dashboard/membership",
      icon: Clock,
      variant: "warning",
    });
  }

  // Pending team invites
  if (pendingInvites.length > 0) {
    actions.push({
      show: true,
      title: "Team invitations",
      description: `${pendingInvites.length} pending invite${pendingInvites.length !== 1 ? "s" : ""}`,
      href: "/dashboard/teams",
      icon: Users,
      variant: "info",
    });
  }

  if (actions.length === 0) {
    return null;
  }

  return (
    <section>
      <h2 className="mb-4 text-lg font-semibold">Your Next Steps</h2>
      <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
        {actions.map((action) => (
          <Link key={action.href + action.title} to={action.href}>
            <Card className="transition-shadow hover:shadow-md">
              <CardContent className="flex items-center gap-4 pt-6">
                <div
                  className={`rounded-full p-2 ${
                    action.variant === "warning"
                      ? "bg-yellow-100 text-yellow-700"
                      : "bg-blue-100 text-blue-700"
                  }`}
                >
                  <action.icon className="h-5 w-5" />
                </div>
                <div>
                  <p className="font-medium">{action.title}</p>
                  <p className="text-muted-foreground text-sm">{action.description}</p>
                </div>
              </CardContent>
            </Card>
          </Link>
        ))}
      </div>
    </section>
  );
}

// Teams Card
function TeamsCard({ teams, invites }: { teams: UserTeam[]; invites: PendingInvite[] }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Users className="h-5 w-5" />
          Your Teams
        </CardTitle>
        <CardDescription>
          {teams.length === 0
            ? "You're not on any teams yet"
            : `${teams.length} active team${teams.length !== 1 ? "s" : ""}`}
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        {teams.length === 0 ? (
          <div className="py-4 text-center">
            <p className="text-muted-foreground mb-4 text-sm">
              Join a team to compete in tournaments and events
            </p>
            <Button asChild variant="outline">
              <Link to="/dashboard/teams/browse">Browse Teams</Link>
            </Button>
          </div>
        ) : (
          <ul className="space-y-3">
            {teams.map(({ team, membership, memberCount }) => (
              <li key={team.id}>
                <Link
                  to="/dashboard/teams/$teamId"
                  params={{ teamId: team.slug }}
                  className="hover:bg-muted/50 flex items-center justify-between rounded-lg border p-3 transition-colors"
                >
                  <div>
                    <p className="font-medium">{team.name}</p>
                    <p className="text-muted-foreground text-sm">
                      {team.city}
                      {team.province ? `, ${team.province}` : ""} &middot; {memberCount}{" "}
                      member{memberCount !== 1 ? "s" : ""}
                    </p>
                  </div>
                  <span className="bg-muted rounded-full px-2 py-1 text-xs capitalize">
                    {membership.role}
                  </span>
                </Link>
              </li>
            ))}
          </ul>
        )}

        {/* Pending Invites */}
        {invites.length > 0 && (
          <div className="border-t pt-4">
            <p className="mb-2 text-sm font-medium">Pending Invitations</p>
            <ul className="space-y-2">
              {invites.map(({ team, membership, inviter }) => (
                <li
                  key={membership.id}
                  className="flex items-center justify-between rounded-lg border border-dashed p-3"
                >
                  <div>
                    <p className="font-medium">{team.name}</p>
                    <p className="text-muted-foreground text-sm">
                      Invited as {membership.role}
                      {inviter?.name ? ` by ${inviter.name}` : ""}
                    </p>
                  </div>
                  <div className="flex gap-2">
                    <Button size="sm" variant="outline">
                      Decline
                    </Button>
                    <Button size="sm">Accept</Button>
                  </div>
                </li>
              ))}
            </ul>
          </div>
        )}
      </CardContent>
    </Card>
  );
}

// Membership Card
function MembershipCard({ status }: { status: MembershipStatus | null }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <CreditCard className="h-5 w-5" />
          Membership Status
        </CardTitle>
      </CardHeader>
      <CardContent>
        {status?.hasMembership ? (
          <div className="space-y-4">
            <div className="flex items-center gap-3">
              <CheckCircle2 className="h-8 w-8 text-green-600" />
              <div>
                <p className="text-2xl font-bold">Active</p>
                <p className="text-muted-foreground text-sm">
                  {status.currentMembership?.membershipType.name}
                </p>
              </div>
            </div>
            {status.expiresAt && (
              <div className="bg-muted rounded-lg p-3">
                <p className="text-sm">
                  <Clock className="mr-1 inline h-4 w-4" />
                  Valid until{" "}
                  {new Date(status.expiresAt).toLocaleDateString("en-CA", {
                    year: "numeric",
                    month: "long",
                    day: "numeric",
                  })}
                </p>
                {typeof status.daysRemaining === "number" &&
                  status.daysRemaining < 60 && (
                    <p className="mt-1 text-sm text-yellow-700">
                      {status.daysRemaining <= 0
                        ? "Expires today"
                        : `${status.daysRemaining} days remaining`}
                    </p>
                  )}
              </div>
            )}
            <Button asChild variant="outline" className="w-full">
              <Link to="/dashboard/membership">
                {typeof status.daysRemaining === "number" && status.daysRemaining < 30
                  ? "Renew Now"
                  : "View Details"}
              </Link>
            </Button>
          </div>
        ) : (
          <div className="space-y-4 text-center">
            <XCircle className="text-muted-foreground mx-auto h-12 w-12" />
            <div>
              <p className="font-medium">No Active Membership</p>
              <p className="text-muted-foreground text-sm">
                Get your membership to compete in official events
              </p>
            </div>
            <Button asChild className="w-full">
              <Link to="/dashboard/membership">View Membership Options</Link>
            </Button>
          </div>
        )}
      </CardContent>
    </Card>
  );
}

// Upcoming Events Card
function UpcomingEventsCard({ events }: { events: UpcomingEvent[] }) {
  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <CardTitle className="flex items-center gap-2">
            <Calendar className="h-5 w-5" />
            Upcoming Events
          </CardTitle>
          <Button asChild variant="ghost" size="sm">
            <Link to="/dashboard/events">View all</Link>
          </Button>
        </div>
      </CardHeader>
      <CardContent>
        {events.length === 0 ? (
          <p className="text-muted-foreground py-4 text-center text-sm">
            No upcoming events scheduled
          </p>
        ) : (
          <ul className="space-y-3">
            {events.slice(0, 5).map((event) => (
              <li key={event.id}>
                <Link
                  to="/dashboard/events/$slug"
                  params={{ slug: event.slug }}
                  className="hover:bg-muted/50 flex items-center justify-between rounded-lg border p-3 transition-colors"
                >
                  <div>
                    <p className="font-medium">{event.name}</p>
                    <p className="text-muted-foreground text-sm">
                      {new Date(event.startDate).toLocaleDateString("en-CA", {
                        month: "short",
                        day: "numeric",
                        year: "numeric",
                      })}{" "}
                      &middot; {event.city}
                      {event.province ? `, ${event.province}` : ""}
                    </p>
                  </div>
                  <span
                    className={`rounded-full px-2 py-1 text-xs ${
                      event.status === "registration_open"
                        ? "bg-green-100 text-green-800"
                        : "bg-muted text-muted-foreground"
                    }`}
                  >
                    {event.status === "registration_open" ? "Open" : event.status}
                  </span>
                </Link>
              </li>
            ))}
          </ul>
        )}
      </CardContent>
    </Card>
  );
}

// Admin Tools Card
function AdminToolsCard() {
  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Shield className="h-5 w-5" />
          Admin Tools
        </CardTitle>
        <CardDescription>Manage organization settings and data</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="grid gap-3 sm:grid-cols-2 lg:grid-cols-4">
          <Button asChild variant="outline">
            <Link to="/dashboard/members">Members</Link>
          </Button>
          <Button asChild variant="outline">
            <Link to="/dashboard/admin/roles">Roles</Link>
          </Button>
          <Button asChild variant="outline">
            <Link to="/dashboard/events">Events</Link>
          </Button>
          <Button asChild variant="outline">
            <Link to="/dashboard/reports">Reports</Link>
          </Button>
        </div>
      </CardContent>
    </Card>
  );
}

// Quick Links Card
function QuickLinksCard() {
  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Settings className="h-5 w-5" />
          Quick Links
        </CardTitle>
      </CardHeader>
      <CardContent>
        <div className="grid gap-3 sm:grid-cols-3">
          <Button asChild variant="ghost" className="justify-start">
            <Link to="/dashboard/profile">
              <UserCircle className="mr-2 h-4 w-4" />
              Edit Profile
            </Link>
          </Button>
          <Button asChild variant="ghost" className="justify-start">
            <Link to="/dashboard/settings">
              <Settings className="mr-2 h-4 w-4" />
              Settings
            </Link>
          </Button>
          <Button asChild variant="ghost" className="justify-start">
            <a href="https://quadballcanada.ca" target="_blank" rel="noopener noreferrer">
              <Calendar className="mr-2 h-4 w-4" />
              News & Updates
            </a>
          </Button>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/events/__tests__/events.schemas.test.ts">
import { describe, expect, it } from "vitest";
import {
  cancelEventRegistrationSchema,
  checkEventRegistrationSchema,
  getEventSchema,
  getUpcomingEventsSchema,
  listEventsSchema,
  registerForEventSchema,
  updateEventSchema,
} from "../events.schemas";

describe("Events Schemas", () => {
  describe("Query Schemas", () => {
    describe("listEventsSchema", () => {
      it("validates with all filters", () => {
        const result = listEventsSchema.safeParse({
          filters: {
            status: ["registration_open", "published"],
            type: "tournament",
            organizerId: "org-123",
            startDateFrom: new Date("2025-01-01"),
            startDateTo: new Date("2025-12-31"),
            city: "Toronto",
            province: "ON",
          },
          page: 1,
          pageSize: 20,
          sortBy: "startDate",
          sortOrder: "asc",
        });
        expect(result.success).toBe(true);
      });

      it("validates with empty input (uses defaults)", () => {
        const result = listEventsSchema.safeParse(undefined);
        expect(result.success).toBe(true);
        expect(result.data).toEqual({});
      });

      it("validates with partial filters", () => {
        const result = listEventsSchema.safeParse({
          filters: {
            type: ["tournament", "league"],
            city: "Vancouver",
          },
          sortBy: "name",
        });
        expect(result.success).toBe(true);
      });

      it("validates status as string or array", () => {
        const stringResult = listEventsSchema.safeParse({
          filters: { status: "published" },
        });
        expect(stringResult.success).toBe(true);

        const arrayResult = listEventsSchema.safeParse({
          filters: { status: ["published", "registration_open"] },
        });
        expect(arrayResult.success).toBe(true);
      });

      it("fails with invalid sortBy", () => {
        const result = listEventsSchema.safeParse({
          sortBy: "invalid",
        });
        expect(result.success).toBe(false);
      });

      it("fails with negative page number", () => {
        const result = listEventsSchema.safeParse({
          page: -1,
        });
        expect(result.success).toBe(false);
      });
    });

    describe("getEventSchema", () => {
      it("validates with ID", () => {
        const result = getEventSchema.safeParse({
          id: "event-123",
        });
        expect(result.success).toBe(true);
      });

      it("validates with slug", () => {
        const result = getEventSchema.safeParse({
          slug: "summer-tournament-2025",
        });
        expect(result.success).toBe(true);
      });

      it("validates with both ID and slug", () => {
        const result = getEventSchema.safeParse({
          id: "event-123",
          slug: "summer-tournament-2025",
        });
        expect(result.success).toBe(true);
      });

      it("validates with empty object", () => {
        const result = getEventSchema.safeParse({});
        expect(result.success).toBe(true);
      });
    });

    describe("getUpcomingEventsSchema", () => {
      it("validates with limit", () => {
        const result = getUpcomingEventsSchema.safeParse({
          limit: 5,
        });
        expect(result.success).toBe(true);
      });

      it("validates without input (uses defaults)", () => {
        const result = getUpcomingEventsSchema.safeParse(undefined);
        expect(result.success).toBe(true);
        expect(result.data).toEqual({});
      });

      it("fails with limit over 10", () => {
        const result = getUpcomingEventsSchema.safeParse({
          limit: 11,
        });
        expect(result.success).toBe(false);
      });

      it("fails with negative limit", () => {
        const result = getUpcomingEventsSchema.safeParse({
          limit: -1,
        });
        expect(result.success).toBe(false);
      });
    });

    describe("checkEventRegistrationSchema", () => {
      it("validates with event ID only", () => {
        const result = checkEventRegistrationSchema.safeParse({
          eventId: "event-123",
        });
        expect(result.success).toBe(true);
      });

      it("validates with event and team ID", () => {
        const result = checkEventRegistrationSchema.safeParse({
          eventId: "event-123",
          teamId: "team-789",
        });
        expect(result.success).toBe(true);
      });

      it("fails without event ID", () => {
        const result = checkEventRegistrationSchema.safeParse({
          teamId: "team-789",
        });
        expect(result.success).toBe(false);
      });

      it("fails with empty object", () => {
        const result = checkEventRegistrationSchema.safeParse({});
        expect(result.success).toBe(false);
      });
    });
  });

  describe("Mutation Schemas", () => {
    describe("updateEventSchema", () => {
      it("validates with partial update data", () => {
        const result = updateEventSchema.safeParse({
          eventId: "event-123",
          data: {
            name: "Updated Tournament Name",
            status: "registration_open",
            maxTeams: 16,
          },
        });
        expect(result.success).toBe(true);
      });

      it("validates with status update only", () => {
        const result = updateEventSchema.safeParse({
          eventId: "event-123",
          data: {
            status: "cancelled",
          },
        });
        expect(result.success).toBe(true);
      });

      it("validates all status values", () => {
        const statuses = [
          "draft",
          "published",
          "registration_open",
          "registration_closed",
          "in_progress",
          "completed",
          "cancelled",
        ];

        statuses.forEach((status) => {
          const result = updateEventSchema.safeParse({
            eventId: "event-123",
            data: { status },
          });
          expect(result.success).toBe(true);
        });
      });

      it("validates with empty data", () => {
        const result = updateEventSchema.safeParse({
          eventId: "event-123",
          data: {},
        });
        expect(result.success).toBe(true);
      });

      it("fails without event ID", () => {
        const result = updateEventSchema.safeParse({
          data: {
            name: "Updated Name",
          },
        });
        expect(result.success).toBe(false);
      });
    });

    describe("registerForEventSchema", () => {
      it("validates team registration with roster", () => {
        const result = registerForEventSchema.safeParse({
          eventId: "event-123",
          teamId: "team-456",
          division: "competitive",
          notes: "Looking forward to the tournament",
          roster: [
            { userId: "user-1", role: "captain" },
            { userId: "user-2", role: "player" },
            { userId: "user-3", role: "player" },
          ],
        });
        expect(result.success).toBe(true);
      });

      it("validates individual registration", () => {
        const result = registerForEventSchema.safeParse({
          eventId: "event-123",
          division: "recreational",
          notes: "First time participating",
        });
        expect(result.success).toBe(true);
      });

      it("validates minimal registration", () => {
        const result = registerForEventSchema.safeParse({
          eventId: "event-123",
        });
        expect(result.success).toBe(true);
      });

      it("fails without event ID", () => {
        const result = registerForEventSchema.safeParse({
          teamId: "team-456",
          division: "competitive",
        });
        expect(result.success).toBe(false);
      });

      it("validates roster with multiple players", () => {
        const result = registerForEventSchema.safeParse({
          eventId: "event-123",
          teamId: "team-456",
          roster: Array.from({ length: 10 }, (_, i) => ({
            userId: `user-${i}`,
            role: i === 0 ? "captain" : "player",
          })),
        });
        expect(result.success).toBe(true);
        expect(result.data?.roster).toHaveLength(10);
      });
    });

    describe("cancelEventRegistrationSchema", () => {
      it("validates with reason", () => {
        const result = cancelEventRegistrationSchema.safeParse({
          registrationId: "reg-123",
          reason: "Team unable to attend due to scheduling conflict",
        });
        expect(result.success).toBe(true);
      });

      it("validates without reason", () => {
        const result = cancelEventRegistrationSchema.safeParse({
          registrationId: "reg-123",
        });
        expect(result.success).toBe(true);
      });

      it("validates with empty reason", () => {
        const result = cancelEventRegistrationSchema.safeParse({
          registrationId: "reg-123",
          reason: "",
        });
        expect(result.success).toBe(true);
      });

      it("fails without registration ID", () => {
        const result = cancelEventRegistrationSchema.safeParse({
          reason: "Cannot attend",
        });
        expect(result.success).toBe(false);
      });
    });
  });
});
</file>

<file path="src/features/events/components/event-list.tsx">
import { useQuery } from "@tanstack/react-query";
import { Link } from "@tanstack/react-router";
import { format } from "date-fns";
import { CalendarIcon, ClockIcon, MapPinIcon, TagIcon, UsersIcon } from "lucide-react";
import { useState } from "react";
import { Badge } from "~/components/ui/badge";
import { Button } from "~/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";
import { Skeleton } from "~/components/ui/skeleton";
import { cn } from "~/shared/lib/utils";
import { listEvents } from "../events.queries";
import type { EventFilters, EventListResult, EventWithDetails } from "../events.types";

type SortBy = "startDate" | "name" | "createdAt";
type SortOrder = "asc" | "desc";

interface EventListProps {
  showFilters?: boolean;
  initialFilters?: EventFilters;
  pageSize?: number;
}

const DEFAULT_FILTERS: EventFilters = {};
const SKELETON_CARD_KEYS = [
  "skeleton-0",
  "skeleton-1",
  "skeleton-2",
  "skeleton-3",
  "skeleton-4",
  "skeleton-5",
];

const SORT_OPTIONS: { label: string; value: SortBy }[] = [
  { label: "Start Date", value: "startDate" },
  { label: "Name", value: "name" },
  { label: "Recently Added", value: "createdAt" },
];

const SORT_ORDER_OPTIONS: { label: string; value: SortOrder }[] = [
  { label: "Ascending", value: "asc" },
  { label: "Descending", value: "desc" },
];

export function EventList({
  showFilters = true,
  initialFilters = DEFAULT_FILTERS,
  pageSize = 12,
}: EventListProps) {
  const [filters, setFilters] = useState<EventFilters>(() => ({ ...initialFilters }));
  const [page, setPage] = useState(1);
  const [sortBy, setSortBy] = useState<SortBy>("startDate");
  const [sortOrder, setSortOrder] = useState<SortOrder>("asc");

  const { data, isLoading, error } = useQuery<EventListResult, Error>({
    queryKey: ["events", filters, page, pageSize, sortBy, sortOrder],
    queryFn: () =>
      listEvents({
        data: {
          filters,
          page,
          pageSize,
          sortBy,
          sortOrder,
        },
      }),
  });

  const handleFilterChange = <K extends keyof EventFilters>(
    key: K,
    value: EventFilters[K] | undefined,
  ) => {
    setFilters((prev) => {
      const next: EventFilters = { ...prev };
      if (value === undefined || (typeof value === "string" && value.length === 0)) {
        delete next[key];
      } else {
        next[key] = value as EventFilters[K];
      }
      return next;
    });
    setPage(1);
  };

  const typeFilterValue = typeof filters.type === "string" ? filters.type : "all";
  const statusFilterValue = typeof filters.status === "string" ? filters.status : "all";
  const provinceFilterValue = filters.province ?? "all";

  const filterSection = showFilters ? (
    <Card>
      <CardHeader>
        <CardTitle>Filter Events</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
          <div className="space-y-2">
            <Label htmlFor="type">Event Type</Label>
            <Select
              value={typeFilterValue}
              onValueChange={(value) =>
                handleFilterChange(
                  "type",
                  value === "all" ? undefined : (value as EventFilters["type"]),
                )
              }
            >
              <SelectTrigger id="type">
                <SelectValue placeholder="All types" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">All types</SelectItem>
                <SelectItem value="tournament">Tournament</SelectItem>
                <SelectItem value="league">League</SelectItem>
                <SelectItem value="camp">Camp</SelectItem>
                <SelectItem value="clinic">Clinic</SelectItem>
                <SelectItem value="social">Social</SelectItem>
                <SelectItem value="other">Other</SelectItem>
              </SelectContent>
            </Select>
          </div>

          <div className="space-y-2">
            <Label htmlFor="status">Status</Label>
            <Select
              value={statusFilterValue}
              onValueChange={(value) =>
                handleFilterChange(
                  "status",
                  value === "all" ? undefined : (value as EventFilters["status"]),
                )
              }
            >
              <SelectTrigger id="status">
                <SelectValue placeholder="All statuses" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">All statuses</SelectItem>
                <SelectItem value="published">Published</SelectItem>
                <SelectItem value="registration_open">Registration Open</SelectItem>
                <SelectItem value="registration_closed">Registration Closed</SelectItem>
                <SelectItem value="in_progress">In Progress</SelectItem>
                <SelectItem value="completed">Completed</SelectItem>
              </SelectContent>
            </Select>
          </div>

          <div className="space-y-2">
            <Label htmlFor="city">City</Label>
            <Input
              id="city"
              placeholder="Filter by city"
              value={filters.city ?? ""}
              onChange={(event) =>
                handleFilterChange("city", event.target.value || undefined)
              }
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="province">Province</Label>
            <Select
              value={provinceFilterValue}
              onValueChange={(value) =>
                handleFilterChange(
                  "province",
                  value === "all" ? undefined : (value as EventFilters["province"]),
                )
              }
            >
              <SelectTrigger id="province">
                <SelectValue placeholder="All provinces" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">All provinces</SelectItem>
                <SelectItem value="AB">Alberta</SelectItem>
                <SelectItem value="BC">British Columbia</SelectItem>
                <SelectItem value="MB">Manitoba</SelectItem>
                <SelectItem value="NB">New Brunswick</SelectItem>
                <SelectItem value="NL">Newfoundland and Labrador</SelectItem>
                <SelectItem value="NS">Nova Scotia</SelectItem>
                <SelectItem value="ON">Ontario</SelectItem>
                <SelectItem value="PE">Prince Edward Island</SelectItem>
                <SelectItem value="QC">Quebec</SelectItem>
                <SelectItem value="SK">Saskatchewan</SelectItem>
              </SelectContent>
            </Select>
          </div>

          <div className="space-y-2">
            <Label htmlFor="sortBy">Sort By</Label>
            <Select value={sortBy} onValueChange={(value) => setSortBy(value as SortBy)}>
              <SelectTrigger id="sortBy">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                {SORT_OPTIONS.map((option) => (
                  <SelectItem key={option.value} value={option.value}>
                    {option.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          <div className="space-y-2">
            <Label htmlFor="sortOrder">Sort Order</Label>
            <Select
              value={sortOrder}
              onValueChange={(value) => setSortOrder(value as SortOrder)}
            >
              <SelectTrigger id="sortOrder">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                {SORT_ORDER_OPTIONS.map((option) => (
                  <SelectItem key={option.value} value={option.value}>
                    {option.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </div>
      </CardContent>
    </Card>
  ) : null;

  if (error) {
    return (
      <div className="text-destructive text-center">
        Error loading events: {error.message}
      </div>
    );
  }

  const events = data?.events ?? [];
  const hasNoEvents = !isLoading && events.length === 0;

  return (
    <div className="space-y-6">
      {filterSection}

      {isLoading ? (
        <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {SKELETON_CARD_KEYS.map((key) => (
            <Card key={key}>
              <CardHeader>
                <Skeleton className="h-6 w-3/4" />
              </CardHeader>
              <CardContent className="space-y-2">
                <Skeleton className="h-4 w-full" />
                <Skeleton className="h-4 w-2/3" />
                <Skeleton className="h-4 w-1/2" />
              </CardContent>
            </Card>
          ))}
        </div>
      ) : hasNoEvents ? (
        <Card className="p-8 text-center">
          <p className="text-muted-foreground">No events found matching your criteria.</p>
        </Card>
      ) : (
        <>
          <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
            {events.map((event) => (
              <EventCard key={event.id} event={event} />
            ))}
          </div>

          {data && data.pageInfo.totalPages > 1 && (
            <div className="flex items-center justify-between">
              <div className="text-muted-foreground text-sm">
                Showing {(page - 1) * pageSize + 1}-
                {Math.min(page * pageSize, data.totalCount)} of {data.totalCount} events
              </div>
              <div className="flex gap-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((prev) => Math.max(1, prev - 1))}
                  disabled={!data.pageInfo.hasPreviousPage}
                >
                  Previous
                </Button>
                <div className="flex items-center gap-1">
                  {Array.from(
                    { length: Math.min(5, data.pageInfo.totalPages) },
                    (_, index) => {
                      const pageNumber = index + 1;
                      return (
                        <Button
                          key={`page-${pageNumber}`}
                          variant={pageNumber === page ? "default" : "outline"}
                          size="sm"
                          onClick={() => setPage(pageNumber)}
                        >
                          {pageNumber}
                        </Button>
                      );
                    },
                  )}
                  {data.pageInfo.totalPages > 5 && (
                    <span className="text-muted-foreground px-2">...</span>
                  )}
                </div>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setPage((prev) => prev + 1)}
                  disabled={!data.pageInfo.hasNextPage}
                >
                  Next
                </Button>
              </div>
            </div>
          )}
        </>
      )}
    </div>
  );
}

function EventCard({ event }: { event: EventWithDetails }) {
  const typeIcon = getTypeIcon(event.type);
  const badgeAppearance = getStatusBadgeAppearance(event.status);

  return (
    <Card className="group transition-all hover:shadow-lg">
      <CardHeader>
        <div className="flex items-start justify-between">
          <div className="flex-1">
            <Link
              to="/dashboard/events/$slug"
              params={{ slug: event.slug }}
              className="group-hover:underline"
            >
              <CardTitle className="line-clamp-2">
                <span className="mr-2">{typeIcon}</span>
                {event.name}
              </CardTitle>
            </Link>
          </div>
          <Badge
            variant={badgeAppearance.variant}
            className={cn("ml-2 capitalize", badgeAppearance.className)}
          >
            {event.status.replace("_", " ")}
          </Badge>
        </div>
      </CardHeader>
      <CardContent className="space-y-4">
        <p className="text-muted-foreground line-clamp-3 text-sm">
          {event.shortDescription || event.description}
        </p>

        <div className="space-y-2 text-sm">
          <div className="flex items-center gap-2">
            <CalendarIcon className="text-muted-foreground h-4 w-4" />
            <span>
              {format(new Date(event.startDate), "MMM d")}
              {event.endDate !== event.startDate &&
                ` - ${format(new Date(event.endDate), "MMM d, yyyy")}`}
            </span>
          </div>

          {event.city ? (
            <div className="flex items-center gap-2">
              <MapPinIcon className="text-muted-foreground h-4 w-4" />
              <span>
                {event.city}
                {event.province && `, ${event.province}`}
              </span>
            </div>
          ) : null}

          {event.isRegistrationOpen ? (
            <div className="flex items-center gap-2">
              <ClockIcon className="h-4 w-4 text-emerald-600" />
              <span className="font-medium text-emerald-600">Registration Open</span>
              {event.availableSpots !== undefined ? (
                <span className="text-muted-foreground">
                  ({event.availableSpots} spots left)
                </span>
              ) : null}
            </div>
          ) : null}

          <div className="flex items-center gap-2">
            <UsersIcon className="text-muted-foreground h-4 w-4" />
            <span>{event.registrationCount} registered</span>
          </div>

          <div className="flex items-center gap-2">
            <TagIcon className="text-muted-foreground h-4 w-4" />
            <span className="capitalize">{event.registrationType} registration</span>
          </div>
        </div>

        <div className="pt-2">
          <Button asChild className="w-full" size="sm">
            <Link to="/dashboard/events/$slug" params={{ slug: event.slug }}>
              View Details
            </Link>
          </Button>
        </div>
      </CardContent>
    </Card>
  );
}

function getStatusBadgeAppearance(status: EventWithDetails["status"]): {
  variant: "default" | "secondary" | "destructive" | "outline";
  className?: string;
} {
  switch (status) {
    case "draft":
      return { variant: "secondary" };
    case "published":
      return { variant: "default" };
    case "registration_open":
      return {
        variant: "outline",
        className: "border-emerald-200 bg-emerald-50 text-emerald-700",
      };
    case "registration_closed":
      return {
        variant: "outline",
        className: "border-amber-200 bg-amber-50 text-amber-700",
      };
    case "in_progress":
      return {
        variant: "outline",
        className: "border-sky-200 bg-sky-50 text-sky-700",
      };
    case "completed":
      return { variant: "default" };
    case "cancelled":
      return { variant: "destructive" };
    default:
      return { variant: "default" };
  }
}

function getTypeIcon(type: EventWithDetails["type"]): string {
  const icons: Record<EventWithDetails["type"], string> = {
    tournament: "ð",
    league: "ð",
    camp: "ðï¸",
    clinic: "ð",
    social: "ð",
    other: "ð",
  };

  return icons[type] ?? "ð";
}
</file>

<file path="src/features/profile/__tests__/profile.validation.test.ts">
import { describe, expect, it } from "vitest";
import {
  completeUserProfileInputSchema,
  updatePrivacySettingsInputSchema,
  updateUserProfileInputSchema,
} from "../profile.schemas";

describe("Profile Server Function Input Schemas", () => {
  describe("updateUserProfileInputSchema", () => {
    it("validates valid partial profile data", () => {
      const validInput = {
        data: {
          gender: "Female",
          pronouns: "she/her",
        },
      };

      const result = updateUserProfileInputSchema.safeParse(validInput);
      expect(result.success).toBe(true);
    });

    it("validates empty data object", () => {
      const validInput = {
        data: {},
      };

      const result = updateUserProfileInputSchema.safeParse(validInput);
      expect(result.success).toBe(true);
    });

    it("validates with date of birth", () => {
      const validInput = {
        data: {
          dateOfBirth: new Date("1990-01-01"),
        },
      };

      const result = updateUserProfileInputSchema.safeParse(validInput);
      expect(result.success).toBe(true);
    });

    it("fails with invalid date of birth (too young)", () => {
      const invalidInput = {
        data: {
          dateOfBirth: new Date("2020-01-01"),
        },
      };

      const result = updateUserProfileInputSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.issues[0]?.message).toContain(
          "You must be between 13 and 120 years old",
        );
      }
    });

    it("validates with emergency contact", () => {
      const validInput = {
        data: {
          emergencyContact: {
            name: "John Doe",
            relationship: "Friend",
            phone: "123-456-7890",
          },
        },
      };

      const result = updateUserProfileInputSchema.safeParse(validInput);
      expect(result.success).toBe(true);
    });

    it("fails with invalid emergency contact (missing contact method)", () => {
      const invalidInput = {
        data: {
          emergencyContact: {
            name: "John Doe",
            relationship: "Friend",
          },
        },
      };

      const result = updateUserProfileInputSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });

    it("validates with privacy settings", () => {
      const validInput = {
        data: {
          privacySettings: {
            showEmail: true,
            showPhone: false,
            showBirthYear: true,
            allowTeamInvitations: true,
          },
        },
      };

      const result = updateUserProfileInputSchema.safeParse(validInput);
      expect(result.success).toBe(true);
    });

    it("fails with missing data wrapper", () => {
      const invalidInput = {
        gender: "Female",
      };

      const result = updateUserProfileInputSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });
  });

  describe("completeUserProfileInputSchema", () => {
    it("validates complete profile data", () => {
      const validInput = {
        data: {
          dateOfBirth: new Date("1990-01-01"),
          emergencyContact: {
            name: "Jane Doe",
            relationship: "Mother",
            phone: "555-123-4567",
          },
          gender: "Female",
          pronouns: "she/her",
          phone: "555-987-6543",
          privacySettings: {
            showEmail: true,
            showPhone: false,
            showBirthYear: false,
            allowTeamInvitations: true,
          },
        },
      };

      const result = completeUserProfileInputSchema.safeParse(validInput);
      expect(result.success).toBe(true);
    });

    it("validates minimal required data", () => {
      const validInput = {
        data: {
          dateOfBirth: new Date("1990-01-01"),
        },
      };

      const result = completeUserProfileInputSchema.safeParse(validInput);
      expect(result.success).toBe(true);
    });

    it("fails without required dateOfBirth", () => {
      const invalidInput = {
        data: {
          gender: "Male",
        },
      };

      const result = completeUserProfileInputSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });

    it("fails with invalid date of birth", () => {
      const invalidInput = {
        data: {
          dateOfBirth: new Date("1800-01-01"),
        },
      };

      const result = completeUserProfileInputSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.issues[0]?.message).toContain(
          "You must be between 13 and 120 years old",
        );
      }
    });
  });

  describe("updatePrivacySettingsInputSchema", () => {
    it("validates valid privacy settings", () => {
      const validInput = {
        data: {
          showEmail: false,
          showPhone: false,
          showBirthYear: false,
          allowTeamInvitations: false,
        },
      };

      const result = updatePrivacySettingsInputSchema.safeParse(validInput);
      expect(result.success).toBe(true);
    });

    it("fails with missing required fields", () => {
      const invalidInput = {
        data: {
          showEmail: true,
          showPhone: true,
          // Missing showBirthYear and allowTeamInvitations
        },
      };

      const result = updatePrivacySettingsInputSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });

    it("fails with invalid field types", () => {
      const invalidInput = {
        data: {
          showEmail: "yes", // Should be boolean
          showPhone: true,
          showBirthYear: true,
          allowTeamInvitations: true,
        },
      };

      const result = updatePrivacySettingsInputSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });

    it("fails without data wrapper", () => {
      const invalidInput = {
        showEmail: true,
        showPhone: true,
        showBirthYear: true,
        allowTeamInvitations: true,
      };

      const result = updatePrivacySettingsInputSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });
  });
});
</file>

<file path="src/features/profile/profile.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import type {
  EmergencyContact,
  PrivacySettings,
  ProfileOperationResult,
  UserProfile,
} from "./profile.types";

function parseJsonField<T>(value: string | null | undefined): T | undefined {
  if (!value) return undefined;
  try {
    return JSON.parse(value) as T;
  } catch {
    return undefined;
  }
}

function mapDbUserToProfile(dbUser: {
  id: string;
  name: string;
  email: string;
  profileComplete: boolean;
  dateOfBirth: Date | null;
  emergencyContact: string | null;
  gender: string | null;
  pronouns: string | null;
  phone: string | null;
  privacySettings: string | null;
  profileVersion: number;
  profileUpdatedAt: Date | null;
}): UserProfile {
  return {
    id: dbUser.id,
    name: dbUser.name,
    email: dbUser.email,
    profileComplete: dbUser.profileComplete,
    dateOfBirth: dbUser.dateOfBirth ?? undefined,
    emergencyContact: parseJsonField<EmergencyContact>(dbUser.emergencyContact),
    gender: dbUser.gender ?? undefined,
    pronouns: dbUser.pronouns ?? undefined,
    phone: dbUser.phone ?? undefined,
    privacySettings: parseJsonField<PrivacySettings>(dbUser.privacySettings),
    profileVersion: dbUser.profileVersion,
    profileUpdatedAt: dbUser.profileUpdatedAt ?? undefined,
  };
}

export const getUserProfile = createServerFn({ method: "GET" }).handler(
  async (): Promise<ProfileOperationResult> => {
    try {
      // Import server-only modules inside the handler
      const [{ getDb }, { getAuth }] = await Promise.all([
        import("~/db/server-helpers"),
        import("~/lib/auth/server-helpers"),
      ]);

      const auth = await getAuth();
      const { getRequest } = await import("@tanstack/react-start/server");
      const { headers } = getRequest();
      const session = await auth.api.getSession({ headers });

      if (!session?.user?.id) {
        return {
          success: false,
          errors: [{ code: "VALIDATION_ERROR", message: "User not authenticated" }],
        };
      }

      const { eq } = await import("drizzle-orm");
      const { user } = await import("~/db/schema");

      const db = await getDb();

      const [dbUser] = await db
        .select()
        .from(user)
        .where(eq(user.id, session.user.id))
        .limit(1);

      if (!dbUser) {
        return {
          success: false,
          errors: [{ code: "DATABASE_ERROR", message: "User not found" }],
        };
      }

      return {
        success: true,
        data: mapDbUserToProfile(dbUser),
      };
    } catch (error) {
      console.error("Error fetching user profile:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to fetch user profile",
          },
        ],
      };
    }
  },
);

export const getProfileCompletionStatus = createServerFn({ method: "GET" }).handler(
  async (): Promise<{ complete: boolean; missingFields: string[] }> => {
    try {
      // Import server-only modules inside the handler
      const [{ getDb }, { getAuth }] = await Promise.all([
        import("~/db/server-helpers"),
        import("~/lib/auth/server-helpers"),
      ]);

      const auth = await getAuth();
      const { getRequest } = await import("@tanstack/react-start/server");
      const { headers } = getRequest();
      const session = await auth.api.getSession({ headers });

      if (!session?.user?.id) {
        throw new Error("User not authenticated");
      }

      const { eq } = await import("drizzle-orm");
      const { user } = await import("~/db/schema");

      const db = await getDb();

      const [dbUser] = await db
        .select()
        .from(user)
        .where(eq(user.id, session.user.id))
        .limit(1);

      if (!dbUser) {
        throw new Error("User not found");
      }

      const missingFields: string[] = [];

      // Required fields for profile completion
      if (!dbUser.dateOfBirth) {
        missingFields.push("dateOfBirth");
      }

      // Note: Emergency contact is optional but recommended
      // It is NOT included in missingFields to maintain consistency
      // with the UI which marks it as "optional but recommended"

      return {
        complete: dbUser.profileComplete,
        missingFields,
      };
    } catch (error) {
      console.error("Error checking profile completion:", error);
      throw error;
    }
  },
);

// Re-export utility function
export { isProfileComplete } from "./profile.utils";
</file>

<file path="src/features/profile/profile.schemas.ts">
import { z } from "zod";

export const emergencyContactSchema = z
  .object({
    name: z.string().min(1, "Emergency contact name is required"),
    relationship: z.string().min(1, "Relationship is required"),
    phone: z.string().optional(),
    email: z.email("Invalid emergency contact email").optional(),
  })
  .refine((data) => data.phone || data.email, {
    path: ["phone"], // This will show the error on the phone field
    error: "Please provide at least one contact method (phone or email)",
  });

export const privacySettingsSchema = z.object({
  showEmail: z.boolean(),
  showPhone: z.boolean(),
  showBirthYear: z.boolean(),
  allowTeamInvitations: z.boolean(),
});

export const profileInputSchema = z.object({
  dateOfBirth: z
    .preprocess((arg) => {
      if (typeof arg === "string" && !arg.includes("T")) {
        return new Date(`${arg}T00:00:00.000Z`);
      }
      return typeof arg === "string" ? new Date(arg) : arg;
    }, z.date())
    .refine(
      (date) => {
        const today = new Date();
        let age = today.getUTCFullYear() - date.getUTCFullYear();
        const m = today.getUTCMonth() - date.getUTCMonth();
        if (m < 0 || (m === 0 && today.getUTCDate() < date.getUTCDate())) {
          age--;
        }
        return age >= 13 && age <= 120;
      },
      {
        error: "You must be between 13 and 120 years old",
      },
    ),
  emergencyContact: emergencyContactSchema.optional(),
  gender: z.string().optional(),
  pronouns: z.string().optional(),
  phone: z.string().optional(),
  privacySettings: privacySettingsSchema.optional(),
});

export const partialProfileInputSchema = profileInputSchema.partial();

export type ProfileInputType = z.infer<typeof profileInputSchema>;
export type PartialProfileInputType = z.infer<typeof partialProfileInputSchema>;

// Server function input schemas
export const updateUserProfileInputSchema = z.object({
  data: partialProfileInputSchema,
});

export const completeUserProfileInputSchema = z.object({
  data: profileInputSchema,
});

export const updatePrivacySettingsInputSchema = z.object({
  data: privacySettingsSchema,
});
</file>

<file path="src/features/settings/settings.mutations.ts">
import { createServerFn } from "@tanstack/react-start";
import { zod$ } from "~/lib/server/fn-utils";
import {
  changePasswordInputSchema,
  revokeSessionInputSchema,
  unlinkAccountInputSchema,
} from "./settings.schemas";
import type { ApiResult } from "./settings.types";

export const changePassword = createServerFn({ method: "POST" })
  .inputValidator(zod$(changePasswordInputSchema))
  .handler(async ({ data }) => {
    try {
      const [{ getAuth }, { getRequest }] = await Promise.all([
        import("~/lib/auth/server-helpers"),
        import("@tanstack/react-start/server"),
      ]);

      const auth = await getAuth();
      const { headers } = getRequest();

      await auth.api.changePassword({
        headers,
        body: {
          currentPassword: data.currentPassword,
          newPassword: data.newPassword,
          revokeOtherSessions: data.revokeOtherSessions ?? false,
        },
      });

      return {
        success: true,
      } satisfies ApiResult<null>;
    } catch (error) {
      console.error("Failed to change password", error);
      const message =
        error instanceof Error
          ? error.message
          : "Unable to update password. Please try again.";
      return {
        success: false,
        errors: [
          {
            code: "CHANGE_PASSWORD_FAILED",
            message,
          },
        ],
      } satisfies ApiResult<null>;
    }
  });

export const revokeSession = createServerFn({ method: "POST" })
  .inputValidator(zod$(revokeSessionInputSchema))
  .handler(async ({ data }) => {
    try {
      const [{ getAuth }, { getRequest }] = await Promise.all([
        import("~/lib/auth/server-helpers"),
        import("@tanstack/react-start/server"),
      ]);

      const auth = await getAuth();
      const { headers } = getRequest();

      await auth.api.revokeSession({
        headers,
        body: { token: data.token },
      });

      return {
        success: true,
      } satisfies ApiResult<null>;
    } catch (error) {
      console.error("Failed to revoke session", error);
      const message =
        error instanceof Error
          ? error.message
          : "Unable to revoke session. Please try again.";
      return {
        success: false,
        errors: [
          {
            code: "REVOKE_SESSION_FAILED",
            message,
          },
        ],
      } satisfies ApiResult<null>;
    }
  });

export const revokeOtherSessions = createServerFn({ method: "POST" }).handler(
  async () => {
    try {
      const [{ getAuth }, { getRequest }] = await Promise.all([
        import("~/lib/auth/server-helpers"),
        import("@tanstack/react-start/server"),
      ]);

      const auth = await getAuth();
      const { headers } = getRequest();

      await auth.api.revokeOtherSessions({ headers });

      return {
        success: true,
      } satisfies ApiResult<null>;
    } catch (error) {
      console.error("Failed to revoke other sessions", error);
      const message =
        error instanceof Error
          ? error.message
          : "Unable to revoke other sessions. Please try again.";
      return {
        success: false,
        errors: [
          {
            code: "REVOKE_OTHER_SESSIONS_FAILED",
            message,
          },
        ],
      } satisfies ApiResult<null>;
    }
  },
);

export const unlinkAccount = createServerFn({ method: "POST" })
  .inputValidator(zod$(unlinkAccountInputSchema))
  .handler(async ({ data }) => {
    try {
      const [{ getAuth }, { getRequest }] = await Promise.all([
        import("~/lib/auth/server-helpers"),
        import("@tanstack/react-start/server"),
      ]);

      const auth = await getAuth();
      const { headers } = getRequest();

      await auth.api.unlinkAccount({
        headers,
        body: {
          providerId: data.providerId,
          accountId: data.accountId,
        },
      });

      return {
        success: true,
      } satisfies ApiResult<null>;
    } catch (error) {
      console.error("Failed to unlink account", error);
      const message =
        error instanceof Error
          ? error.message
          : "Unable to unlink account. Please try again.";
      return {
        success: false,
        errors: [
          {
            code: "UNLINK_ACCOUNT_FAILED",
            message,
          },
        ],
      } satisfies ApiResult<null>;
    }
  });
</file>

<file path="src/features/teams/__tests__/teams.schemas.test.ts">
import { describe, expect, it } from "vitest";
import {
  addTeamMemberSchema,
  createTeamSchema,
  getTeamBySlugSchema,
  getTeamMembersSchema,
  getTeamSchema,
  isTeamMemberSchema,
  listTeamsSchema,
  removeTeamMemberSchema,
  searchTeamsSchema,
  updateTeamMemberSchema,
  updateTeamSchema,
} from "../teams.schemas";

describe("Teams Schemas", () => {
  describe("Query Schemas", () => {
    describe("getTeamSchema", () => {
      it("validates valid team ID", () => {
        const result = getTeamSchema.safeParse({ teamId: "team-123" });
        expect(result.success).toBe(true);
      });

      it("fails without team ID", () => {
        const result = getTeamSchema.safeParse({});
        expect(result.success).toBe(false);
      });
    });

    describe("getTeamBySlugSchema", () => {
      it("validates valid slug", () => {
        const result = getTeamBySlugSchema.safeParse({ slug: "toronto-titans" });
        expect(result.success).toBe(true);
      });

      it("fails without slug", () => {
        const result = getTeamBySlugSchema.safeParse({});
        expect(result.success).toBe(false);
      });
    });

    describe("listTeamsSchema", () => {
      it("validates with includeInactive flag", () => {
        const result = listTeamsSchema.safeParse({ includeInactive: true });
        expect(result.success).toBe(true);
        expect(result.data?.includeInactive).toBe(true);
      });

      it("validates without any input (defaults to false)", () => {
        const result = listTeamsSchema.safeParse(undefined);
        expect(result.success).toBe(true);
        expect(result.data?.includeInactive).toBe(false);
      });

      it("validates empty object (defaults to false)", () => {
        const result = listTeamsSchema.safeParse({});
        expect(result.success).toBe(true);
        expect(result.data?.includeInactive).toBe(false);
      });
    });

    describe("getTeamMembersSchema", () => {
      it("validates with all fields", () => {
        const result = getTeamMembersSchema.safeParse({
          teamId: "team-123",
          includeInactive: true,
        });
        expect(result.success).toBe(true);
      });

      it("validates without optional field", () => {
        const result = getTeamMembersSchema.safeParse({
          teamId: "team-123",
        });
        expect(result.success).toBe(true);
      });

      it("fails without team ID", () => {
        const result = getTeamMembersSchema.safeParse({
          includeInactive: true,
        });
        expect(result.success).toBe(false);
      });
    });

    describe("isTeamMemberSchema", () => {
      it("validates with both IDs", () => {
        const result = isTeamMemberSchema.safeParse({
          teamId: "team-123",
          userId: "user-456",
        });
        expect(result.success).toBe(true);
      });

      it("fails without team ID", () => {
        const result = isTeamMemberSchema.safeParse({
          userId: "user-456",
        });
        expect(result.success).toBe(false);
      });

      it("fails without user ID", () => {
        const result = isTeamMemberSchema.safeParse({
          teamId: "team-123",
        });
        expect(result.success).toBe(false);
      });
    });

    describe("searchTeamsSchema", () => {
      it("validates with valid query", () => {
        const result = searchTeamsSchema.safeParse({
          query: "toronto",
        });
        expect(result.success).toBe(true);
      });

      it("trims whitespace from the query", () => {
        const result = searchTeamsSchema.safeParse({
          query: "  Toronto  ",
        });
        expect(result.success).toBe(true);
        if (result.success) {
          expect(result.data.query).toBe("Toronto");
        }
      });

      it("fails with empty query", () => {
        const result = searchTeamsSchema.safeParse({
          query: "",
        });
        expect(result.success).toBe(false);
      });

      it("fails with whitespace-only query", () => {
        const result = searchTeamsSchema.safeParse({
          query: "   ",
        });
        expect(result.success).toBe(false);
      });

      it("fails without query", () => {
        const result = searchTeamsSchema.safeParse({});
        expect(result.success).toBe(false);
      });
    });
  });

  describe("Mutation Schemas", () => {
    describe("createTeamSchema", () => {
      it("validates with all fields", () => {
        const result = createTeamSchema.safeParse({
          name: "Toronto Titans",
          slug: "toronto-titans",
          description: "A competitive Quadball team",
          city: "Toronto",
          province: "ON",
          primaryColor: "#FF0000",
          secondaryColor: "#0000FF",
          foundedYear: "2025",
          website: "https://torontotitans.com",
          socialLinks: {
            instagram: "@torontotitans",
            facebook: "torontotitans",
          },
        });
        expect(result.success).toBe(true);
      });

      it("validates with required fields only", () => {
        const result = createTeamSchema.safeParse({
          name: "Toronto Titans",
          slug: "toronto-titans",
        });
        expect(result.success).toBe(true);
      });

      it("fails without name", () => {
        const result = createTeamSchema.safeParse({
          slug: "toronto-titans",
        });
        expect(result.success).toBe(false);
      });

      it("fails without slug", () => {
        const result = createTeamSchema.safeParse({
          name: "Toronto Titans",
        });
        expect(result.success).toBe(false);
      });

      it("fails with invalid slug format", () => {
        const result = createTeamSchema.safeParse({
          name: "Toronto Titans",
          slug: "Toronto Titans", // Should be lowercase with hyphens
        });
        expect(result.success).toBe(false);
        if (!result.success) {
          expect(result.error.issues[0]?.message).toContain(
            "Slug can only contain lowercase letters, numbers, and hyphens",
          );
        }
      });

      it("fails with invalid color format", () => {
        const result = createTeamSchema.safeParse({
          name: "Toronto Titans",
          slug: "toronto-titans",
          primaryColor: "red", // Should be hex
        });
        expect(result.success).toBe(false);
      });

      it("fails with invalid founded year", () => {
        const result = createTeamSchema.safeParse({
          name: "Toronto Titans",
          slug: "toronto-titans",
          foundedYear: "25", // Should be 4 digits
        });
        expect(result.success).toBe(false);
      });

      it("fails with invalid website URL", () => {
        const result = createTeamSchema.safeParse({
          name: "Toronto Titans",
          slug: "toronto-titans",
          website: "not-a-url",
        });
        expect(result.success).toBe(false);
      });
    });

    describe("updateTeamSchema", () => {
      it("validates with all fields", () => {
        const result = updateTeamSchema.safeParse({
          teamId: "team-123",
          data: {
            name: "Toronto Titans Updated",
            description: "Updated description",
          },
        });
        expect(result.success).toBe(true);
      });

      it("validates with empty data (no updates)", () => {
        const result = updateTeamSchema.safeParse({
          teamId: "team-123",
          data: {},
        });
        expect(result.success).toBe(true);
      });

      it("fails without team ID", () => {
        const result = updateTeamSchema.safeParse({
          data: {
            name: "Updated Name",
          },
        });
        expect(result.success).toBe(false);
      });
    });

    describe("addTeamMemberSchema", () => {
      it("validates with all fields", () => {
        const result = addTeamMemberSchema.safeParse({
          teamId: "team-123",
          email: "player@example.com",
          role: "player",
          jerseyNumber: "42",
          position: "Chaser",
        });
        expect(result.success).toBe(true);
      });

      it("validates with required fields only", () => {
        const result = addTeamMemberSchema.safeParse({
          teamId: "team-123",
          email: "player@example.com",
          role: "player",
        });
        expect(result.success).toBe(true);
      });

      it("validates all role types", () => {
        const roles = ["captain", "coach", "player", "substitute"];
        roles.forEach((role) => {
          const result = addTeamMemberSchema.safeParse({
            teamId: "team-123",
            email: "player@example.com",
            role,
          });
          expect(result.success).toBe(true);
        });
      });

      it("fails with invalid email", () => {
        const result = addTeamMemberSchema.safeParse({
          teamId: "team-123",
          email: "not-an-email",
          role: "player",
        });
        expect(result.success).toBe(false);
        if (!result.success) {
          expect(result.error.issues[0]?.message).toContain("valid email");
        }
      });

      it("fails with invalid role", () => {
        const result = addTeamMemberSchema.safeParse({
          teamId: "team-123",
          email: "player@example.com",
          role: "manager", // Not a valid role
        });
        expect(result.success).toBe(false);
      });
    });

    describe("updateTeamMemberSchema", () => {
      it("validates with all fields", () => {
        const result = updateTeamMemberSchema.safeParse({
          teamId: "team-123",
          memberId: "member-456",
          role: "captain",
          jerseyNumber: "99",
          position: "Keeper",
          notes: "Promoted to captain",
        });
        expect(result.success).toBe(true);
      });

      it("validates with only required fields", () => {
        const result = updateTeamMemberSchema.safeParse({
          teamId: "team-123",
          memberId: "member-456",
        });
        expect(result.success).toBe(true);
      });

      it("fails without team ID", () => {
        const result = updateTeamMemberSchema.safeParse({
          memberId: "member-456",
          role: "captain",
        });
        expect(result.success).toBe(false);
      });

      it("fails without member ID", () => {
        const result = updateTeamMemberSchema.safeParse({
          teamId: "team-123",
          role: "captain",
        });
        expect(result.success).toBe(false);
      });
    });

    describe("removeTeamMemberSchema", () => {
      it("validates with both IDs", () => {
        const result = removeTeamMemberSchema.safeParse({
          teamId: "team-123",
          memberId: "member-456",
        });
        expect(result.success).toBe(true);
      });

      it("fails without team ID", () => {
        const result = removeTeamMemberSchema.safeParse({
          memberId: "member-456",
        });
        expect(result.success).toBe(false);
      });

      it("fails without member ID", () => {
        const result = removeTeamMemberSchema.safeParse({
          teamId: "team-123",
        });
        expect(result.success).toBe(false);
      });
    });
  });
});
</file>

<file path="src/features/teams/components/team-invitations.tsx">
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { formatDistanceToNow } from "date-fns";
import { useState } from "react";
import { Badge } from "~/components/ui/badge";
import { Button } from "~/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";
import { acceptTeamInvite, declineTeamInvite } from "~/features/teams/teams.mutations";
import type { PendingTeamInvite } from "~/features/teams/teams.queries";
import { cn } from "~/shared/lib/utils";

export interface TeamInvitationsSectionProps {
  invites: PendingTeamInvite[];
}

export function TeamInvitationsSection({ invites }: TeamInvitationsSectionProps) {
  const [feedback, setFeedback] = useState<{
    type: "success" | "error";
    message: string;
  } | null>(null);
  const queryClient = useQueryClient();

  const acceptInviteMutation = useMutation({
    mutationFn: async (teamId: string) =>
      acceptTeamInvite({ data: { teamId } }),
    onMutate: async (teamId: string) => {
      await queryClient.cancelQueries({ queryKey: ["pendingTeamInvites"] });
      const previousInvites = queryClient.getQueryData<PendingTeamInvite[]>([
        "pendingTeamInvites",
      ]);
      queryClient.setQueryData<PendingTeamInvite[]>(
        ["pendingTeamInvites"],
        (current = []) => current.filter((invite) => invite.membership.teamId !== teamId),
      );

      return { previousInvites, teamId };
    },
    onSuccess: () => {
      setFeedback({ type: "success", message: "Invitation accepted." });
    },
    onError: (error, _teamId, context) => {
      setFeedback({
        type: "error",
        message: error instanceof Error ? error.message : "Failed to accept invitation.",
      });
      if (context?.previousInvites) {
        queryClient.setQueryData(["pendingTeamInvites"], context.previousInvites);
      }
    },
    onSettled: (_, __, teamId) => {
      invalidateTeamQueries(teamId ?? "");
    },
  });

  const declineInviteMutation = useMutation({
    mutationFn: async (teamId: string) =>
      declineTeamInvite({ data: { teamId } }),
    onMutate: async (teamId: string) => {
      await queryClient.cancelQueries({ queryKey: ["pendingTeamInvites"] });
      const previousInvites = queryClient.getQueryData<PendingTeamInvite[]>([
        "pendingTeamInvites",
      ]);
      queryClient.setQueryData<PendingTeamInvite[]>(
        ["pendingTeamInvites"],
        (current = []) => current.filter((invite) => invite.membership.teamId !== teamId),
      );

      return { previousInvites, teamId };
    },
    onSuccess: () => {
      setFeedback({ type: "success", message: "Invitation declined." });
    },
    onError: (error, _teamId, context) => {
      setFeedback({
        type: "error",
        message: error instanceof Error ? error.message : "Failed to decline invitation.",
      });
      if (context?.previousInvites) {
        queryClient.setQueryData(["pendingTeamInvites"], context.previousInvites);
      }
    },
    onSettled: (_, __, teamId) => {
      invalidateTeamQueries(teamId ?? "");
    },
  });

  function invalidateTeamQueries(teamId: string) {
    queryClient.invalidateQueries({ queryKey: ["pendingTeamInvites"] });
    queryClient.invalidateQueries({ queryKey: ["user-teams"] });
    queryClient.invalidateQueries({ queryKey: ["teamMembers", teamId] });
  }

  if (invites.length === 0) {
    return null;
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between">
        <CardTitle className="text-xl">Pending Team Invitations</CardTitle>
        <Badge variant="secondary" className="tracking-wide uppercase">
          {invites.length} pending
        </Badge>
      </CardHeader>
      <CardContent className="space-y-4">
        {feedback && (
          <div
            className={cn(
              "rounded-md border px-3 py-2 text-sm",
              feedback.type === "error"
                ? "border-destructive/40 bg-destructive/10 text-destructive"
                : "border-primary/40 bg-primary/5 text-primary",
            )}
          >
            {feedback.message}
          </div>
        )}

        {invites.map((invite) => {
          const invitedAt = invite.membership.invitedAt
            ? new Date(invite.membership.invitedAt)
            : undefined;
          const requestedAt = invite.membership.requestedAt
            ? new Date(invite.membership.requestedAt)
            : undefined;

          const activityTimestamp = invitedAt || requestedAt;
          const activityLabel = invitedAt
            ? "Invitation sent"
            : requestedAt
              ? "Request created"
              : null;

          const isProcessing =
            acceptInviteMutation.isPending || declineInviteMutation.isPending;

          return (
            <Card key={invite.membership.id} className="border-muted bg-muted/20">
              <CardContent className="flex flex-col gap-4 p-4 md:flex-row md:items-center md:justify-between">
                <div>
                  <div className="flex items-center gap-2">
                    <h3 className="text-lg font-semibold">{invite.team.name}</h3>
                    <Badge variant="outline" className="capitalize">
                      {invite.membership.role}
                    </Badge>
                  </div>
                  {activityTimestamp && activityLabel && (
                    <p className="text-muted-foreground mt-1 text-sm">
                      {activityLabel}{" "}
                      {formatDistanceToNow(activityTimestamp, { addSuffix: true })}
                    </p>
                  )}
                  {invite.inviter?.name && (
                    <p className="text-muted-foreground mt-2 text-sm">
                      Invited by {invite.inviter.name}
                    </p>
                  )}
                </div>

                <div className="flex flex-col gap-2 md:flex-row">
                  <Button
                    variant="default"
                    onClick={() => acceptInviteMutation.mutate(invite.membership.teamId)}
                    disabled={isProcessing}
                  >
                    {acceptInviteMutation.isPending ? "Accepting..." : "Accept"}
                  </Button>
                  <Button
                    variant="outline"
                    onClick={() => declineInviteMutation.mutate(invite.membership.teamId)}
                    disabled={isProcessing}
                  >
                    {declineInviteMutation.isPending ? "Declining..." : "Decline"}
                  </Button>
                </div>
              </CardContent>
            </Card>
          );
        })}
      </CardContent>
    </Card>
  );
}

export default TeamInvitationsSection;
</file>

<file path="src/routes/api/auth/$action/$provider.ts">
import { createFileRoute } from "@tanstack/react-router";
import { getAuth } from "~/lib/auth/server-helpers";

export const Route = createFileRoute("/api/auth/$action/$provider")({
  server: {
    handlers: {
      GET: async ({ request }) => {
        const auth = await getAuth();
        return await auth.handler(request);
      },
      POST: async ({ request }) => {
        const auth = await getAuth();
        return await auth.handler(request);
      },
    },
  },
});
</file>

<file path="src/routes/api/auth/$.ts">
import { createFileRoute } from "@tanstack/react-router";
import { getAuth } from "~/lib/auth/server-helpers";

export const Route = createFileRoute("/api/auth/$")({
  server: {
    handlers: {
      GET: async ({ request }) => {
        const auth = await getAuth();
        return await auth.handler(request);
      },
      POST: async ({ request }) => {
        const auth = await getAuth();
        return await auth.handler(request);
      },
      OPTIONS: async ({ request }) => {
        const auth = await getAuth();
        return await auth.handler(request);
      },
    },
  },
});
</file>

<file path="src/routes/api/debug-square.ts">
import { createFileRoute } from "@tanstack/react-router";
import { getSquarePaymentService } from "~/lib/payments/square";
import { debugGuard } from "~/lib/server/debug-guard";

export const Route = createFileRoute("/api/debug-square")({
  server: {
    handlers: {
      GET: async () => {
        // Block access in production - returns 404
        const guardResponse = debugGuard();
        if (guardResponse) return guardResponse;

        try {
          // Test if we can get the Square service and what type it is
          const service = await getSquarePaymentService();
          const serviceName = service.constructor.name;

          // Only expose non-sensitive configuration info - no checkout creation
          return Response.json({
            status: "Square Debug Info",
            serviceType: serviceName,
            isRealSquare: serviceName === "SquarePaymentService",
            isMockSquare: serviceName === "MockSquarePaymentService",
            env: {
              SQUARE_ENV: process.env["SQUARE_ENV"] || "NOT SET",
              hasAccessToken: !!process.env["SQUARE_ACCESS_TOKEN"],
              hasLocationId: !!process.env["SQUARE_LOCATION_ID"],
            },
            timestamp: new Date().toISOString(),
          });
        } catch (error) {
          return Response.json(
            {
              error: "Failed to debug Square",
              message: error instanceof Error ? error.message : String(error),
            },
            { status: 500 },
          );
        }
      },
    },
  },
});
</file>

<file path="src/routes/api/test-square.ts">
import { createFileRoute } from "@tanstack/react-router";
import { debugGuard } from "~/lib/server/debug-guard";

export const Route = createFileRoute("/api/test-square")({
  server: {
    handlers: {
      GET: async () => {
        // Block access in production - returns 404
        const guardResponse = debugGuard();
        if (guardResponse) return guardResponse;

        const hasAccessToken = !!process.env["SQUARE_ACCESS_TOKEN"];
        const hasLocationId = !!process.env["SQUARE_LOCATION_ID"];
        const locationId = process.env["SQUARE_LOCATION_ID"];
        const env = process.env["SQUARE_ENV"];

        // Only show first/last few chars for security
        const maskValue = (val: string | undefined) => {
          if (!val) return "NOT SET";
          if (val.length < 10) return `${val.substring(0, 3)}...`;
          return `${val.substring(0, 5)}...${val.substring(val.length - 5)}`;
        };

        return Response.json({
          status: "Square Config Check",
          hasAccessToken,
          hasLocationId,
          locationId: maskValue(locationId),
          environment: env || "NOT SET",
          isValidLocationId: locationId && locationId !== "test-location-id",
          timestamp: new Date().toISOString(),
        });
      },
    },
  },
});
</file>

<file path="src/routes/auth/route.tsx">
import { createFileRoute, Outlet } from "@tanstack/react-router";
import { redirectIfAuthenticated } from "~/lib/auth/guards/route-guards";

export const Route = createFileRoute("/auth")({
  component: RouteComponent,
  beforeLoad: async ({ context }) => {
    redirectIfAuthenticated({ user: context.user });
  },
});

function RouteComponent() {
  return (
    <div className="bg-background flex min-h-screen flex-col">
      <main className="flex flex-1 flex-col items-center justify-center gap-6 p-6 md:p-10">
        <div className="w-full max-w-sm">
          <Outlet />
        </div>
      </main>
    </div>
  );
}
</file>

<file path="src/routes/dashboard/reports.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { Suspense } from "react";
import { AdminMembershipsReport } from "~/features/membership/components/admin-memberships-report";
import { requireGlobalAdmin } from "~/lib/auth/middleware/role-guard";

export const Route = createFileRoute("/dashboard/reports")({
  beforeLoad: async ({ context }) => {
    await requireGlobalAdmin(context.user);
  },
  component: ReportsPage,
});

function ReportsPage() {
  return (
    <div className="container mx-auto space-y-8 p-6">
      <h1 className="text-3xl font-bold tracking-tight">Reports</h1>

      <Suspense
        fallback={
          <div className="flex h-64 items-center justify-center">
            <div className="text-muted-foreground">Loading reports...</div>
          </div>
        }
      >
        <AdminMembershipsReport />
      </Suspense>
    </div>
  );
}
</file>

<file path="src/components/DefaultCatchBoundary.tsx">
import {
  ErrorComponent,
  type ErrorComponentProps,
  rootRouteId,
  useMatch,
  useRouter,
} from "@tanstack/react-router";
import { AlertCircle } from "lucide-react";
import { Button } from "~/components/ui/button";

export function DefaultCatchBoundary({ error }: Readonly<ErrorComponentProps>) {
  const router = useRouter();
  const isRoot = useMatch({
    strict: false,
    select: (state) => state.id === rootRouteId,
  });

  console.error(error);

  return (
    <div className="flex min-h-[60vh] flex-col items-center justify-center bg-gray-50 px-6 py-16 text-center">
      <div className="text-brand-red flex items-center gap-2">
        <AlertCircle className="h-5 w-5" />
        <span className="text-xs font-semibold tracking-[0.3em] uppercase">
          Something went wrong
        </span>
      </div>
      <h1 className="mt-4 text-2xl font-bold text-gray-900 sm:text-3xl">
        A bludger hit us while loading this view
      </h1>
      <p className="mt-3 max-w-xl text-sm text-gray-600 sm:text-base">
        {error.message ||
          "An unexpected error occurred. Try again in a moment or return to the previous page."}
      </p>
      <div className="mt-6 flex flex-wrap justify-center gap-3">
        <Button
          type="button"
          className="btn-brand-primary"
          onClick={() => {
            router.invalidate();
          }}
        >
          Retry
        </Button>
        <Button
          variant="outline"
          onClick={() => {
            if (isRoot) {
              router.navigate({ to: "/" });
            } else {
              window.history.back();
            }
          }}
          className="border-brand-red text-brand-red hover:bg-brand-red/10"
        >
          {isRoot ? "Go to homepage" : "Go back"}
        </Button>
        <Button asChild variant="ghost" className="text-sm">
          <a href="/">Visit the portal</a>
        </Button>
      </div>
      <div className="mt-10 w-full max-w-xl rounded-2xl border border-gray-200 bg-white p-6 text-left text-sm text-gray-600 shadow-sm">
        <p className="font-semibold text-gray-900">Technical details</p>
        <ErrorComponent error={error} />
      </div>
    </div>
  );
}
</file>

<file path="src/features/auth/auth.schemas.ts">
import { z } from "zod";

/**
 * Login form validation schema
 */
export const loginFormSchema = z.object({
  email: z.email("Please enter a valid email").min(1, "Email is required"),
  password: z.string().min(1, "Password is required"),
});

export type LoginFormData = z.infer<typeof loginFormSchema>;

/**
 * Base signup form field schemas
 */
export const signupFormFieldSchemas = {
  name: z
    .string()
    .min(1, "Name is required")
    .min(2, "Name must be at least 2 characters"),
  email: z.email("Please enter a valid email").min(1, "Email is required"),
  password: z
    .string()
    .min(1, "Password is required")
    .min(8, "Password must be at least 8 characters"),
  confirmPassword: z.string().min(1, "Please confirm your password"),
};

/**
 * Signup form field validators for TanStack Form
 */
export const signupFormFields = {
  name: ({ value }: { value: string }) => {
    try {
      signupFormFieldSchemas.name.parse(value);
      return undefined;
    } catch (error) {
      if (error instanceof z.ZodError) {
        return error.issues[0]?.message || "Invalid name";
      }
      return "Invalid name";
    }
  },
  email: ({ value }: { value: string }) => {
    try {
      signupFormFieldSchemas.email.parse(value);
      return undefined;
    } catch (error) {
      if (error instanceof z.ZodError) {
        return error.issues[0]?.message || "Invalid email";
      }
      return "Invalid email";
    }
  },
  password: ({ value }: { value: string }) => {
    try {
      signupFormFieldSchemas.password.parse(value);
      return undefined;
    } catch (error) {
      if (error instanceof z.ZodError) {
        return error.issues[0]?.message || "Invalid password";
      }
      return "Invalid password";
    }
  },
  confirmPassword: ({ value }: { value: string }) => {
    try {
      signupFormFieldSchemas.confirmPassword.parse(value);
      return undefined;
    } catch (error) {
      if (error instanceof z.ZodError) {
        return error.issues[0]?.message || "Please confirm your password";
      }
      return "Please confirm your password";
    }
  },
};

/**
 * Signup form validation schema
 */
export const signupFormSchema = z
  .object(signupFormFieldSchemas)
  .refine((data) => data.password === data.confirmPassword, {
    path: ["confirmPassword"],
    error: "Passwords do not match",
  });

export type SignupFormData = z.infer<typeof signupFormSchema>;
</file>

<file path="src/features/events/__tests__/events.base-schemas.test.ts">
import { describe, expect, it } from "vitest";
import { createEventInputSchema } from "~/db/schema/events.schema";

describe("Event Base Schemas", () => {
  describe("createEventInputSchema", () => {
    it("validates complete event input", () => {
      const validInput = {
        name: "Summer Quadball Tournament 2025",
        slug: "summer-quadball-2025",
        description: "Annual summer tournament",
        shortDescription: "Join us for the biggest Quadball event of the summer!",
        type: "tournament",
        venueName: "Toronto Sports Complex",
        venueAddress: "123 Sports Way",
        city: "Toronto",
        province: "ON",
        postalCode: "M5V 3A8",
        startDate: "2025-07-15",
        endDate: "2025-07-17",
        registrationType: "team",
        maxTeams: 16,
        teamRegistrationFee: 20000, // $200 in cents
        individualRegistrationFee: 5000,
        allowEtransfer: true,
        etransferRecipient: "payments@example.com",
        etransferInstructions: "Send with answer 'quadball'.",
      };

      const result = createEventInputSchema.safeParse(validInput);
      expect(result.success).toBe(true);
    });

    it("validates minimal required fields", () => {
      const minimalInput = {
        name: "Quick Tournament",
        slug: "quick-tournament",
        type: "tournament",
        startDate: "2025-08-01",
        endDate: "2025-08-01",
        registrationType: "individual",
      };

      const result = createEventInputSchema.safeParse(minimalInput);
      expect(result.success).toBe(true);
    });

    it("validates all event types", () => {
      const types = ["tournament", "league", "camp", "clinic", "social", "other"];

      types.forEach((type) => {
        const input = {
          name: `Test ${type}`,
          slug: `test-${type}`,
          type,
          startDate: "2025-08-01",
          endDate: "2025-08-01",
          registrationType: "individual",
        };

        const result = createEventInputSchema.safeParse(input);
        expect(result.success).toBe(true);
      });
    });

    it("validates all registration types", () => {
      const registrationTypes = ["team", "individual", "both"];

      registrationTypes.forEach((registrationType) => {
        const input = {
          name: "Test Event",
          slug: "test-event",
          type: "tournament",
          startDate: "2025-08-01",
          endDate: "2025-08-01",
          registrationType,
        };

        const result = createEventInputSchema.safeParse(input);
        expect(result.success).toBe(true);
      });
    });

    it("fails with invalid slug format", () => {
      const invalidInput = {
        name: "Test Event",
        slug: "Test Event!", // Should be lowercase with hyphens only
        type: "tournament",
        startDate: "2025-08-01",
        endDate: "2025-08-01",
        registrationType: "team",
      };

      const result = createEventInputSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.issues[0]?.message).toContain("lowercase with hyphens only");
      }
    });

    it("fails with name too short", () => {
      const invalidInput = {
        name: "Hi", // Min 3 characters
        slug: "hi-event",
        type: "tournament",
        startDate: "2025-08-01",
        endDate: "2025-08-01",
        registrationType: "team",
      };

      const result = createEventInputSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });

    it("fails with shortDescription too long", () => {
      const invalidInput = {
        name: "Test Event",
        slug: "test-event",
        shortDescription: "a".repeat(501), // Max 500 characters
        type: "tournament",
        startDate: "2025-08-01",
        endDate: "2025-08-01",
        registrationType: "team",
      };

      const result = createEventInputSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });

    it("fails with negative fees", () => {
      const invalidInput = {
        name: "Test Event",
        slug: "test-event",
        type: "tournament",
        startDate: "2025-08-01",
        endDate: "2025-08-01",
        registrationType: "team",
        teamRegistrationFee: -100,
      };

      const result = createEventInputSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });

    it("fails with invalid e-transfer email when enabled", () => {
      const invalidInput = {
        name: "Test Event",
        slug: "test-event",
        type: "tournament",
        startDate: "2025-08-01",
        endDate: "2025-08-01",
        registrationType: "team",
        allowEtransfer: true,
        etransferRecipient: "not-an-email",
      };

      const result = createEventInputSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });

    it("fails with invalid event type", () => {
      const invalidInput = {
        name: "Test Event",
        slug: "test-event",
        type: "workshop", // Not a valid type
        startDate: "2025-08-01",
        endDate: "2025-08-01",
        registrationType: "individual",
      };

      const result = createEventInputSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });

    it("fails without required fields", () => {
      const invalidInput = {
        name: "Test Event",
        slug: "test-event",
        // Missing type, dates, and registrationType
      };

      const result = createEventInputSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });

    it("validates with zero fees", () => {
      const validInput = {
        name: "Free Event",
        slug: "free-event",
        type: "social",
        startDate: "2025-08-01",
        endDate: "2025-08-01",
        registrationType: "individual",
        teamRegistrationFee: 0,
        individualRegistrationFee: 0,
      };

      const result = createEventInputSchema.safeParse(validInput);
      expect(result.success).toBe(true);
    });
  });
});
</file>

<file path="src/features/members/members.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { zod$ } from "~/lib/server/fn-utils";
import { listMembersSchema } from "./members.schemas";
import type {
  MemberDirectoryMember,
  MemberDirectoryMembershipSummary,
  MemberDirectoryOperationResult,
  MemberDirectoryResponse,
} from "./members.types";

type PrivacySettings = import("~/features/profile/profile.types").PrivacySettings;
type SQLExpression = import("drizzle-orm").SQL<unknown>;

type ListMembersResult = MemberDirectoryOperationResult<MemberDirectoryResponse>;

type MembershipAccumulator = {
  id: string;
  status: "active" | "expired" | "cancelled";
  membershipType: string | null;
  startDate: Date | null;
  endDate: Date | null;
};

type MemberAccumulator = {
  id: string;
  name: string;
  email: string | null;
  phone: string | null;
  pronouns: string | null;
  dateOfBirth: Date | null;
  privacySettings: string | null;
  profileUpdatedAt: Date | null;
  teams: Set<string>;
  memberships: Map<string, MembershipAccumulator>;
};

function escapeSearchTerm(value: string): string {
  return value.replace(/[%_]/g, (match) => `\\${match}`);
}

function parsePrivacySettings(
  value: string | null,
  fallback: PrivacySettings,
): PrivacySettings {
  if (!value) {
    return fallback;
  }

  try {
    const parsed = JSON.parse(value) as Partial<PrivacySettings>;
    return {
      showEmail: parsed.showEmail ?? fallback.showEmail,
      showPhone: parsed.showPhone ?? fallback.showPhone,
      showBirthYear: parsed.showBirthYear ?? fallback.showBirthYear,
      allowTeamInvitations: parsed.allowTeamInvitations ?? fallback.allowTeamInvitations,
    };
  } catch (error) {
    console.warn("Failed to parse privacy settings", error);
    return fallback;
  }
}

export const listMembers = createServerFn({ method: "GET" })
  .inputValidator(zod$(listMembersSchema))
  .handler(async ({ data }): Promise<ListMembersResult> => {
    try {
      const searchTerm = data.search?.trim();
      const limit = Math.min(100, Math.max(1, data.limit ?? 50));
      const offset = Math.max(0, data.offset ?? 0);

      const [{ getDb }, { getCurrentUser }] = await Promise.all([
        import("~/db/server-helpers"),
        import("~/features/auth/auth.queries"),
      ]);

      const [db, currentUser] = await Promise.all([getDb(), getCurrentUser()]);

      if (!currentUser) {
        return {
          success: false,
          errors: [
            {
              code: "NOT_AUTHENTICATED",
              message: "User not authenticated",
            },
          ],
        };
      }

      const { user, teamMembers, teams, memberships, membershipTypes } = await import(
        "~/db/schema"
      );
      const { defaultPrivacySettings } = await import("~/features/profile/profile.types");
      const { and, eq, inArray, sql } = await import("drizzle-orm");

      const conditions: SQLExpression[] = [];

      if (searchTerm) {
        const pattern = `%${escapeSearchTerm(searchTerm)}%`;
        conditions.push(
          sql`(
            ${user.name} ILIKE ${pattern} OR
            ${user.email} ILIKE ${pattern} OR
            ${user.phone} ILIKE ${pattern} OR
            ${teams.name} ILIKE ${pattern}
          )`,
        );
      }

      const whereClause = conditions.length > 0 ? and(...conditions) : undefined;

      const baseQuery = db
        .select({ userId: user.id })
        .from(user)
        .leftJoin(teamMembers, eq(teamMembers.userId, user.id))
        .leftJoin(teams, eq(teamMembers.teamId, teams.id));

      const filteredBaseQuery = whereClause ? baseQuery.where(whereClause) : baseQuery;

      const userIdRows = await filteredBaseQuery
        .groupBy(user.id)
        .orderBy(sql`LOWER(${user.name})`)
        .limit(limit)
        .offset(offset);
      const userIds = userIdRows.map((row) => row.userId);

      const totalQuery = db
        .select({ count: sql<number>`COUNT(DISTINCT ${user.id})::int` })
        .from(user)
        .leftJoin(teamMembers, eq(teamMembers.userId, user.id))
        .leftJoin(teams, eq(teamMembers.teamId, teams.id));

      const filteredTotalQuery = whereClause ? totalQuery.where(whereClause) : totalQuery;

      const totalResult = await filteredTotalQuery;
      const total = totalResult[0]?.count ?? 0;

      if (userIds.length === 0) {
        return {
          success: true,
          data: {
            members: [],
            pagination: {
              total,
              limit,
              offset,
              hasMore: false,
            },
          },
        };
      }

      const detailRows = await db
        .select({
          id: user.id,
          name: user.name,
          email: user.email,
          phone: user.phone,
          pronouns: user.pronouns,
          dateOfBirth: user.dateOfBirth,
          privacySettings: user.privacySettings,
          profileUpdatedAt: user.profileUpdatedAt,
          teamId: teamMembers.teamId,
          teamName: teams.name,
          teamStatus: teamMembers.status,
          membershipId: memberships.id,
          membershipStatus: memberships.status,
          membershipStartDate: memberships.startDate,
          membershipEndDate: memberships.endDate,
          membershipTypeName: membershipTypes.name,
        })
        .from(user)
        .leftJoin(teamMembers, eq(teamMembers.userId, user.id))
        .leftJoin(teams, eq(teamMembers.teamId, teams.id))
        .leftJoin(memberships, eq(memberships.userId, user.id))
        .leftJoin(membershipTypes, eq(membershipTypes.id, memberships.membershipTypeId))
        .where(inArray(user.id, userIds));

      const memberAccumulator = new Map<string, MemberAccumulator>();

      for (const row of detailRows) {
        let accumulator = memberAccumulator.get(row.id);

        if (!accumulator) {
          const dateOfBirth = row.dateOfBirth
            ? row.dateOfBirth instanceof Date
              ? row.dateOfBirth
              : new Date(row.dateOfBirth)
            : null;
          const profileUpdatedAt = row.profileUpdatedAt
            ? row.profileUpdatedAt instanceof Date
              ? row.profileUpdatedAt
              : new Date(row.profileUpdatedAt)
            : null;

          accumulator = {
            id: row.id,
            name: row.name || "Unknown",
            email: row.email ?? null,
            phone: row.phone ?? null,
            pronouns: row.pronouns ?? null,
            dateOfBirth,
            privacySettings: row.privacySettings ?? null,
            profileUpdatedAt,
            teams: new Set<string>(),
            memberships: new Map<string, MembershipAccumulator>(),
          };

          memberAccumulator.set(row.id, accumulator);
        }

        if (row.teamName && row.teamStatus === "active") {
          accumulator.teams.add(row.teamName);
        }

        if (row.membershipId) {
          const existingMembership = accumulator.memberships.get(row.membershipId);

          if (!existingMembership) {
            const startDate = row.membershipStartDate
              ? new Date(row.membershipStartDate)
              : null;
            const endDate = row.membershipEndDate
              ? new Date(row.membershipEndDate)
              : null;

            accumulator.memberships.set(row.membershipId, {
              id: row.membershipId,
              status: (row.membershipStatus ??
                "expired") as MembershipAccumulator["status"],
              membershipType: row.membershipTypeName ?? null,
              startDate,
              endDate,
            });
          }
        }
      }

      const today = new Date();
      today.setHours(0, 0, 0, 0);

      const members: MemberDirectoryMember[] = [];

      for (const memberId of userIds) {
        const accumulator = memberAccumulator.get(memberId);

        if (!accumulator) {
          continue;
        }

        const privacy = parsePrivacySettings(
          accumulator.privacySettings,
          defaultPrivacySettings,
        );

        const isSelf = memberId === currentUser.id;
        const showEmail = privacy.showEmail || isSelf;
        const showPhone = privacy.showPhone || isSelf;
        const showBirthYear = privacy.showBirthYear || isSelf;

        const membershipList = Array.from(accumulator.memberships.values()).sort(
          (a, b) => {
            const aTime = a.endDate ? a.endDate.getTime() : 0;
            const bTime = b.endDate ? b.endDate.getTime() : 0;
            return bTime - aTime;
          },
        );

        const activeMembership = membershipList.find(
          (membership) =>
            membership.status === "active" &&
            membership.endDate !== null &&
            membership.endDate.getTime() >= today.getTime(),
        );

        const latestMembership = membershipList[0];

        const membershipStatus = activeMembership
          ? "active"
          : latestMembership
            ? latestMembership.status
            : "none";

        const membershipType = activeMembership
          ? activeMembership.membershipType
          : (latestMembership?.membershipType ?? null);

        const membershipEndDate = activeMembership?.endDate
          ? activeMembership.endDate.toISOString()
          : latestMembership?.endDate
            ? latestMembership.endDate.toISOString()
            : null;

        const membershipHistory: MemberDirectoryMembershipSummary[] = membershipList.map(
          (membership) => ({
            status: membership.status,
            membershipType: membership.membershipType,
            startDate: membership.startDate ? membership.startDate.toISOString() : null,
            endDate: membership.endDate ? membership.endDate.toISOString() : null,
          }),
        );

        const birthDate = accumulator.dateOfBirth;

        members.push({
          id: accumulator.id,
          name: accumulator.name,
          email: showEmail ? accumulator.email : null,
          emailVisible: Boolean(showEmail && accumulator.email),
          phone: showPhone ? accumulator.phone : null,
          phoneVisible: Boolean(showPhone && accumulator.phone),
          pronouns: accumulator.pronouns,
          teams: Array.from(accumulator.teams).sort((a, b) => a.localeCompare(b)),
          membershipStatus,
          membershipType,
          membershipEndDate,
          hasActiveMembership: membershipStatus === "active",
          allowTeamInvitations: privacy.allowTeamInvitations,
          birthYear: showBirthYear && birthDate ? birthDate.getUTCFullYear() : null,
          birthYearVisible: showBirthYear && Boolean(birthDate),
          profileUpdatedAt: accumulator.profileUpdatedAt
            ? accumulator.profileUpdatedAt.toISOString()
            : null,
          membershipHistory,
        });
      }

      return {
        success: true,
        data: {
          members,
          pagination: {
            total,
            limit,
            offset,
            hasMore: offset + members.length < total,
          },
        },
      };
    } catch (error) {
      console.error("Error listing members:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to fetch members",
          },
        ],
      };
    }
  });
</file>

<file path="src/features/membership/membership.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { zod$ } from "~/lib/server/fn-utils";
import { getMembershipTypeSchema } from "./membership.schemas";
import type {
  MembershipOperationResult,
  MembershipStatus,
  UserMembership,
} from "./membership.types";

/**
 * List all active membership types available for purchase
 */
export const listMembershipTypes = createServerFn({ method: "GET" }).handler(
  async (): Promise<
    MembershipOperationResult<import("./membership.types").MembershipType[]>
  > => {
    try {
      // Import server-only modules inside the handler
      const { getDb } = await import("~/db/server-helpers");

      // Import database dependencies inside handler
      const { eq } = await import("drizzle-orm");
      const { membershipTypes } = await import("~/db/schema");

      const db = await getDb();

      const activeTypes = await db
        .select()
        .from(membershipTypes)
        .where(eq(membershipTypes.status, "active"))
        .orderBy(membershipTypes.priceCents);

      return {
        success: true,
        data: activeTypes,
      };
    } catch (error) {
      console.error("Error fetching membership types:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to fetch membership types",
          },
        ],
      };
    }
  },
);

/**
 * Get a specific membership type by ID
 */
export const getMembershipType = createServerFn({ method: "GET" })
  .inputValidator(zod$(getMembershipTypeSchema))
  .handler(
    async ({
      data,
    }): Promise<
      MembershipOperationResult<import("./membership.types").MembershipType>
    > => {
      try {
        // Import server-only modules inside the handler
        const { getDb } = await import("~/db/server-helpers");

        // Import database dependencies inside handler
        const { eq } = await import("drizzle-orm");
        const { membershipTypes } = await import("~/db/schema");

        const db = await getDb();

        const [membershipType] = await db
          .select()
          .from(membershipTypes)
          .where(eq(membershipTypes.id, data.membershipTypeId))
          .limit(1);

        if (!membershipType) {
          return {
            success: false,
            errors: [
              {
                code: "NOT_FOUND",
                message: "Membership type not found",
              },
            ],
          };
        }

        return {
          success: true,
          data: membershipType,
        };
      } catch (error) {
        console.error("Error fetching membership type:", error);
        return {
          success: false,
          errors: [
            {
              code: "DATABASE_ERROR",
              message: "Failed to fetch membership type",
            },
          ],
        };
      }
    },
  );

/**
 * Get current user's membership status
 */
export const getUserMembershipStatus = createServerFn({ method: "GET" }).handler(
  async (): Promise<MembershipOperationResult<MembershipStatus>> => {
    try {
      // Import server-only modules inside the handler
      const [{ getDb }, { getAuth }] = await Promise.all([
        import("~/db/server-helpers"),
        import("~/lib/auth/server-helpers"),
      ]);

      const auth = await getAuth();
      const { getRequest } = await import("@tanstack/react-start/server");
      const { headers } = getRequest();
      const session = await auth.api.getSession({ headers });

      if (!session?.user?.id) {
        return {
          success: false,
          errors: [
            {
              code: "VALIDATION_ERROR",
              message: "User not authenticated",
            },
          ],
        };
      }

      // Import database dependencies inside handler
      const { and, eq, gte, sql } = await import("drizzle-orm");
      const { membershipTypes, memberships } = await import("~/db/schema");

      // Get active membership for the user
      const db = await getDb();

      const [currentMembership] = await db
        .select({
          membership: memberships,
          membershipType: membershipTypes,
        })
        .from(memberships)
        .innerJoin(membershipTypes, eq(memberships.membershipTypeId, membershipTypes.id))
        .where(
          and(
            eq(memberships.userId, session.user.id),
            eq(memberships.status, "active"),
            gte(memberships.endDate, sql`CURRENT_DATE`),
          ),
        )
        .orderBy(sql`${memberships.endDate} DESC`)
        .limit(1);

      if (!currentMembership) {
        return {
          success: true,
          data: {
            hasMembership: false,
          },
        };
      }

      const endDate = new Date(currentMembership.membership.endDate);
      const daysRemaining = Math.ceil(
        (endDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24),
      );

      const userMembership: UserMembership = {
        ...currentMembership.membership,
        membershipType: currentMembership.membershipType,
      };

      return {
        success: true,
        data: {
          hasMembership: true,
          currentMembership: userMembership,
          expiresAt: endDate,
          daysRemaining,
        },
      };
    } catch (error) {
      console.error("Error fetching membership status:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to fetch membership status",
          },
        ],
      };
    }
  },
);
</file>

<file path="src/features/roles/roles.mutations.ts">
import { createServerFn } from "@tanstack/react-start";
import { z } from "zod";
import { zod$ } from "~/lib/server/fn-utils";
import type { RoleAssignmentRow, RoleOperationResult } from "./roles.types";

const assignRoleSchema = z
  .object({
    userId: z.string().min(1, "User is required"),
    roleId: z.string().min(1, "Role is required"),
    teamId: z.string().min(1).optional().nullable(),
    eventId: z.string().min(1).optional().nullable(),
    notes: z.string().trim().max(500, "Notes must be 500 characters or fewer").optional(),
    expiresAt: z.iso.datetime().optional(),
  })
  .superRefine((data, ctx) => {
    if (data.teamId && data.eventId) {
      ctx.addIssue({
        code: "custom",
        message: "Choose either a team scope or an event scopeânot both.",
        path: ["teamId"],
      });
    }
  });

const removeRoleSchema = z.object({
  assignmentId: z.string().min(1, "Assignment id is required"),
});

function normalizeNotes(notes?: string) {
  if (!notes) return null;
  const trimmed = notes.trim();
  return trimmed.length > 0 ? trimmed : null;
}

export const assignRoleToUser = createServerFn({ method: "POST" })
  .inputValidator(zod$(assignRoleSchema))
  .handler(async ({ data }): Promise<RoleOperationResult<RoleAssignmentRow>> => {
    try {
      const [{ getDb }, { getAuth }] = await Promise.all([
        import("~/db/server-helpers"),
        import("~/lib/auth/server-helpers"),
      ]);

      const auth = await getAuth();
      const { getRequest } = await import("@tanstack/react-start/server");
      const { headers } = getRequest();
      const session = await auth.api.getSession({ headers });

      if (!session?.user?.id) {
        return {
          success: false,
          errors: [
            {
              code: "UNAUTHORIZED",
              message: "User not authenticated",
            },
          ],
        };
      }

      const { requireAdmin, GLOBAL_ADMIN_ROLE_NAMES } = await import(
        "~/lib/auth/utils/admin-check"
      );
      await requireAdmin(session.user.id);

      const db = await getDb();
      const { roles, user, userRoles } = await import("~/db/schema");
      const { alias } = await import("drizzle-orm/pg-core");
      const { and, eq, isNull } = await import("drizzle-orm");

      const assignerUser = alias(user, "assigner_user");

      const [targetUser] = await db
        .select({ id: user.id, email: user.email, name: user.name })
        .from(user)
        .where(eq(user.id, data.userId))
        .limit(1);

      if (!targetUser) {
        return {
          success: false,
          errors: [
            {
              code: "NOT_FOUND",
              message: "User not found",
            },
          ],
        };
      }

      const [roleRecord] = await db
        .select({ id: roles.id, name: roles.name })
        .from(roles)
        .where(eq(roles.id, data.roleId))
        .limit(1);

      if (!roleRecord) {
        return {
          success: false,
          errors: [
            {
              code: "NOT_FOUND",
              message: "Role not found",
            },
          ],
        };
      }

      let teamId: string | null = data.teamId ?? null;
      let eventId: string | null = data.eventId ?? null;

      if (GLOBAL_ADMIN_ROLE_NAMES.includes(roleRecord.name)) {
        teamId = null;
        eventId = null;
      } else if (roleRecord.name === "Team Admin") {
        if (!teamId) {
          return {
            success: false,
            errors: [
              {
                code: "VALIDATION_ERROR",
                message: "Team Admin roles must be scoped to a specific team.",
              },
            ],
          };
        }
        eventId = null;
      } else if (roleRecord.name === "Event Admin") {
        if (!eventId) {
          return {
            success: false,
            errors: [
              {
                code: "VALIDATION_ERROR",
                message: "Event Admin roles must be scoped to a specific event.",
              },
            ],
          };
        }
        teamId = null;
      } else {
        teamId = teamId ?? null;
        eventId = eventId ?? null;
      }

      const expiresAt = data.expiresAt ? new Date(data.expiresAt) : null;
      if (expiresAt && Number.isNaN(expiresAt.getTime())) {
        return {
          success: false,
          errors: [
            {
              code: "VALIDATION_ERROR",
              message: "Invalid expiration date provided.",
            },
          ],
        };
      }

      const scopeConditions = [
        eq(userRoles.userId, targetUser.id),
        eq(userRoles.roleId, roleRecord.id),
        teamId ? eq(userRoles.teamId, teamId) : isNull(userRoles.teamId),
        eventId ? eq(userRoles.eventId, eventId) : isNull(userRoles.eventId),
      ];

      const [existingAssignment] = await db
        .select({ id: userRoles.id })
        .from(userRoles)
        .where(and(...scopeConditions))
        .limit(1);

      const fetchAssignment = async (assignmentId: string) => {
        const [assignment] = await db
          .select({
            id: userRoles.id,
            roleId: userRoles.roleId,
            roleName: roles.name,
            roleDescription: roles.description,
            userId: user.id,
            userName: user.name,
            userEmail: user.email,
            teamId: userRoles.teamId,
            eventId: userRoles.eventId,
            assignedBy: userRoles.assignedBy,
            assignedByName: assignerUser.name,
            assignedByEmail: assignerUser.email,
            assignedAt: userRoles.assignedAt,
            expiresAt: userRoles.expiresAt,
            notes: userRoles.notes,
          })
          .from(userRoles)
          .innerJoin(user, eq(userRoles.userId, user.id))
          .innerJoin(roles, eq(userRoles.roleId, roles.id))
          .leftJoin(assignerUser, eq(assignerUser.id, userRoles.assignedBy))
          .where(eq(userRoles.id, assignmentId))
          .limit(1);

        return assignment ?? null;
      };

      if (existingAssignment) {
        const existing = await fetchAssignment(existingAssignment.id);
        if (!existing) {
          return {
            success: false,
            errors: [
              {
                code: "DATABASE_ERROR",
                message: "Existing role assignment could not be loaded.",
              },
            ],
          };
        }

        return {
          success: true,
          data: existing,
        };
      }

      const [inserted] = await db
        .insert(userRoles)
        .values({
          userId: targetUser.id,
          roleId: roleRecord.id,
          teamId,
          eventId,
          assignedBy: session.user.id,
          notes: normalizeNotes(data.notes),
          expiresAt,
        })
        .returning();

      const created = await fetchAssignment(inserted.id);
      if (!created) {
        return {
          success: false,
          errors: [
            {
              code: "DATABASE_ERROR",
              message: "Role assignment was created but could not be loaded.",
            },
          ],
        };
      }

      return {
        success: true,
        data: created,
      };
    } catch (error) {
      console.error("Error assigning role:", error);

      if (error instanceof Error && error.message.includes("Admin access required")) {
        return {
          success: false,
          errors: [
            {
              code: "UNAUTHORIZED",
              message: "Admin access required",
            },
          ],
        };
      }

      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to assign role",
          },
        ],
      };
    }
  });

export const removeRoleAssignment = createServerFn({ method: "POST" })
  .inputValidator(zod$(removeRoleSchema))
  .handler(async ({ data }): Promise<RoleOperationResult<RoleAssignmentRow>> => {
    try {
      const [{ getDb }, { getAuth }] = await Promise.all([
        import("~/db/server-helpers"),
        import("~/lib/auth/server-helpers"),
      ]);

      const auth = await getAuth();
      const { getRequest } = await import("@tanstack/react-start/server");
      const { headers } = getRequest();
      const session = await auth.api.getSession({ headers });

      if (!session?.user?.id) {
        return {
          success: false,
          errors: [
            {
              code: "UNAUTHORIZED",
              message: "User not authenticated",
            },
          ],
        };
      }

      const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
      await requireAdmin(session.user.id);

      const db = await getDb();
      const { roles, userRoles, user } = await import("~/db/schema");
      const { alias } = await import("drizzle-orm/pg-core");
      const { eq } = await import("drizzle-orm");

      const assignerUser = alias(user, "assigner_user");

      const [existingAssignment] = await db
        .select({
          id: userRoles.id,
          roleId: userRoles.roleId,
          roleName: roles.name,
          roleDescription: roles.description,
          userId: user.id,
          userName: user.name,
          userEmail: user.email,
          teamId: userRoles.teamId,
          eventId: userRoles.eventId,
          assignedBy: userRoles.assignedBy,
          assignedByName: assignerUser.name,
          assignedByEmail: assignerUser.email,
          assignedAt: userRoles.assignedAt,
          expiresAt: userRoles.expiresAt,
          notes: userRoles.notes,
        })
        .from(userRoles)
        .innerJoin(user, eq(userRoles.userId, user.id))
        .innerJoin(roles, eq(userRoles.roleId, roles.id))
        .leftJoin(assignerUser, eq(assignerUser.id, userRoles.assignedBy))
        .where(eq(userRoles.id, data.assignmentId))
        .limit(1);

      if (!existingAssignment) {
        return {
          success: false,
          errors: [
            {
              code: "NOT_FOUND",
              message: "Role assignment not found",
            },
          ],
        };
      }

      await db.delete(userRoles).where(eq(userRoles.id, data.assignmentId));

      return {
        success: true,
        data: existingAssignment,
      };
    } catch (error) {
      console.error("Error removing role assignment:", error);

      if (error instanceof Error && error.message.includes("Admin access required")) {
        return {
          success: false,
          errors: [
            {
              code: "UNAUTHORIZED",
              message: "Admin access required",
            },
          ],
        };
      }

      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to remove role assignment",
          },
        ],
      };
    }
  });
</file>

<file path="src/features/teams/teams.cleanup.ts">
import { createServerFn, createServerOnlyFn } from "@tanstack/react-start";
import { eq } from "drizzle-orm";
import { z } from "zod";
import { zod$ } from "~/lib/server/fn-utils";

const getDb = createServerOnlyFn(async () => {
  const { getDb } = await import("~/db/server-helpers");
  return getDb();
});

const clearUserTeamsSchema = z.object({
  userEmail: z.email(),
});

export const clearUserTeamsForTesting = createServerFn({ method: "POST" })
  .inputValidator(zod$(clearUserTeamsSchema))
  .handler(async ({ data }) => {
    // Only allow in test environments
    if (process.env["NODE_ENV"] === "production" && !process.env["E2E_TEST_EMAIL"]) {
      throw new Error("This function is only available in test environments");
    }

    const db = await getDb();
    const { user, teamMembers } = await import("~/db/schema");

    // Find the user
    const [targetUser] = await db
      .select({ id: user.id })
      .from(user)
      .where(eq(user.email, data.userEmail));

    if (!targetUser) {
      return { success: true, message: "User not found, nothing to clear" };
    }

    // Delete all team memberships for this user
    await db.delete(teamMembers).where(eq(teamMembers.userId, targetUser.id));

    return { success: true, message: `Cleared teams for ${data.userEmail}` };
  });
</file>

<file path="src/routes/api/payments/square/callback.ts">
import { createFileRoute, redirect } from "@tanstack/react-router";
import { eq } from "drizzle-orm";
import {
  eventPaymentSessions,
  eventRegistrations,
  events,
  membershipPaymentSessions,
  membershipTypes,
} from "~/db/schema";
import { user } from "~/db/schema/auth.schema";

export const Route = createFileRoute("/api/payments/square/callback")({
  server: {
    handlers: {
      GET: async ({ request }) => {
        try {
          const url = new URL(request.url);
          const params = url.searchParams;

          // Get checkout ID from Square
          const checkoutId = params.get("checkoutId");
          const transactionId = params.get("transactionId");

          if (!checkoutId) {
            return redirect({
              to: "/dashboard/membership",
              search: {
                error: "cancelled",
              },
            });
          }

          const { getDb } = await import("~/db/server-helpers");
          const db = await getDb();

          const handleEventSession = async (): Promise<Response | null> => {
            const eventSessionResult = await db
              .select({
                session: eventPaymentSessions,
                registration: eventRegistrations,
                event: events,
              })
              .from(eventPaymentSessions)
              .innerJoin(
                eventRegistrations,
                eq(eventPaymentSessions.registrationId, eventRegistrations.id),
              )
              .innerJoin(events, eq(eventPaymentSessions.eventId, events.id))
              .where(eq(eventPaymentSessions.squareCheckoutId, checkoutId))
              .limit(1);

            if (eventSessionResult.length === 0) {
              return null;
            }

            const [{ session, registration, event }] = eventSessionResult;
            const now = new Date();
            const nowIso = now.toISOString();

            if (!transactionId) {
              await db
                .update(eventPaymentSessions)
                .set({
                  status: "cancelled",
                  metadata: {
                    ...(session.metadata ?? {}),
                    cancelledAt: nowIso,
                  },
                  updatedAt: now,
                })
                .where(eq(eventPaymentSessions.id, session.id));

              await db
                .update(eventRegistrations)
                .set({
                  paymentStatus: "pending",
                  updatedAt: now,
                  paymentMetadata: {
                    ...(registration.paymentMetadata ?? {}),
                    cancelledAt: nowIso,
                  },
                })
                .where(eq(eventRegistrations.id, registration.id));

              return redirect({
                to: "/dashboard/events",
                search: {
                  payment: "cancelled",
                  eventId: event.id,
                },
              });
            }

            const { getSquarePaymentService } = await import("~/lib/payments/square");
            const paymentService = await getSquarePaymentService();
            const result = await paymentService.verifyPayment(checkoutId, transactionId);

            if (!result.success) {
              await db
                .update(eventPaymentSessions)
                .set({
                  status: "failed",
                  metadata: {
                    ...(session.metadata ?? {}),
                    lastError: result.error || "Payment verification failed",
                    lastErrorAt: nowIso,
                    squareTransactionId: transactionId,
                  },
                  updatedAt: now,
                })
                .where(eq(eventPaymentSessions.id, session.id));

              return redirect({
                to: "/dashboard/events",
                search: {
                  payment: "verification_failed",
                  eventId: event.id,
                },
              });
            }

            const paymentIdentifier = result.paymentId || transactionId;
            const amountCents =
              typeof result.amount === "number" ? result.amount : session.amountCents;

            await db
              .update(eventPaymentSessions)
              .set({
                status: "completed",
                squarePaymentId: paymentIdentifier,
                metadata: {
                  ...(session.metadata ?? {}),
                  squareTransactionId: paymentIdentifier,
                  paymentVerifiedAt: nowIso,
                },
                updatedAt: now,
              })
              .where(eq(eventPaymentSessions.id, session.id));

            const existingMetadata = (registration.paymentMetadata ?? {}) as Record<
              string,
              unknown
            >;

            await db
              .update(eventRegistrations)
              .set({
                paymentStatus: "paid",
                status:
                  registration.status === "cancelled" ? registration.status : "confirmed",
                paymentCompletedAt: now,
                paymentId: paymentIdentifier,
                amountPaidCents: amountCents,
                paymentMetadata: {
                  ...existingMetadata,
                  squareTransactionId: paymentIdentifier,
                  markedPaidAt: nowIso,
                },
                updatedAt: now,
              })
              .where(eq(eventRegistrations.id, registration.id));

            return redirect({
              to: "/dashboard/events",
              search: {
                payment: "success",
                eventId: event.id,
              },
            });
          };

          const [paymentSession] = await db
            .select()
            .from(membershipPaymentSessions)
            .where(eq(membershipPaymentSessions.squareCheckoutId, checkoutId))
            .limit(1);

          if (!paymentSession) {
            const eventRedirect = await handleEventSession();
            if (eventRedirect) {
              return eventRedirect;
            }

            console.error("Membership payment session not found for Square callback", {
              checkoutId,
              transactionId,
            });
            return redirect({
              to: "/dashboard/membership",
              search: {
                error: "processing_error",
              },
            });
          }

          let sessionRecord = paymentSession;
          const now = new Date();
          const nowIso = now.toISOString();

          // Check if payment was cancelled
          if (!transactionId) {
            await db
              .update(membershipPaymentSessions)
              .set({
                status: "cancelled",
                metadata: {
                  ...(sessionRecord.metadata ?? {}),
                  cancelledAt: nowIso,
                },
                updatedAt: now,
              })
              .where(eq(membershipPaymentSessions.id, sessionRecord.id));

            return redirect({
              to: "/dashboard/membership",
              search: {
                error: "cancelled",
              },
            });
          }

          const callbackMetadata = {
            ...(sessionRecord.metadata ?? {}),
            squareTransactionId: transactionId,
            callbackReceivedAt: nowIso,
          } as Record<string, unknown>;

          await db
            .update(membershipPaymentSessions)
            .set({
              squarePaymentId: transactionId,
              metadata: callbackMetadata,
              updatedAt: now,
            })
            .where(eq(membershipPaymentSessions.id, sessionRecord.id));

          sessionRecord = {
            ...sessionRecord,
            squarePaymentId: transactionId,
            metadata: callbackMetadata,
            updatedAt: now,
          };

          // Get the payment service
          const { getSquarePaymentService } = await import("~/lib/payments/square");
          const paymentService = await getSquarePaymentService();

          // Verify the payment with Square
          const result = await paymentService.verifyPayment(checkoutId, transactionId);

          if (!result.success) {
            console.error("Payment verification failed:", result.error);

            await db
              .update(membershipPaymentSessions)
              .set({
                status: "failed",
                metadata: {
                  ...(sessionRecord.metadata ?? {}),
                  lastError: result.error || "Payment verification failed",
                  lastErrorAt: nowIso,
                  squareTransactionId: transactionId,
                },
                updatedAt: now,
              })
              .where(eq(membershipPaymentSessions.id, sessionRecord.id));

            return redirect({
              to: "/dashboard/membership",
              search: {
                error: "verification_failed",
              },
            });
          }

          const paymentIdentifier = result.paymentId || transactionId;

          const verifiedMetadata = {
            ...(sessionRecord.metadata ?? {}),
            squareTransactionId: paymentIdentifier,
            paymentVerifiedAt: nowIso,
          } as Record<string, unknown>;

          await db
            .update(membershipPaymentSessions)
            .set({
              status: "completed",
              squarePaymentId: paymentIdentifier,
              metadata: verifiedMetadata,
              updatedAt: now,
            })
            .where(eq(membershipPaymentSessions.id, sessionRecord.id));

          sessionRecord = {
            ...sessionRecord,
            status: "completed",
            squarePaymentId: paymentIdentifier,
            metadata: verifiedMetadata,
            updatedAt: now,
          };

          const [membershipType] = await db
            .select()
            .from(membershipTypes)
            .where(eq(membershipTypes.id, sessionRecord.membershipTypeId))
            .limit(1);

          if (!membershipType) {
            await db
              .update(membershipPaymentSessions)
              .set({
                status: "failed",
                metadata: {
                  ...(sessionRecord.metadata ?? {}),
                  lastError: "Membership type not found",
                  lastErrorAt: nowIso,
                },
                updatedAt: now,
              })
              .where(eq(membershipPaymentSessions.id, sessionRecord.id));

            return redirect({
              to: "/dashboard/membership",
              search: {
                error: "processing_error",
              },
            });
          }

          if (
            typeof result.amount === "number" &&
            result.amount !== membershipType.priceCents
          ) {
            console.error("Payment amount mismatch", {
              expected: membershipType.priceCents,
              actual: result.amount,
              paymentIdentifier,
              checkoutId,
            });

            await db
              .update(membershipPaymentSessions)
              .set({
                status: "failed",
                metadata: {
                  ...(sessionRecord.metadata ?? {}),
                  lastError: "Payment amount mismatch",
                  lastErrorAt: nowIso,
                },
                updatedAt: now,
              })
              .where(eq(membershipPaymentSessions.id, sessionRecord.id));

            return redirect({
              to: "/dashboard/membership",
              search: {
                error: "processing_error",
              },
            });
          }

          if (result.currency && result.currency !== "CAD") {
            console.error("Unsupported payment currency", {
              expected: "CAD",
              actual: result.currency,
              paymentIdentifier,
              checkoutId,
            });

            await db
              .update(membershipPaymentSessions)
              .set({
                status: "failed",
                metadata: {
                  ...(sessionRecord.metadata ?? {}),
                  lastError: "Unsupported payment currency",
                  lastErrorAt: nowIso,
                },
                updatedAt: now,
              })
              .where(eq(membershipPaymentSessions.id, sessionRecord.id));

            return redirect({
              to: "/dashboard/membership",
              search: {
                error: "processing_error",
              },
            });
          }

          const { finalizeMembershipForSession } = await import(
            "~/features/membership/membership.finalize"
          );

          const finalizeTimestamp = new Date();
          const finalizeResult = await finalizeMembershipForSession({
            db,
            paymentSession: sessionRecord,
            membershipType,
            paymentId: paymentIdentifier,
            orderId: result.orderId ?? sessionRecord.squareOrderId ?? null,
            sessionId: sessionRecord.squareCheckoutId,
            now: finalizeTimestamp,
          });

          if (finalizeResult.wasCreated) {
            const [membershipUser] = await db
              .select({
                id: user.id,
                email: user.email,
                name: user.name,
              })
              .from(user)
              .where(eq(user.id, sessionRecord.userId))
              .limit(1);

            if (membershipUser?.email) {
              try {
                const { sendMembershipPurchaseReceipt } = await import(
                  "~/lib/email/sendgrid"
                );

                await sendMembershipPurchaseReceipt({
                  to: {
                    email: membershipUser.email,
                    name: membershipUser.name || undefined,
                  },
                  membershipType: membershipType.name,
                  amount: membershipType.priceCents,
                  paymentId: paymentIdentifier,
                  expiresAt: new Date(finalizeResult.membership.endDate),
                });
              } catch (emailError) {
                console.error("Failed to send membership receipt", emailError);
              }
            }
          }

          const searchParams: Record<string, string> = {
            success: "true",
            payment_id: paymentIdentifier,
            session: checkoutId,
          };

          if (sessionRecord.membershipTypeId) {
            searchParams["type"] = sessionRecord.membershipTypeId;
          }

          if (finalizeResult.membership?.id) {
            searchParams["membership_id"] = finalizeResult.membership.id;
          }

          return redirect({
            to: "/dashboard/membership",
            search: searchParams,
          });
        } catch (error) {
          console.error("Square callback error:", error);
          return redirect({
            to: "/dashboard/membership",
            search: {
              error: "processing_error",
            },
          });
        }
      },
    },
  },
});
</file>

<file path="src/routes/api/test/cleanup.ts">
import { createFileRoute } from "@tanstack/react-router";
import { eq } from "drizzle-orm";
import { z } from "zod";
import { debugGuard } from "~/lib/server/debug-guard";

const cleanupSchema = z.object({
  action: z.enum([
    "reset-user",
    "delete-team",
    "clear-user-teams",
    "clear-user-memberships",
  ]),
  userId: z.string().optional(),
  teamId: z.string().optional(),
  userEmail: z.email().optional(),
});

export const Route = createFileRoute("/api/test/cleanup")({
  server: {
    handlers: {
      POST: async ({ request }) => {
        // Block access in production builds - returns 404
        // Uses import.meta.env.PROD which is a compile-time constant
        // and cannot be bypassed via environment variables
        const guardResponse = debugGuard();
        if (guardResponse) return guardResponse;

        try {
          const body = await request.json();
          const { action, userId, teamId, userEmail } = cleanupSchema.parse(body);

          // Import server-only modules inside the handler
          const { getDb } = await import("~/db/server-helpers");
          const { teams, teamMembers, user, memberships } = await import("~/db/schema");

          const db = await getDb();

          switch (action) {
            case "clear-user-teams": {
              // Remove all team memberships for a user
              if (userId) {
                await db.delete(teamMembers).where(eq(teamMembers.userId, userId));
              } else if (userEmail) {
                const [targetUser] = await db
                  .select({ id: user.id })
                  .from(user)
                  .where(eq(user.email, userEmail));

                if (targetUser) {
                  await db
                    .delete(teamMembers)
                    .where(eq(teamMembers.userId, targetUser.id));
                }
              }
              return new Response(JSON.stringify({ success: true }), {
                status: 200,
                headers: { "Content-Type": "application/json" },
              });
            }

            case "delete-team": {
              // Delete a team and all its memberships
              if (teamId) {
                await db.transaction(async (tx) => {
                  await tx.delete(teamMembers).where(eq(teamMembers.teamId, teamId));
                  await tx.delete(teams).where(eq(teams.id, teamId));
                });
              }
              return new Response(JSON.stringify({ success: true }), {
                status: 200,
                headers: { "Content-Type": "application/json" },
              });
            }

            case "reset-user": {
              // Reset user to clean state (remove teams, memberships, etc.)
              if (userId || userEmail) {
                const targetUserId =
                  userId ||
                  (await db
                    .select({ id: user.id })
                    .from(user)
                    .where(eq(user.email, userEmail!))
                    .then((rows) => rows[0]?.id));

                if (targetUserId) {
                  // Remove team memberships
                  await db
                    .delete(teamMembers)
                    .where(eq(teamMembers.userId, targetUserId));

                  // Remove memberships
                  await db
                    .delete(memberships)
                    .where(eq(memberships.userId, targetUserId));

                  // Reset profile to incomplete state
                  await db
                    .update(user)
                    .set({
                      profileComplete: false,
                      dateOfBirth: null,
                      phone: null,
                      gender: null,
                      pronouns: null,
                      emergencyContact: null,
                      privacySettings: null,
                      profileUpdatedAt: null,
                    })
                    .where(eq(user.id, targetUserId));
                }
              }
              return new Response(JSON.stringify({ success: true }), {
                status: 200,
                headers: { "Content-Type": "application/json" },
              });
            }

            case "clear-user-memberships": {
              // Remove all memberships for a user
              if (userId || userEmail) {
                const targetUserId =
                  userId ||
                  (await db
                    .select({ id: user.id })
                    .from(user)
                    .where(eq(user.email, userEmail!))
                    .then((rows) => rows[0]?.id));

                if (targetUserId) {
                  await db
                    .delete(memberships)
                    .where(eq(memberships.userId, targetUserId));
                }
              }
              return new Response(JSON.stringify({ success: true }), {
                status: 200,
                headers: { "Content-Type": "application/json" },
              });
            }

            default:
              return new Response(JSON.stringify({ error: "Invalid action" }), {
                status: 400,
                headers: { "Content-Type": "application/json" },
              });
          }
        } catch (error) {
          console.error("Cleanup error:", error);
          return new Response(
            JSON.stringify({
              error: error instanceof Error ? error.message : "Cleanup failed",
            }),
            {
              status: 500,
              headers: { "Content-Type": "application/json" },
            },
          );
        }
      },
    },
  },
});
</file>

<file path="src/routes/api/webhooks/square.ts">
import { createFileRoute } from "@tanstack/react-router";
import { json } from "@tanstack/react-start";
import { eq } from "drizzle-orm";
import {
  eventPaymentSessions,
  eventRegistrations,
  events,
  membershipPaymentSessions,
  membershipTypes,
  memberships,
} from "~/db/schema";
import { user } from "~/db/schema/auth.schema";
import { atomicJsonbMerge } from "~/lib/db/jsonb-utils";
import { getSquarePaymentService } from "~/lib/payments/square";

async function finalizeMembershipFromWebhook({
  paymentId,
  orderId,
  eventType,
}: {
  paymentId: string | undefined;
  orderId: string | undefined;
  eventType: string;
}) {
  if (!paymentId && !orderId) {
    console.warn("[Square webhook] Missing payment identifiers for finalize", {
      eventType,
    });
    return;
  }

  const [{ getDb }, { finalizeMembershipForSession }] = await Promise.all([
    import("~/db/server-helpers"),
    import("~/features/membership/membership.finalize"),
  ]);

  const db = await getDb();

  let session = null as typeof membershipPaymentSessions.$inferSelect | null;

  if (paymentId) {
    const [byPaymentId] = await db
      .select()
      .from(membershipPaymentSessions)
      .where(eq(membershipPaymentSessions.squarePaymentId, paymentId))
      .limit(1);
    session = byPaymentId ?? session;
  }

  if (!session && orderId) {
    const [byOrderId] = await db
      .select()
      .from(membershipPaymentSessions)
      .where(eq(membershipPaymentSessions.squareOrderId, orderId))
      .limit(1);
    session = byOrderId ?? session;
  }

  if (!session) {
    console.warn("[Square webhook] No payment session found for finalize", {
      paymentId,
      orderId,
      eventType,
    });
    return;
  }

  const [membershipType] = await db
    .select()
    .from(membershipTypes)
    .where(eq(membershipTypes.id, session.membershipTypeId))
    .limit(1);

  if (!membershipType) {
    console.error("[Square webhook] Membership type missing during finalize", {
      membershipTypeId: session.membershipTypeId,
      sessionId: session.id,
    });
    return;
  }

  // Ensure we have a valid payment ID before finalizing
  const resolvedPaymentId = paymentId ?? session.squarePaymentId;
  if (!resolvedPaymentId) {
    console.warn("[Square webhook] Skipping finalize - missing paymentId", {
      orderId,
      sessionId: session.id,
      eventType,
    });
    return;
  }

  const now = new Date();
  const finalizeResult = await finalizeMembershipForSession({
    db,
    paymentSession: session,
    membershipType,
    paymentId: resolvedPaymentId,
    orderId: orderId ?? session.squareOrderId ?? null,
    sessionId: session.squareCheckoutId,
    now,
  });

  const [{ sendMembershipPurchaseReceipt }] = await Promise.all([
    import("~/lib/email/sendgrid"),
  ]);

  if (finalizeResult.wasCreated) {
    const [member] = await db
      .select({
        email: user.email,
        name: user.name,
      })
      .from(user)
      .where(eq(user.id, session.userId))
      .limit(1);

    if (member?.email) {
      try {
        await sendMembershipPurchaseReceipt({
          to: {
            email: member.email,
            name: member.name ?? undefined,
          },
          membershipType: membershipType.name,
          amount: membershipType.priceCents,
          paymentId: finalizeResult.membership.paymentId ?? paymentId ?? "",
          expiresAt: new Date(finalizeResult.membership.endDate),
        });
      } catch (emailError) {
        console.error("[Square webhook] Failed to send membership receipt", {
          paymentId,
          email: member.email,
          error: emailError,
        });
      }
    }
  }

  await db
    .update(membershipPaymentSessions)
    .set({
      metadata: atomicJsonbMerge(membershipPaymentSessions.metadata, {
        membershipId: finalizeResult.membership.id,
        lastWebhookFinalizeAt: now.toISOString(),
        lastWebhookEvent: eventType,
      }),
      updatedAt: now,
    })
    .where(eq(membershipPaymentSessions.id, session.id));
}

async function finalizeEventRegistrationFromWebhook({
  paymentId,
  orderId,
  eventType,
  amount,
}: {
  paymentId: string | undefined;
  orderId: string | undefined;
  eventType: string;
  amount: number | undefined;
}) {
  if (!paymentId && !orderId) {
    return;
  }

  const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);
  const db = await getDb();

  let session = null as typeof eventPaymentSessions.$inferSelect | null;

  if (paymentId) {
    const [byPaymentId] = await db
      .select()
      .from(eventPaymentSessions)
      .where(eq(eventPaymentSessions.squarePaymentId, paymentId))
      .limit(1);
    session = byPaymentId ?? session;
  }

  if (!session && orderId) {
    const [byOrderId] = await db
      .select()
      .from(eventPaymentSessions)
      .where(eq(eventPaymentSessions.squareOrderId, orderId))
      .limit(1);
    session = byOrderId ?? session;
  }

  if (!session) {
    return;
  }

  const [registrationResult] = await db
    .select({
      registration: eventRegistrations,
      event: events,
    })
    .from(eventRegistrations)
    .innerJoin(events, eq(eventRegistrations.eventId, events.id))
    .where(eq(eventRegistrations.id, session.registrationId))
    .limit(1);

  if (!registrationResult) {
    console.warn("[Square webhook] Event registration not found for payment", {
      registrationId: session.registrationId,
      paymentId,
      orderId,
    });
    return;
  }

  const { registration, event } = registrationResult;

  const now = new Date();
  const nowIso = now.toISOString();
  const paymentIdentifier = paymentId ?? session.squarePaymentId ?? "";
  const resolvedAmount = typeof amount === "number" ? amount : session.amountCents;

  await db
    .update(eventPaymentSessions)
    .set({
      status: "completed",
      squarePaymentId: paymentIdentifier,
      metadata: atomicJsonbMerge(eventPaymentSessions.metadata, {
        lastWebhookFinalizeAt: nowIso,
        lastWebhookEvent: eventType,
      }),
      updatedAt: now,
    })
    .where(eq(eventPaymentSessions.id, session.id));

  await db
    .update(eventRegistrations)
    .set({
      paymentStatus: "paid",
      status: registration.status === "cancelled" ? registration.status : "confirmed",
      paymentCompletedAt: now,
      paymentId: paymentIdentifier,
      amountPaidCents: resolvedAmount,
      paymentMetadata: atomicJsonbMerge(eventRegistrations.paymentMetadata, {
        squareTransactionId: paymentIdentifier,
        lastWebhookFinalizeAt: nowIso,
        lastWebhookEvent: eventType,
      }),
      updatedAt: now,
    })
    .where(eq(eventRegistrations.id, registration.id));

  console.log("[Square webhook] Event registration finalized", {
    registrationId: registration.id,
    eventId: event.id,
    paymentId: paymentIdentifier,
    amount: resolvedAmount,
  });
}

async function handleRefundEvent({
  paymentId,
  refundId,
  status,
  eventType,
}: {
  paymentId: string | undefined;
  refundId: string | undefined;
  status: string | undefined;
  eventType: string;
}) {
  if (!paymentId) {
    console.warn("[Square webhook] Refund event missing payment id", { eventType });
    return;
  }

  const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);
  const db = await getDb();

  const [membershipRecord] = await db
    .select()
    .from(memberships)
    .where(eq(memberships.paymentId, paymentId))
    .limit(1);

  if (!membershipRecord) {
    console.warn("[Square webhook] Refund received for unknown membership", {
      paymentId,
      refundId,
    });
    return;
  }

  const now = new Date();
  const nowIso = now.toISOString();

  await db
    .update(memberships)
    .set({
      status: "cancelled",
      metadata: atomicJsonbMerge(memberships.metadata, {
        lastRefundStatus: status,
        lastRefundId: refundId,
        lastRefundedAt: nowIso,
      }),
      updatedAt: now,
    })
    .where(eq(memberships.id, membershipRecord.id));

  const supportEmail = process.env["SUPPORT_EMAIL"];
  if (!supportEmail) {
    return;
  }

  try {
    const [{ getEmailService }] = await Promise.all([import("~/lib/email/sendgrid")]);
    const emailService = await getEmailService();
    const fromEmail = process.env["SENDGRID_FROM_EMAIL"] || "noreply@quadballcanada.com";
    const fromName = process.env["SENDGRID_FROM_NAME"] || "Quadball Canada";

    await emailService.send({
      to: { email: supportEmail },
      from: { email: fromEmail, name: fromName },
      subject: `Membership refund processed (${paymentId})`,
      text: `A refund event was received from Square.

Payment ID: ${paymentId}
Refund ID: ${refundId ?? "unknown"}
Status: ${status ?? "unknown"}
Membership ID: ${membershipRecord.id}
User ID: ${membershipRecord.userId}
Event Type: ${eventType}
Processed At: ${nowIso}
`,
    });
  } catch (emailError) {
    console.error("[Square webhook] Failed to send refund notification", {
      paymentId,
      refundId,
      error: emailError,
    });
  }
}

export const __squareWebhookTestUtils = {
  finalizeMembershipFromWebhook,
  finalizeEventRegistrationFromWebhook,
  handleRefundEvent,
};

export const Route = createFileRoute("/api/webhooks/square")({
  server: {
    handlers: {
      POST: async ({ request }) => {
        try {
          // Get the raw body for signature verification
          const body = await request.text();

          // Get the signature from headers
          const signature = request.headers.get("x-square-signature") || "";

          if (!signature) {
            console.error("Missing Square webhook signature");
            return json({ error: "Missing signature" }, { status: 401 });
          }

          // Parse the body
          let payload: unknown;
          try {
            payload = JSON.parse(body);
          } catch (error) {
            console.error("Invalid webhook payload:", error);
            return json({ error: "Invalid payload" }, { status: 400 });
          }

          // Get the payment service and verify the webhook
          const paymentService = await getSquarePaymentService();
          const { valid, event, error } = await paymentService.verifyAndParseWebhook(
            payload,
            signature,
          );

          if (!valid) {
            console.error("Webhook verification failed:", error);
            return json({ error: error || "Verification failed" }, { status: 401 });
          }

          if (!event) {
            console.error("No event parsed from webhook");
            return json({ error: "No event parsed" }, { status: 400 });
          }

          // Handle normalized event types
          switch (event.type) {
            case "payment.success": {
              console.log("[Square webhook] Payment success:", {
                paymentId: event.paymentId,
                orderId: event.orderId,
                amount: event.amount,
              });

              await finalizeMembershipFromWebhook({
                paymentId: event.paymentId,
                orderId: event.orderId,
                eventType: event.rawType,
              });
              await finalizeEventRegistrationFromWebhook({
                paymentId: event.paymentId,
                orderId: event.orderId,
                eventType: event.rawType,
                amount: event.amount,
              });
              break;
            }

            case "payment.failed":
            case "payment.cancelled": {
              console.warn("[Square webhook] Payment not successful:", {
                type: event.type,
                paymentId: event.paymentId,
                orderId: event.orderId,
                status: event.status,
              });
              break;
            }

            case "refund": {
              console.log("[Square webhook] Refund received:", {
                refundId: event.refundId,
                paymentId: event.paymentId,
                status: event.status,
                amount: event.amount,
              });

              await handleRefundEvent({
                paymentId: event.paymentId,
                refundId: event.refundId,
                status: event.status,
                eventType: event.rawType,
              });
              break;
            }

            case "unknown":
            default:
              console.log("[Square webhook] Unhandled event type:", event.rawType);
          }

          // Return success
          return json({ received: true });
        } catch (error) {
          console.error("Webhook handler error:", error);
          return json({ error: "Internal server error" }, { status: 500 });
        }
      },
    },
  },
});
</file>

<file path="src/routes/dashboard/teams/browse.tsx">
import { useQuery, useSuspenseQuery } from "@tanstack/react-query";
import { createFileRoute, Link } from "@tanstack/react-router";
import { useState } from "react";
import { Button } from "~/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";
import { DataErrorState } from "~/components/ui/data-state";
import { ArrowLeftIcon, SearchIcon, UsersIcon } from "~/components/ui/icons";
import { Input } from "~/components/ui/input";
import { Skeleton } from "~/components/ui/skeleton";
import type { TeamListItem } from "~/features/teams/teams.queries";
import { listTeams, searchTeams } from "~/features/teams/teams.queries";

export const Route = createFileRoute("/dashboard/teams/browse")({
  loader: async () => {
    // Pre-fetch all teams
    const teams = await listTeams({ data: { includeInactive: false } });
    return { teams };
  },
  component: BrowseTeamsPage,
});

function BrowseTeamsPage() {
  const { teams: initialTeams } = Route.useLoaderData();
  const [searchQuery, setSearchQuery] = useState("");
  const trimmedQuery = searchQuery.trim();

  const { data: allTeams, isFetching: isFetchingAll } = useSuspenseQuery({
    queryKey: ["allTeams"],
    queryFn: async () => listTeams({ data: { includeInactive: false } }),
    initialData: initialTeams,
  });

  const {
    data: searchResults = [],
    isFetching: isSearching,
    isError: searchErrored,
    refetch: retrySearch,
  } = useQuery({
    queryKey: ["searchTeams", trimmedQuery],
    queryFn: async () =>
      trimmedQuery ? searchTeams({ data: { query: trimmedQuery } }) : [],
    enabled: trimmedQuery.length > 0,
    placeholderData: [],
  });

  const teams = trimmedQuery
    ? searchResults.map((item) => ({ ...item, creator: null }))
    : allTeams;

  const showSkeletons =
    (trimmedQuery ? isSearching : isFetchingAll) && (teams?.length ?? 0) === 0;
  const skeletonKeys = ["alpha", "bravo", "charlie", "delta", "echo", "foxtrot"];

  return (
    <div className="container mx-auto p-6">
      <div className="mb-6">
        <Button variant="ghost" size="sm" asChild>
          <Link to="/dashboard/teams">
            <ArrowLeftIcon className="mr-2 h-4 w-4" />
            Back to My Teams
          </Link>
        </Button>
      </div>

      <div className="mb-8">
        <h1 className="text-3xl font-bold">Browse Teams</h1>
        <p className="text-muted-foreground">Discover and join teams in your area</p>
      </div>

      <div className="mb-6">
        <div className="relative">
          <SearchIcon className="text-muted-foreground absolute top-1/2 left-3 h-4 w-4 -translate-y-1/2" />
          <Input
            type="search"
            placeholder="Search teams by name or city..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="pl-10"
          />
        </div>
      </div>

      {trimmedQuery && searchErrored ? (
        <DataErrorState
          title="We couldnât find teams matching that search"
          description="Please try again or adjust your search filters."
          onRetry={() => retrySearch()}
        />
      ) : showSkeletons ? (
        <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {skeletonKeys.map((key) => (
            <TeamCardSkeleton key={key} />
          ))}
        </div>
      ) : teams.length === 0 ? (
        <Card>
          <CardContent className="flex flex-col items-center justify-center py-12">
            <UsersIcon className="text-muted-foreground mb-4 h-12 w-12" />
            <h3 className="mb-2 text-lg font-semibold">No teams found</h3>
            <p className="text-muted-foreground text-center">
              {trimmedQuery
                ? "Try a different search term"
                : "No teams available to browse"}
            </p>
          </CardContent>
        </Card>
      ) : (
        <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {teams.map((teamItem) => (
            <PublicTeamCard key={teamItem.team.id} teamItem={teamItem} />
          ))}
        </div>
      )}
    </div>
  );
}

function PublicTeamCard({ teamItem }: { teamItem: TeamListItem }) {
  const { team, memberCount, creator } = teamItem;

  return (
    <Card className="transition-shadow hover:shadow-lg">
      <CardHeader>
        <div className="flex items-start justify-between">
          <div>
            <CardTitle className="text-xl">{team.name}</CardTitle>
            {team.city && (
              <CardDescription>
                {team.city}
                {team.province ? `, ${team.province}` : ""}
              </CardDescription>
            )}
          </div>
          {team.primaryColor && (
            <div
              className="h-8 w-8 rounded-full border"
              style={{ backgroundColor: team.primaryColor }}
            />
          )}
        </div>
      </CardHeader>
      <CardContent>
        <div className="space-y-2 text-sm">
          <div className="flex items-center justify-between">
            <span className="text-muted-foreground">Members</span>
            <span className="font-medium">{memberCount}</span>
          </div>
          {team.foundedYear && (
            <div className="flex items-center justify-between">
              <span className="text-muted-foreground">Founded</span>
              <span className="font-medium">{team.foundedYear}</span>
            </div>
          )}
          {creator && (
            <div className="flex items-center justify-between">
              <span className="text-muted-foreground">Created by</span>
              <span className="truncate font-medium">
                {creator.name || creator.email}
              </span>
            </div>
          )}
        </div>
        <div className="mt-4">
          <Button asChild variant="outline" size="sm" className="w-full">
            <Link to="/dashboard/teams/$teamId" params={{ teamId: team.id }}>
              View Team
            </Link>
          </Button>
        </div>
      </CardContent>
    </Card>
  );
}

function TeamCardSkeleton() {
  return (
    <Card className="shadow-sm">
      <CardHeader>
        <div className="space-y-3">
          <Skeleton className="h-5 w-2/3" />
          <Skeleton className="h-4 w-1/2" />
        </div>
      </CardHeader>
      <CardContent className="space-y-3">
        <Skeleton className="h-4 w-1/2" />
        <Skeleton className="h-4 w-2/3" />
        <Skeleton className="h-4 w-1/3" />
        <Skeleton className="mt-6 h-9 w-full" />
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/routes/dashboard/teams/create.tsx">
import { useForm } from "@tanstack/react-form";
import { useMutation } from "@tanstack/react-query";
import { createFileRoute, Link, useNavigate } from "@tanstack/react-router";
import { useState } from "react";
import { FormSubmitButton } from "~/components/form-fields/FormSubmitButton";
import { ValidatedColorPicker } from "~/components/form-fields/ValidatedColorPicker";
import { ValidatedCombobox } from "~/components/form-fields/ValidatedCombobox";
import { ValidatedInput } from "~/components/form-fields/ValidatedInput";
import { Button } from "~/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";
import { AlertCircle, ArrowLeftIcon } from "~/components/ui/icons";
import { Label } from "~/components/ui/label";
import { Textarea } from "~/components/ui/textarea";
import { createTeam } from "~/features/teams/teams.mutations";
import type { CreateTeamInput } from "~/features/teams/teams.schemas";
import { unwrapServerFnResult } from "~/lib/server/fn-utils";

// Canadian provinces and territories
const PROVINCES = [
  { value: "AB", label: "Alberta" },
  { value: "BC", label: "British Columbia" },
  { value: "MB", label: "Manitoba" },
  { value: "NB", label: "New Brunswick" },
  { value: "NL", label: "Newfoundland and Labrador" },
  { value: "NT", label: "Northwest Territories" },
  { value: "NS", label: "Nova Scotia" },
  { value: "NU", label: "Nunavut" },
  { value: "ON", label: "Ontario" },
  { value: "PE", label: "Prince Edward Island" },
  { value: "QC", label: "Quebec" },
  { value: "SK", label: "Saskatchewan" },
  { value: "YT", label: "Yukon" },
];

export const Route = createFileRoute("/dashboard/teams/create")({
  component: CreateTeamPage,
});

function CreateTeamPage() {
  const navigate = useNavigate();
  const [serverError, setServerError] = useState<string | null>(null);

  const createTeamMutation = useMutation({
    mutationFn: (payload: CreateTeamInput) =>
      unwrapServerFnResult(createTeam({ data: payload })),
    onSuccess: (team) => {
      navigate({ to: "/dashboard/teams/$teamId", params: { teamId: team.id } });
    },
    onError: (error) => {
      setServerError(error.message || "Failed to create team");
    },
  });

  const form = useForm({
    defaultValues: {
      name: "",
      slug: "",
      description: "",
      city: "",
      province: "",
      primaryColor: "#000000",
      secondaryColor: "#ffffff",
      foundedYear: new Date().getFullYear().toString(),
      website: "",
    },
    onSubmit: async ({ value }) => {
      setServerError(null);

      // Validate required fields
      if (!value.name) {
        setServerError("Team name is required");
        return;
      }

      try {
        // Generate slug from name if not provided
        const slug = value.slug || value.name.toLowerCase().replace(/[^a-z0-9]+/g, "-");

        await createTeamMutation.mutateAsync({
          name: value.name,
          slug,
          description: value.description || undefined,
          city: value.city || undefined,
          province: value.province || undefined,
          primaryColor: value.primaryColor || undefined,
          secondaryColor: value.secondaryColor || undefined,
          foundedYear: value.foundedYear || undefined,
          website: value.website || undefined,
        });
      } catch (error) {
        console.error("Form submission error:", error);
        setServerError(error instanceof Error ? error.message : "Failed to create team");
      }
    },
  });

  return (
    <div className="container mx-auto max-w-2xl p-6">
      <div className="mb-6">
        <Button variant="ghost" size="sm" asChild>
          <Link to="/dashboard/teams">
            <ArrowLeftIcon className="mr-2 h-4 w-4" />
            Back to Teams
          </Link>
        </Button>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Create a New Team</CardTitle>
          <CardDescription>
            Set up your team profile and start inviting members
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form
            onSubmit={(e) => {
              e.preventDefault();
              e.stopPropagation();
              form.handleSubmit();
            }}
            className="space-y-6"
          >
            {serverError && (
              <div className="bg-destructive/10 text-destructive border-destructive/20 flex items-start gap-3 rounded-lg border p-4">
                <AlertCircle className="mt-0.5 h-5 w-5 flex-shrink-0" />
                <div className="flex-1">
                  <p className="font-medium">Error creating team</p>
                  <p className="mt-1 text-sm">{serverError}</p>
                </div>
              </div>
            )}

            <div className="grid gap-4">
              <form.Field
                name="name"
                validators={{
                  onChange: ({ value }) => (!value ? "Team name is required" : undefined),
                }}
              >
                {(field) => (
                  <ValidatedInput
                    field={field}
                    label="Team Name"
                    placeholder="UVic Valkyries"
                  />
                )}
              </form.Field>

              <form.Field
                name="slug"
                validators={{
                  onChange: ({ value }) => {
                    if (!value) return undefined;
                    if (!/^[a-z0-9-]+$/.test(value)) {
                      return "Slug can only contain lowercase letters, numbers, and hyphens";
                    }
                    return undefined;
                  },
                }}
              >
                {(field) => (
                  <ValidatedInput
                    field={field}
                    label="URL Slug"
                    placeholder="uvic-valkyries"
                  />
                )}
              </form.Field>

              <form.Field name="description">
                {(field) => (
                  <div className="space-y-2">
                    <Label htmlFor={field.name}>Description</Label>
                    <Textarea
                      id={field.name}
                      name={field.name}
                      value={field.state.value ?? ""}
                      onChange={(e) => field.handleChange(e.target.value)}
                      onBlur={field.handleBlur}
                      placeholder="Tell us about your team..."
                      rows={4}
                    />
                  </div>
                )}
              </form.Field>

              <div className="grid grid-cols-2 gap-4">
                <form.Field name="city">
                  {(field) => (
                    <ValidatedInput field={field} label="City" placeholder="Victoria" />
                  )}
                </form.Field>

                <form.Field
                  name="province"
                  validators={{
                    onChange: ({ value }) => {
                      if (value && !PROVINCES.some((p) => p.value === value)) {
                        return "Please select a valid province";
                      }
                      return undefined;
                    },
                  }}
                >
                  {(field) => (
                    <ValidatedCombobox
                      field={field}
                      label="Province"
                      placeholder="Select a province..."
                      options={PROVINCES}
                      searchPlaceholder="Search provinces..."
                      emptyText="No province found."
                    />
                  )}
                </form.Field>
              </div>

              <div className="grid grid-cols-2 gap-4">
                <form.Field
                  name="primaryColor"
                  validators={{
                    onChange: ({ value }) => {
                      if (value && !/^#[0-9A-F]{6}$/i.test(value)) {
                        return "Color must be in hex format (e.g., #FF0000)";
                      }
                      return undefined;
                    },
                  }}
                >
                  {(field) => (
                    <ValidatedColorPicker
                      field={field}
                      label="Primary Color"
                      description="Used for jerseys, branding, and team identity"
                    />
                  )}
                </form.Field>

                <form.Field
                  name="secondaryColor"
                  validators={{
                    onChange: ({ value }) => {
                      if (value && !/^#[0-9A-F]{6}$/i.test(value)) {
                        return "Color must be in hex format (e.g., #0000FF)";
                      }
                      return undefined;
                    },
                  }}
                >
                  {(field) => (
                    <ValidatedColorPicker
                      field={field}
                      label="Secondary Color"
                      description="Accent color for team materials and website"
                    />
                  )}
                </form.Field>
              </div>

              <div className="grid grid-cols-2 gap-4">
                <form.Field
                  name="foundedYear"
                  validators={{
                    onChange: ({ value }) => {
                      if (
                        value &&
                        (!/^\d{4}$/.test(value) ||
                          parseInt(value) > new Date().getFullYear())
                      ) {
                        return "Enter a valid year";
                      }
                      return undefined;
                    },
                  }}
                >
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Founded Year"
                      placeholder="2010"
                      maxLength={4}
                    />
                  )}
                </form.Field>

                <form.Field
                  name="website"
                  validators={{
                    onChange: ({ value }) => {
                      if (value && !value.startsWith("http")) {
                        return "Website must start with http:// or https://";
                      }
                      return undefined;
                    },
                  }}
                >
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Website"
                      placeholder="https://uvicvalkyries.com"
                      type="url"
                    />
                  )}
                </form.Field>
              </div>
            </div>

            <div className="flex justify-end gap-4">
              <Button variant="outline" asChild>
                <Link to="/dashboard/teams">Cancel</Link>
              </Button>
              <FormSubmitButton
                isSubmitting={form.state.isSubmitting}
                loadingText="Creating team..."
              >
                Create Team
              </FormSubmitButton>
            </div>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/routes/__root.tsx">
/// <reference types="vite/client" />
import type { QueryClient } from "@tanstack/react-query";
import {
  createRootRouteWithContext,
  HeadContent,
  Outlet,
  ScriptOnce,
  Scripts,
} from "@tanstack/react-router";

import { lazy, Suspense } from "react";
import {
  authQueryOptions,
  getCurrentUser,
  type AuthQueryResult,
} from "~/features/auth/auth.queries";
import appCss from "~/styles.css?url";

// Lazy load devtools only in development to exclude from production bundles
const ReactQueryDevtools = import.meta.env.DEV
  ? lazy(() =>
      import("@tanstack/react-query-devtools").then((mod) => ({
        default: mod.ReactQueryDevtools,
      })),
    )
  : null;

const TanStackRouterDevtools = import.meta.env.DEV
  ? lazy(() =>
      import("@tanstack/react-router-devtools").then((mod) => ({
        default: mod.TanStackRouterDevtools,
      })),
    )
  : null;

// Lazy load Toaster to avoid SSR issues
const Toaster = lazy(() => import("sonner").then((mod) => ({ default: mod.Toaster })));

export const Route = createRootRouteWithContext<{
  queryClient: QueryClient;
  user: AuthQueryResult;
}>()({
  beforeLoad: async ({ context }) => {
    try {
      // Check if we're on the server or client
      if (typeof window === "undefined") {
        // Server: use the server function
        const user = await getCurrentUser();
        return { user };
      } else {
        // Client: fetch the full user data
        const user = await context.queryClient.fetchQuery(authQueryOptions());
        return { user };
      }
    } catch (error) {
      console.error("Error loading user:", error);
      return { user: null };
    }
  },
  head: () => ({
    meta: [
      {
        charSet: "utf-8",
      },
      {
        name: "viewport",
        content: "width=device-width, initial-scale=1",
      },
      {
        title: "Quadball Canada",
      },
      {
        name: "description",
        content:
          "Official hub for Quadball Canada competitions, club resources, and national team updates.",
      },
    ],
    links: [{ rel: "stylesheet", href: appCss }],
  }),
  component: RootComponent,
});

function RootComponent() {
  return (
    <RootDocument>
      <Outlet />
    </RootDocument>
  );
}

function RootDocument({ children }: { readonly children: React.ReactNode }) {
  return (
    // suppress since we're updating the "dark" class in a custom script below
    <html lang="en" suppressHydrationWarning>
      <head>
        <HeadContent />
      </head>
      <body>
        <ScriptOnce>
          {`
            // Minimal process shim for TanStack server functions
            if (typeof globalThis.process === 'undefined') {
              globalThis.process = {
                env: { NODE_ENV: '${import.meta.env.PROD ? "production" : "development"}' },
                versions: { node: '22.0.0' }
              };
            }

            // Theme toggle
            document.documentElement.classList.toggle(
              'dark',
              localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)
            );
          `}
        </ScriptOnce>

        {children}

        <Suspense fallback={null}>
          <Toaster richColors closeButton />
        </Suspense>
        {import.meta.env.DEV && ReactQueryDevtools && TanStackRouterDevtools && (
          <Suspense fallback={null}>
            <ReactQueryDevtools buttonPosition="bottom-left" />
            <TanStackRouterDevtools position="bottom-right" />
          </Suspense>
        )}

        <Scripts />
      </body>
    </html>
  );
}
</file>

<file path="src/components/form-fields/ValidatedInput.tsx">
import React from "react";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";
import { FieldComponentProps, isFieldApi } from "~/lib/form";
import { cn } from "~/shared/lib/utils";

// Type specifically for ValidatedInput, extending the base props
interface ValidatedInputProps extends FieldComponentProps {
  type?: React.HTMLInputTypeAttribute; // Allow passing input type (text, password, email, etc.)
  maxLength?: number;
  min?: string | number;
  max?: string | number;
  step?: string | number;
  autoComplete?: string;
  autoFocus?: boolean;
  pattern?: string;
  required?: boolean;
  readOnly?: boolean;
  disabled?: boolean;
  description?: string;
  onValueChange?: (value: string, event: React.ChangeEvent<HTMLInputElement>) => void;
}

// Correctly define the component receiving props
export const ValidatedInput: React.FC<ValidatedInputProps> = (props) => {
  const {
    field,
    label,
    type = "text",
    placeholder,
    className,
    description,
    onValueChange,
    ...rest // Collect rest of props here
  } = props;

  // Ensure field is correctly passed
  if (!isFieldApi(field)) {
    console.error("ValidatedInput requires a valid field prop.", { field, props });
    return null;
  }

  const inputId = `${field.name}-input`;
  const meta = field.state.meta;

  return (
    <div className={cn("space-y-2", className)}>
      <Label htmlFor={inputId}>{label}</Label>
      <Input
        id={inputId}
        name={field.name}
        type={type}
        value={field.state.value ?? ""}
        onBlur={field.handleBlur}
        onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
          if (onValueChange) {
            onValueChange(event.target.value, event);
            return;
          }
          field.handleChange(event.target.value);
        }}
        placeholder={placeholder}
        disabled={field.form.state.isSubmitting || props.disabled}
        // Add aria-invalid for accessibility based on errors
        aria-invalid={!!meta.errors.length}
        aria-describedby={meta.errors.length ? `${inputId}-errors` : undefined}
        {...rest}
      />
      {description && <p className="text-muted-foreground text-sm">{description}</p>}
      {/* Show errors only if the field has been touched and has errors */}
      {meta.isTouched && meta.errors.length > 0 && (
        <div id={`${inputId}-errors`} className="text-destructive text-sm font-medium">
          {meta.errors.join(", ")}
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/features/profile/profile.mutations.ts">
import { createServerFn } from "@tanstack/react-start";
import { getAuthMiddleware, requireUser } from "~/lib/server/auth";
import { zod$ } from "~/lib/server/fn-utils";
import { isProfileComplete } from "./profile.queries";
import {
  partialProfileInputSchema,
  privacySettingsSchema,
  profileInputSchema,
} from "./profile.schemas";
import type {
  EmergencyContact,
  PrivacySettings,
  ProfileOperationResult,
  UserProfile,
} from "./profile.types";
import { defaultPrivacySettings } from "./profile.types";

function parseJsonField<T>(value: string | null | undefined): T | undefined {
  if (!value) return undefined;
  try {
    return JSON.parse(value) as T;
  } catch {
    return undefined;
  }
}

function mapDbUserToProfile(dbUser: {
  id: string;
  name: string;
  email: string;
  profileComplete: boolean;
  dateOfBirth: Date | null;
  emergencyContact: string | null;
  gender: string | null;
  pronouns: string | null;
  phone: string | null;
  privacySettings: string | null;
  profileVersion: number;
  profileUpdatedAt: Date | null;
}): UserProfile {
  return {
    id: dbUser.id,
    name: dbUser.name,
    email: dbUser.email,
    profileComplete: dbUser.profileComplete,
    dateOfBirth: dbUser.dateOfBirth ?? undefined,
    emergencyContact: parseJsonField<EmergencyContact>(dbUser.emergencyContact),
    gender: dbUser.gender ?? undefined,
    pronouns: dbUser.pronouns ?? undefined,
    phone: dbUser.phone ?? undefined,
    privacySettings: parseJsonField<PrivacySettings>(dbUser.privacySettings),
    profileVersion: dbUser.profileVersion,
    profileUpdatedAt: dbUser.profileUpdatedAt ?? undefined,
  };
}

export const updateUserProfile = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(partialProfileInputSchema))
  .handler(async ({ data: inputData, context }): Promise<ProfileOperationResult> => {
    // Now inputData contains the actual profile data
    try {
      const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);
      const db = await getDb();
      const currentUser = requireUser(context);

      // Input is already validated by .inputValidator(), just check if it's empty
      if (!inputData || Object.keys(inputData).length === 0) {
        return {
          success: false,
          errors: [{ code: "VALIDATION_ERROR", message: "No data provided" }],
        };
      }

      // Import database dependencies inside handler
      const { eq, sql } = await import("drizzle-orm");
      const { user } = await import("~/db/schema");

      const updateData: Record<string, unknown> = {
        profileUpdatedAt: new Date(),
        profileVersion: sql`${user.profileVersion} + 1`,
      };

      if (inputData.dateOfBirth !== undefined) {
        // Convert string date to Date object if needed
        updateData["dateOfBirth"] =
          typeof inputData.dateOfBirth === "string"
            ? new Date(inputData.dateOfBirth)
            : inputData.dateOfBirth;
      }
      if (inputData.emergencyContact !== undefined) {
        updateData["emergencyContact"] = JSON.stringify(inputData.emergencyContact);
      }
      if (inputData.gender !== undefined) {
        updateData["gender"] = inputData.gender;
      }
      if (inputData.pronouns !== undefined) {
        updateData["pronouns"] = inputData.pronouns;
      }
      if (inputData.phone !== undefined) {
        updateData["phone"] = inputData.phone;
      }
      if (inputData.privacySettings !== undefined) {
        updateData["privacySettings"] = JSON.stringify(inputData.privacySettings);
      }
      const [updatedUser] = await db
        .update(user)
        .set(updateData)
        .where(eq(user.id, currentUser.id))
        .returning();

      if (!updatedUser) {
        return {
          success: false,
          errors: [{ code: "DATABASE_ERROR", message: "Failed to update profile" }],
        };
      }

      // Check if profile is now complete
      const profile = mapDbUserToProfile(updatedUser);
      const profileComplete = isProfileComplete(profile);

      if (profileComplete !== updatedUser.profileComplete) {
        const [finalUser] = await db
          .update(user)
          .set({ profileComplete })
          .where(eq(user.id, currentUser.id))
          .returning();

        return {
          success: true,
          data: mapDbUserToProfile(finalUser),
        };
      }

      return {
        success: true,
        data: profile,
      };
    } catch (error) {
      console.error("Error updating user profile:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to update profile",
          },
        ],
      };
    }
  });

export const completeUserProfile = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(profileInputSchema))
  .handler(async ({ data, context }): Promise<ProfileOperationResult> => {
    try {
      const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);
      const db = await getDb();
      const currentUser = requireUser(context);

      const { eq, sql } = await import("drizzle-orm");
      const { user } = await import("~/db/schema");

      const updateData = {
        dateOfBirth: data.dateOfBirth,
        emergencyContact: JSON.stringify(data.emergencyContact),
        gender: data.gender || null,
        pronouns: data.pronouns || null,
        phone: data.phone || null,
        privacySettings: JSON.stringify(data.privacySettings || defaultPrivacySettings),
        profileComplete: true,
        profileUpdatedAt: new Date(),
        profileVersion: sql`${user.profileVersion} + 1`,
      };

      const [updatedUser] = await db
        .update(user)
        .set(updateData)
        .where(eq(user.id, currentUser.id))
        .returning();

      if (!updatedUser) {
        return {
          success: false,
          errors: [{ code: "DATABASE_ERROR", message: "Failed to complete profile" }],
        };
      }

      return {
        success: true,
        data: mapDbUserToProfile(updatedUser),
      };
    } catch (error) {
      console.error("Error completing user profile:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to complete profile",
          },
        ],
      };
    }
  });

export const updatePrivacySettings = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(privacySettingsSchema))
  .handler(async ({ data, context }): Promise<ProfileOperationResult> => {
    try {
      const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);
      const db = await getDb();
      const currentUser = requireUser(context);

      const { eq } = await import("drizzle-orm");
      const { user } = await import("~/db/schema");

      const [updatedUser] = await db
        .update(user)
        .set({
          privacySettings: JSON.stringify(data),
          profileUpdatedAt: new Date(),
        })
        .where(eq(user.id, currentUser.id))
        .returning();

      if (!updatedUser) {
        return {
          success: false,
          errors: [
            { code: "DATABASE_ERROR", message: "Failed to update privacy settings" },
          ],
        };
      }

      return {
        success: true,
        data: mapDbUserToProfile(updatedUser),
      };
    } catch (error) {
      console.error("Error updating privacy settings:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to update privacy settings",
          },
        ],
      };
    }
  });
</file>

<file path="src/features/roles/roles.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { z } from "zod";
import { zod$ } from "~/lib/server/fn-utils";
import type {
  RoleManagementData,
  RoleOperationResult,
  RoleUserSearchResult,
} from "./roles.types";

function escapeLike(term: string) {
  return term.replace(/\\/g, "\\\\").replace(/%/g, "\\%").replace(/_/g, "\\_");
}

const searchUsersSchema = z.object({
  query: z.string().min(2, "Enter at least 2 characters"),
  limit: z.int().positive().max(25).optional().prefault(10),
});

export const getRoleManagementData = createServerFn({ method: "GET" }).handler(
  async (): Promise<RoleOperationResult<RoleManagementData>> => {
    try {
      const [{ getDb }, { getAuth }] = await Promise.all([
        import("~/db/server-helpers"),
        import("~/lib/auth/server-helpers"),
      ]);

      const auth = await getAuth();
      const { getRequest } = await import("@tanstack/react-start/server");
      const { headers } = getRequest();
      const session = await auth.api.getSession({ headers });

      if (!session?.user?.id) {
        return {
          success: false,
          errors: [
            {
              code: "UNAUTHORIZED",
              message: "User not authenticated",
            },
          ],
        };
      }

      const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
      await requireAdmin(session.user.id);

      const db = await getDb();
      const { roles, userRoles, user } = await import("~/db/schema");
      const { asc, desc, sql, eq } = await import("drizzle-orm");
      const { alias } = await import("drizzle-orm/pg-core");

      const roleSummaries = await db
        .select({
          id: roles.id,
          name: roles.name,
          description: roles.description,
          permissions: roles.permissions,
          createdAt: roles.createdAt,
          updatedAt: roles.updatedAt,
          assignmentCount: sql<number>`count(${userRoles.id})`,
        })
        .from(roles)
        .leftJoin(userRoles, eq(userRoles.roleId, roles.id))
        .groupBy(
          roles.id,
          roles.name,
          roles.description,
          roles.permissions,
          roles.createdAt,
          roles.updatedAt,
        )
        .orderBy(asc(roles.name));

      const assignerUser = alias(user, "assigner_user");

      const assignments = await db
        .select({
          id: userRoles.id,
          roleId: userRoles.roleId,
          roleName: roles.name,
          roleDescription: roles.description,
          userId: user.id,
          userName: user.name,
          userEmail: user.email,
          teamId: userRoles.teamId,
          eventId: userRoles.eventId,
          assignedBy: userRoles.assignedBy,
          assignedByName: assignerUser.name,
          assignedByEmail: assignerUser.email,
          assignedAt: userRoles.assignedAt,
          expiresAt: userRoles.expiresAt,
          notes: userRoles.notes,
        })
        .from(userRoles)
        .innerJoin(user, eq(userRoles.userId, user.id))
        .innerJoin(roles, eq(userRoles.roleId, roles.id))
        .leftJoin(assignerUser, eq(assignerUser.id, userRoles.assignedBy))
        .orderBy(desc(userRoles.assignedAt));

      return {
        success: true,
        data: {
          roles: roleSummaries,
          assignments,
        },
      };
    } catch (error) {
      console.error("Error loading role management data:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to load role management data",
          },
        ],
      };
    }
  },
);

export const searchRoleEligibleUsers = createServerFn({ method: "GET" })
  .inputValidator(zod$(searchUsersSchema))
  .handler(async ({ data }): Promise<RoleOperationResult<RoleUserSearchResult[]>> => {
    try {
      const [{ getDb }, { getAuth }] = await Promise.all([
        import("~/db/server-helpers"),
        import("~/lib/auth/server-helpers"),
      ]);

      const auth = await getAuth();
      const { getRequest } = await import("@tanstack/react-start/server");
      const { headers } = getRequest();
      const session = await auth.api.getSession({ headers });

      if (!session?.user?.id) {
        return {
          success: false,
          errors: [
            {
              code: "UNAUTHORIZED",
              message: "User not authenticated",
            },
          ],
        };
      }

      const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
      await requireAdmin(session.user.id);

      const db = await getDb();
      const { user, userRoles, roles } = await import("~/db/schema");
      const { asc, ilike, or, sql, eq } = await import("drizzle-orm");

      const searchTerm = `%${escapeLike(data.query.trim())}%`;

      const matches = await db
        .select({
          id: user.id,
          name: user.name,
          email: user.email,
          roleNames: sql<string[]>`array_remove(array_agg(${roles.name}), NULL)`,
        })
        .from(user)
        .leftJoin(userRoles, eq(userRoles.userId, user.id))
        .leftJoin(roles, eq(userRoles.roleId, roles.id))
        .where(or(ilike(user.email, searchTerm), ilike(user.name, searchTerm)))
        .groupBy(user.id)
        .orderBy(asc(user.name))
        .limit(data.limit);

      const results: RoleUserSearchResult[] = matches.map((match) => ({
        id: match.id,
        name: match.name,
        email: match.email,
        roleNames: Array.isArray(match.roleNames) ? match.roleNames : [],
      }));

      return {
        success: true,
        data: results,
      };
    } catch (error) {
      console.error("Error searching users for roles:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to search users",
          },
        ],
      };
    }
  });
</file>

<file path="src/features/teams/teams.schemas.ts">
import { z } from "zod";

// Query schemas
export const getTeamSchema = z.object({
  teamId: z.string(),
});
export type GetTeamInput = z.infer<typeof getTeamSchema>;

export const getTeamBySlugSchema = z.object({
  slug: z.string(),
});
export type GetTeamBySlugInput = z.infer<typeof getTeamBySlugSchema>;

const listTeamsInputSchema = z.object({
  includeInactive: z.boolean().optional().prefault(false),
});

export const listTeamsSchema = listTeamsInputSchema
  .nullish()
  .transform((value) => value ?? { includeInactive: false });
export type ListTeamsInput = z.infer<typeof listTeamsSchema>;

export const getTeamMembersSchema = z.object({
  teamId: z.string(),
  includeInactive: z.boolean().optional(),
});
export type GetTeamMembersInput = z.infer<typeof getTeamMembersSchema>;

export const isTeamMemberSchema = z.object({
  teamId: z.string(),
  userId: z.string(),
});
export type IsTeamMemberInput = z.infer<typeof isTeamMemberSchema>;

export const searchTeamsSchema = z.object({
  query: z.string().trim().min(1),
});
export type SearchTeamsInput = z.infer<typeof searchTeamsSchema>;

// Mutation schemas
export const createTeamSchema = z.object({
  name: z.string().min(1, "Team name is required"),
  slug: z
    .string()
    .min(1, "A unique URL slug is required")
    .regex(
      /^[a-z0-9-]+$/,
      "Slug can only contain lowercase letters, numbers, and hyphens",
    ),
  description: z.string().optional(),
  city: z.string().optional(),
  province: z.string().optional(),
  primaryColor: z
    .string()
    .regex(/^#[0-9A-Fa-f]{6}$/)
    .optional(),
  secondaryColor: z
    .string()
    .regex(/^#[0-9A-Fa-f]{6}$/)
    .optional(),
  foundedYear: z.string().length(4).optional(),
  website: z.url().optional(),
  socialLinks: z.record(z.string(), z.string()).optional(),
});
export type CreateTeamInput = z.infer<typeof createTeamSchema>;

export const updateTeamSchema = z.object({
  teamId: z.string(),
  data: createTeamSchema.partial(),
});
export type UpdateTeamInput = z.infer<typeof updateTeamSchema>;

export const addTeamMemberSchema = z.object({
  teamId: z.string(),
  email: z.email("Please enter a valid email address"),
  role: z.enum(["captain", "coach", "player", "substitute"]),
  jerseyNumber: z.string().optional(),
  position: z.string().optional(),
});
export type AddTeamMemberInput = z.infer<typeof addTeamMemberSchema>;

export const updateTeamMemberSchema = z.object({
  teamId: z.string(),
  memberId: z.string(),
  role: z.enum(["captain", "coach", "player", "substitute"]).optional(),
  jerseyNumber: z.string().optional(),
  position: z.string().optional(),
  notes: z.string().optional(),
});
export type UpdateTeamMemberInput = z.infer<typeof updateTeamMemberSchema>;

export const removeTeamMemberSchema = z.object({
  teamId: z.string(),
  memberId: z.string(),
});
export type RemoveTeamMemberInput = z.infer<typeof removeTeamMemberSchema>;

export const teamInviteActionSchema = z.object({
  teamId: z.string(),
});
export type TeamInviteActionInput = z.infer<typeof teamInviteActionSchema>;

export const requestTeamMembershipSchema = z.object({
  teamId: z.string(),
});
export type RequestTeamMembershipInput = z.infer<typeof requestTeamMembershipSchema>;
</file>

<file path="src/routes/dashboard/events/$eventId.manage.tsx">
import { useMutation, useQuery } from "@tanstack/react-query";
import { createFileRoute, Link, redirect, useRouteContext } from "@tanstack/react-router";
import { format } from "date-fns";
import {
  ArrowLeftIcon,
  CalendarIcon,
  ClockIcon,
  DollarSignIcon,
  DownloadIcon,
  MailIcon,
  TrashIcon,
  UsersIcon,
  XCircleIcon,
} from "lucide-react";
import { useState } from "react";
import { toast } from "sonner";
import { Alert, AlertDescription, AlertTitle } from "~/components/ui/alert";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "~/components/ui/alert-dialog";
import { Badge } from "~/components/ui/badge";
import { Button } from "~/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";
import { Label } from "~/components/ui/label";
import { Separator } from "~/components/ui/separator";
import { Skeleton } from "~/components/ui/skeleton";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "~/components/ui/table";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "~/components/ui/tabs";
import {
  cancelEvent,
  markEventEtransferPaid,
  markEventEtransferReminder,
  updateEvent,
} from "~/features/events/events.mutations";
import type { EventRegistrationSummary } from "~/features/events/events.queries";
import { getEvent, getEventRegistrations } from "~/features/events/events.queries";
import type {
  EventOperationResult,
  EventStatus,
  EventWithDetails,
  UpdateEventInput,
} from "~/features/events/events.types";
import { isAdminClient } from "~/lib/auth/utils/admin-check";
import { unwrapServerFnResult } from "~/lib/server/fn-utils";
import { cn } from "~/shared/lib/utils";

type ManagementTab = "overview" | "registrations" | "settings";

const currencyFormatter = new Intl.NumberFormat("en-CA", {
  style: "currency",
  currency: "CAD",
});

function formatCurrency(cents: number): string {
  return currencyFormatter.format(cents / 100);
}

export const Route = createFileRoute("/dashboard/events/$eventId/manage")({
  beforeLoad: async ({ context, location }) => {
    const { user } = context;
    if (!user) {
      throw redirect({
        to: "/auth/login",
        search: { redirect: location.pathname },
      });
    }

    if (!isAdminClient(user)) {
      throw redirect({ to: "/dashboard/events" });
    }
  },
  component: EventManagementPage,
});

function EventManagementPage() {
  const { eventId } = Route.useParams();
  const { user } = useRouteContext({ from: "/dashboard/events/$eventId/manage" });
  const [activeTab, setActiveTab] = useState<ManagementTab>("overview");

  // Fetch event details
  const {
    data: eventResult,
    isLoading: eventLoading,
    refetch: refetchEvent,
  } = useQuery<EventOperationResult<EventWithDetails>, Error>({
    queryKey: ["event", eventId],
    queryFn: () => getEvent({ data: { id: eventId } }),
  });

  // Fetch registrations
  const {
    data: registrations,
    isLoading: registrationsLoading,
    refetch: refetchRegistrations,
  } = useQuery<EventRegistrationSummary[], Error>({
    queryKey: ["event-registrations", eventId],
    queryFn: () => getEventRegistrations({ data: { eventId } }),
    enabled: !!eventId,
  });

  // Update event mutation
  const updateMutation = useMutation({
    mutationFn: (payload: UpdateEventInput) =>
      unwrapServerFnResult(
        updateEvent({
          data: {
            eventId,
            data: payload,
          },
        }),
      ),
    onSuccess: (result) => {
      if (result.success) {
        toast.success("Event updated successfully");
        refetchEvent();
      } else {
        toast.error(result.errors?.[0]?.message || "Failed to update event");
      }
    },
  });

  const markEtransferPaidMutation = useMutation({
    mutationFn: (registrationId: string) =>
      unwrapServerFnResult(
        markEventEtransferPaid({
          data: { registrationId },
        }),
      ),
    onSuccess: (result) => {
      if (result.success) {
        toast.success("Registration marked as paid");
        refetchRegistrations();
        refetchEvent();
      } else {
        toast.error(result.errors?.[0]?.message || "Failed to update registration");
      }
    },
    onError: (error) => {
      toast.error("Failed to update registration");
      console.error(error);
    },
  });

  const markEtransferReminderMutation = useMutation({
    mutationFn: (registrationId: string) =>
      unwrapServerFnResult(
        markEventEtransferReminder({
          data: { registrationId },
        }),
      ),
    onSuccess: (result) => {
      if (result.success) {
        toast.success("Reminder logged");
        refetchRegistrations();
      } else {
        toast.error(result.errors?.[0]?.message || "Failed to update registration");
      }
    },
    onError: (error) => {
      toast.error("Failed to update registration");
      console.error(error);
    },
  });

  // Cancel event mutation
  const cancelMutation = useMutation({
    mutationFn: () =>
      unwrapServerFnResult(cancelEvent({ data: { eventId } })) as Promise<
        EventOperationResult<null>
      >,
    onSuccess: (result) => {
      if (result.success) {
        toast.success("Event cancelled successfully");
        refetchEvent();
      } else {
        toast.error(result.errors?.[0]?.message || "Failed to cancel event");
      }
    },
  });

  if (eventLoading) {
    return <ManagementSkeleton />;
  }

  if (!eventResult?.success || !eventResult.data) {
    return (
      <div className="container mx-auto p-6">
        <Alert variant="destructive">
          <AlertTitle>Event Not Found</AlertTitle>
          <AlertDescription>
            The event you're trying to manage doesn't exist.
          </AlertDescription>
        </Alert>
        <Button asChild className="mt-4">
          <Link to="/dashboard/events">
            <ArrowLeftIcon className="mr-2 h-4 w-4" />
            Back to Events
          </Link>
        </Button>
      </div>
    );
  }

  const event = eventResult.data;
  const isOwner = event.organizerId === user?.id;
  const eventStatusBadge = getEventStatusBadge(event.status);
  const maxTeamsValue = typeof event.maxTeams === "number" ? event.maxTeams : undefined;
  const maxParticipantsValue =
    typeof event.maxParticipants === "number" ? event.maxParticipants : undefined;

  // Calculate statistics
  const confirmedRegistrations =
    registrations?.filter((registration) => registration.status === "confirmed") ?? [];
  const pendingRegistrations =
    registrations?.filter((registration) => registration.status === "pending") ?? [];
  const paidRegistrations =
    registrations?.filter((registration) => registration.paymentStatus === "paid") ?? [];
  const outstandingEtransferRegistrations =
    registrations?.filter(
      (registration) =>
        registration.paymentMethod === "etransfer" &&
        registration.paymentStatus !== "paid" &&
        registration.status !== "cancelled",
    ) ?? [];

  const totalRevenueCents = paidRegistrations.reduce(
    (sum, registration) => sum + (registration.amountPaidCents ?? 0),
    0,
  );

  const handleStatusChange = (newStatus: EventStatus) => {
    updateMutation.mutate({ status: newStatus });
  };

  const handleExportRegistrations = () => {
    if (!registrations || registrations.length === 0) {
      toast.error("No registrations to export");
      return;
    }

    // Create CSV content
    const headers = [
      "Name",
      "Email",
      "Type",
      "Team",
      "Status",
      "Payment Status",
      "Payment Method",
      "Amount Due (CAD)",
      "Amount Paid (CAD)",
      "Registered At",
    ];
    const rows = registrations.map((registration) => [
      registration.userName || "",
      registration.userEmail || "",
      registration.registrationType,
      registration.teamName || "N/A",
      registration.status,
      registration.paymentStatus,
      registration.paymentMethod,
      (registration.amountDueCents / 100).toFixed(2),
      ((registration.amountPaidCents ?? 0) / 100).toFixed(2),
      format(new Date(registration.createdAt), "yyyy-MM-dd HH:mm"),
    ]);

    const csvContent = [
      headers.join(","),
      ...rows.map((row) => row.map((cell) => `"${cell}"`).join(",")),
    ].join("\n");

    // Download CSV file
    const blob = new Blob([csvContent], { type: "text/csv" });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${event.slug}-registrations-${format(new Date(), "yyyy-MM-dd")}.csv`;
    a.click();
    window.URL.revokeObjectURL(url);

    toast.success("Registrations exported successfully");
  };

  return (
    <div className="container mx-auto space-y-6 p-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-4">
          <Button asChild variant="ghost" size="sm">
            <Link to="/dashboard/events">
              <ArrowLeftIcon className="mr-2 h-4 w-4" />
              Back to Events
            </Link>
          </Button>
          <div>
            <h1 className="text-2xl font-bold">Manage Event</h1>
            <p className="text-muted-foreground">{event.name}</p>
          </div>
        </div>
        <div className="flex gap-2">
          <Button asChild variant="outline">
            <Link to="/dashboard/events/$slug" params={{ slug: event.slug }}>
              View Public Page
            </Link>
          </Button>
        </div>
      </div>

      <Tabs
        value={activeTab}
        onValueChange={(value) => setActiveTab(value as ManagementTab)}
      >
        <TabsList>
          <TabsTrigger value="overview">Overview</TabsTrigger>
          <TabsTrigger value="registrations">
            Registrations
            {registrations && registrations.length > 0 && (
              <Badge variant="secondary" className="ml-2">
                {registrations.length}
              </Badge>
            )}
          </TabsTrigger>
          <TabsTrigger value="settings">Settings</TabsTrigger>
        </TabsList>

        {/* Overview Tab */}
        <TabsContent value="overview" className="space-y-6">
          <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-5">
            <Card>
              <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                <CardTitle className="text-sm font-medium">Total Registrations</CardTitle>
                <UsersIcon className="text-muted-foreground h-4 w-4" />
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold">{confirmedRegistrations.length}</div>
                <p className="text-muted-foreground text-xs">
                  {pendingRegistrations.length} pending
                </p>
              </CardContent>
            </Card>

            <Card>
              <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                <CardTitle className="text-sm font-medium">Total Revenue</CardTitle>
                <DollarSignIcon className="text-muted-foreground h-4 w-4" />
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold">
                  {"$"}
                  {(totalRevenueCents / 100).toFixed(2)}
                </div>
                <p className="text-muted-foreground text-xs">
                  From {confirmedRegistrations.length} registrations
                </p>
              </CardContent>
            </Card>

            <Card>
              <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                <CardTitle className="text-sm font-medium">
                  Outstanding E-Transfers
                </CardTitle>
                <MailIcon className="text-muted-foreground h-4 w-4" />
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold">
                  {outstandingEtransferRegistrations.length}
                </div>
                <p className="text-muted-foreground text-xs">
                  Awaiting manual confirmation
                </p>
              </CardContent>
            </Card>

            <Card>
              <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                <CardTitle className="text-sm font-medium">Available Spots</CardTitle>
                <ClockIcon className="text-muted-foreground h-4 w-4" />
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold">
                  {event.availableSpots ?? "Unlimited"}
                </div>
                <p className="text-muted-foreground text-xs">
                  {maxTeamsValue !== undefined ? `of ${maxTeamsValue} teams` : ""}
                  {maxParticipantsValue !== undefined
                    ? `${maxTeamsValue !== undefined ? " / " : "of "}${maxParticipantsValue} participants`
                    : ""}
                </p>
              </CardContent>
            </Card>

            <Card>
              <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                <CardTitle className="text-sm font-medium">Event Status</CardTitle>
                <CalendarIcon className="text-muted-foreground h-4 w-4" />
              </CardHeader>
              <CardContent>
                <Badge
                  variant={eventStatusBadge.variant}
                  className={cn("mb-1 capitalize", eventStatusBadge.className)}
                >
                  {event.status.replace("_", " ")}
                </Badge>
                <p className="text-muted-foreground text-xs">
                  {format(new Date(event.startDate), "MMM d, yyyy")}
                </p>
              </CardContent>
            </Card>
          </div>

          {/* Recent Activity */}
          <Card>
            <CardHeader>
              <CardTitle>Recent Registrations</CardTitle>
              <CardDescription>Latest registrations for your event</CardDescription>
            </CardHeader>
            <CardContent>
              {registrations && registrations.length > 0 ? (
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead>Name</TableHead>
                      <TableHead>Type</TableHead>
                      <TableHead>Status</TableHead>
                      <TableHead>Payment Status</TableHead>
                      <TableHead>Payment Method</TableHead>
                      <TableHead>Amount</TableHead>
                      <TableHead>Date</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {registrations.slice(0, 5).map((registration) => {
                      const badge = getRegistrationStatusBadge(registration.status);
                      return (
                        <TableRow key={registration.id}>
                          <TableCell className="font-medium">
                            {registration.userName || "Unknown"}
                          </TableCell>
                          <TableCell className="capitalize">
                            {registration.registrationType}
                          </TableCell>
                          <TableCell>
                            <Badge
                              variant={badge.variant}
                              className={cn("capitalize", badge.className)}
                            >
                              {registration.status}
                            </Badge>
                          </TableCell>
                          <TableCell className="capitalize">
                            {registration.paymentStatus}
                          </TableCell>
                          <TableCell className="capitalize">
                            {registration.paymentMethod}
                          </TableCell>
                          <TableCell>
                            {registration.paymentStatus === "paid"
                              ? formatCurrency(registration.amountPaidCents ?? 0)
                              : formatCurrency(registration.amountDueCents)}
                          </TableCell>
                          <TableCell>
                            {format(new Date(registration.createdAt), "MMM d")}
                          </TableCell>
                        </TableRow>
                      );
                    })}
                  </TableBody>
                </Table>
              ) : (
                <p className="text-muted-foreground py-4 text-center">
                  No registrations yet
                </p>
              )}
            </CardContent>
          </Card>

          {/* Quick Actions */}
          <Card>
            <CardHeader>
              <CardTitle>Quick Actions</CardTitle>
            </CardHeader>
            <CardContent className="flex flex-wrap gap-2">
              <Button
                variant="outline"
                onClick={handleExportRegistrations}
                disabled={!registrations || registrations.length === 0}
              >
                <DownloadIcon className="mr-2 h-4 w-4" />
                Export Registrations
              </Button>

              <Button variant="outline" disabled>
                <MailIcon className="mr-2 h-4 w-4" />
                Email Participants
              </Button>

              {event.status === "published" && (
                <Button
                  variant="outline"
                  onClick={() => handleStatusChange("registration_open")}
                >
                  Open Registration
                </Button>
              )}

              {event.status === "registration_open" && (
                <Button
                  variant="outline"
                  onClick={() => handleStatusChange("registration_closed")}
                >
                  Close Registration
                </Button>
              )}

              {event.status !== "cancelled" && (
                <AlertDialog>
                  <AlertDialogTrigger asChild>
                    <Button variant="destructive">
                      <XCircleIcon className="mr-2 h-4 w-4" />
                      Cancel Event
                    </Button>
                  </AlertDialogTrigger>
                  <AlertDialogContent>
                    <AlertDialogHeader>
                      <AlertDialogTitle>Are you sure?</AlertDialogTitle>
                      <AlertDialogDescription>
                        This will cancel the event and notify all registered participants.
                        This action cannot be undone.
                      </AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                      <AlertDialogCancel>No, keep event</AlertDialogCancel>
                      <AlertDialogAction
                        onClick={() => cancelMutation.mutate()}
                        className="bg-destructive text-destructive-foreground"
                      >
                        Yes, cancel event
                      </AlertDialogAction>
                    </AlertDialogFooter>
                  </AlertDialogContent>
                </AlertDialog>
              )}
            </CardContent>
          </Card>
        </TabsContent>

        {/* Registrations Tab */}
        <TabsContent value="registrations" className="space-y-6">
          <Card>
            <CardHeader>
              <div className="flex items-center justify-between">
                <div>
                  <CardTitle>All Registrations</CardTitle>
                  <CardDescription>
                    Manage event registrations and participants
                  </CardDescription>
                </div>
                <Button onClick={handleExportRegistrations} size="sm">
                  <DownloadIcon className="mr-2 h-4 w-4" />
                  Export CSV
                </Button>
              </div>
            </CardHeader>
            <CardContent>
              {registrationsLoading ? (
                <div className="space-y-2">
                  {["row-0", "row-1", "row-2", "row-3", "row-4"].map((rowKey) => (
                    <Skeleton key={rowKey} className="h-12 w-full" />
                  ))}
                </div>
              ) : registrations && registrations.length > 0 ? (
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead>Name</TableHead>
                      <TableHead>Email</TableHead>
                      <TableHead>Type</TableHead>
                      <TableHead>Team</TableHead>
                      <TableHead>Status</TableHead>
                      <TableHead>Payment Status</TableHead>
                      <TableHead>Payment Method</TableHead>
                      <TableHead>Amount Due</TableHead>
                      <TableHead>Amount Paid</TableHead>
                      <TableHead>Registered</TableHead>
                      <TableHead>Actions</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {registrations.map((registration) => {
                      const badge = getRegistrationStatusBadge(registration.status);
                      return (
                        <TableRow key={registration.id}>
                          <TableCell className="font-medium">
                            {registration.userName || "Unknown"}
                          </TableCell>
                          <TableCell>{registration.userEmail || "N/A"}</TableCell>
                          <TableCell className="capitalize">
                            {registration.registrationType}
                          </TableCell>
                          <TableCell>{registration.teamName || "N/A"}</TableCell>
                          <TableCell>
                            <Badge
                              variant={badge.variant}
                              className={cn("capitalize", badge.className)}
                            >
                              {registration.status}
                            </Badge>
                          </TableCell>
                          <TableCell className="capitalize">
                            {registration.paymentStatus}
                          </TableCell>
                          <TableCell className="capitalize">
                            {registration.paymentMethod}
                          </TableCell>
                          <TableCell>
                            {formatCurrency(registration.amountDueCents)}
                          </TableCell>
                          <TableCell>
                            {registration.paymentStatus === "paid"
                              ? formatCurrency(registration.amountPaidCents ?? 0)
                              : "â"}
                          </TableCell>
                          <TableCell>
                            {format(new Date(registration.createdAt), "MMM d, yyyy")}
                          </TableCell>
                          <TableCell>
                            <div className="flex flex-wrap gap-2">
                              {registration.paymentMethod === "etransfer" &&
                              registration.paymentStatus !== "paid" ? (
                                <>
                                  <Button
                                    variant="outline"
                                    size="sm"
                                    onClick={() =>
                                      markEtransferPaidMutation.mutate(registration.id)
                                    }
                                    disabled={markEtransferPaidMutation.isPending}
                                  >
                                    {markEtransferPaidMutation.isPending
                                      ? "Marking..."
                                      : "Mark Paid"}
                                  </Button>
                                  <Button
                                    variant="ghost"
                                    size="sm"
                                    onClick={() =>
                                      markEtransferReminderMutation.mutate(
                                        registration.id,
                                      )
                                    }
                                    disabled={markEtransferReminderMutation.isPending}
                                  >
                                    {markEtransferReminderMutation.isPending
                                      ? "Sending..."
                                      : "Send Reminder"}
                                  </Button>
                                </>
                              ) : null}
                              <Button variant="ghost" size="sm">
                                View
                              </Button>
                            </div>
                          </TableCell>
                        </TableRow>
                      );
                    })}
                  </TableBody>
                </Table>
              ) : (
                <div className="py-8 text-center">
                  <UsersIcon className="text-muted-foreground mx-auto h-12 w-12" />
                  <p className="text-muted-foreground mt-2">No registrations yet</p>
                </div>
              )}
            </CardContent>
          </Card>
        </TabsContent>

        {/* Settings Tab */}
        <TabsContent value="settings" className="space-y-6">
          <Card>
            <CardHeader>
              <CardTitle>Event Settings</CardTitle>
              <CardDescription>Manage event configuration and status</CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              {/* Status Management */}
              <div className="space-y-2">
                <Label>Event Status</Label>
                <div className="flex gap-2">
                  <Button
                    variant={event.status === "draft" ? "default" : "outline"}
                    size="sm"
                    onClick={() => handleStatusChange("draft")}
                  >
                    Draft
                  </Button>
                  <Button
                    variant={event.status === "published" ? "default" : "outline"}
                    size="sm"
                    onClick={() => handleStatusChange("published")}
                  >
                    Published
                  </Button>
                  <Button
                    variant={event.status === "registration_open" ? "default" : "outline"}
                    size="sm"
                    onClick={() => handleStatusChange("registration_open")}
                  >
                    Registration Open
                  </Button>
                  <Button
                    variant={
                      event.status === "registration_closed" ? "default" : "outline"
                    }
                    size="sm"
                    onClick={() => handleStatusChange("registration_closed")}
                  >
                    Registration Closed
                  </Button>
                </div>
              </div>

              <Separator />

              {/* Danger Zone */}
              {isOwner && (
                <div className="border-destructive/50 rounded-lg border p-4">
                  <h3 className="text-destructive mb-2 font-semibold">Danger Zone</h3>
                  <p className="text-muted-foreground mb-4 text-sm">
                    These actions are permanent and cannot be undone.
                  </p>
                  <AlertDialog>
                    <AlertDialogTrigger asChild>
                      <Button variant="destructive" size="sm">
                        <TrashIcon className="mr-2 h-4 w-4" />
                        Delete Event
                      </Button>
                    </AlertDialogTrigger>
                    <AlertDialogContent>
                      <AlertDialogHeader>
                        <AlertDialogTitle>Delete Event?</AlertDialogTitle>
                        <AlertDialogDescription>
                          This will permanently delete the event and all associated data.
                          This action cannot be undone.
                        </AlertDialogDescription>
                      </AlertDialogHeader>
                      <AlertDialogFooter>
                        <AlertDialogCancel>Cancel</AlertDialogCancel>
                        <AlertDialogAction className="bg-destructive text-destructive-foreground">
                          Delete Event
                        </AlertDialogAction>
                      </AlertDialogFooter>
                    </AlertDialogContent>
                  </AlertDialog>
                </div>
              )}
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
    </div>
  );
}

function ManagementSkeleton() {
  const skeletonCards = ["card-0", "card-1", "card-2", "card-3"];

  return (
    <div className="container mx-auto space-y-6 p-6">
      <div className="flex items-center justify-between">
        <Skeleton className="h-8 w-48" />
        <div className="flex gap-2">
          <Skeleton className="h-10 w-32" />
          <Skeleton className="h-10 w-32" />
        </div>
      </div>
      <div className="grid gap-6 md:grid-cols-4">
        {skeletonCards.map((cardKey) => (
          <Card key={cardKey}>
            <CardHeader>
              <Skeleton className="h-4 w-24" />
            </CardHeader>
            <CardContent>
              <Skeleton className="h-8 w-16" />
            </CardContent>
          </Card>
        ))}
      </div>
    </div>
  );
}

function getEventStatusBadge(status: EventWithDetails["status"]): {
  variant: "default" | "secondary" | "destructive" | "outline";
  className?: string;
} {
  switch (status) {
    case "draft":
      return { variant: "secondary" };
    case "published":
      return { variant: "default" };
    case "registration_open":
      return {
        variant: "outline",
        className: "border-emerald-200 bg-emerald-50 text-emerald-700",
      };
    case "registration_closed":
      return {
        variant: "outline",
        className: "border-amber-200 bg-amber-50 text-amber-700",
      };
    case "in_progress":
      return {
        variant: "outline",
        className: "border-sky-200 bg-sky-50 text-sky-700",
      };
    case "cancelled":
      return { variant: "destructive" };
    case "completed":
    default:
      return { variant: "default" };
  }
}

function getRegistrationStatusBadge(status: EventRegistrationSummary["status"]): {
  variant: "default" | "secondary" | "destructive" | "outline";
  className?: string;
} {
  switch (status) {
    case "confirmed":
      return {
        variant: "outline",
        className: "border-emerald-200 bg-emerald-50 text-emerald-700",
      };
    case "pending":
      return {
        variant: "outline",
        className: "border-amber-200 bg-amber-50 text-amber-700",
      };
    case "cancelled":
      return { variant: "destructive" };
    case "waitlisted":
      return {
        variant: "outline",
        className: "border-slate-200 bg-slate-50 text-slate-700",
      };
    default:
      return { variant: "default" };
  }
}
</file>

<file path="src/routes/dashboard/teams/$teamId.index.tsx">
import { useMutation, useQueryClient, useSuspenseQuery } from "@tanstack/react-query";
import { createFileRoute } from "@tanstack/react-router";
import { useState } from "react";
import { TypedLink as Link } from "~/components/ui/TypedLink";
import { Avatar, AvatarFallback, AvatarImage } from "~/components/ui/avatar";
import { Badge } from "~/components/ui/badge";
import { Button } from "~/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";
import {
  ArrowLeftIcon,
  CalendarIcon,
  LinkIcon,
  MapPinIcon,
  UsersIcon,
} from "~/components/ui/icons";
import { useAuth } from "~/features/auth";
import { requestTeamMembership } from "~/features/teams/teams.mutations";
import { getTeam, getTeamMembers } from "~/features/teams/teams.queries";
import { unwrapServerFnResult } from "~/lib/server/fn-utils";

export const Route = createFileRoute("/dashboard/teams/$teamId/")({
  component: TeamDetailsPage,
});

function TeamDetailsPage() {
  const { teamId } = Route.useParams();

  const { user } = useAuth();
  const queryClient = useQueryClient();
  const [requestState, setRequestState] = useState<{
    type: "success" | "error";
    message: string;
  } | null>(null);

  const { data: teamData } = useSuspenseQuery({
    queryKey: ["team", teamId],
    queryFn: async () => getTeam({ data: { teamId } }),
    // Don't pass stale data - let React Query fetch fresh data when invalidated
    // This ensures updates are reflected immediately after navigation
  });

  const { data: members } = useSuspenseQuery({
    queryKey: ["teamMembers", teamId],
    queryFn: async () => getTeamMembers({ data: { teamId } }),
    // Don't pass stale data - let React Query fetch fresh data when invalidated
  });

  const membershipRecord = members.find((member) => member.user.id === user?.id);
  const membershipStatus = membershipRecord?.member.status;
  const isActiveMember = membershipStatus === "active";
  const pendingInviteFromTeam =
    membershipStatus === "pending" && Boolean(membershipRecord?.invitedBy?.id);
  const pendingJoinRequest =
    membershipStatus === "pending" && !membershipRecord?.invitedBy?.id;

  const requestMembershipMutation = useMutation({
    mutationFn: () =>
      unwrapServerFnResult(requestTeamMembership({ data: { teamId } })),
    onSuccess: () => {
      setRequestState({
        type: "success",
        message: "Join request sent to the team captains.",
      });
      queryClient.invalidateQueries({ queryKey: ["pendingTeamInvites"] });
      queryClient.invalidateQueries({ queryKey: ["teamMembers", teamId] });
      queryClient.invalidateQueries({ queryKey: ["userTeams"] });
    },
    onError: (error) => {
      setRequestState({
        type: "error",
        message:
          error instanceof Error
            ? error.message
            : "Unable to send join request right now.",
      });
    },
  });

  const handleRequestToJoin = () => {
    setRequestState(null);
    requestMembershipMutation.mutate();
  };

  if (!teamData) {
    return <div>Team not found</div>;
  }

  const { team, memberCount } = teamData;

  return (
    <div className="container mx-auto p-6">
      <div className="mb-6">
        <Button variant="ghost" size="sm" asChild>
          <Link to="/dashboard/teams">
            <ArrowLeftIcon className="mr-2 h-4 w-4" />
            Back to Teams
          </Link>
        </Button>
      </div>

      <div className="mb-8">
        <div className="flex items-start justify-between">
          <div>
            <h1 className="text-3xl font-bold">{team.name}</h1>
            {team.city && (
              <p className="text-muted-foreground mt-1 flex items-center">
                <MapPinIcon className="mr-1 h-4 w-4" />
                {team.city}
                {team.province ? `, ${team.province}` : ""}
              </p>
            )}
          </div>
          {team.primaryColor && (
            <div className="flex gap-2">
              <div
                className="h-12 w-12 rounded-full border"
                style={{ backgroundColor: team.primaryColor }}
              />
              {team.secondaryColor && (
                <div
                  className="h-12 w-12 rounded-full border"
                  style={{ backgroundColor: team.secondaryColor }}
                />
              )}
            </div>
          )}
        </div>
      </div>

      <div className="grid gap-6 lg:grid-cols-3">
        <div className="space-y-6 lg:col-span-2">
          <Card>
            <CardHeader>
              <CardTitle>About</CardTitle>
            </CardHeader>
            <CardContent>
              {team.description ? (
                <p className="text-muted-foreground whitespace-pre-wrap">
                  {team.description}
                </p>
              ) : (
                <p className="text-muted-foreground italic">No description provided</p>
              )}

              <div className="mt-4 space-y-2">
                {team.foundedYear && (
                  <div className="flex items-center text-sm">
                    <CalendarIcon className="text-muted-foreground mr-2 h-4 w-4" />
                    Founded in {team.foundedYear}
                  </div>
                )}
                {team.website && (
                  <div className="flex items-center text-sm">
                    <LinkIcon className="text-muted-foreground mr-2 h-4 w-4" />
                    <a
                      href={team.website}
                      target="_blank"
                      rel="noopener noreferrer"
                      className="text-primary hover:underline"
                    >
                      {team.website}
                    </a>
                  </div>
                )}
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle className="flex items-center justify-between">
                Members
                <Badge variant="secondary">{memberCount}</Badge>
              </CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {members.map(({ member, user }) => (
                  <div key={member.id} className="flex items-center justify-between">
                    <div className="flex items-center gap-3">
                      <Avatar className="h-10 w-10">
                        <AvatarImage
                          src={user.image || undefined}
                          alt={user.name || ""}
                        />
                        <AvatarFallback>
                          {user.name
                            ?.split(" ")
                            .map((n) => n[0])
                            .join("")
                            .toUpperCase() || "??"}
                        </AvatarFallback>
                      </Avatar>
                      <div>
                        <p className="font-medium">{user.name || user.email}</p>
                        <div className="text-muted-foreground flex items-center gap-2 text-sm">
                          <Badge variant="outline" className="capitalize">
                            {member.role}
                          </Badge>
                          {member.status === "pending" && (
                            <Badge variant="secondary">Pending</Badge>
                          )}
                          {member.jerseyNumber && <span>#{member.jerseyNumber}</span>}
                          {member.position && <span>{member.position}</span>}
                        </div>
                      </div>
                    </div>
                    <div className="text-muted-foreground text-sm">
                      {member.status === "pending"
                        ? member.invitedAt
                          ? `Invited ${new Date(member.invitedAt).toLocaleDateString()}`
                          : member.requestedAt
                            ? `Requested ${new Date(member.requestedAt).toLocaleDateString()}`
                            : "Pending"
                        : `Joined ${new Date(member.joinedAt).toLocaleDateString()}`}
                    </div>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        </div>

        <div className="space-y-6">
          <Card>
            <CardHeader>
              <CardTitle>Team Stats</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                <div>
                  <p className="text-muted-foreground text-sm">Total Members</p>
                  <p className="text-2xl font-bold">{memberCount}</p>
                </div>
                <div>
                  <p className="text-muted-foreground text-sm">Status</p>
                  <Badge variant={team.isActive === "true" ? "default" : "secondary"}>
                    {team.isActive === "true" ? "Active" : "Inactive"}
                  </Badge>
                </div>
                <div>
                  <p className="text-muted-foreground text-sm">Created</p>
                  <p className="text-sm">
                    {new Date(team.createdAt).toLocaleDateString()}
                  </p>
                </div>
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle>Quick Actions</CardTitle>
            </CardHeader>
            <CardContent className="space-y-3">
              {requestState && (
                <div
                  className={
                    requestState.type === "success"
                      ? "border-primary/40 bg-primary/5 text-primary rounded-md border px-3 py-2 text-sm"
                      : "border-destructive/40 bg-destructive/10 text-destructive rounded-md border px-3 py-2 text-sm"
                  }
                >
                  {requestState.message}
                </div>
              )}

              {isActiveMember ? (
                <Button className="w-full" variant="outline" asChild>
                  <Link to="/dashboard/teams/$teamId/members" params={{ teamId }}>
                    <UsersIcon className="mr-2 h-4 w-4" />
                    Manage Members
                  </Link>
                </Button>
              ) : pendingInviteFromTeam ? (
                <div className="text-muted-foreground text-sm">
                  You have a pending invitation for this team. Visit the Teams dashboard
                  to accept or decline.
                </div>
              ) : pendingJoinRequest ? (
                <div className="text-muted-foreground text-sm">
                  Your join request is awaiting approval from the team captains.
                </div>
              ) : user ? (
                <Button
                  className="w-full"
                  onClick={handleRequestToJoin}
                  disabled={requestMembershipMutation.isPending}
                >
                  {requestMembershipMutation.isPending
                    ? "Sending request..."
                    : "Ask to Join"}
                </Button>
              ) : null}

              <Button asChild variant="outline" className="w-full">
                <Link to="/dashboard/teams/browse">Browse Teams</Link>
              </Button>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/routes/dashboard/teams/$teamId.tsx">
import { createFileRoute, Outlet } from "@tanstack/react-router";
import { getTeam, getTeamMembers } from "~/features/teams/teams.queries";

export const Route = createFileRoute("/dashboard/teams/$teamId")({
  loader: async ({ params }) => {
    const [teamData, members] = await Promise.all([
      getTeam({ data: { teamId: params.teamId } }),
      getTeamMembers({ data: { teamId: params.teamId } }),
    ]);

    if (!teamData) {
      throw new Error("Team not found");
    }

    return { teamData, members };
  },
  component: TeamLayout,
});

function TeamLayout() {
  return <Outlet />;
}
</file>

<file path="src/routes/dashboard/index.tsx">
import { createFileRoute } from "@tanstack/react-router";
import { SafeLink as Link } from "~/components/ui/SafeLink";
import { Button } from "~/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";
import {
  AlertCircle,
  Calendar,
  CheckCircle2,
  Clock,
  CreditCard,
  Trophy,
  User,
  UserPlus,
  Users,
  XCircle,
} from "~/components/ui/icons";
import { getUserMembershipStatus } from "~/features/membership/membership.queries";
import type { MembershipStatus } from "~/features/membership/membership.types";
import { getUserTeams, type UserTeam } from "~/features/teams/teams.queries";

export const Route = createFileRoute("/dashboard/")({
  loader: async () => {
    // Load data in parallel on the server
    const [membershipResult, userTeams] = await Promise.all([
      getUserMembershipStatus(),
      getUserTeams({ data: {} }),
    ]);

    const membershipStatus: MembershipStatus | null = membershipResult.success
      ? (membershipResult.data ?? null)
      : null;

    return {
      membershipStatus,
      userTeams: userTeams || [],
    };
  },
  component: DashboardIndex,
});

function DashboardIndex() {
  const { user } = Route.useRouteContext();
  const { membershipStatus, userTeams } = Route.useLoaderData();

  const teamCount = (userTeams as UserTeam[]).length;
  const upcomingEventsCount = 0;

  return (
    <div className="container mx-auto space-y-8 p-6">
      {/* Welcome Section */}
      <div>
        <h1 className="text-3xl font-bold tracking-tight">
          Welcome back, {user?.name || "Player"}!
        </h1>
        <p className="text-muted-foreground mt-2">
          Here's an overview of your Quadball Canada account
        </p>
      </div>

      {/* Stats Cards */}
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
        {/* Membership Status Card */}
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Membership Status</CardTitle>
            {membershipStatus?.hasMembership ? (
              <CheckCircle2 className="h-4 w-4 text-green-600" />
            ) : (
              <XCircle className="text-muted-foreground h-4 w-4" />
            )}
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {membershipStatus?.hasMembership ? "Active" : "Inactive"}
            </div>
            {membershipStatus?.hasMembership && membershipStatus.daysRemaining ? (
              <p className="text-muted-foreground mt-1 text-xs">
                <Clock className="mr-1 inline h-3 w-3" />
                {membershipStatus.daysRemaining} days remaining
              </p>
            ) : null}
            {!membershipStatus?.hasMembership && (
              <p className="text-muted-foreground mt-1 text-xs">
                <AlertCircle className="mr-1 inline h-3 w-3" />
                No active membership
              </p>
            )}
          </CardContent>
        </Card>

        {/* Teams Card */}
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">My Teams</CardTitle>
            <Users className="text-muted-foreground h-4 w-4" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{teamCount}</div>
            <p className="text-muted-foreground mt-1 text-xs">
              {teamCount === 0
                ? "Not on any teams yet"
                : `Active team${teamCount !== 1 ? "s" : ""}`}
            </p>
          </CardContent>
        </Card>

        {/* Upcoming Events Card */}
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Upcoming Events</CardTitle>
            <Calendar className="text-muted-foreground h-4 w-4" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{upcomingEventsCount}</div>
            <p className="text-muted-foreground mt-1 text-xs">
              {upcomingEventsCount === 0 ? "No events scheduled" : "Events this season"}
            </p>
          </CardContent>
        </Card>
      </div>

      {/* Quick Actions */}
      <div>
        <h2 className="mb-4 text-lg font-semibold">Quick Actions</h2>
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
          {/* Complete Profile - always shown since profile is complete to access dashboard */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <User className="h-5 w-5" />
                View Profile
              </CardTitle>
              <CardDescription>
                Review and update your profile information
              </CardDescription>
            </CardHeader>
            <CardContent>
              <Button asChild className="w-full">
                <Link to="/dashboard/profile">View Profile</Link>
              </Button>
            </CardContent>
          </Card>

          {/* Buy/Renew Membership */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <CreditCard className="h-5 w-5" />
                {membershipStatus?.hasMembership ? "Renew Membership" : "Buy Membership"}
              </CardTitle>
              <CardDescription>
                {membershipStatus?.hasMembership
                  ? "Extend your membership for another year"
                  : "Get your annual player membership"}
              </CardDescription>
            </CardHeader>
            <CardContent>
              <Button asChild className="w-full">
                <Link to="/dashboard/membership">
                  {membershipStatus?.hasMembership ? "Renew Now" : "Get Membership"}
                </Link>
              </Button>
            </CardContent>
          </Card>

          {/* Join Team */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <UserPlus className="h-5 w-5" />
                Join a Team
              </CardTitle>
              <CardDescription>
                Find and join a team to compete in tournaments
              </CardDescription>
            </CardHeader>
            <CardContent>
              <Button asChild className="w-full" variant="outline">
                <Link to="/dashboard/teams/browse">Browse Teams</Link>
              </Button>
            </CardContent>
          </Card>
        </div>
      </div>

      {/* Recent Activity - Placeholder */}
      <div>
        <h2 className="mb-4 text-lg font-semibold">Recent Activity</h2>
        <Card>
          <CardContent className="pt-6">
            <div className="text-muted-foreground flex items-center justify-center py-8">
              <Trophy className="mr-3 h-12 w-12 opacity-20" />
              <div>
                <p className="text-sm font-medium">No recent activity</p>
                <p className="text-xs">Your recent activities will appear here</p>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
</file>

<file path="src/features/auth/auth.queries.ts">
import { queryOptions } from "@tanstack/react-query";
import { createServerFn } from "@tanstack/react-start";
import type { User } from "~/lib/auth/types";

/**
 * Server function to get the current user with all custom fields
 */
export const getCurrentUser = createServerFn({ method: "GET" }).handler(
  async (): Promise<User | null> => {
    // Import server-only modules inside the handler
    const { getDb } = await import("~/db/server-helpers");
    const { getAuth } = await import("~/lib/auth/server-helpers");
    const auth = await getAuth();
    const { getRequest } = await import("@tanstack/react-start/server");
    const { headers } = getRequest();

    const session = await auth.api.getSession({ headers });

    if (!session?.user) {
      return null;
    }

    // Import schema and ORM inside the handler
    const { eq } = await import("drizzle-orm");
    const { user } = await import("~/db/schema");

    // Fetch the full user data from the database
    const db = await getDb();
    const dbUser = await db
      .select()
      .from(user)
      .where(eq(user.id, session.user.id))
      .limit(1);

    if (!dbUser[0]) {
      return null;
    }

    // Fetch user roles
    const { PermissionService } = await import("~/features/roles/permission.service");
    const userRoles = await PermissionService.getUserRoles(session.user.id);

    // Map the database user to our extended User type
    return {
      ...session.user,
      profileComplete: dbUser[0].profileComplete,
      dateOfBirth: dbUser[0].dateOfBirth,
      emergencyContact: dbUser[0].emergencyContact,
      gender: dbUser[0].gender,
      pronouns: dbUser[0].pronouns,
      phone: dbUser[0].phone,
      privacySettings: dbUser[0].privacySettings,
      profileVersion: dbUser[0].profileVersion,
      profileUpdatedAt: dbUser[0].profileUpdatedAt,
      roles: userRoles,
    };
  },
);

export type AuthQueryResult = Awaited<ReturnType<typeof getCurrentUser>>;

export const authQueryKey = ["user"] as const;

export const authQueryOptions = () =>
  queryOptions({
    queryKey: authQueryKey,
    queryFn: ({ signal }) => getCurrentUser({ signal }),
  });
</file>

<file path="src/features/events/events.types.ts">
import type { z } from "zod";
import type { Event, EventRegistration } from "~/db/schema";
import type { createEventInputSchema } from "~/db/schema/events.schema";
import type {
  EventAmenities,
  EventDivisions,
  EventMetadata,
  EventPaymentMetadata,
  EventRegistrationRoster,
  EventRequirements,
  EventRules,
  EventSchedule,
} from "./events.db-types";

// Input types
export type CreateEventInput = z.infer<typeof createEventInputSchema>;

export type UpdateEventInput = Partial<CreateEventInput> & {
  status?: EventStatus;
};

export type EventFilters = {
  status?: Event["status"] | Event["status"][];
  type?: Event["type"] | Event["type"][];
  organizerId?: string;
  startDateFrom?: Date;
  startDateTo?: Date;
  city?: string;
  province?: string;
};

export type EventRegistrationInput = {
  eventId: string;
  teamId?: string;
  division?: string;
  notes?: string;
  roster?: {
    userId: string;
    role: string;
  }[];
};

// Response types
export interface EventWithDetails
  extends Omit<
    Event,
    "rules" | "schedule" | "divisions" | "amenities" | "requirements" | "metadata"
  > {
  rules: EventRules;
  schedule: EventSchedule;
  divisions: EventDivisions;
  amenities: EventAmenities;
  requirements: EventRequirements;
  metadata: EventMetadata;
  organizer: {
    id: string;
    name: string;
    email: string;
  };
  registrationCount: number;
  isRegistrationOpen: boolean;
  availableSpots: number | undefined;
}

export interface EventRegistrationWithDetails
  extends Omit<EventRegistration, "roster" | "paymentMetadata"> {
  roster: EventRegistrationRoster;
  paymentMetadata: EventPaymentMetadata | null;
  event: EventWithDetails;
  team?: {
    id: string;
    name: string;
    slug: string;
  };
  user: {
    id: string;
    name: string;
    email: string;
  };
}

export type EventPaymentMethod = EventRegistration["paymentMethod"];
export type EventPaymentStatus = EventRegistration["paymentStatus"];

export type EventRegistrationPaymentInfo =
  | {
      method: "square";
      checkoutUrl: string;
      sessionId: string;
    }
  | {
      method: "etransfer";
      instructions?: string | null;
      recipient?: string | null;
    }
  | {
      method: "free";
    };

export interface EventRegistrationResultPayload {
  registration: EventRegistrationWithDetails;
  payment?: EventRegistrationPaymentInfo;
}

export type CancelEventErrorCode =
  | "REFUND_FAILED"
  | "NO_PAYMENT_SESSION"
  | "NOT_PAID"
  | "UNAUTHORIZED";

export interface CancelEventResult {
  eventId: string;
  affected: {
    totalRegistrations: number;
    cancelled: number;
    alreadyCancelled: number;
    squareRefunded: number;
    etransferMarkedForRefund: number;
    freeOrUnpaid: number;
  };
  errors: Array<{
    registrationId: string;
    code: CancelEventErrorCode;
    message: string;
    paymentId?: string;
  }>;
}

// Operation result types
export type EventOperationResult<T = Event> =
  | { success: true; data: T }
  | { success: false; errors: EventError[] };

export type EventError = {
  code: EventErrorCode;
  message: string;
  field?: string;
};

export type EventErrorCode =
  | "VALIDATION_ERROR"
  | "NOT_FOUND"
  | "DUPLICATE_SLUG"
  | "UNAUTHORIZED"
  | "FORBIDDEN"
  | "REGISTRATION_CLOSED"
  | "EVENT_FULL"
  | "ALREADY_REGISTERED"
  | "INVALID_DATES"
  | "DATABASE_ERROR";

// Utility types
export type EventStatus = Event["status"];
export type EventType = Event["type"];
export type RegistrationType = Event["registrationType"];

// Pagination
export type EventListResult = {
  events: EventWithDetails[];
  totalCount: number;
  pageInfo: {
    currentPage: number;
    pageSize: number;
    totalPages: number;
    hasNextPage: boolean;
    hasPreviousPage: boolean;
  };
};
</file>

<file path="src/features/membership/membership.admin-queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { z } from "zod";
import { zod$ } from "~/lib/server/fn-utils";
import type { MembershipOperationResult } from "./membership.types";

const getAllMembershipsSchema = z.object({
  status: z.enum(["all", "active", "expired", "cancelled"]).optional().prefault("all"),
  limit: z.number().optional().prefault(100),
  offset: z.number().optional().prefault(0),
});

export interface MembershipReportRow {
  id: string;
  userName: string;
  userEmail: string;
  membershipType: string;
  startDate: string;
  endDate: string;
  status: "active" | "expired" | "cancelled";
  priceCents: number;
  paymentId: string | null;
  createdAt: Date;
}

/**
 * Admin-only: Get all memberships with user information
 */
export const getAllMemberships = createServerFn({ method: "GET" })
  .inputValidator(zod$(getAllMembershipsSchema))
  .handler(
    async ({ data }): Promise<MembershipOperationResult<MembershipReportRow[]>> => {
      try {
        // Import server-only modules inside the handler
        const [{ getDb }, { getAuth }] = await Promise.all([
          import("~/db/server-helpers"),
          import("~/lib/auth/server-helpers"),
        ]);

        const auth = await getAuth();
        const { getRequest } = await import("@tanstack/react-start/server");
        const { headers } = getRequest();
        const session = await auth.api.getSession({ headers });

        if (!session?.user?.id) {
          return {
            success: false,
            errors: [
              {
                code: "VALIDATION_ERROR",
                message: "User not authenticated",
              },
            ],
          };
        }

        // Check admin access
        const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
        await requireAdmin(session.user.id);

        // Import database dependencies inside handler
        const { and, eq, sql } = await import("drizzle-orm");
        const { memberships, membershipTypes, user } = await import("~/db/schema");

        const db = await getDb();

        // Build where conditions
        const conditions = [];
        if (data.status !== "all") {
          conditions.push(eq(memberships.status, data.status));
        }
        const query = db
          .select({
            id: memberships.id,
            userName: user.name,
            userEmail: user.email,
            membershipType: membershipTypes.name,
            startDate: memberships.startDate,
            endDate: memberships.endDate,
            status: memberships.status,
            priceCents: membershipTypes.priceCents,
            paymentId: memberships.paymentId,
            createdAt: memberships.createdAt,
          })
          .from(memberships)
          .innerJoin(user, eq(memberships.userId, user.id))
          .innerJoin(
            membershipTypes,
            eq(memberships.membershipTypeId, membershipTypes.id),
          )
          .orderBy(sql`${memberships.createdAt} DESC`)
          .limit(data.limit)
          .offset(data.offset);

        if (conditions.length > 0) {
          const results = await query.where(and(...conditions));
          return {
            success: true,
            data: results,
          };
        }

        const results = await query;
        return {
          success: true,
          data: results,
        };
      } catch (error) {
        console.error("Error fetching memberships:", error);

        if ((error as Error).message?.includes("Admin access required")) {
          return {
            success: false,
            errors: [
              {
                code: "VALIDATION_ERROR",
                message: "Admin access required",
              },
            ],
          };
        }

        return {
          success: false,
          errors: [
            {
              code: "DATABASE_ERROR",
              message: "Failed to fetch memberships",
            },
          ],
        };
      }
    },
  );
</file>

<file path="src/features/profile/components/complete-profile-form-simple.tsx">
import { useForm } from "@tanstack/react-form";
import { useQueryClient } from "@tanstack/react-query";
import { useRouter } from "@tanstack/react-router";
import { useState } from "react";
import { FormSubmitButton } from "~/components/form-fields/FormSubmitButton";
import { ValidatedCheckbox } from "~/components/form-fields/ValidatedCheckbox";
import { ValidatedDatePicker } from "~/components/form-fields/ValidatedDatePicker";
import { ValidatedInput } from "~/components/form-fields/ValidatedInput";
import { ValidatedSelect } from "~/components/form-fields/ValidatedSelect";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";
import { Separator } from "~/components/ui/separator";
import { authQueryKey } from "~/features/auth/auth.queries";
import { unwrapServerFnResult } from "~/lib/server/fn-utils";
import { cn } from "~/shared/lib/utils";
import { completeUserProfile } from "../profile.mutations";
import type { ProfileInputType } from "../profile.schemas";
import type { ProfileInput, ProfileOperationResult } from "../profile.types";

const STEPS = [
  {
    id: "personal",
    title: "Personal Information",
    description: "Basic information about you",
  },
  {
    id: "emergency",
    title: "Emergency Contact",
    description: "Who should we contact in case of emergency",
  },
  {
    id: "privacy",
    title: "Privacy Settings",
    description: "Control what information is visible to others",
  },
] as const;

type StepId = (typeof STEPS)[number]["id"];

export function CompleteProfileForm() {
  const router = useRouter();
  const queryClient = useQueryClient();
  const [currentStep, setCurrentStep] = useState<StepId>("personal");
  const [error, setError] = useState<string | null>(null);

  const form = useForm({
    defaultValues: {
      dateOfBirth: new Date(),
      gender: "",
      pronouns: "",
      phone: "",
      emergencyContact: {
        name: "",
        relationship: "",
        phone: "",
        email: "",
      },
      privacySettings: {
        showEmail: false,
        showPhone: false,
        showBirthYear: false,
        allowTeamInvitations: true,
      },
    } as ProfileInputType,
    onSubmit: async ({ value }) => {
      if (currentStepIndex < STEPS.length - 1) {
        goToNextStep();
        return;
      }

      setError(null);

      try {
        // Build profile input with only defined values
        const dataToSubmit: ProfileInput = {
          dateOfBirth: value.dateOfBirth,
        };

        // Add optional fields only if they have values
        if (value.gender) dataToSubmit.gender = value.gender;
        if (value.pronouns) dataToSubmit.pronouns = value.pronouns;
        if (value.phone) dataToSubmit.phone = value.phone;
        if (value.privacySettings) dataToSubmit.privacySettings = value.privacySettings;

        // Only include emergency contact if it has meaningful data
        if (
          value.emergencyContact &&
          (value.emergencyContact.name ||
            value.emergencyContact.relationship ||
            value.emergencyContact.phone ||
            value.emergencyContact.email)
        ) {
          // Build emergency contact with required fields
          const emergencyContact: ProfileInput["emergencyContact"] = {
            name: value.emergencyContact.name || "",
            relationship: value.emergencyContact.relationship || "",
          };
          if (value.emergencyContact.phone)
            emergencyContact.phone = value.emergencyContact.phone;
          if (value.emergencyContact.email)
            emergencyContact.email = value.emergencyContact.email;

          dataToSubmit.emergencyContact = emergencyContact;
        }

        const result = (await unwrapServerFnResult(
          completeUserProfile({
            data: dataToSubmit,
          }),
        )) as ProfileOperationResult;

        if (result.success) {
          await queryClient.invalidateQueries({ queryKey: authQueryKey });
          router.navigate({ to: "/dashboard" });
        } else {
          const errorMessage = result.errors?.[0]?.message || "Failed to save profile";
          setError(errorMessage);
        }
      } catch (err) {
        setError("An unexpected error occurred. Please try again.");
        console.error("Profile submission error:", err);
      }
    },
  });

  const currentStepIndex = STEPS.findIndex((step) => step.id === currentStep);

  // Check if emergency contact has any data
  const emergencyContact = form.getFieldValue("emergencyContact");
  const hasEmergencyContactData =
    emergencyContact &&
    (emergencyContact.name ||
      emergencyContact.relationship ||
      emergencyContact.phone ||
      emergencyContact.email);

  const goToStep = (stepId: StepId) => setCurrentStep(stepId);
  const goToNextStep = () => {
    const nextIndex = currentStepIndex + 1;
    if (nextIndex < STEPS.length) {
      setCurrentStep(STEPS[nextIndex].id);
    }
  };
  const goToPreviousStep = () => {
    const prevIndex = currentStepIndex - 1;
    if (prevIndex >= 0) {
      setCurrentStep(STEPS[prevIndex].id);
    }
  };

  const isLastStep = currentStepIndex === STEPS.length - 1;

  // Gender options for select component
  const genderOptions = [
    { value: "male", label: "Male" },
    { value: "female", label: "Female" },
    { value: "non-binary", label: "Non-binary" },
    { value: "other", label: "Other" },
    { value: "prefer-not-to-say", label: "Prefer not to say" },
  ];

  return (
    <div className="space-y-6">
      {/* Step indicators */}
      <div className="flex justify-between">
        {STEPS.map((step, index) => (
          <button
            key={step.id}
            onClick={() => goToStep(step.id)}
            className={cn(
              "flex items-center gap-2 text-sm font-medium transition-colors",
              index <= currentStepIndex ? "text-primary" : "text-muted-foreground",
              "hover:text-primary",
            )}
            type="button"
          >
            <div
              className={cn(
                "flex h-8 w-8 items-center justify-center rounded-full border-2 transition-colors",
                index <= currentStepIndex
                  ? "border-primary bg-primary text-primary-foreground"
                  : "border-muted-foreground",
              )}
            >
              {index + 1}
            </div>
            <span className="hidden sm:inline">{step.title}</span>
          </button>
        ))}
      </div>

      {error && (
        <div className="bg-destructive/10 text-destructive rounded-md p-3 text-sm">
          {error}
        </div>
      )}

      <form
        onSubmit={(e) => {
          e.preventDefault();
          e.stopPropagation();
          form.handleSubmit();
        }}
      >
        <Card>
          <CardHeader>
            <CardTitle>{STEPS[currentStepIndex].title}</CardTitle>
            <CardDescription>{STEPS[currentStepIndex].description}</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            {/* Personal Information Step */}
            {currentStep === "personal" && (
              <>
                <form.Field
                  name="dateOfBirth"
                  validators={{
                    onChange: ({ value }) => {
                      if (!value) return "Date of birth is required";
                      // Value is a YYYY-MM-DD string from ValidatedDatePicker
                      const birthDate = new Date(value);
                      const age = new Date().getFullYear() - birthDate.getFullYear();
                      if (age < 13 || age > 120) {
                        return "Age must be between 13 and 120 years";
                      }
                      return undefined;
                    },
                  }}
                >
                  {(field) => (
                    <ValidatedDatePicker
                      field={field}
                      label="Date of Birth"
                      minAge={13}
                      maxAge={120}
                    />
                  )}
                </form.Field>

                <form.Field name="gender">
                  {(field) => (
                    <ValidatedSelect
                      field={field}
                      label="Gender (optional)"
                      options={genderOptions}
                      placeholderText="Select gender"
                    />
                  )}
                </form.Field>

                <form.Field name="pronouns">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Pronouns (optional)"
                      placeholder="e.g., they/them, she/her, he/him"
                    />
                  )}
                </form.Field>

                <form.Field name="phone">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Phone Number (optional)"
                      type="tel"
                      placeholder="+1 (555) 000-0000"
                    />
                  )}
                </form.Field>
              </>
            )}

            {/* Emergency Contact Step */}
            {currentStep === "emergency" && (
              <>
                <p className="text-muted-foreground mb-4 text-sm">
                  Emergency contact information is optional but recommended for your
                  safety.
                </p>

                <form.Field name="emergencyContact.name">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Emergency Contact Name (optional)"
                      placeholder="Full name"
                    />
                  )}
                </form.Field>

                <form.Field name="emergencyContact.relationship">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Relationship"
                      placeholder="e.g., Parent, Spouse, Friend"
                      disabled={!hasEmergencyContactData}
                    />
                  )}
                </form.Field>

                <form.Field name="emergencyContact.phone">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Emergency Contact Phone"
                      type="tel"
                      placeholder="+1 (555) 000-0000"
                      disabled={!hasEmergencyContactData}
                    />
                  )}
                </form.Field>

                <form.Field name="emergencyContact.email">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Emergency Contact Email"
                      type="email"
                      placeholder="email@example.com"
                      disabled={!hasEmergencyContactData}
                    />
                  )}
                </form.Field>

                {hasEmergencyContactData && (
                  <p className="text-muted-foreground text-sm">
                    If providing emergency contact, please include at least one contact
                    method (phone or email).
                  </p>
                )}
              </>
            )}

            {/* Privacy Settings Step */}
            {currentStep === "privacy" && (
              <>
                <div className="space-y-4">
                  <p className="text-muted-foreground text-sm">
                    Choose what information other members can see about you.
                  </p>

                  <Separator />

                  <form.Field name="privacySettings.showEmail">
                    {(field) => (
                      <ValidatedCheckbox
                        field={field}
                        label="Show my email address to team members"
                      />
                    )}
                  </form.Field>

                  <form.Field name="privacySettings.showPhone">
                    {(field) => (
                      <ValidatedCheckbox
                        field={field}
                        label="Show my phone number to team members"
                      />
                    )}
                  </form.Field>

                  <form.Field name="privacySettings.showBirthYear">
                    {(field) => (
                      <ValidatedCheckbox
                        field={field}
                        label="Show my birth year on my profile"
                      />
                    )}
                  </form.Field>

                  <form.Field name="privacySettings.allowTeamInvitations">
                    {(field) => (
                      <ValidatedCheckbox
                        field={field}
                        label="Allow team captains to send me invitations"
                      />
                    )}
                  </form.Field>
                </div>
              </>
            )}

            <Separator />

            {/* Navigation buttons */}
            <div className="flex justify-between">
              <button
                type="button"
                onClick={goToPreviousStep}
                disabled={currentStepIndex === 0}
                className={cn(
                  "rounded-md px-4 py-2 text-sm font-medium transition-colors",
                  currentStepIndex === 0
                    ? "invisible"
                    : "border-input bg-background hover:bg-accent hover:text-accent-foreground border",
                )}
              >
                Previous
              </button>

              {isLastStep ? (
                <FormSubmitButton
                  isSubmitting={form.state.isSubmitting}
                  loadingText="Completing Profile..."
                >
                  Complete Profile
                </FormSubmitButton>
              ) : (
                <button
                  type="submit"
                  className="text-primary-foreground bg-primary hover:bg-primary/90 rounded-md px-4 py-2 text-sm font-medium transition-colors"
                >
                  Next
                </button>
              )}
            </div>
          </CardContent>
        </Card>
      </form>
    </div>
  );
}
</file>

<file path="src/routes/dashboard/teams/$teamId.manage.tsx">
import { useForm } from "@tanstack/react-form";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { createFileRoute, Link, useNavigate } from "@tanstack/react-router";
import { useState } from "react";
import { ValidatedColorPicker } from "~/components/form-fields/ValidatedColorPicker";
import { ValidatedCombobox } from "~/components/form-fields/ValidatedCombobox";
import { ValidatedInput } from "~/components/form-fields/ValidatedInput";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "~/components/ui/alert-dialog";
import { Button } from "~/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";
import { AlertCircle, ArrowLeftIcon } from "~/components/ui/icons";
import { Label } from "~/components/ui/label";
import { Textarea } from "~/components/ui/textarea";
import { deactivateTeam, updateTeam } from "~/features/teams/teams.mutations";
import { getTeam } from "~/features/teams/teams.queries";
import type { UpdateTeamInput } from "~/features/teams/teams.schemas";
import { unwrapServerFnResult } from "~/lib/server/fn-utils";

// Canadian provinces and territories
const PROVINCES = [
  { value: "AB", label: "Alberta" },
  { value: "BC", label: "British Columbia" },
  { value: "MB", label: "Manitoba" },
  { value: "NB", label: "New Brunswick" },
  { value: "NL", label: "Newfoundland and Labrador" },
  { value: "NT", label: "Northwest Territories" },
  { value: "NS", label: "Nova Scotia" },
  { value: "NU", label: "Nunavut" },
  { value: "ON", label: "Ontario" },
  { value: "PE", label: "Prince Edward Island" },
  { value: "QC", label: "Quebec" },
  { value: "SK", label: "Saskatchewan" },
  { value: "YT", label: "Yukon" },
];

export const Route = createFileRoute("/dashboard/teams/$teamId/manage")({
  loader: async ({ params }) => {
    const teamData = await getTeam({ data: { teamId: params.teamId } });
    if (!teamData) throw new Error("Team not found");
    return { teamData };
  },
  component: ManageTeamPage,
});

function ManageTeamPage() {
  const navigate = useNavigate();
  const queryClient = useQueryClient();
  const { teamId } = Route.useParams();
  const { teamData } = Route.useLoaderData();
  console.log("ManageTeamPage - teamData:", teamData);
  const { team } = teamData || {};
  const [serverError, setServerError] = useState<string | null>(null);

  const updateTeamMutation = useMutation({
    mutationFn: (payload: UpdateTeamInput) =>
      unwrapServerFnResult(updateTeam({ data: payload })),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["team", teamId] });
      navigate({ to: "/dashboard/teams/$teamId", params: { teamId } });
    },
    onError: (error) => {
      setServerError(error.message || "Failed to update team");
    },
  });

  const deactivateTeamMutation = useMutation({
    mutationFn: (teamId: string) =>
      unwrapServerFnResult(deactivateTeam({ data: { teamId } })),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["userTeams"] });
      navigate({ to: "/dashboard/teams" });
    },
    onError: (error) => {
      setServerError(error.message || "Failed to deactivate team");
    },
  });

  const form = useForm({
    defaultValues: {
      name: team?.name || "",
      description: team?.description || "",
      city: team?.city || "",
      province: team?.province || "",
      primaryColor: team?.primaryColor || "#000000",
      secondaryColor: team?.secondaryColor || "#ffffff",
      foundedYear: team?.foundedYear || new Date().getFullYear().toString(),
      website: team?.website || "",
    },
    onSubmit: async ({ value }) => {
      setServerError(null);
      await updateTeamMutation.mutateAsync({
        teamId,
        data: {
          ...value,
          description: value.description || undefined,
          city: value.city || undefined,
          province: value.province || undefined,
          website: value.website || undefined,
        },
      });
    },
  });

  const handleDeactivate = async () => {
    await deactivateTeamMutation.mutateAsync(teamId);
  };

  if (!team) {
    return <div>Team not found (teamData: {JSON.stringify(teamData)})</div>;
  }

  return (
    <div className="container mx-auto max-w-2xl p-6">
      <div className="mb-6">
        <Button variant="ghost" size="sm" asChild>
          <Link to="/dashboard/teams/$teamId" params={{ teamId }}>
            <ArrowLeftIcon className="mr-2 h-4 w-4" />
            Back to Team
          </Link>
        </Button>
      </div>
      <Card>
        <CardHeader>
          <CardTitle>Manage Team Settings</CardTitle>
          <CardDescription>Update your team profile and settings</CardDescription>
        </CardHeader>
        <CardContent>
          <form
            onSubmit={(e) => {
              e.preventDefault();
              e.stopPropagation();
              form.handleSubmit();
            }}
            className="space-y-6"
          >
            {serverError && (
              <div className="bg-destructive/10 text-destructive rounded-md p-3 text-sm">
                {serverError}
              </div>
            )}

            <div className="grid gap-4">
              <form.Field
                name="name"
                validators={{
                  onChange: ({ value }) => (!value ? "Team name is required" : undefined),
                }}
              >
                {(field) => (
                  <ValidatedInput
                    field={field}
                    label="Team Name"
                    placeholder="UVic Valkyries"
                  />
                )}
              </form.Field>

              <form.Field name="description">
                {(field) => (
                  <div className="space-y-2">
                    <Label htmlFor={field.name}>Description</Label>
                    <Textarea
                      id={field.name}
                      name={field.name}
                      value={field.state.value ?? ""}
                      onChange={(e) => field.handleChange(e.target.value)}
                      onBlur={field.handleBlur}
                      placeholder="Tell us about your team..."
                      rows={4}
                    />
                  </div>
                )}
              </form.Field>

              <div className="grid grid-cols-2 gap-4">
                <form.Field name="city">
                  {(field) => (
                    <ValidatedInput field={field} label="City" placeholder="Victoria" />
                  )}
                </form.Field>

                <form.Field name="province">
                  {(field) => (
                    <ValidatedCombobox
                      field={field}
                      label="Province"
                      placeholder="Select a province"
                      options={PROVINCES}
                      searchPlaceholder="Search provinces..."
                      emptyText="No province found."
                    />
                  )}
                </form.Field>
              </div>

              <div className="grid grid-cols-2 gap-4">
                <form.Field name="primaryColor">
                  {(field) => (
                    <ValidatedColorPicker
                      field={field}
                      label="Primary Color"
                      description="Used for jerseys, branding, and team identity"
                    />
                  )}
                </form.Field>

                <form.Field name="secondaryColor">
                  {(field) => (
                    <ValidatedColorPicker
                      field={field}
                      label="Secondary Color"
                      description="Accent color for team materials and website"
                    />
                  )}
                </form.Field>
              </div>

              <div className="grid grid-cols-2 gap-4">
                <form.Field
                  name="foundedYear"
                  validators={{
                    onChange: ({ value }) => {
                      if (
                        value &&
                        (!/^\d{4}$/.test(value) ||
                          parseInt(value) > new Date().getFullYear())
                      ) {
                        return "Enter a valid year";
                      }
                      return undefined;
                    },
                  }}
                >
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Founded Year"
                      placeholder="2010"
                      maxLength={4}
                    />
                  )}
                </form.Field>

                <form.Field
                  name="website"
                  validators={{
                    onChange: ({ value }) => {
                      if (value && !value.startsWith("http")) {
                        return "Website must start with http:// or https://";
                      }
                      return undefined;
                    },
                  }}
                >
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Website"
                      placeholder="https://uvicvalkyries.com"
                      type="url"
                    />
                  )}
                </form.Field>
              </div>
            </div>

            <div className="flex justify-between">
              <AlertDialog>
                <AlertDialogTrigger asChild>
                  <Button variant="destructive" type="button">
                    <AlertCircle className="mr-2 h-4 w-4" />
                    Deactivate Team
                  </Button>
                </AlertDialogTrigger>
                <AlertDialogContent>
                  <AlertDialogHeader>
                    <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
                    <AlertDialogDescription>
                      This will deactivate your team and hide it from the member
                      directory. You can reactivate it later, but all members will need to
                      rejoin.
                    </AlertDialogDescription>
                  </AlertDialogHeader>
                  <AlertDialogFooter>
                    <AlertDialogCancel>Cancel</AlertDialogCancel>
                    <AlertDialogAction onClick={handleDeactivate}>
                      Deactivate Team
                    </AlertDialogAction>
                  </AlertDialogFooter>
                </AlertDialogContent>
              </AlertDialog>

              <div className="flex gap-4">
                <Button variant="outline" asChild>
                  <Link to="/dashboard/teams/$teamId" params={{ teamId }}>
                    Cancel
                  </Link>
                </Button>
                <Button type="submit" disabled={form.state.isSubmitting}>
                  {form.state.isSubmitting ? "Saving..." : "Save Changes"}
                </Button>
              </div>
            </div>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/routes/dashboard/teams/$teamId.members.tsx">
import { useForm } from "@tanstack/react-form";
import { useMutation, useQueryClient, useSuspenseQuery } from "@tanstack/react-query";
import { createFileRoute, Link } from "@tanstack/react-router";
import { formatDistanceToNow } from "date-fns";
import { useState } from "react";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "~/components/ui/alert-dialog";
import { Avatar, AvatarFallback, AvatarImage } from "~/components/ui/avatar";
import { Badge } from "~/components/ui/badge";
import { Button } from "~/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";
import { ArrowLeftIcon, UserPlus, XCircle } from "~/components/ui/icons";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";
import type { TeamMemberRole } from "~/db/schema";
import {
  addTeamMember,
  removeTeamMember,
  updateTeamMember,
} from "~/features/teams/teams.mutations";
import type {
  TeamMemberDetails,
  TeamWithMemberCount,
} from "~/features/teams/teams.queries";
import { getTeam, getTeamMembers } from "~/features/teams/teams.queries";
import type {
  AddTeamMemberInput,
  RemoveTeamMemberInput,
  UpdateTeamMemberInput,
} from "~/features/teams/teams.schemas";
import { unwrapServerFnResult } from "~/lib/server/fn-utils";

type TeamMembersLoaderData = {
  team: NonNullable<TeamWithMemberCount>;
  members: TeamMemberDetails[];
};

export const Route = createFileRoute("/dashboard/teams/$teamId/members")({
  loader: async ({ params }) => {
    const [team, members] = await Promise.all([
      getTeam({ data: { teamId: params.teamId } }),
      getTeamMembers({ data: { teamId: params.teamId } }),
    ]);
    if (!team) throw new Error("Team not found");
    return { team, members } satisfies TeamMembersLoaderData;
  },
  component: TeamMembersPage,
});

function TeamMembersPage() {
  const { teamId } = Route.useParams();
  const { team: teamData, members: initialMembers } = Route.useLoaderData();
  const { team } = teamData;
  const queryClient = useQueryClient();
  const [showAddMember, setShowAddMember] = useState(false);
  const [serverError, setServerError] = useState<string | null>(null);

  const { data: members } = useSuspenseQuery<TeamMemberDetails[]>({
    queryKey: ["teamMembers", teamId],
    queryFn: async () => getTeamMembers({ data: { teamId } }),
    initialData: initialMembers,
  });

  const pendingMembers = members.filter((entry) => entry.member.status === "pending");

  const addMemberMutation = useMutation({
    mutationFn: (payload: AddTeamMemberInput) =>
      unwrapServerFnResult(addTeamMember({ data: payload })),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["teamMembers", teamId] });
      setShowAddMember(false);
      form.reset();
    },
    onError: (error) => {
      setServerError(error.message || "Failed to add member");
    },
  });

  const updateMemberMutation = useMutation({
    mutationFn: (payload: UpdateTeamMemberInput) =>
      unwrapServerFnResult(updateTeamMember({ data: payload })),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["teamMembers", teamId] });
    },
  });

  const removeMemberMutation = useMutation({
    mutationFn: (payload: RemoveTeamMemberInput) =>
      unwrapServerFnResult(removeTeamMember({ data: payload })),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["teamMembers", teamId] });
    },
  });

  const form = useForm({
    defaultValues: {
      email: "",
      role: "player" as TeamMemberRole,
      jerseyNumber: "",
      position: "",
    },
    onSubmit: async ({ value }) => {
      setServerError(null);
      await addMemberMutation.mutateAsync({
        teamId,
        ...value,
        jerseyNumber: value.jerseyNumber || undefined,
        position: value.position || undefined,
      });
    },
  });

  return (
    <div className="container mx-auto max-w-4xl p-6">
      <div className="mb-6">
        <Button variant="ghost" size="sm" asChild>
          <Link to="/dashboard/teams/$teamId" params={{ teamId }}>
            <ArrowLeftIcon className="mr-2 h-4 w-4" />
            Back to Team
          </Link>
        </Button>
      </div>

      <div className="mb-8 flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold">{team.name} Members</h1>
          <p className="text-muted-foreground">
            Manage your team roster and member roles
          </p>
          {pendingMembers.length > 0 && (
            <Badge variant="secondary" className="mt-2 text-xs uppercase">
              {pendingMembers.length} pending invite
              {pendingMembers.length > 1 ? "s" : ""}
            </Badge>
          )}
        </div>
        <Button onClick={() => setShowAddMember(!showAddMember)}>
          <UserPlus className="mr-2 h-4 w-4" />
          Add Member
        </Button>
      </div>

      {showAddMember && (
        <Card className="mb-6">
          <CardHeader>
            <CardTitle>Add New Member</CardTitle>
            <CardDescription>Invite a new member to join your team</CardDescription>
          </CardHeader>
          <CardContent>
            <form
              onSubmit={(e) => {
                e.preventDefault();
                e.stopPropagation();
                form.handleSubmit();
              }}
              className="space-y-4"
            >
              {serverError && (
                <div className="bg-destructive/10 text-destructive rounded-md p-3 text-sm">
                  {serverError}
                </div>
              )}

              <div className="grid gap-4 md:grid-cols-2">
                <form.Field
                  name="email"
                  validators={{
                    onChange: ({ value }) => (!value ? "Email is required" : undefined),
                  }}
                >
                  {(field) => (
                    <div className="space-y-2">
                      <Label htmlFor={field.name}>Email Address</Label>
                      <Input
                        id={field.name}
                        type="email"
                        value={field.state.value}
                        onChange={(e) => field.handleChange(e.target.value)}
                        onBlur={field.handleBlur}
                        placeholder="player@example.com"
                      />
                      {field.state.meta.isTouched &&
                        field.state.meta.errors.length > 0 && (
                          <p className="text-destructive text-sm">
                            {field.state.meta.errors.join(", ")}
                          </p>
                        )}
                    </div>
                  )}
                </form.Field>

                <form.Field name="role">
                  {(field) => (
                    <div className="space-y-2">
                      <Label htmlFor={field.name}>Role</Label>
                      <Select
                        value={field.state.value}
                        onValueChange={(value) =>
                          field.handleChange(value as TeamMemberRole)
                        }
                      >
                        <SelectTrigger>
                          <SelectValue />
                        </SelectTrigger>
                        <SelectContent>
                          <SelectItem value="captain">Captain</SelectItem>
                          <SelectItem value="coach">Coach</SelectItem>
                          <SelectItem value="player">Player</SelectItem>
                          <SelectItem value="substitute">Substitute</SelectItem>
                        </SelectContent>
                      </Select>
                    </div>
                  )}
                </form.Field>

                <form.Field name="jerseyNumber">
                  {(field) => (
                    <div className="space-y-2">
                      <Label htmlFor={field.name}>Jersey Number</Label>
                      <Input
                        id={field.name}
                        value={field.state.value}
                        onChange={(e) => field.handleChange(e.target.value)}
                        onBlur={field.handleBlur}
                        placeholder="42"
                        maxLength={3}
                      />
                    </div>
                  )}
                </form.Field>

                <form.Field name="position">
                  {(field) => (
                    <div className="space-y-2">
                      <Label htmlFor={field.name}>Position</Label>
                      <Input
                        id={field.name}
                        value={field.state.value}
                        onChange={(e) => field.handleChange(e.target.value)}
                        onBlur={field.handleBlur}
                        placeholder="Chaser"
                      />
                    </div>
                  )}
                </form.Field>
              </div>

              <div className="flex justify-end gap-4">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => {
                    setShowAddMember(false);
                    form.reset();
                  }}
                >
                  Cancel
                </Button>
                <Button type="submit" disabled={form.state.isSubmitting}>
                  {form.state.isSubmitting ? "Adding..." : "Add Member"}
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>
      )}

      <div className="space-y-4">
        {members.map(({ member, user, invitedBy }) => (
          <Card key={member.id}>
            <CardContent className="p-6">
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-4">
                  <Avatar>
                    <AvatarImage
                      src={user.image || undefined}
                      alt={user.name || user.email}
                    />
                    <AvatarFallback>
                      {(user.name || user.email).charAt(0).toUpperCase()}
                    </AvatarFallback>
                  </Avatar>
                  <div>
                    <div className="flex items-center gap-2">
                      <h3 className="font-semibold">{user.name || user.email}</h3>
                      <Badge
                        variant={member.status === "active" ? "default" : "secondary"}
                      >
                        {member.status}
                      </Badge>
                    </div>
                    <div className="text-muted-foreground flex gap-4 text-sm">
                      <span className="capitalize">{member.role}</span>
                      {member.jerseyNumber && <span>#{member.jerseyNumber}</span>}
                      {member.position && <span>{member.position}</span>}
                    </div>
                    {member.status === "pending" && (
                      <p className="text-muted-foreground mt-2 text-sm">
                        {member.requestedAt
                          ? `Join request received ${formatDistanceToNow(
                              new Date(member.requestedAt),
                              { addSuffix: true },
                            )}.`
                          : member.invitedAt
                            ? `Invitation sent ${formatDistanceToNow(
                                new Date(member.invitedAt),
                                { addSuffix: true },
                              )}${invitedBy?.name ? ` by ${invitedBy.name}` : ""}.`
                            : "Pending response."}
                      </p>
                    )}
                  </div>
                </div>

                <div className="flex items-center gap-2">
                  <Select
                    value={member.role}
                    onValueChange={(value) =>
                      updateMemberMutation.mutate({
                        teamId,
                        memberId: member.id,
                        role: value as TeamMemberRole,
                      })
                    }
                  >
                    <SelectTrigger className="w-32">
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="captain">Captain</SelectItem>
                      <SelectItem value="coach">Coach</SelectItem>
                      <SelectItem value="player">Player</SelectItem>
                      <SelectItem value="substitute">Substitute</SelectItem>
                    </SelectContent>
                  </Select>

                  <AlertDialog>
                    <AlertDialogTrigger asChild>
                      <Button variant="ghost" size="icon">
                        <XCircle className="h-4 w-4" />
                      </Button>
                    </AlertDialogTrigger>
                    <AlertDialogContent>
                      <AlertDialogHeader>
                        <AlertDialogTitle>Remove team member?</AlertDialogTitle>
                        <AlertDialogDescription>
                          This will remove {user.name || user.email} from the team. They
                          can be re-invited later.
                        </AlertDialogDescription>
                      </AlertDialogHeader>
                      <AlertDialogFooter>
                        <AlertDialogCancel>Cancel</AlertDialogCancel>
                        <AlertDialogAction
                          onClick={() =>
                            removeMemberMutation.mutate({
                              teamId,
                              memberId: member.id,
                            })
                          }
                        >
                          Remove Member
                        </AlertDialogAction>
                      </AlertDialogFooter>
                    </AlertDialogContent>
                  </AlertDialog>
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="src/features/auth/components/signup.tsx">
import { useQueryClient } from "@tanstack/react-query";
import { useNavigate, useRouter } from "@tanstack/react-router";
import { useState } from "react";
import { FormSubmitButton } from "~/components/form-fields/FormSubmitButton";
import { ValidatedInput } from "~/components/form-fields/ValidatedInput";
import { Button } from "~/components/ui/button";
import { GoogleIcon, LogoIcon } from "~/components/ui/icons";
import { SafeLink as Link } from "~/components/ui/SafeLink";
import { auth } from "~/lib/auth-client";
import { useAppForm } from "~/lib/hooks/useAppForm";
import { authQueryKey } from "../auth.queries";
import { signupFormFields } from "../auth.schemas";

export default function SignupForm() {
  const queryClient = useQueryClient();
  const navigate = useNavigate();
  const router = useRouter();
  const redirectUrl = "/dashboard"; // Default redirect after signup

  const [isLoading, setIsLoading] = useState(false);
  const [errorMessage, setErrorMessage] = useState("");

  const form = useAppForm({
    defaultValues: {
      name: "",
      email: "",
      password: "",
      confirmPassword: "",
    },
    onSubmit: async ({ value }) => {
      setIsLoading(true);
      setErrorMessage("");

      try {
        const result = await auth.signUp.email({
          name: value.name,
          email: value.email,
          password: value.password,
          callbackURL: redirectUrl,
        });

        if (result?.error) {
          throw new Error(result.error.message || "Signup failed");
        }

        // Success path
        await queryClient.invalidateQueries({ queryKey: authQueryKey });
        await router.invalidate();
        await navigate({ to: redirectUrl });
      } catch (error) {
        // Error handling
        setErrorMessage((error as Error)?.message || "Signup failed");
        // Keep form values but reset submitting state by resetting with current values
        form.reset({
          name: value.name,
          email: value.email,
          password: value.password,
          confirmPassword: value.confirmPassword,
        });
      } finally {
        // Always reset loading state
        setIsLoading(false);
      }
    },
  });

  return (
    <div className="flex flex-col gap-6">
      <form
        onSubmit={async (e) => {
          e.preventDefault();
          e.stopPropagation();
          await form.handleSubmit();
        }}
      >
        <div className="flex flex-col gap-6">
          <div className="flex flex-col items-center gap-2">
            <a href="#" className="flex flex-col items-center gap-2 font-medium">
              <div className="flex h-8 w-8 items-center justify-center rounded-md">
                <LogoIcon className="size-6" />
              </div>
              <span className="sr-only">Quadball Canada</span>
            </a>
            <h1 className="text-xl font-bold">Sign up for Quadball Canada</h1>
          </div>
          <div className="flex flex-col gap-5">
            <form.Field
              name="name"
              validators={{
                onChange: signupFormFields.name,
              }}
            >
              {(field) => (
                <ValidatedInput
                  field={field}
                  label="Name"
                  type="text"
                  placeholder="John Doe"
                  autoComplete="name"
                  autoFocus
                />
              )}
            </form.Field>
            <form.Field
              name="email"
              validators={{
                onChange: signupFormFields.email,
              }}
            >
              {(field) => (
                <ValidatedInput
                  field={field}
                  label="Email"
                  type="email"
                  placeholder="hello@example.com"
                  autoComplete="email"
                />
              )}
            </form.Field>
            <form.Field
              name="password"
              validators={{
                onChange: signupFormFields.password,
              }}
            >
              {(field) => (
                <ValidatedInput
                  field={field}
                  label="Password"
                  type="password"
                  placeholder="Password"
                  autoComplete="new-password"
                />
              )}
            </form.Field>
            <form.Field
              name="confirmPassword"
              validators={{
                onChangeListenTo: ["password"],
                onChange: ({ value, fieldApi }) => {
                  const password = fieldApi.form.getFieldValue("password");
                  // Only validate if both fields have values
                  if (value && password && value !== password) {
                    return "Passwords do not match";
                  }
                  return undefined;
                },
              }}
            >
              {(field) => (
                <ValidatedInput
                  field={field}
                  label="Confirm Password"
                  type="password"
                  placeholder="Confirm Password"
                  autoComplete="new-password"
                />
              )}
            </form.Field>
            <FormSubmitButton
              isSubmitting={form.state.isSubmitting || isLoading}
              className="mt-2 w-full"
              size="lg"
              loadingText="Signing up..."
            >
              Sign up
            </FormSubmitButton>
          </div>
          {errorMessage && (
            <span className="text-destructive text-center text-sm">{errorMessage}</span>
          )}
          <div className="after:border-border relative text-center text-sm after:absolute after:inset-0 after:top-1/2 after:z-0 after:flex after:items-center after:border-t">
            <span className="bg-background text-muted-foreground relative z-10 px-2">
              Or
            </span>
          </div>
          <Button
            variant="outline"
            className="w-full"
            type="button"
            disabled={isLoading || form.state.isSubmitting}
            onClick={() =>
              auth.signInWithOAuth(
                {
                  provider: "google",
                  callbackURL: redirectUrl,
                },
                {
                  onRequest: () => {
                    setIsLoading(true);
                    setErrorMessage("");
                  },
                  // eslint-disable-next-line @typescript-eslint/no-explicit-any
                  onError: (ctx: any) => {
                    setIsLoading(false);
                    setErrorMessage(ctx.error?.message || "OAuth signup failed");
                  },
                },
              )
            }
          >
            <GoogleIcon />
            Sign up with Google
          </Button>
        </div>
      </form>

      <div className="text-center text-sm">
        Already have an account?{" "}
        <Link to="/auth/login" className="underline underline-offset-4">
          Login
        </Link>
      </div>
    </div>
  );
}
</file>

<file path="src/features/events/components/event-create-form.tsx">
import { useForm, useStore } from "@tanstack/react-form";
import { useMutation } from "@tanstack/react-query";
import { useNavigate } from "@tanstack/react-router";
import { ArrowLeft, ArrowRight } from "lucide-react";
import { useEffect, useRef, useState } from "react";
import { toast } from "sonner";
import { z } from "zod";
import { FormSubmitButton } from "~/components/form-fields/FormSubmitButton";
import { ValidatedCheckbox } from "~/components/form-fields/ValidatedCheckbox";
import { ValidatedInput } from "~/components/form-fields/ValidatedInput";
import { ValidatedSelect } from "~/components/form-fields/ValidatedSelect";
import { Button } from "~/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";
import { Label } from "~/components/ui/label";
import { Textarea } from "~/components/ui/textarea";
import { createEvent } from "../events.mutations";
import type { EventOperationResult, EventWithDetails } from "../events.types";

const EVENT_TYPE_OPTIONS = [
  { value: "tournament", label: "Tournament" },
  { value: "league", label: "League" },
  { value: "camp", label: "Training Camp" },
  { value: "clinic", label: "Skills Clinic" },
  { value: "social", label: "Social Event" },
  { value: "other", label: "Other" },
];

const EVENT_STATUS_OPTIONS = [
  { value: "draft", label: "Draft (Not visible)" },
  { value: "published", label: "Published (Visible)" },
  { value: "registration_open", label: "Registration Open" },
];

const PROVINCE_OPTIONS = [
  { value: "", label: "Select Province" },
  { value: "AB", label: "Alberta" },
  { value: "BC", label: "British Columbia" },
  { value: "MB", label: "Manitoba" },
  { value: "NB", label: "New Brunswick" },
  { value: "NL", label: "Newfoundland and Labrador" },
  { value: "NS", label: "Nova Scotia" },
  { value: "ON", label: "Ontario" },
  { value: "PE", label: "Prince Edward Island" },
  { value: "QC", label: "Quebec" },
  { value: "SK", label: "Saskatchewan" },
];

const REGISTRATION_TYPE_OPTIONS = [
  { value: "team", label: "Team" },
  { value: "individual", label: "Individual" },
  { value: "both", label: "Team & Individual" },
];

function Separator() {
  return <div className="border-t" />;
}

const eventFormSchema = z
  .object({
    name: z.string().min(1, "Event name is required").max(255),
    slug: z
      .string()
      .min(1, "URL slug is required")
      .max(255)
      .regex(/^[a-z0-9-]+$/, "Slug must be lowercase letters, numbers, and hyphens only"),
    description: z.string().optional(),
    shortDescription: z
      .string()
      .max(500, "Short description must be under 500 characters")
      .optional(),
    type: z.enum(["tournament", "league", "camp", "clinic", "social", "other"]),
    status: z.enum(["draft", "published", "registration_open"]),
    venueName: z.string().max(255).optional(),
    venueAddress: z.string().optional(),
    city: z.string().max(100).optional(),
    province: z.string().max(50).optional(),
    postalCode: z.string().max(10).optional(),
    locationNotes: z.string().optional(),
    startDate: z.string().min(1, "Start date is required"),
    endDate: z.string().min(1, "End date is required"),
    registrationOpensAt: z.string().optional(),
    registrationClosesAt: z.string().optional(),
    registrationType: z.enum(["team", "individual", "both"]),
    maxTeams: z.number().min(1).optional(),
    maxParticipants: z.number().min(1).optional(),
    minPlayersPerTeam: z.number().min(1).prefault(7),
    maxPlayersPerTeam: z.number().min(1).prefault(21),
    teamRegistrationFee: z.number().min(0).prefault(0),
    individualRegistrationFee: z.number().min(0).prefault(0),
    earlyBirdDiscount: z.number().min(0).max(100).prefault(0),
    earlyBirdDeadline: z.string().optional(),
    contactEmail: z.email().optional(),
    contactPhone: z.string().optional(),
    websiteUrl: z.url().optional().or(z.literal("")),
    allowWaitlist: z.boolean().prefault(false),
    requireMembership: z.boolean().prefault(false),
    allowEtransfer: z.boolean().prefault(false),
    etransferRecipient: z
      .email("Enter a valid e-transfer email")
      .optional()
      .or(z.literal("")),
    etransferInstructions: z.string().max(2000).optional(),
  })
  .superRefine((values, ctx) => {
    if (values.allowEtransfer) {
      const recipient = values.etransferRecipient?.trim() ?? "";
      if (!recipient) {
        ctx.addIssue({
          path: ["etransferRecipient"],
          code: "custom",
          message: "E-transfer recipient email is required when e-transfer is enabled",
        });
      }
    }
  });

type EventFormData = z.infer<typeof eventFormSchema>;

export function EventCreateForm() {
  const navigate = useNavigate();
  const [currentStep, setCurrentStep] = useState(0);
  const slugManuallyEditedRef = useRef(false);

  const defaultValues: EventFormData = {
    name: "",
    slug: "",
    description: "",
    shortDescription: "",
    type: "tournament",
    status: "draft",
    venueName: "",
    venueAddress: "",
    city: "",
    province: "",
    postalCode: "",
    locationNotes: "",
    startDate: "",
    endDate: "",
    registrationOpensAt: "",
    registrationClosesAt: "",
    registrationType: "team",
    maxTeams: undefined,
    maxParticipants: undefined,
    minPlayersPerTeam: 7,
    maxPlayersPerTeam: 21,
    teamRegistrationFee: 0,
    individualRegistrationFee: 0,
    earlyBirdDiscount: 0,
    earlyBirdDeadline: "",
    contactEmail: "",
    contactPhone: "",
    websiteUrl: "",
    allowWaitlist: false,
    requireMembership: false,
    allowEtransfer: false,
    etransferRecipient: "",
    etransferInstructions: "",
  };

  const form = useForm({
    defaultValues,
    onSubmit: async ({ value }) => {
      const validationResult = eventFormSchema.safeParse(value);

      if (!validationResult.success) {
        const firstIssue = validationResult.error.issues[0];
        toast.error(firstIssue?.message ?? "Please fix the highlighted fields.");
        return;
      }

      const parsed = validationResult.data;

      const formData: EventFormData = {
        ...parsed,
        teamRegistrationFee: Math.round((parsed.teamRegistrationFee || 0) * 100),
        individualRegistrationFee: Math.round(
          (parsed.individualRegistrationFee || 0) * 100,
        ),
        description: parsed.description || undefined,
        shortDescription: parsed.shortDescription || undefined,
        venueName: parsed.venueName || undefined,
        venueAddress: parsed.venueAddress || undefined,
        city: parsed.city || undefined,
        province: parsed.province || undefined,
        postalCode: parsed.postalCode || undefined,
        locationNotes: parsed.locationNotes || undefined,
        registrationOpensAt: parsed.registrationOpensAt || undefined,
        registrationClosesAt: parsed.registrationClosesAt || undefined,
        earlyBirdDeadline: parsed.earlyBirdDeadline || undefined,
        contactEmail: parsed.contactEmail || undefined,
        contactPhone: parsed.contactPhone || undefined,
        websiteUrl: parsed.websiteUrl,
        maxTeams: parsed.maxTeams,
        maxParticipants: parsed.maxParticipants,
        minPlayersPerTeam: parsed.minPlayersPerTeam,
        maxPlayersPerTeam: parsed.maxPlayersPerTeam,
        status: parsed.status,
        allowEtransfer: parsed.allowEtransfer ?? false,
        etransferRecipient: parsed.etransferRecipient?.trim()
          ? parsed.etransferRecipient.trim()
          : undefined,
        etransferInstructions: parsed.etransferInstructions?.trim()
          ? parsed.etransferInstructions.trim()
          : undefined,
      };

      createMutation.mutate(formData);
    },
  });

  const formState = useStore(form.store, (state) => state);

  useEffect(() => {
    const generatedSlug = generateSlug(formState.values.name ?? "");
    if (!slugManuallyEditedRef.current && formState.values.slug !== generatedSlug) {
      form.setFieldValue("slug", generatedSlug);
    }
  }, [form, formState.values.name, formState.values.slug]);

  useEffect(() => {
    if (!formState.values.slug) {
      slugManuallyEditedRef.current = false;
    }
  }, [formState.values.slug]);

  const createMutation = useMutation<
    EventOperationResult<EventWithDetails>,
    Error,
    EventFormData
  >({
    mutationFn: async (data: EventFormData) =>
      createEvent({ data }) as Promise<EventOperationResult<EventWithDetails>>,
    onSuccess: (result) => {
      if (!result.success) {
        const errorMessage = result.errors[0]?.message ?? "Failed to create event";
        toast.error(errorMessage);
        return;
      }

      toast.success("Event created successfully!");

      navigate({ to: "/dashboard/events/$slug", params: { slug: result.data.slug } });
    },
    onError: (error) => {
      toast.error("An error occurred while creating the event");
      console.error(error);
    },
  });

  const steps = [
    { title: "Basic Info", description: "Event name and description" },
    { title: "Location & Dates", description: "Where and when" },
    { title: "Registration", description: "Registration settings and pricing" },
    { title: "Additional Details", description: "Contact info and settings" },
  ];

  const canProceedToNext = () => {
    switch (currentStep) {
      case 0:
        return Boolean(formState.values.name?.trim() && formState.values.slug?.trim());
      case 1:
        return Boolean(formState.values.startDate && formState.values.endDate);
      default:
        return true;
    }
  };

  return (
    <Card className="mx-auto max-w-4xl">
      <CardHeader>
        <CardTitle>Create New Event</CardTitle>
        <CardDescription>
          Fill in the details to create a new Quadball event. You can save as draft and
          publish later.
        </CardDescription>
      </CardHeader>
      <CardContent>
        <div className="mb-8">
          <div className="flex items-center justify-between">
            {steps.map((step, index) => (
              <div
                key={step.title}
                className={`flex-1 ${index !== steps.length - 1 ? "relative" : ""}`}
              >
                <div
                  className={`flex items-center ${
                    index <= currentStep ? "text-primary" : "text-muted-foreground"
                  }`}
                >
                  <div
                    className={`flex h-10 w-10 items-center justify-center rounded-full border-2 ${
                      index <= currentStep
                        ? "border-primary bg-primary text-primary-foreground"
                        : "border-muted-foreground"
                    }`}
                  >
                    {index + 1}
                  </div>
                  <div className="ml-3 hidden md:block">
                    <div className="text-sm leading-tight font-medium">{step.title}</div>
                    <div className="text-muted-foreground mt-0.5 text-xs">
                      {step.description}
                    </div>
                  </div>
                </div>
                {index !== steps.length - 1 && (
                  <div
                    className={`absolute top-5 left-5 h-0.5 w-full ${
                      index < currentStep ? "bg-primary" : "bg-muted-foreground/30"
                    }`}
                    style={{ width: "calc(100% - 2.5rem)" }}
                  />
                )}
              </div>
            ))}
          </div>
        </div>

        <form
          onSubmit={(e) => {
            e.preventDefault();
            e.stopPropagation();
            form.handleSubmit();
          }}
          className="space-y-6"
        >
          {currentStep === 0 && (
            <div className="space-y-6">
              <form.Field name="name">
                {(field) => (
                  <ValidatedInput
                    field={field}
                    label="Event Name"
                    placeholder="2024 Summer Championship"
                    required
                    onValueChange={(value) => {
                      field.handleChange(value);
                      if (!value) {
                        slugManuallyEditedRef.current = false;
                      }
                    }}
                  />
                )}
              </form.Field>

              <form.Field name="slug">
                {(field) => (
                  <ValidatedInput
                    field={field}
                    label="URL Slug"
                    placeholder="2024-summer-championship"
                    description="This will be used in the event URL"
                    required
                    onValueChange={(value) => {
                      field.handleChange(value);
                      const generated = generateSlug(formState.values.name ?? "");
                      slugManuallyEditedRef.current =
                        Boolean(value) && value !== generated;
                    }}
                  />
                )}
              </form.Field>

              <form.Field name="shortDescription">
                {(field) => (
                  <ValidatedInput
                    field={field}
                    label="Short Description"
                    placeholder="Brief description for event cards and previews"
                    description="Max 500 characters"
                    maxLength={500}
                  />
                )}
              </form.Field>

              <form.Field name="description">
                {(field) => (
                  <div className="space-y-2">
                    <Label htmlFor={field.name}>Full Description</Label>
                    <Textarea
                      id={field.name}
                      value={field.state.value ?? ""}
                      onChange={(event) => field.handleChange(event.target.value)}
                      onBlur={field.handleBlur}
                      placeholder="Detailed event description..."
                      rows={6}
                      className="resize-none"
                    />
                    {field.state.meta.errors[0] && (
                      <p className="text-destructive text-sm">
                        {field.state.meta.errors[0]}
                      </p>
                    )}
                  </div>
                )}
              </form.Field>

              <div className="grid gap-4 md:grid-cols-2">
                <form.Field name="type">
                  {(field) => (
                    <ValidatedSelect
                      field={field}
                      label="Event Type"
                      options={EVENT_TYPE_OPTIONS}
                      required
                    />
                  )}
                </form.Field>

                <form.Field name="status">
                  {(field) => (
                    <ValidatedSelect
                      field={field}
                      label="Initial Status"
                      options={EVENT_STATUS_OPTIONS}
                      required
                    />
                  )}
                </form.Field>
              </div>
            </div>
          )}

          {currentStep === 1 && (
            <div className="space-y-6">
              <div className="grid gap-4 md:grid-cols-2">
                <form.Field name="venueName">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Venue Name"
                      placeholder="Community Sports Complex"
                    />
                  )}
                </form.Field>

                <form.Field name="venueAddress">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Venue Address"
                      placeholder="123 Main Street"
                    />
                  )}
                </form.Field>
              </div>

              <div className="grid gap-4 md:grid-cols-3">
                <form.Field name="city">
                  {(field) => (
                    <ValidatedInput field={field} label="City" placeholder="Toronto" />
                  )}
                </form.Field>

                <form.Field name="province">
                  {(field) => (
                    <ValidatedSelect
                      field={field}
                      label="Province"
                      options={PROVINCE_OPTIONS}
                    />
                  )}
                </form.Field>

                <form.Field name="postalCode">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Postal Code"
                      placeholder="M5V 3A8"
                    />
                  )}
                </form.Field>
              </div>

              <form.Field name="locationNotes">
                {(field) => (
                  <div className="space-y-2">
                    <Label htmlFor={field.name}>Location Notes</Label>
                    <Textarea
                      id={field.name}
                      value={field.state.value ?? ""}
                      onChange={(event) => field.handleChange(event.target.value)}
                      onBlur={field.handleBlur}
                      placeholder="Parking information, directions, accessibility notes..."
                      rows={3}
                      className="resize-none"
                    />
                    {field.state.meta.errors[0] && (
                      <p className="text-destructive text-sm">
                        {field.state.meta.errors[0]}
                      </p>
                    )}
                  </div>
                )}
              </form.Field>

              <Separator />

              <div className="grid gap-4 md:grid-cols-2">
                <form.Field name="startDate">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Start Date"
                      type="date"
                      required
                      onValueChange={(value) => {
                        field.handleChange(value);
                        if (!formState.values.endDate) {
                          form.setFieldValue("endDate", value);
                        }
                      }}
                    />
                  )}
                </form.Field>

                <form.Field name="endDate">
                  {(field) => (
                    <ValidatedInput field={field} label="End Date" type="date" required />
                  )}
                </form.Field>
              </div>

              <div className="grid gap-4 md:grid-cols-2">
                <form.Field name="registrationOpensAt">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Registration Opens"
                      type="date"
                    />
                  )}
                </form.Field>

                <form.Field name="registrationClosesAt">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Registration Closes"
                      type="date"
                    />
                  )}
                </form.Field>
              </div>
            </div>
          )}

          {currentStep === 2 && (
            <div className="space-y-6">
              <form.Field name="registrationType">
                {(field) => (
                  <ValidatedSelect
                    field={field}
                    label="Registration Type"
                    options={REGISTRATION_TYPE_OPTIONS}
                    required
                  />
                )}
              </form.Field>

              <div className="grid gap-4 md:grid-cols-2">
                <form.Field name="maxTeams">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Maximum Teams"
                      type="number"
                      min={1}
                      onValueChange={(value) => {
                        const nextValue = value ? Number.parseInt(value, 10) : undefined;
                        field.handleChange(nextValue as unknown as number);
                      }}
                    />
                  )}
                </form.Field>

                <form.Field name="maxParticipants">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Maximum Participants"
                      type="number"
                      min={1}
                      onValueChange={(value) => {
                        const nextValue = value ? Number.parseInt(value, 10) : undefined;
                        field.handleChange(nextValue as unknown as number);
                      }}
                    />
                  )}
                </form.Field>
              </div>

              <div className="grid gap-4 md:grid-cols-2">
                <form.Field name="minPlayersPerTeam">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Minimum Players per Team"
                      type="number"
                      min={1}
                      onValueChange={(value) => {
                        const nextValue = value ? Number.parseInt(value, 10) : undefined;
                        field.handleChange(nextValue as unknown as number);
                      }}
                    />
                  )}
                </form.Field>

                <form.Field name="maxPlayersPerTeam">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Maximum Players per Team"
                      type="number"
                      min={1}
                      onValueChange={(value) => {
                        const nextValue = value ? Number.parseInt(value, 10) : undefined;
                        field.handleChange(nextValue as unknown as number);
                      }}
                    />
                  )}
                </form.Field>
              </div>

              <Separator />

              <div className="space-y-4">
                <h3 className="text-lg font-semibold">Pricing</h3>
                <div className="grid gap-4 md:grid-cols-2">
                  <form.Field name="teamRegistrationFee">
                    {(field) => (
                      <ValidatedInput
                        field={field}
                        label="Team Registration Fee ($)"
                        type="number"
                        min={0}
                        step="0.01"
                        onValueChange={(value) => {
                          field.handleChange(value === "" ? 0 : Number.parseFloat(value));
                        }}
                      />
                    )}
                  </form.Field>

                  <form.Field name="individualRegistrationFee">
                    {(field) => (
                      <ValidatedInput
                        field={field}
                        label="Individual Registration Fee ($)"
                        type="number"
                        min={0}
                        step="0.01"
                        onValueChange={(value) => {
                          field.handleChange(value === "" ? 0 : Number.parseFloat(value));
                        }}
                      />
                    )}
                  </form.Field>
                </div>
              </div>

              <div className="space-y-4">
                <h3 className="text-lg font-semibold">Early Bird Discount</h3>
                <div className="grid gap-4 md:grid-cols-2">
                  <form.Field name="earlyBirdDiscount">
                    {(field) => (
                      <ValidatedInput
                        field={field}
                        label="Discount Percentage"
                        type="number"
                        min={0}
                        max={100}
                        onValueChange={(value) => {
                          field.handleChange(
                            value === "" ? 0 : Number.parseInt(value, 10),
                          );
                        }}
                        description="Percentage discount for early registration"
                      />
                    )}
                  </form.Field>

                  <form.Field name="earlyBirdDeadline">
                    {(field) => (
                      <ValidatedInput
                        field={field}
                        label="Early Bird Deadline"
                        type="date"
                        disabled={!formState.values.earlyBirdDiscount}
                      />
                    )}
                  </form.Field>
                </div>
              </div>

              <Separator />

              <div className="space-y-4">
                <h3 className="text-lg font-semibold">Alternate Payment Options</h3>
                <form.Field name="allowEtransfer">
                  {(field) => (
                    <ValidatedCheckbox
                      field={field}
                      label="Allow Interac e-Transfer"
                      description="Let registrants choose e-transfer instead of Square checkout"
                    />
                  )}
                </form.Field>

                <div className="grid gap-4 md:grid-cols-2">
                  <form.Field name="etransferRecipient">
                    {(field) => (
                      <ValidatedInput
                        field={field}
                        label="E-transfer Recipient Email"
                        type="email"
                        disabled={!formState.values.allowEtransfer}
                        onValueChange={(value) => field.handleChange(value ?? "")}
                        description="Where e-transfer payments should be sent"
                      />
                    )}
                  </form.Field>
                </div>

                <form.Field name="etransferInstructions">
                  {(field) => (
                    <div className="space-y-2">
                      <Label htmlFor="etransferInstructions">
                        E-transfer Instructions
                      </Label>
                      <Textarea
                        id="etransferInstructions"
                        placeholder="Include the security question, expected password, or any other notes for e-transfer payments."
                        value={field.state.value ?? ""}
                        onChange={(event) => field.handleChange(event.target.value)}
                        onBlur={field.handleBlur}
                        disabled={!formState.values.allowEtransfer}
                        className="min-h-[120px]"
                      />
                      {field.state.meta.errors?.length ? (
                        <p className="text-destructive text-sm">
                          {field.state.meta.errors[0]}
                        </p>
                      ) : null}
                    </div>
                  )}
                </form.Field>
              </div>

              <div className="space-y-4">
                <form.Field name="allowWaitlist">
                  {(field) => (
                    <ValidatedCheckbox
                      field={field}
                      label="Allow Waitlist"
                      description="Allow registrations to join a waitlist when the event is full"
                    />
                  )}
                </form.Field>

                <form.Field name="requireMembership">
                  {(field) => (
                    <ValidatedCheckbox
                      field={field}
                      label="Require Active Membership"
                      description="Only allow users with active Quadball Canada memberships to register"
                    />
                  )}
                </form.Field>
              </div>
            </div>
          )}

          {currentStep === 3 && (
            <div className="space-y-6">
              <div className="space-y-4">
                <h3 className="text-lg font-semibold">Contact Information</h3>
                <div className="grid gap-4 md:grid-cols-2">
                  <form.Field name="contactEmail">
                    {(field) => (
                      <ValidatedInput
                        field={field}
                        label="Contact Email"
                        type="email"
                        placeholder="event@example.com"
                      />
                    )}
                  </form.Field>

                  <form.Field name="contactPhone">
                    {(field) => (
                      <ValidatedInput
                        field={field}
                        label="Contact Phone"
                        type="tel"
                        placeholder="(555) 123-4567"
                      />
                    )}
                  </form.Field>
                </div>

                <form.Field name="websiteUrl">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Event Website"
                      type="url"
                      placeholder="https://example.com/event"
                    />
                  )}
                </form.Field>
              </div>
            </div>
          )}

          <div className="flex items-center justify-between pt-6">
            <Button
              type="button"
              variant="outline"
              onClick={() => setCurrentStep((prev) => Math.max(0, prev - 1))}
              disabled={currentStep === 0}
            >
              <ArrowLeft className="mr-2 h-4 w-4" />
              Previous
            </Button>

            {currentStep < steps.length - 1 ? (
              <Button
                type="button"
                onClick={() =>
                  setCurrentStep((prev) => Math.min(steps.length - 1, prev + 1))
                }
                disabled={!canProceedToNext()}
              >
                Next
                <ArrowRight className="ml-2 h-4 w-4" />
              </Button>
            ) : (
              <FormSubmitButton
                isSubmitting={createMutation.isPending}
                loadingText="Creating..."
                disabled={!formState.canSubmit}
              >
                Create Event
              </FormSubmitButton>
            )}
          </div>
        </form>
      </CardContent>
    </Card>
  );
}

function generateSlug(name: string) {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "");
}
</file>

<file path="src/features/events/events.schemas.ts">
import { z } from "zod";
import { baseCreateEventSchema, createEventInputSchema } from "~/db/schema/events.schema";

// Query schemas
export const listEventsSchema = z
  .object({
    filters: z
      .object({
        status: z.union([z.string(), z.array(z.string())]).optional(),
        type: z.union([z.string(), z.array(z.string())]).optional(),
        organizerId: z.string().optional(),
        startDateFrom: z.date().optional(),
        startDateTo: z.date().optional(),
        city: z.string().optional(),
        province: z.string().optional(),
      })
      .optional(),
    page: z.int().positive().optional(),
    pageSize: z.int().positive().optional(),
    sortBy: z.enum(["startDate", "createdAt", "name"]).optional(),
    sortOrder: z.enum(["asc", "desc"]).optional(),
  })
  .optional()
  .prefault({});
export type ListEventsInput = z.infer<typeof listEventsSchema>;

export const getEventSchema = z.object({
  id: z.string().optional(),
  slug: z.string().optional(),
});
export type GetEventInput = z.infer<typeof getEventSchema>;

export const getUpcomingEventsSchema = z
  .object({
    limit: z.int().positive().max(10).optional(),
  })
  .optional()
  .prefault({});
export type GetUpcomingEventsInput = z.infer<typeof getUpcomingEventsSchema>;

export const checkEventRegistrationSchema = z.object({
  eventId: z.string(),
  // userId is now inferred from session - not passed from client
  teamId: z.string().optional(),
});
export type CheckEventRegistrationInput = z.infer<typeof checkEventRegistrationSchema>;

// Mutation schemas
export const createEventSchema = createEventInputSchema;
export type CreateEventInput = z.infer<typeof createEventSchema>;

export const updateEventSchema = z.object({
  eventId: z.string(),
  data: baseCreateEventSchema.partial().extend({
    status: z
      .enum([
        "draft",
        "published",
        "registration_open",
        "registration_closed",
        "in_progress",
        "completed",
        "cancelled",
      ])
      .optional(),
  }),
});
export type UpdateEventInput = z.infer<typeof updateEventSchema>;

const rosterPlayerSchema = z.object({
  userId: z.string(),
  role: z.string().optional(),
  name: z.string().optional(),
  jerseyNumber: z.string().optional(),
});

const rosterObjectSchema = z.looseObject({
  players: z.array(rosterPlayerSchema).optional(),
  emergencyContact: z
    .looseObject({
      name: z.string().optional(),
      phone: z.string().optional(),
      relationship: z.string().optional(),
    })
    .optional(),
});

export const registerForEventSchema = z.object({
  eventId: z.string(),
  teamId: z.string().optional(),
  division: z.string().optional(),
  notes: z.string().optional(),
  roster: z.union([z.array(rosterPlayerSchema), rosterObjectSchema]).optional(),
  paymentMethod: z.enum(["square", "etransfer"]).prefault("square"),
});
export type RegisterForEventInput = z.infer<typeof registerForEventSchema>;

export const cancelEventRegistrationSchema = z.object({
  registrationId: z.string(),
  reason: z.string().optional(),
});
export type CancelEventRegistrationInput = z.infer<typeof cancelEventRegistrationSchema>;

export const cancelEntireEventSchema = z.object({
  eventId: z.uuid(),
  reason: z.string().optional(),
  notify: z.boolean().optional().prefault(true),
  refundMode: z.enum(["auto", "manual", "none"]).optional().prefault("auto"),
});
export type CancelEntireEventInput = z.infer<typeof cancelEntireEventSchema>;

export const markEtransferPaidSchema = z.object({
  registrationId: z.string(),
});

export const markEtransferReminderSchema = z.object({
  registrationId: z.string(),
});
</file>

<file path="src/features/teams/teams.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { zod$ } from "~/lib/server/fn-utils";
import {
  getTeamBySlugSchema,
  getTeamMembersSchema,
  getTeamSchema,
  isTeamMemberSchema,
  listTeamsSchema,
  searchTeamsSchema,
} from "./teams.schemas";

/**
 * Get a team by ID with member count
 */
export const getTeam = createServerFn({ method: "GET" })
  .inputValidator(zod$(getTeamSchema))
  .handler(async ({ data }) => {
    // Import server-only modules inside the handler
    const { getDb } = await import("~/db/server-helpers");
    const { teams, teamMembers } = await import("~/db/schema");
    const { and, eq, sql } = await import("drizzle-orm");

    const db = await getDb();

    const result = await db
      .select({
        team: teams,
        memberCount: sql<number>`count(distinct ${teamMembers.userId})::int`,
      })
      .from(teams)
      .leftJoin(
        teamMembers,
        and(eq(teamMembers.teamId, teams.id), eq(teamMembers.status, "active")),
      )
      .where(eq(teams.id, data.teamId))
      .groupBy(teams.id)
      .limit(1);

    return result[0] || null;
  });

/**
 * Get a team by slug
 */
export const getTeamBySlug = createServerFn({ method: "GET" })
  .inputValidator(zod$(getTeamBySlugSchema))
  .handler(async ({ data }) => {
    // Import server-only modules inside the handler
    const { getDb } = await import("~/db/server-helpers");
    const { teams, teamMembers } = await import("~/db/schema");
    const { and, eq, sql } = await import("drizzle-orm");

    const db = await getDb();

    const result = await db
      .select({
        team: teams,
        memberCount: sql<number>`count(distinct ${teamMembers.userId})::int`,
      })
      .from(teams)
      .leftJoin(
        teamMembers,
        and(eq(teamMembers.teamId, teams.id), eq(teamMembers.status, "active")),
      )
      .where(eq(teams.slug, data.slug))
      .groupBy(teams.id)
      .limit(1);

    return result[0] || null;
  });

/**
 * List all active teams
 */
export const listTeams = createServerFn({ method: "GET" })
  .inputValidator(zod$(listTeamsSchema))
  .handler(async ({ data }) => {
    // Import server-only modules inside the handler
    const { getDb } = await import("~/db/server-helpers");
    const { teams, teamMembers, user } = await import("~/db/schema");
    const { and, desc, eq, sql } = await import("drizzle-orm");

    const db = await getDb();

    const conditions = data?.includeInactive ? undefined : eq(teams.isActive, "true");

    const result = await db
      .select({
        team: teams,
        memberCount: sql<number>`count(distinct ${teamMembers.userId})::int`,
        creator: {
          id: user.id,
          name: user.name,
          email: user.email,
        },
      })
      .from(teams)
      .leftJoin(user, eq(teams.createdBy, user.id))
      .leftJoin(
        teamMembers,
        and(eq(teamMembers.teamId, teams.id), eq(teamMembers.status, "active")),
      )
      .where(conditions)
      .groupBy(teams.id, user.id, user.name, user.email)
      .orderBy(desc(teams.createdAt));

    return result;
  });

/**
 * Get teams for the current user
 */
export const getUserTeams = createServerFn({ method: "GET" })
  .inputValidator(zod$(listTeamsSchema))
  .handler(async ({ data }) => {
    // Import server-only modules inside the handler
    const [{ getCurrentUser }, { getDb }] = await Promise.all([
      import("~/features/auth/auth.queries"),
      import("~/db/server-helpers"),
    ]);
    const { teams, teamMembers } = await import("~/db/schema");
    const { and, desc, eq, sql } = await import("drizzle-orm");

    const currentUser = await getCurrentUser();
    if (!currentUser) {
      throw new Error("Not authenticated");
    }

    const db = await getDb();

    const statusConditions = data?.includeInactive
      ? undefined
      : eq(teamMembers.status, "active");

    const result = await db
      .select({
        team: teams,
        membership: {
          role: teamMembers.role,
          status: teamMembers.status,
          joinedAt: teamMembers.joinedAt,
          jerseyNumber: teamMembers.jerseyNumber,
          position: teamMembers.position,
        },
        memberCount: sql<number>`count(distinct tm2.user_id)::int`,
      })
      .from(teamMembers)
      .innerJoin(teams, eq(teamMembers.teamId, teams.id))
      .leftJoin(
        sql`${teamMembers} as tm2`,
        and(sql`tm2.team_id = ${teams.id}`, sql`tm2.status = 'active'`),
      )
      .where(and(eq(teamMembers.userId, currentUser.id), statusConditions))
      .groupBy(
        teams.id,
        teamMembers.role,
        teamMembers.status,
        teamMembers.joinedAt,
        teamMembers.jerseyNumber,
        teamMembers.position,
      )
      .orderBy(desc(teamMembers.joinedAt));

    return result;
  });

/**
 * Get team members
 */
export const getTeamMembers = createServerFn({ method: "GET" })
  .inputValidator(zod$(getTeamMembersSchema))
  .handler(async ({ data }) => {
    // Import server-only modules inside the handler
    const { getDb } = await import("~/db/server-helpers");
    const { teamMembers, user } = await import("~/db/schema");
    const { and, eq, inArray, sql } = await import("drizzle-orm");

    const db = await getDb();

    const statusCondition = data.includeInactive
      ? undefined
      : inArray(teamMembers.status, ["active", "pending"]);

    const conditions = and(eq(teamMembers.teamId, data.teamId), statusCondition);

    const result = await db
      .select({
        member: {
          id: teamMembers.id,
          role: teamMembers.role,
          status: teamMembers.status,
          jerseyNumber: teamMembers.jerseyNumber,
          position: teamMembers.position,
          joinedAt: teamMembers.joinedAt,
          leftAt: teamMembers.leftAt,
          notes: teamMembers.notes,
          invitedAt: teamMembers.invitedAt,
          requestedAt: teamMembers.requestedAt,
          invitationReminderCount: teamMembers.invitationReminderCount,
          lastInvitationReminderAt: teamMembers.lastInvitationReminderAt,
        },
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
          image: user.image,
        },
        invitedBy: {
          id: sql<string | null>`inviter.id`,
          name: sql<string | null>`inviter.name`,
          email: sql<string | null>`inviter.email`,
        },
      })
      .from(teamMembers)
      .innerJoin(user, eq(teamMembers.userId, user.id))
      .leftJoin(sql`${user} as inviter`, sql`${teamMembers.invitedBy} = inviter.id`)
      .where(conditions)
      .orderBy(
        sql`CASE ${teamMembers.role} 
          WHEN 'captain' THEN 1 
          WHEN 'coach' THEN 2 
          WHEN 'player' THEN 3 
          WHEN 'substitute' THEN 4 
        END`,
        teamMembers.joinedAt,
      );

    return result;
  });

export const getPendingTeamInvites = createServerFn({ method: "GET" }).handler(
  async () => {
    const [{ getCurrentUser }, { getDb }, { and, eq, sql }] = await Promise.all([
      import("~/features/auth/auth.queries"),
      import("~/db/server-helpers"),
      import("drizzle-orm"),
    ]);
    const { teamMembers, teams, user } = await import("~/db/schema");

    const currentUser = await getCurrentUser();
    if (!currentUser) {
      throw new Error("Not authenticated");
    }

    const db = await getDb();

    const invites = await db
      .select({
        membership: {
          id: teamMembers.id,
          teamId: teamMembers.teamId,
          role: teamMembers.role,
          invitedAt: teamMembers.invitedAt,
          requestedAt: teamMembers.requestedAt,
          invitedBy: teamMembers.invitedBy,
        },
        team: {
          id: teams.id,
          name: teams.name,
          slug: teams.slug,
        },
        inviter: {
          id: user.id,
          name: user.name,
          email: user.email,
        },
      })
      .from(teamMembers)
      .innerJoin(teams, eq(teamMembers.teamId, teams.id))
      .leftJoin(user, eq(teamMembers.invitedBy, user.id))
      .where(
        and(eq(teamMembers.userId, currentUser.id), eq(teamMembers.status, "pending")),
      )
      .orderBy(sql`COALESCE(${teamMembers.invitedAt}, ${teamMembers.requestedAt}) DESC`);

    return invites;
  },
);

/**
 * Check if a user is a member of a team
 */
export const isTeamMember = createServerFn({ method: "GET" })
  .inputValidator(zod$(isTeamMemberSchema))
  .handler(async ({ data }) => {
    // Import server-only modules inside the handler
    const { getDb } = await import("~/db/server-helpers");
    const { teamMembers } = await import("~/db/schema");
    const { and, eq, sql } = await import("drizzle-orm");

    const db = await getDb();

    const result = await db
      .select({
        isMember: sql<boolean>`COUNT(*) > 0`,
        role: teamMembers.role,
        status: teamMembers.status,
      })
      .from(teamMembers)
      .where(
        and(eq(teamMembers.teamId, data.teamId), eq(teamMembers.userId, data.userId)),
      )
      .groupBy(teamMembers.role, teamMembers.status)
      .limit(1);

    return result[0] || { isMember: false, role: null, status: null };
  });

/**
 * Search teams by name or city
 */
export const searchTeams = createServerFn({ method: "GET" })
  .inputValidator(zod$(searchTeamsSchema))
  .handler(async ({ data }) => {
    // Import server-only modules inside the handler
    const { getDb } = await import("~/db/server-helpers");
    const { teams, teamMembers } = await import("~/db/schema");
    const { and, eq, sql } = await import("drizzle-orm");

    const db = await getDb();
    const searchTerm = `%${data.query}%`;
    const cityProvince = sql`
      coalesce(${teams.city}, '') || ', ' || coalesce(${teams.province}, '')
    `;

    const result = await db
      .select({
        team: teams,
        memberCount: sql<number>`count(distinct ${teamMembers.userId})::int`,
      })
      .from(teams)
      .leftJoin(
        teamMembers,
        and(eq(teamMembers.teamId, teams.id), eq(teamMembers.status, "active")),
      )
      .where(
        and(
          eq(teams.isActive, "true"),
          sql`(
            ${teams.name} ILIKE ${searchTerm} OR
            ${teams.city} ILIKE ${searchTerm} OR
            ${teams.province} ILIKE ${searchTerm} OR
            ${cityProvince} ILIKE ${searchTerm}
          )`,
        ),
      )
      .groupBy(teams.id)
      .orderBy(teams.name)
      .limit(20);

    return result;
  });

// Export types
export type TeamWithMemberCount = Awaited<ReturnType<typeof getTeam>>;
export type TeamListItem = Awaited<ReturnType<typeof listTeams>>[number];
export type UserTeam = Awaited<ReturnType<typeof getUserTeams>>[number];
export type TeamMemberDetails = Awaited<ReturnType<typeof getTeamMembers>>[number];
export type PendingTeamInvite = Awaited<ReturnType<typeof getPendingTeamInvites>>[number];
</file>

<file path="src/features/profile/components/profile-view.tsx">
import { useForm } from "@tanstack/react-form";
import { useQuery, useQueryClient } from "@tanstack/react-query";
import { Edit2, LoaderCircle, Save, X } from "lucide-react";
import { useState } from "react";
import { toast } from "sonner";
import { ValidatedCheckbox } from "~/components/form-fields/ValidatedCheckbox";
import { ValidatedDatePicker } from "~/components/form-fields/ValidatedDatePicker";
import { ValidatedInput } from "~/components/form-fields/ValidatedInput";
import { ValidatedSelect } from "~/components/form-fields/ValidatedSelect";
import { Button } from "~/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";
import { Label } from "~/components/ui/label";
import { Separator } from "~/components/ui/separator";
import { updateUserProfile } from "../profile.mutations";
import { getUserProfile } from "../profile.queries";
import type { PartialProfileInputType } from "../profile.schemas";
import type { ProfileOperationResult } from "../profile.types";

function toUtcDate(value: Date | string | undefined): Date | null {
  if (!value) return null;
  if (typeof value === "string") {
    const isoValue = value.includes("T") ? value : `${value}T00:00:00.000Z`;
    const parsed = new Date(isoValue);
    return isNaN(parsed.getTime()) ? null : parsed;
  }
  return isNaN(value.getTime()) ? null : value;
}

function calculateAgeUtc(value: Date | string | undefined): number | null {
  const birthDate = toUtcDate(value);
  if (!birthDate) return null;
  const today = new Date();
  let age = today.getUTCFullYear() - birthDate.getUTCFullYear();
  const monthDiff = today.getUTCMonth() - birthDate.getUTCMonth();
  if (monthDiff < 0 || (monthDiff === 0 && today.getUTCDate() < birthDate.getUTCDate())) {
    age--;
  }
  return age;
}

function formatDateOnly(value: Date | string | undefined): string | null {
  const date = toUtcDate(value);
  if (!date) return null;
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric",
    month: "numeric",
    day: "numeric",
    timeZone: "UTC",
  }).format(date);
}

export function ProfileView() {
  const queryClient = useQueryClient();
  const [isEditing, setIsEditing] = useState(false);
  const [formError, setFormError] = useState<string | null>(null);

  // Fetch profile data
  const {
    data: profileResult,
    isLoading,
    error,
  } = useQuery({
    queryKey: ["userProfile"],
    queryFn: async () => getUserProfile(),
    retry: 1,
  });

  const profile = profileResult?.success ? profileResult.data : null;

  // TanStack Form for editing
  const form = useForm({
    defaultValues: {
      dateOfBirth: undefined as Date | undefined,
      gender: "",
      pronouns: "",
      phone: "",
      emergencyContact: {
        name: "",
        relationship: "",
        phone: "",
        email: "",
      },
      privacySettings: {
        showEmail: false,
        showPhone: false,
        showBirthYear: false,
        allowTeamInvitations: true,
      },
    } as PartialProfileInputType,
    onSubmit: async ({ value }) => {
      // Build ProfileInput with only changed/meaningful values
      // Use a more flexible type since we need to handle Date serialization
      const dataToSubmit: Record<string, unknown> = {};

      // Include fields that have values - convert Date to ISO string for serialization
      if (value.dateOfBirth) {
        dataToSubmit["dateOfBirth"] =
          value.dateOfBirth instanceof Date
            ? value.dateOfBirth.toISOString()
            : value.dateOfBirth;
      }
      if (value.gender) dataToSubmit["gender"] = value.gender;
      if (value.pronouns) dataToSubmit["pronouns"] = value.pronouns;
      if (value.phone) dataToSubmit["phone"] = value.phone;

      // Handle emergency contact
      if (value.emergencyContact) {
        const ec = value.emergencyContact;
        if (ec.name || ec.relationship || ec.phone || ec.email) {
          dataToSubmit["emergencyContact"] = {
            name: ec.name || "",
            relationship: ec.relationship || "",
            ...(ec.phone && { phone: ec.phone }),
            ...(ec.email && { email: ec.email }),
          };
        }
      }

      // Always include privacy settings as they have default values
      if (value.privacySettings) {
        dataToSubmit["privacySettings"] = {
          showEmail: value.privacySettings.showEmail ?? false,
          showPhone: value.privacySettings.showPhone ?? false,
          showBirthYear: value.privacySettings.showBirthYear ?? false,
          allowTeamInvitations: value.privacySettings.allowTeamInvitations ?? true,
        };
      }

      try {
        setFormError(null); // Clear any previous errors

        // Debug logging to check what we're sending
        console.log("Form value:", value);
        console.log("Data to submit:", dataToSubmit);
        console.log("Data to submit keys:", Object.keys(dataToSubmit));
        console.log("Privacy settings in dataToSubmit:", dataToSubmit["privacySettings"]);

        // Make sure we're not sending an empty object
        if (Object.keys(dataToSubmit).length === 0) {
          console.error("No data to submit!");
          setFormError("No changes detected");
          return;
        }

        console.log("Sending to server function:", JSON.stringify(dataToSubmit, null, 2));
        console.log("Data type:", typeof dataToSubmit);

        const result = (await updateUserProfile({
          data: dataToSubmit as PartialProfileInputType,
        })) as ProfileOperationResult;

        if (result.success) {
          toast.success("Profile updated successfully");
          await queryClient.invalidateQueries({ queryKey: ["userProfile"] });
          // Only exit edit mode on success
          setIsEditing(false);
          setFormError(null);
        } else {
          // Show error but don't exit edit mode
          const error = result.errors?.[0]?.message || "Failed to update profile";
          setFormError(error);
          toast.error(error);
          // Don't throw - let form remain interactive
        }
      } catch (error) {
        // Network/unexpected errors
        const errorMessage =
          error instanceof Error ? error.message : "An unexpected error occurred";
        setFormError(errorMessage);
        toast.error(errorMessage);
        console.error("Profile update error:", error);
        // Don't throw - let form remain interactive
      } finally {
        // Don't reset form on error - this was causing fields to clear
        // TanStack Form handles submission state automatically
      }
    },
  });

  // Gender options for select component
  const genderOptions = [
    { value: "male", label: "Male" },
    { value: "female", label: "Female" },
    { value: "non-binary", label: "Non-binary" },
    { value: "other", label: "Other" },
    { value: "prefer-not-to-say", label: "Prefer not to say" },
  ];

  // Initialize form data when entering edit mode
  const startEditing = () => {
    if (!profile) return;

    // Reset form with current profile data
    form.reset();

    // Set field values from profile
    if (profile.dateOfBirth) {
      const date = toUtcDate(profile.dateOfBirth);
      if (date) {
        form.setFieldValue("dateOfBirth", date);
      }
    }
    if (profile.gender) {
      form.setFieldValue("gender", profile.gender);
    }
    if (profile.pronouns) {
      form.setFieldValue("pronouns", profile.pronouns);
    }
    if (profile.phone) {
      form.setFieldValue("phone", profile.phone);
    }
    if (profile.emergencyContact) {
      form.setFieldValue("emergencyContact.name", profile.emergencyContact.name || "");
      form.setFieldValue(
        "emergencyContact.relationship",
        profile.emergencyContact.relationship || "",
      );
      form.setFieldValue("emergencyContact.phone", profile.emergencyContact.phone || "");
      form.setFieldValue("emergencyContact.email", profile.emergencyContact.email || "");
    }

    const privacySettings = profile.privacySettings || {
      showEmail: false,
      showPhone: false,
      showBirthYear: false,
      allowTeamInvitations: true,
    };
    form.setFieldValue("privacySettings.showEmail", privacySettings.showEmail);
    form.setFieldValue("privacySettings.showPhone", privacySettings.showPhone);
    form.setFieldValue("privacySettings.showBirthYear", privacySettings.showBirthYear);
    form.setFieldValue(
      "privacySettings.allowTeamInvitations",
      privacySettings.allowTeamInvitations,
    );

    setIsEditing(true);
  };

  const cancelEditing = () => {
    // Reset form to original values
    form.reset();
    // Clear any errors
    setFormError(null);
    // Exit edit mode
    setIsEditing(false);
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center p-8">
        <LoaderCircle className="h-8 w-8 animate-spin" />
      </div>
    );
  }

  if (!profile) {
    const errorMessage =
      profileResult?.errors?.[0]?.message || error?.message || "Failed to load profile";
    return (
      <div className="p-8 text-center">
        <p className="text-muted-foreground">{errorMessage}</p>
        {profileResult?.errors?.[0]?.code === "VALIDATION_ERROR" && (
          <p className="text-muted-foreground mt-2 text-sm">
            Please try logging in again
          </p>
        )}
      </div>
    );
  }

  const age = calculateAgeUtc(profile.dateOfBirth);
  const formattedDob = formatDateOnly(profile.dateOfBirth);

  return (
    <div className="space-y-6">
      {/* Basic Information */}
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <div>
              <CardTitle>Basic Information</CardTitle>
              <CardDescription>
                Your personal details and contact information
              </CardDescription>
            </div>
            {!isEditing && (
              <Button onClick={startEditing} variant="outline" size="sm">
                <Edit2 className="mr-2 h-4 w-4" />
                Edit Profile
              </Button>
            )}
            {isEditing && (
              <div className="flex gap-2">
                <Button
                  onClick={cancelEditing}
                  variant="outline"
                  size="sm"
                  disabled={form.state.isSubmitting}
                >
                  <X className="mr-2 h-4 w-4" />
                  Cancel
                </Button>
                <form.Subscribe
                  selector={(state) => [state.canSubmit, state.isSubmitting]}
                >
                  {([canSubmit, isSubmitting]) => (
                    <Button
                      type="button"
                      onClick={() => form.handleSubmit()}
                      disabled={!canSubmit || isSubmitting}
                      size="sm"
                    >
                      {isSubmitting ? (
                        <>
                          <LoaderCircle className="mr-2 h-4 w-4 animate-spin" />
                          Saving...
                        </>
                      ) : (
                        <>
                          <Save className="mr-2 h-4 w-4" />
                          Save Changes
                        </>
                      )}
                    </Button>
                  )}
                </form.Subscribe>
              </div>
            )}
          </div>
        </CardHeader>
        <CardContent className="space-y-4">
          {formError && (
            <div className="bg-destructive/10 text-destructive rounded-md p-3 text-sm">
              {formError}
            </div>
          )}
          <div className="grid gap-4 md:grid-cols-2">
            <div className="space-y-2">
              <Label>Name</Label>
              <p className="text-base">{profile.name || "Not set"}</p>
            </div>
            <div className="space-y-2">
              <Label>Email</Label>
              <p className="text-base">{profile.email}</p>
            </div>
          </div>

          <Separator />

          <div className="grid gap-4 md:grid-cols-2">
            <div className="space-y-2">
              {isEditing ? (
                <form.Field
                  name="dateOfBirth"
                  validators={{
                    onChange: ({ value }) => {
                      if (value) {
                        const computedAge = calculateAgeUtc(value);
                        if (
                          computedAge !== null &&
                          (computedAge < 13 || computedAge > 120)
                        ) {
                          return "You must be between 13 and 120 years old";
                        }
                      }
                      return undefined;
                    },
                  }}
                >
                  {(field) => (
                    <ValidatedDatePicker
                      field={field}
                      label="Date of Birth"
                      minAge={13}
                      maxAge={120}
                    />
                  )}
                </form.Field>
              ) : (
                <>
                  <Label>Date of Birth</Label>
                  <p className="text-base">
                    {formattedDob
                      ? `${formattedDob}${age !== null ? ` (Age: ${age})` : ""}`
                      : "Not set"}
                  </p>
                </>
              )}
            </div>

            <div className="space-y-2">
              {isEditing ? (
                <form.Field name="phone">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Phone Number"
                      type="tel"
                      placeholder="+1 (555) 000-0000"
                    />
                  )}
                </form.Field>
              ) : (
                <>
                  <Label>Phone Number</Label>
                  <p className="text-base">{profile.phone || "Not set"}</p>
                </>
              )}
            </div>

            <div className="space-y-2">
              {isEditing ? (
                <form.Field name="gender">
                  {(field) => (
                    <ValidatedSelect
                      field={field}
                      label="Gender"
                      options={genderOptions}
                      placeholderText="Select gender"
                    />
                  )}
                </form.Field>
              ) : (
                <>
                  <Label>Gender</Label>
                  <p className="text-base">{profile.gender || "Not set"}</p>
                </>
              )}
            </div>

            <div className="space-y-2">
              {isEditing ? (
                <form.Field name="pronouns">
                  {(field) => (
                    <ValidatedInput
                      field={field}
                      label="Pronouns"
                      placeholder="e.g., they/them, she/her, he/him"
                    />
                  )}
                </form.Field>
              ) : (
                <>
                  <Label>Pronouns</Label>
                  <p className="text-base">{profile.pronouns || "Not set"}</p>
                </>
              )}
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Emergency Contact */}
      <Card>
        <CardHeader>
          <CardTitle>Emergency Contact</CardTitle>
          <CardDescription>Who should we contact in case of emergency</CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          {isEditing ? (
            <div className="grid gap-4 md:grid-cols-2">
              <form.Field name="emergencyContact.name">
                {(field) => (
                  <ValidatedInput
                    field={field}
                    label="Contact Name"
                    placeholder="Full name"
                  />
                )}
              </form.Field>

              <form.Field name="emergencyContact.relationship">
                {(field) => (
                  <ValidatedInput
                    field={field}
                    label="Relationship"
                    placeholder="e.g., Parent, Spouse, Friend"
                  />
                )}
              </form.Field>

              <form.Field name="emergencyContact.phone">
                {(field) => (
                  <ValidatedInput
                    field={field}
                    label="Contact Phone"
                    type="tel"
                    placeholder="+1 (555) 000-0000"
                  />
                )}
              </form.Field>

              <form.Field name="emergencyContact.email">
                {(field) => (
                  <ValidatedInput
                    field={field}
                    label="Contact Email"
                    type="email"
                    placeholder="email@example.com"
                  />
                )}
              </form.Field>
            </div>
          ) : (
            <div className="grid gap-4 md:grid-cols-2">
              <div className="space-y-2">
                <Label>Contact Name</Label>
                <p className="text-base">{profile.emergencyContact?.name || "Not set"}</p>
              </div>
              <div className="space-y-2">
                <Label>Relationship</Label>
                <p className="text-base">
                  {profile.emergencyContact?.relationship || "Not set"}
                </p>
              </div>
              <div className="space-y-2">
                <Label>Contact Phone</Label>
                <p className="text-base">
                  {profile.emergencyContact?.phone || "Not set"}
                </p>
              </div>
              <div className="space-y-2">
                <Label>Contact Email</Label>
                <p className="text-base">
                  {profile.emergencyContact?.email || "Not set"}
                </p>
              </div>
            </div>
          )}
        </CardContent>
      </Card>

      {/* Privacy Settings */}
      <Card>
        <CardHeader>
          <CardTitle>Privacy Settings</CardTitle>
          <CardDescription>Control what information is visible to others</CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          {isEditing ? (
            <div className="space-y-4">
              <form.Field name="privacySettings.showEmail">
                {(field) => (
                  <ValidatedCheckbox
                    field={field}
                    label="Show my email address to team members"
                  />
                )}
              </form.Field>

              <form.Field name="privacySettings.showPhone">
                {(field) => (
                  <ValidatedCheckbox
                    field={field}
                    label="Show my phone number to team members"
                  />
                )}
              </form.Field>

              <form.Field name="privacySettings.showBirthYear">
                {(field) => (
                  <ValidatedCheckbox
                    field={field}
                    label="Show my birth year on my profile"
                  />
                )}
              </form.Field>

              <form.Field name="privacySettings.allowTeamInvitations">
                {(field) => (
                  <ValidatedCheckbox
                    field={field}
                    label="Allow team captains to send me invitations"
                  />
                )}
              </form.Field>
            </div>
          ) : (
            <div className="space-y-2">
              <p className="text-sm">
                <span className="font-medium">Email visibility:</span>{" "}
                {profile.privacySettings?.showEmail
                  ? "Visible to team members"
                  : "Hidden"}
              </p>
              <p className="text-sm">
                <span className="font-medium">Phone visibility:</span>{" "}
                {profile.privacySettings?.showPhone
                  ? "Visible to team members"
                  : "Hidden"}
              </p>
              <p className="text-sm">
                <span className="font-medium">Birth year visibility:</span>{" "}
                {profile.privacySettings?.showBirthYear ? "Visible on profile" : "Hidden"}
              </p>
              <p className="text-sm">
                <span className="font-medium">Team invitations:</span>{" "}
                {profile.privacySettings?.allowTeamInvitations !== false
                  ? "Allowed"
                  : "Not allowed"}
              </p>
            </div>
          )}
        </CardContent>
      </Card>

      {/* Profile Metadata */}
      <Card>
        <CardHeader>
          <CardTitle>Profile Information</CardTitle>
          <CardDescription>Technical details about your profile</CardDescription>
        </CardHeader>
        <CardContent className="space-y-2">
          <p className="text-sm">
            <span className="font-medium">Profile Status:</span>{" "}
            {profile.profileComplete ? "Complete" : "Incomplete"}
          </p>
          <p className="text-sm">
            <span className="font-medium">Profile Version:</span> {profile.profileVersion}
          </p>
          <p className="text-sm">
            <span className="font-medium">Last Updated:</span>{" "}
            {profile.profileUpdatedAt
              ? new Date(profile.profileUpdatedAt).toLocaleString()
              : "Never"}
          </p>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/features/teams/teams.mutations.ts">
import { createServerFn } from "@tanstack/react-start";
import { z } from "zod";
import type { TeamMemberRole, TeamMemberStatus } from "~/db/schema";
import { getAuthMiddleware, requireUser } from "~/lib/server/auth";
import { forbidden, notFound, validationError } from "~/lib/server/errors";
import { zod$ } from "~/lib/server/fn-utils";
import {
  addTeamMemberSchema,
  createTeamSchema,
  removeTeamMemberSchema,
  requestTeamMembershipSchema,
  teamInviteActionSchema,
  updateTeamMemberSchema,
  updateTeamSchema,
} from "./teams.schemas";

/**
 * Create a new team
 */
const ACTIVE_TEAM_MEMBERSHIP_CONSTRAINT = "team_members_active_user_idx";

const isActiveMembershipConstraintError = (error: unknown): boolean => {
  if (!error || typeof error !== "object") return false;

  const constraint =
    (error as { constraint?: string }).constraint ??
    (error as { constraint_name?: string }).constraint_name;
  const code = (error as { code?: string }).code;

  if (constraint === ACTIVE_TEAM_MEMBERSHIP_CONSTRAINT && code === "23505") {
    return true;
  }

  if ("cause" in error) {
    return isActiveMembershipConstraintError((error as { cause?: unknown }).cause);
  }

  return false;
};

export const createTeam = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(createTeamSchema))
  .handler(async ({ data, context }) => {
    // Import server-only modules inside the handler
    const [{ getDb }, { createId }] = await Promise.all([
      import("~/db/server-helpers"),
      import("@paralleldrive/cuid2"),
    ]);
    const { teams, teamMembers } = await import("~/db/schema");

    const user = requireUser(context);

    // Debug logging for E2E tests
    if (process.env["NODE_ENV"] === "development") {
      console.log("Creating team with user ID:", user.id);
    }

    const db = await getDb();

    // Start a transaction
    return await db.transaction(async (tx) => {
      // Create the team
      const [newTeam] = await tx
        .insert(teams)
        .values({
          id: createId(),
          name: data.name,
          slug: data.slug.toLowerCase().replace(/[^a-z0-9-]/g, "-"),
          description: data.description,
          city: data.city,
          province: data.province,
          primaryColor: data.primaryColor,
          secondaryColor: data.secondaryColor,
          foundedYear: data.foundedYear,
          website: data.website,
          socialLinks: data.socialLinks ? JSON.stringify(data.socialLinks) : null,
          createdBy: user.id,
        })
        .returning();

      // Add the creator as captain
      try {
        await tx.insert(teamMembers).values({
          id: createId(),
          teamId: newTeam.id,
          userId: user.id,
          role: "captain" as TeamMemberRole,
          status: "active" as TeamMemberStatus,
          invitedBy: user.id,
        });
      } catch (error) {
        if (isActiveMembershipConstraintError(error)) {
          throw validationError(
            "You already have an active team membership. Leave or deactivate your existing team before creating a new one.",
          );
        }

        throw error;
      }

      return newTeam;
    });
  });

/**
 * Update team details
 */
export const updateTeam = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(
    zod$(
      updateTeamSchema.extend({
        data: updateTeamSchema.shape.data.extend({
          socialLinks: z.record(z.string(), z.string()).optional(),
          logoUrl: z.string().optional(),
        }),
      }),
    ),
  )
  .handler(async ({ data, context }) => {
    // Import server-only modules inside the handler
    const [{ getDb }, { and, eq }] = await Promise.all([
      import("~/db/server-helpers"),
      import("drizzle-orm"),
    ]);
    const { teams, teamMembers } = await import("~/db/schema");

    const user = requireUser(context);

    const db = await getDb();

    // Check if user is captain or coach
    const [memberCheck] = await db
      .select({ role: teamMembers.role })
      .from(teamMembers)
      .where(
        and(
          eq(teamMembers.teamId, data.teamId),
          eq(teamMembers.userId, user.id),
          eq(teamMembers.status, "active"),
        ),
      )
      .limit(1);

    if (!memberCheck || !["captain", "coach"].includes(memberCheck.role)) {
      throw forbidden("Only captains or coaches can update team details");
    }

    // Update team
    const [updatedTeam] = await db
      .update(teams)
      .set({
        name: data.data.name,
        description: data.data.description,
        city: data.data.city,
        province: data.data.province,
        primaryColor: data.data.primaryColor,
        secondaryColor: data.data.secondaryColor,
        foundedYear: data.data.foundedYear,
        website: data.data.website,
        socialLinks: data.data.socialLinks
          ? JSON.stringify(data.data.socialLinks)
          : undefined,
        logoUrl: data.data.logoUrl,
      })
      .where(eq(teams.id, data.teamId))
      .returning();

    return updatedTeam;
  });

/**
 * Deactivate a team (soft delete)
 */
export const deactivateTeam = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(z.object({ teamId: z.string() })))
  .handler(async ({ data, context }) => {
    // Import server-only modules inside the handler
    const [{ getDb }, { and, eq }] = await Promise.all([
      import("~/db/server-helpers"),
      import("drizzle-orm"),
    ]);
    const { teams, teamMembers } = await import("~/db/schema");

    const user = requireUser(context);

    const db = await getDb();

    return await db.transaction(async (tx) => {
      // Check if user is captain
      const [memberCheck] = await tx
        .select({ role: teamMembers.role })
        .from(teamMembers)
        .where(
          and(
            eq(teamMembers.teamId, data.teamId),
            eq(teamMembers.userId, user.id),
            eq(teamMembers.status, "active"),
          ),
        )
        .limit(1);

      if (!memberCheck || memberCheck.role !== "captain") {
        throw forbidden("Only team captains can deactivate teams");
      }

      const now = new Date();

      await tx
        .update(teamMembers)
        .set({ status: "inactive", leftAt: now })
        .where(
          and(eq(teamMembers.teamId, data.teamId), eq(teamMembers.status, "active")),
        );

      const [deactivatedTeam] = await tx
        .update(teams)
        .set({ isActive: "false" })
        .where(eq(teams.id, data.teamId))
        .returning();

      return deactivatedTeam;
    });
  });

/**
 * Add a member to a team
 */
export const addTeamMember = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(addTeamMemberSchema))
  .handler(async ({ data, context }) => {
    // Import server-only modules inside the handler
    const [{ getDb }, { and, eq }, { createId }] = await Promise.all([
      import("~/db/server-helpers"),
      import("drizzle-orm"),
      import("@paralleldrive/cuid2"),
    ]);
    const { teamMembers, teams, user } = await import("~/db/schema");

    const currentUser = requireUser(context);

    const db = await getDb();

    // Check if current user has permission to add members
    const [memberCheck] = await db
      .select({ role: teamMembers.role })
      .from(teamMembers)
      .where(
        and(
          eq(teamMembers.teamId, data.teamId),
          eq(teamMembers.userId, currentUser.id),
          eq(teamMembers.status, "active"),
        ),
      )
      .limit(1);

    if (!memberCheck || !["captain", "coach"].includes(memberCheck.role)) {
      throw forbidden("Only captains and coaches can add team members");
    }

    // Find user by email
    const [targetUser] = await db
      .select({ id: user.id, email: user.email, name: user.name })
      .from(user)
      .where(eq(user.email, data.email))
      .limit(1);

    if (!targetUser) {
      throw notFound("User not found with that email address");
    }

    // Check if user is already a member
    const [existingMember] = await db
      .select({ status: teamMembers.status })
      .from(teamMembers)
      .where(
        and(eq(teamMembers.teamId, data.teamId), eq(teamMembers.userId, targetUser.id)),
      )
      .limit(1);

    if (existingMember) {
      if (existingMember.status === "active") {
        throw validationError("User is already an active member of this team");
      }
      // Reactivate if they were previously removed
      const [reactivated] = await db
        .update(teamMembers)
        .set({
          status: "pending" as TeamMemberStatus,
          invitedBy: currentUser.id,
          role: data.role,
          jerseyNumber: data.jerseyNumber,
          position: data.position,
          leftAt: null,
          invitedAt: new Date(),
          invitationReminderCount: 0,
          lastInvitationReminderAt: null,
          requestedAt: null,
        })
        .where(
          and(eq(teamMembers.teamId, data.teamId), eq(teamMembers.userId, targetUser.id)),
        )
        .returning();
      return reactivated;
    }

    // Add new member
    const [newMember] = await db
      .insert(teamMembers)
      .values({
        id: createId(),
        teamId: data.teamId,
        userId: targetUser.id,
        role: data.role,
        status: "pending" as TeamMemberStatus,
        jerseyNumber: data.jerseyNumber,
        position: data.position,
        invitedBy: currentUser.id,
        invitedAt: new Date(),
        invitationReminderCount: 0,
        lastInvitationReminderAt: null,
        requestedAt: null,
      })
      .returning();

    // Send invitation email in the background; failure shouldn't block flow
    const { sendTeamInvitationEmail } = await import("~/lib/email/sendgrid");
    if (targetUser?.email) {
      try {
        const [teamInfo] = await db
          .select({ name: teams.name, slug: teams.slug })
          .from(teams)
          .where(eq(teams.id, data.teamId))
          .limit(1);

        await sendTeamInvitationEmail({
          to: {
            email: targetUser.email,
            name: targetUser.name ?? undefined,
          },
          teamName: teamInfo?.name ?? "Quadball Canada Team",
          teamSlug: teamInfo?.slug ?? data.teamId,
          role: data.role,
          invitedByName: currentUser.name ?? undefined,
          invitedByEmail: currentUser.email ?? undefined,
        });
      } catch (error) {
        console.error("Failed to send team invitation email", error);
      }
    }

    return newMember;
  });

/**
 * Update team member details
 */
export const updateTeamMember = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(updateTeamMemberSchema))
  .handler(async ({ data, context }) => {
    // Import server-only modules inside the handler
    const [{ getDb }, { and, eq, sql }] = await Promise.all([
      import("~/db/server-helpers"),
      import("drizzle-orm"),
    ]);
    const { teamMembers } = await import("~/db/schema");

    const currentUser = requireUser(context);

    const db = await getDb();

    // Check if current user has permission
    const [memberCheck] = await db
      .select({ role: teamMembers.role })
      .from(teamMembers)
      .where(
        and(
          eq(teamMembers.teamId, data.teamId),
          eq(teamMembers.userId, currentUser.id),
          eq(teamMembers.status, "active"),
        ),
      )
      .limit(1);

    if (!memberCheck || !["captain", "coach"].includes(memberCheck.role)) {
      throw forbidden("Only captains and coaches can update team members");
    }

    // Don't allow demoting the last captain
    if (data.role && data.role !== "captain") {
      const [targetMember] = await db
        .select({ role: teamMembers.role })
        .from(teamMembers)
        .where(eq(teamMembers.id, data.memberId))
        .limit(1);

      if (targetMember?.role === "captain") {
        const [captainCount] = await db
          .select({ count: sql<number>`count(*)::int` })
          .from(teamMembers)
          .where(
            and(
              eq(teamMembers.teamId, data.teamId),
              eq(teamMembers.role, "captain"),
              eq(teamMembers.status, "active"),
            ),
          );
        const totalCaptains = captainCount?.count ?? 0;
        if (totalCaptains <= 1) {
          throw validationError("Cannot demote the last captain");
        }
      }
    }

    // Update member
    const [updatedMember] = await db
      .update(teamMembers)
      .set({
        role: data.role,
        jerseyNumber: data.jerseyNumber,
        position: data.position,
        notes: data.notes,
      })
      .where(eq(teamMembers.id, data.memberId))
      .returning();

    return updatedMember;
  });

/**
 * Remove a member from team
 */
export const removeTeamMember = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(removeTeamMemberSchema))
  .handler(async ({ data, context }) => {
    // Import server-only modules inside the handler
    const [{ getDb }, { and, eq, sql }] = await Promise.all([
      import("~/db/server-helpers"),
      import("drizzle-orm"),
    ]);
    const { teamMembers } = await import("~/db/schema");

    const currentUser = requireUser(context);

    const db = await getDb();

    // Check if current user has permission
    const [memberCheck] = await db
      .select({ role: teamMembers.role })
      .from(teamMembers)
      .where(
        and(
          eq(teamMembers.teamId, data.teamId),
          eq(teamMembers.userId, currentUser.id),
          eq(teamMembers.status, "active"),
        ),
      )
      .limit(1);

    if (!memberCheck || !["captain", "coach"].includes(memberCheck.role)) {
      throw forbidden("Only captains and coaches can remove team members");
    }

    // Don't allow removing the last captain
    const [targetMember] = await db
      .select({ role: teamMembers.role })
      .from(teamMembers)
      .where(eq(teamMembers.id, data.memberId))
      .limit(1);

    if (targetMember?.role === "captain") {
      const [captainCount] = await db
        .select({ count: sql<number>`count(*)::int` })
        .from(teamMembers)
        .where(
          and(
            eq(teamMembers.teamId, data.teamId),
            eq(teamMembers.role, "captain"),
            eq(teamMembers.status, "active"),
          ),
        );
      const totalCaptains = captainCount?.count ?? 0;
      if (totalCaptains <= 1) {
        throw validationError("Cannot remove the last captain");
      }
    }

    // Soft delete by updating status
    const [removedMember] = await db
      .update(teamMembers)
      .set({
        status: "inactive" as TeamMemberStatus,
        leftAt: new Date(),
      })
      .where(eq(teamMembers.id, data.memberId))
      .returning();

    return removedMember;
  });

/**
 * Accept a team invite
 */
export const acceptTeamInvite = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(teamInviteActionSchema))
  .handler(async ({ data, context }) => {
    // Import server-only modules inside the handler
    const [{ getDb }, { and, eq }] = await Promise.all([
      import("~/db/server-helpers"),
      import("drizzle-orm"),
    ]);
    const { teamMembers } = await import("~/db/schema");

    const currentUser = requireUser(context);

    const db = await getDb();

    // Update membership status
    const [updatedMember] = await db
      .update(teamMembers)
      .set({
        status: "active" as TeamMemberStatus,
        joinedAt: new Date(),
        requestedAt: null,
      })
      .where(
        and(
          eq(teamMembers.teamId, data.teamId),
          eq(teamMembers.userId, currentUser.id),
          eq(teamMembers.status, "pending"),
        ),
      )
      .returning();

    if (!updatedMember) {
      throw notFound("No pending invite found for this team");
    }

    return updatedMember;
  });

/**
 * Decline a team invite
 */
export const declineTeamInvite = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(teamInviteActionSchema))
  .handler(async ({ data, context }) => {
    // Import server-only modules inside the handler
    const [{ getDb }, { and, eq }] = await Promise.all([
      import("~/db/server-helpers"),
      import("drizzle-orm"),
    ]);
    const { teamMembers } = await import("~/db/schema");

    const currentUser = requireUser(context);

    const db = await getDb();

    // Update membership status
    const [declinedMember] = await db
      .update(teamMembers)
      .set({
        status: "inactive" as TeamMemberStatus,
        leftAt: new Date(),
        requestedAt: null,
      })
      .where(
        and(
          eq(teamMembers.teamId, data.teamId),
          eq(teamMembers.userId, currentUser.id),
          eq(teamMembers.status, "pending"),
        ),
      )
      .returning();

    if (!declinedMember) {
      throw notFound("No pending invite found for this team");
    }

    return declinedMember;
  });

export const requestTeamMembership = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(requestTeamMembershipSchema))
  .handler(async ({ data, context }) => {
    const [{ getDb }, { and, eq }, { createId }] = await Promise.all([
      import("~/db/server-helpers"),
      import("drizzle-orm"),
      import("@paralleldrive/cuid2"),
    ]);
    const { teamMembers } = await import("~/db/schema");

    const currentUser = requireUser(context);

    const db = await getDb();

    const [existingMember] = await db
      .select({
        id: teamMembers.id,
        status: teamMembers.status,
        invitedBy: teamMembers.invitedBy,
      })
      .from(teamMembers)
      .where(
        and(eq(teamMembers.teamId, data.teamId), eq(teamMembers.userId, currentUser.id)),
      )
      .limit(1);

    if (existingMember) {
      if (existingMember.status === "active") {
        throw validationError("You are already an active member of this team");
      }

      if (existingMember.status === "pending") {
        if (existingMember.invitedBy) {
          throw validationError("You already have a pending invitation for this team");
        }

        const [refreshedMember] = await db
          .update(teamMembers)
          .set({
            requestedAt: new Date(),
            invitationReminderCount: 0,
            lastInvitationReminderAt: null,
          })
          .where(eq(teamMembers.id, existingMember.id))
          .returning();

        return refreshedMember;
      }

      const [reactivatedMember] = await db
        .update(teamMembers)
        .set({
          status: "pending" as TeamMemberStatus,
          invitedBy: null,
          requestedAt: new Date(),
          invitedAt: null,
          invitationReminderCount: 0,
          lastInvitationReminderAt: null,
          leftAt: null,
        })
        .where(eq(teamMembers.id, existingMember.id))
        .returning();

      return reactivatedMember;
    }

    const [newRequest] = await db
      .insert(teamMembers)
      .values({
        id: createId(),
        teamId: data.teamId,
        userId: currentUser.id,
        role: "player" as TeamMemberRole,
        status: "pending" as TeamMemberStatus,
        invitedBy: null,
        requestedAt: new Date(),
        invitationReminderCount: 0,
        lastInvitationReminderAt: null,
      })
      .returning();

    return newRequest;
  });

/**
 * Leave a team voluntarily
 */
export const leaveTeam = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(z.object({ teamId: z.string() })))
  .handler(async ({ data, context }) => {
    // Import server-only modules inside the handler
    const [{ getDb }, { and, eq, sql }] = await Promise.all([
      import("~/db/server-helpers"),
      import("drizzle-orm"),
    ]);
    const { teamMembers } = await import("~/db/schema");

    const currentUser = requireUser(context);

    const db = await getDb();

    // Check membership
    const [member] = await db
      .select({ role: teamMembers.role })
      .from(teamMembers)
      .where(
        and(
          eq(teamMembers.teamId, data.teamId),
          eq(teamMembers.userId, currentUser.id),
          eq(teamMembers.status, "active"),
        ),
      )
      .limit(1);

    if (!member) {
      throw notFound("You are not an active member of this team");
    }

    // Don't allow the last captain to leave
    if (member.role === "captain") {
      const [captainCount] = await db
        .select({ count: sql<number>`count(*)::int` })
        .from(teamMembers)
        .where(
          and(
            eq(teamMembers.teamId, data.teamId),
            eq(teamMembers.role, "captain"),
            eq(teamMembers.status, "active"),
          ),
        );
      const totalCaptains = captainCount?.count ?? 0;
      if (totalCaptains <= 1) {
        throw validationError(
          "Cannot leave team as the last captain. Promote another member first.",
        );
      }
    }

    // Update membership status
    const [leftMember] = await db
      .update(teamMembers)
      .set({
        status: "inactive" as TeamMemberStatus,
        leftAt: new Date(),
      })
      .where(
        and(eq(teamMembers.teamId, data.teamId), eq(teamMembers.userId, currentUser.id)),
      )
      .returning();

    return leftMember;
  });
</file>

<file path="src/routes/dashboard/teams/index.tsx">
import { useSuspenseQuery } from "@tanstack/react-query";
import { createFileRoute } from "@tanstack/react-router";
import { TypedLink as Link } from "~/components/ui/TypedLink";
import { Badge } from "~/components/ui/badge";
import { Button } from "~/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";
import { LoaderIcon, PlusIcon, UsersIcon } from "~/components/ui/icons";
import { TeamInvitationsSection } from "~/features/teams/components/team-invitations";
import type { PendingTeamInvite, UserTeam } from "~/features/teams/teams.queries";
import { getPendingTeamInvites, getUserTeams } from "~/features/teams/teams.queries";

export const Route = createFileRoute("/dashboard/teams/")({
  loader: async () => {
    const userTeams = (await getUserTeams()) as UserTeam[];
    const pendingInvites = (await getPendingTeamInvites()) as PendingTeamInvite[];
    return { userTeams, pendingInvites };
  },
  component: TeamsIndexPage,
});

function TeamsIndexPage() {
  const loaderData = Route.useLoaderData() as {
    userTeams: UserTeam[];
    pendingInvites: PendingTeamInvite[];
  };
  const initialTeams = loaderData.userTeams as UserTeam[];
  const initialInvites = loaderData.pendingInvites as PendingTeamInvite[];

  const { data: userTeams, isFetching: isFetchingTeams } = useSuspenseQuery<UserTeam[]>({
    queryKey: ["userTeams"],
    queryFn: async () => getUserTeams() as Promise<UserTeam[]>,
    initialData: () => initialTeams,
  });

  const { data: pendingInvites, isFetching: isFetchingInvites } = useSuspenseQuery<
    PendingTeamInvite[]
  >({
    queryKey: ["pendingTeamInvites"],
    queryFn: async () => getPendingTeamInvites() as Promise<PendingTeamInvite[]>,
    initialData: () => initialInvites,
  });

  const pendingCount = pendingInvites.length;
  const isRefreshing = isFetchingTeams || isFetchingInvites;

  return (
    <div className="container mx-auto p-6">
      <div className="mb-8 flex items-center justify-between">
        <div>
          <div className="flex items-center gap-3">
            <h1 className="text-3xl font-bold">My Teams</h1>
            {pendingCount > 0 && (
              <Badge variant="secondary" className="text-xs uppercase">
                {pendingCount} pending invite{pendingCount > 1 ? "s" : ""}
              </Badge>
            )}
          </div>
          <p className="text-muted-foreground">Manage your teams and memberships</p>
        </div>
        <Button asChild>
          <Link to="/dashboard/teams/create">
            <PlusIcon className="mr-2 h-4 w-4" />
            Create Team
          </Link>
        </Button>
      </div>

      <div className="space-y-6">
        {isRefreshing && (
          <div className="bg-brand-red/5 text-brand-red flex items-center gap-2 rounded-lg px-4 py-2 text-xs font-semibold tracking-wider uppercase">
            <LoaderIcon className="h-4 w-4 animate-spin" /> Refreshing team dataâ¦
          </div>
        )}

        {pendingCount > 0 && <TeamInvitationsSection invites={pendingInvites} />}

        {userTeams.length === 0 ? (
          <Card>
            <CardContent className="flex flex-col items-center justify-center py-12">
              <UsersIcon className="text-muted-foreground mb-4 h-12 w-12" />
              <h3 className="mb-2 text-lg font-semibold">No teams yet</h3>
              <p className="text-muted-foreground mb-4 text-center">
                Join an existing team or create your own to get started
              </p>
              <div className="flex gap-4">
                <Button asChild variant="outline">
                  <Link to="/dashboard/teams/browse">Browse Teams</Link>
                </Button>
                <Button asChild>
                  <Link to="/dashboard/teams/create">
                    <PlusIcon className="mr-2 h-4 w-4" />
                    Create Team
                  </Link>
                </Button>
              </div>
            </CardContent>
          </Card>
        ) : (
          <>
            <div className="mb-4 flex justify-end">
              <Button asChild variant="outline">
                <Link to="/dashboard/teams/browse">Browse All Teams</Link>
              </Button>
            </div>
            <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
              {userTeams.map((userTeam) => (
                <TeamCard key={userTeam.team.id} userTeam={userTeam} />
              ))}
            </div>
          </>
        )}
      </div>
    </div>
  );
}

function TeamCard({ userTeam }: { userTeam: UserTeam }) {
  const { team, membership, memberCount } = userTeam;

  return (
    <Card className="transition-shadow hover:shadow-lg">
      <CardHeader>
        <div className="flex items-start justify-between">
          <div>
            <CardTitle className="text-xl">{team.name}</CardTitle>
            {team.city && (
              <CardDescription>
                {team.city}
                {team.province ? `, ${team.province}` : ""}
              </CardDescription>
            )}
          </div>
          {team.primaryColor && (
            <div
              className="h-8 w-8 rounded-full border"
              style={{ backgroundColor: team.primaryColor }}
            />
          )}
        </div>
      </CardHeader>
      <CardContent>
        <div className="space-y-2 text-sm">
          <div className="flex items-center justify-between">
            <span className="text-muted-foreground">Role</span>
            <span className="font-medium capitalize">{membership.role}</span>
          </div>
          <div className="flex items-center justify-between">
            <span className="text-muted-foreground">Members</span>
            <span className="font-medium">{memberCount}</span>
          </div>
          {membership.jerseyNumber && (
            <div className="flex items-center justify-between">
              <span className="text-muted-foreground">Jersey #</span>
              <span className="font-medium">{membership.jerseyNumber}</span>
            </div>
          )}
          {membership.position && (
            <div className="flex items-center justify-between">
              <span className="text-muted-foreground">Position</span>
              <span className="font-medium">{membership.position}</span>
            </div>
          )}
        </div>
        <div className="mt-4 flex gap-2">
          <Button asChild variant="outline" size="sm" className="flex-1">
            <Link to="/dashboard/teams/$teamId" params={{ teamId: team.id }}>
              View Team
            </Link>
          </Button>
          {["captain", "coach"].includes(membership.role) && (
            <Button asChild variant="outline" size="sm" className="flex-1">
              <Link to="/dashboard/teams/$teamId/manage" params={{ teamId: team.id }}>
                Manage
              </Link>
            </Button>
          )}
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/routes/index.tsx">
import { createFileRoute, useNavigate, useRouteContext } from "@tanstack/react-router";
import { useEffect } from "react";
import { PublicPortalPage } from "~/features/dashboard";

export const Route = createFileRoute("/")({
  component: HomePage,
});

function HomePage() {
  const { user } = useRouteContext({ from: "__root__" });
  const navigate = useNavigate();

  useEffect(() => {
    if (user) {
      navigate({ to: "/dashboard", replace: true });
    }
  }, [navigate, user]);

  if (user) {
    return (
      <div className="flex min-h-screen items-center justify-center bg-gray-50 px-4">
        <p className="text-muted-foreground text-sm">Redirecting to your dashboard...</p>
      </div>
    );
  }

  return <PublicPortalPage />;
}
</file>

<file path="src/features/membership/membership.mutations.ts">
import { createServerFn } from "@tanstack/react-start";
import { and, eq, gte, sql } from "drizzle-orm";
import { membershipPaymentSessions, memberships, membershipTypes } from "~/db/schema";
import { atomicJsonbMerge } from "~/lib/db/jsonb-utils";
import { getAuthMiddleware, requireUser } from "~/lib/server/auth";
import { zod$ } from "~/lib/server/fn-utils";
import type { MembershipMetadata } from "./membership.db-types";
import {
  confirmMembershipPurchaseSchema,
  purchaseMembershipSchema,
} from "./membership.schemas";
import type {
  CheckoutSessionResult,
  Membership,
  MembershipOperationResult,
} from "./membership.types";

// Helper to cast membership jsonb fields
function castMembershipJsonbFields(
  membership: typeof memberships.$inferSelect,
): Membership {
  return {
    ...membership,
    metadata: (membership.metadata || {}) as MembershipMetadata,
  } as Membership;
}

const RETRYABLE_PAYMENT_ERROR_PATTERNS = [/pending/i, /not available/i, /processing/i];

function isRetryablePaymentError(message: string | undefined): boolean {
  if (!message) return false;
  return RETRYABLE_PAYMENT_ERROR_PATTERNS.some((pattern) => pattern.test(message));
}

async function wait(ms: number) {
  await new Promise((resolve) => setTimeout(resolve, ms));
}

const getSquarePaymentService = async () => {
  const { squarePaymentService } = await import("~/lib/payments/square");
  return squarePaymentService;
};

/**
 * Create a checkout session for membership purchase
 */
export const createCheckoutSession = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(purchaseMembershipSchema.omit({ autoRenew: true })))
  .handler(
    async ({
      data,
      context,
    }): Promise<MembershipOperationResult<CheckoutSessionResult>> => {
      try {
        // Import server-only modules inside the handler
        const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);

        const db = await getDb();
        const user = requireUser(context);

        // Verify membership type exists and is active

        const [membershipType] = await db
          .select()
          .from(membershipTypes)
          .where(
            and(
              eq(membershipTypes.id, data.membershipTypeId),
              eq(membershipTypes.status, "active"),
            ),
          )
          .limit(1);

        if (!membershipType) {
          return {
            success: false,
            errors: [
              {
                code: "NOT_FOUND",
                message: "Membership type not found or inactive",
              },
            ],
          };
        }

        // Check if user already has an active, unexpired membership
        // Must check both status AND date to allow renewal of expired memberships
        const [existingMembership] = await db
          .select()
          .from(memberships)
          .where(
            and(
              eq(memberships.userId, user.id),
              eq(memberships.status, "active"),
              gte(memberships.endDate, sql`CURRENT_DATE`),
            ),
          )
          .limit(1);

        if (existingMembership) {
          return {
            success: false,
            errors: [
              {
                code: "VALIDATION_ERROR",
                message: "User already has an active membership",
              },
            ],
          };
        }

        // Create checkout session with Square
        const squarePaymentService = await getSquarePaymentService();
        const checkoutSession = await squarePaymentService.createCheckoutSession(
          membershipType.id,
          user.id,
          membershipType.priceCents,
        );

        await db
          .insert(membershipPaymentSessions)
          .values({
            userId: user.id,
            membershipTypeId: membershipType.id,
            squareCheckoutId: checkoutSession.id,
            squarePaymentLinkUrl: checkoutSession.checkoutUrl,
            squareOrderId: checkoutSession.orderId || null,
            amountCents: membershipType.priceCents,
            currency: checkoutSession.currency,
            expiresAt: checkoutSession.expiresAt ?? null,
            metadata: {
              membershipName: membershipType.name,
              squareOrderId: checkoutSession.orderId || null,
            },
          })
          .onConflictDoUpdate({
            target: membershipPaymentSessions.squareCheckoutId,
            set: {
              membershipTypeId: membershipType.id,
              squarePaymentLinkUrl: checkoutSession.checkoutUrl,
              squareOrderId: checkoutSession.orderId || null,
              amountCents: membershipType.priceCents,
              currency: checkoutSession.currency,
              expiresAt: checkoutSession.expiresAt ?? null,
              metadata: {
                membershipName: membershipType.name,
                squareOrderId: checkoutSession.orderId || null,
              },
              updatedAt: new Date(),
            },
          });

        return {
          success: true,
          data: {
            checkoutUrl: checkoutSession.checkoutUrl,
            sessionId: checkoutSession.id,
          },
        };
      } catch (error) {
        console.error("Error creating checkout session:", error);
        return {
          success: false,
          errors: [
            {
              code: "PAYMENT_ERROR",
              message: "Failed to create checkout session",
            },
          ],
        };
      }
    },
  );

/**
 * Confirm membership purchase after payment
 */
export const confirmMembershipPurchase = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(confirmMembershipPurchaseSchema))
  .handler(async ({ data, context }): Promise<MembershipOperationResult<Membership>> => {
    try {
      // Import server-only modules inside the handler
      const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);

      const db = await getDb();
      const user = requireUser(context);

      // Look up the stored payment session
      const [paymentSession] = await db
        .select()
        .from(membershipPaymentSessions)
        .where(eq(membershipPaymentSessions.squareCheckoutId, data.sessionId))
        .limit(1);

      if (!paymentSession) {
        return {
          success: false,
          errors: [
            {
              code: "NOT_FOUND",
              message: "Checkout session not found",
            },
          ],
        };
      }

      if (paymentSession.userId !== user.id) {
        return {
          success: false,
          errors: [
            {
              code: "VALIDATION_ERROR",
              message: "Payment session does not belong to user",
            },
          ],
        };
      }

      if (data.membershipTypeId !== paymentSession.membershipTypeId) {
        return {
          success: false,
          errors: [
            {
              code: "VALIDATION_ERROR",
              message: "Membership type mismatch",
            },
          ],
        };
      }

      if (paymentSession.status === "completed" && paymentSession.squarePaymentId) {
        const [existingMembershipByPayment] = await db
          .select()
          .from(memberships)
          .where(eq(memberships.paymentId, paymentSession.squarePaymentId))
          .limit(1);

        if (existingMembershipByPayment) {
          return {
            success: true,
            data: castMembershipJsonbFields(existingMembershipByPayment),
          };
        }
      }

      // Verify payment with Square
      const squarePaymentService = await getSquarePaymentService();
      let paymentResult = await squarePaymentService.verifyPayment(
        paymentSession.squareCheckoutId,
        data.paymentId ?? paymentSession.squarePaymentId ?? undefined,
      );

      let retryAttempts = 0;
      const maxRetryAttempts = 2;

      while (
        !paymentResult.success &&
        retryAttempts < maxRetryAttempts &&
        isRetryablePaymentError(paymentResult.error)
      ) {
        retryAttempts += 1;
        await wait(750 * retryAttempts);

        const [latestSession] = await db
          .select()
          .from(membershipPaymentSessions)
          .where(eq(membershipPaymentSessions.id, paymentSession.id))
          .limit(1);

        if (
          latestSession &&
          latestSession.status === "completed" &&
          latestSession.squarePaymentId
        ) {
          paymentResult = {
            success: true,
            paymentId: latestSession.squarePaymentId,
            orderId: latestSession.squareOrderId,
            status: "COMPLETED",
            amount: latestSession.amountCents,
            currency: latestSession.currency,
          };
          break;
        }

        paymentResult = await squarePaymentService.verifyPayment(
          paymentSession.squareCheckoutId,
          data.paymentId ?? paymentSession.squarePaymentId ?? undefined,
        );
      }

      if (!paymentResult.success) {
        const now = new Date();
        await db
          .update(membershipPaymentSessions)
          .set({
            status: paymentSession.status === "completed" ? "completed" : "failed",
            metadata: atomicJsonbMerge(membershipPaymentSessions.metadata, {
              lastError: paymentResult.error || "Payment verification failed",
              lastErrorAt: now.toISOString(),
              retryAttempts,
            }),
            updatedAt: now,
          })
          .where(eq(membershipPaymentSessions.id, paymentSession.id));

        return {
          success: false,
          errors: [
            {
              code: "PAYMENT_ERROR",
              message: paymentResult.error || "Payment verification failed",
            },
          ],
        };
      }

      const squarePaymentId =
        paymentResult.paymentId ?? data.paymentId ?? paymentSession.squarePaymentId;

      if (!squarePaymentId) {
        return {
          success: false,
          errors: [
            {
              code: "PAYMENT_ERROR",
              message: "Missing payment identifier",
            },
          ],
        };
      }

      // Get membership type details

      const [membershipType] = await db
        .select()
        .from(membershipTypes)
        .where(eq(membershipTypes.id, data.membershipTypeId))
        .limit(1);

      if (!membershipType) {
        return {
          success: false,
          errors: [
            {
              code: "NOT_FOUND",
              message: "Membership type not found",
            },
          ],
        };
      }

      if (
        typeof paymentResult.amount === "number" &&
        paymentResult.amount !== membershipType.priceCents
      ) {
        return {
          success: false,
          errors: [
            {
              code: "PAYMENT_ERROR",
              message: "Payment amount does not match membership price",
            },
          ],
        };
      }

      if (paymentResult.currency && paymentResult.currency !== "CAD") {
        return {
          success: false,
          errors: [
            {
              code: "PAYMENT_ERROR",
              message: "Payment currency is not supported",
            },
          ],
        };
      }

      const now = new Date();
      const { finalizeMembershipForSession } = await import("./membership.finalize");
      const finalizeResult = await finalizeMembershipForSession({
        db,
        paymentSession,
        membershipType,
        paymentId: squarePaymentId,
        orderId: paymentResult.orderId ?? paymentSession.squareOrderId ?? null,
        sessionId: data.sessionId,
        now,
      });

      const confirmedMembership = finalizeResult.membership;
      const membershipWasCreated = finalizeResult.wasCreated;

      // Send confirmation email
      if (membershipWasCreated) {
        try {
          const { sendMembershipPurchaseReceipt } = await import("~/lib/email/sendgrid");

          await sendMembershipPurchaseReceipt({
            to: {
              email: user.email,
              name: user.name || undefined,
            },
            membershipType: membershipType.name,
            amount: membershipType.priceCents,
            paymentId: squarePaymentId,
            expiresAt: new Date(confirmedMembership.endDate),
          });
        } catch (emailError) {
          // Log error but don't fail the purchase
          console.error("Failed to send confirmation email:", emailError);
        }
      }

      return {
        success: true,
        data: castMembershipJsonbFields(
          confirmedMembership as typeof memberships.$inferSelect,
        ),
      };
    } catch (error) {
      console.error("Error confirming membership purchase:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to create membership record",
          },
        ],
      };
    }
  });
</file>

<file path="src/routes/dashboard/membership.tsx">
import { useQuery } from "@tanstack/react-query";
import { createFileRoute } from "@tanstack/react-router";
import { AlertCircle, Loader2 } from "lucide-react";
import { useCallback, useEffect, useState } from "react";
import { toast } from "sonner";
import { Alert, AlertDescription, AlertTitle } from "~/components/ui/alert";
import { Button } from "~/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";
import {
  clearPaymentParams,
  getPaymentErrorMessage,
  usePaymentReturn,
} from "~/features/membership/hooks/usePaymentReturn";
import {
  confirmMembershipPurchase,
  createCheckoutSession,
} from "~/features/membership/membership.mutations";
import {
  getUserMembershipStatus,
  listMembershipTypes,
} from "~/features/membership/membership.queries";
import { unwrapServerFnResult } from "~/lib/server/fn-utils";

export const Route = createFileRoute("/dashboard/membership")({
  component: MembershipPage,
});

function MembershipPage() {
  const [processingPayment, setProcessingPayment] = useState(false);
  const paymentReturn = usePaymentReturn();
  const [hasProcessedReturn, setHasProcessedReturn] = useState(false);

  const membershipStatusQuery = useQuery({
    queryKey: ["membership-status"],
    queryFn: async () => {
      const result = await getUserMembershipStatus();
      if (!result.success) {
        throw new Error(
          result.errors?.[0]?.message || "Failed to fetch membership status",
        );
      }
      return result.data || null;
    },
  });

  const { refetch: refetchMembershipStatus } = membershipStatusQuery;

  const membershipTypesQuery = useQuery({
    queryKey: ["membership-types"],
    queryFn: async () => {
      const result = await listMembershipTypes();
      if (!result.success) {
        throw new Error(
          result.errors?.[0]?.message || "Failed to fetch membership types",
        );
      }
      return result.data || [];
    },
  });

  const squareStatusQuery = useQuery({
    queryKey: ["square-status"],
    queryFn: async () => {
      const response = await fetch("/api/health");
      if (!response.ok) {
        throw new Error("Failed to load payment status");
      }
      const data = (await response.json()) as {
        services?: { square?: { environment?: string } };
      };
      return data.services?.square ?? null;
    },
    staleTime: 60_000,
    retry: false,
    enabled: typeof window !== "undefined",
  });

  const confirmPurchase = useCallback(
    async (sessionId: string, membershipTypeId: string, paymentId: string) => {
      setProcessingPayment(true);
      try {
        const result = await unwrapServerFnResult(
          confirmMembershipPurchase({
            data: {
              membershipTypeId,
              sessionId,
              paymentId,
            },
          }),
        );

        if (result.success) {
          toast.success("Membership purchased successfully!");
          clearPaymentParams();
          await refetchMembershipStatus();
        } else {
          toast.error(result.errors?.[0]?.message || "Failed to confirm membership");
        }
      } catch (error) {
        console.error("Error confirming membership:", error);
        toast.error("Failed to confirm membership purchase");
      } finally {
        setProcessingPayment(false);
      }
    },
    [refetchMembershipStatus],
  );

  const handleMockPaymentReturn = useCallback(
    async (sessionId: string, membershipTypeId: string) => {
      await confirmPurchase(sessionId, membershipTypeId, `mock_payment_${Date.now()}`);
    },
    [confirmPurchase],
  );

  // Process payment return if needed
  const processPaymentReturn = useCallback(async () => {
    if (hasProcessedReturn) return;

    // Handle mock checkout
    if (paymentReturn.isMockCheckout && paymentReturn.sessionId) {
      if (!paymentReturn.membershipTypeId) {
        setHasProcessedReturn(true);
        toast.error("Missing membership type for checkout session");
        clearPaymentParams();
        return;
      }

      setHasProcessedReturn(true);
      await handleMockPaymentReturn(
        paymentReturn.sessionId,
        paymentReturn.membershipTypeId || "",
      );
    }
    // Handle real Square success
    else if (paymentReturn.success && paymentReturn.paymentId) {
      if (!paymentReturn.sessionId || !paymentReturn.membershipTypeId) {
        setHasProcessedReturn(true);
        toast.error("Missing checkout information. Please contact support.");
        clearPaymentParams();
        return;
      }

      setHasProcessedReturn(true);
      await confirmPurchase(
        paymentReturn.sessionId,
        paymentReturn.membershipTypeId,
        paymentReturn.paymentId,
      );
    }
    // Handle errors
    else if (paymentReturn.error) {
      setHasProcessedReturn(true);
      const errorMessage = getPaymentErrorMessage(paymentReturn.error);
      if (errorMessage) toast.error(errorMessage);
      clearPaymentParams();
    }
  }, [hasProcessedReturn, paymentReturn, handleMockPaymentReturn, confirmPurchase]);

  // Process payment return using useEffect
  useEffect(() => {
    if (
      !hasProcessedReturn &&
      (paymentReturn.isMockCheckout || paymentReturn.success || paymentReturn.error) &&
      (paymentReturn.sessionId || paymentReturn.paymentId || paymentReturn.error)
    ) {
      processPaymentReturn();
    }
  }, [paymentReturn, hasProcessedReturn, processPaymentReturn]);

  const handlePurchase = async (membershipTypeId: string) => {
    try {
      const result = await unwrapServerFnResult(
        createCheckoutSession({
          data: { membershipTypeId },
        }),
      );
      if (result.success && result.data) {
        // Redirect to checkout URL
        window.location.href = result.data.checkoutUrl;
      } else {
        toast.error(result.errors?.[0]?.message || "Failed to create checkout session");
      }
    } catch (error) {
      console.error("Error creating checkout session:", error);
      toast.error("Failed to create checkout session");
    }
  };

  if (membershipStatusQuery.isLoading || membershipTypesQuery.isLoading) {
    return (
      <div className="flex min-h-[400px] items-center justify-center">
        <Loader2 className="h-8 w-8 animate-spin" />
      </div>
    );
  }

  if (membershipStatusQuery.error || membershipTypesQuery.error) {
    return (
      <div className="container mx-auto py-8">
        <Card className="border-destructive">
          <CardHeader>
            <CardTitle>Error</CardTitle>
            <CardDescription>
              {membershipStatusQuery.error?.message ||
                membershipTypesQuery.error?.message}
            </CardDescription>
          </CardHeader>
        </Card>
      </div>
    );
  }

  const membershipStatus = membershipStatusQuery.data;
  const membershipTypes = membershipTypesQuery.data || [];
  const isSandbox = squareStatusQuery.data?.environment === "sandbox";

  if (processingPayment) {
    return (
      <div className="container mx-auto py-8">
        <Card>
          <CardContent className="pt-6">
            <div className="flex flex-col items-center justify-center space-y-4">
              <Loader2 className="h-8 w-8 animate-spin" />
              <p>Processing your payment...</p>
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className="container mx-auto py-8">
      <h1 className="mb-8 text-3xl font-bold">Membership</h1>
      <p className="text-muted-foreground mb-6">
        Join Quadball Canada and access exclusive member benefits
      </p>

      {isSandbox ? (
        <Alert className="mb-6 border-amber-200 bg-amber-50 text-amber-900">
          <AlertCircle className="text-amber-700" />
          <AlertTitle>Sandbox payments enabled</AlertTitle>
          <AlertDescription>
            Purchases are running in Square sandbox mode. Use test credentials only.
          </AlertDescription>
        </Alert>
      ) : null}

      {/* Current Membership Status */}
      <Card className="mb-8">
        <CardHeader>
          <CardTitle>Current Status</CardTitle>
        </CardHeader>
        <CardContent>
          {membershipStatus?.hasMembership ? (
            <div className="space-y-2">
              <p className="text-lg font-semibold text-green-600 dark:text-green-400">
                Active Membership
              </p>
              <p className="text-muted-foreground text-sm">
                Type: {membershipStatus.currentMembership?.membershipType.name}
              </p>
              <p className="text-muted-foreground text-sm">
                Expires:{" "}
                {membershipStatus.currentMembership
                  ? new Date(
                      membershipStatus.currentMembership.endDate,
                    ).toLocaleDateString()
                  : "N/A"}
              </p>
              {membershipStatus.daysRemaining != null &&
                membershipStatus.daysRemaining > 0 && (
                  <p className="text-muted-foreground text-sm">
                    Days Remaining: {membershipStatus.daysRemaining}
                  </p>
                )}
            </div>
          ) : (
            <div>
              <p className="text-lg font-semibold">No Active Membership</p>
              <p className="text-muted-foreground text-sm">
                Join today to participate in events and access member benefits
              </p>
            </div>
          )}
        </CardContent>
      </Card>

      {/* Available Memberships */}
      <div>
        <h2 className="mb-4 text-2xl font-bold">Available Memberships</h2>
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
          {membershipTypes.map((type) => {
            const isCurrent =
              membershipStatus?.currentMembership?.membershipType.id === type.id;
            const canPurchase =
              !membershipStatus?.hasMembership ||
              (membershipStatus.daysRemaining ?? 0) <= 30;

            return (
              <Card key={type.id}>
                <CardHeader>
                  <CardTitle>{type.name}</CardTitle>
                  <CardDescription>${(type.priceCents / 100).toFixed(2)}</CardDescription>
                </CardHeader>
                <CardContent>
                  <p className="text-muted-foreground text-sm">{type.description}</p>
                </CardContent>
                <CardFooter>
                  {isCurrent ? (
                    <Button className="w-full" disabled>
                      Current Plan
                    </Button>
                  ) : canPurchase ? (
                    <Button
                      className="w-full"
                      onClick={() => handlePurchase(type.id)}
                      disabled={processingPayment}
                    >
                      {membershipStatus?.hasMembership &&
                      (membershipStatus.daysRemaining ?? 0) <= 30
                        ? "Renew"
                        : "Purchase"}
                    </Button>
                  ) : (
                    <Button className="w-full" disabled>
                      Not Available
                    </Button>
                  )}
                </CardFooter>
              </Card>
            );
          })}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/features/auth/components/login.tsx">
import { useQueryClient } from "@tanstack/react-query";
import { useNavigate, useRouter } from "@tanstack/react-router";
import { useEffect, useState } from "react";
import { z } from "zod";
import { FormSubmitButton } from "~/components/form-fields/FormSubmitButton";
import { ValidatedInput } from "~/components/form-fields/ValidatedInput";
import { Button } from "~/components/ui/button";
import { GoogleIcon, LogoIcon } from "~/components/ui/icons";
import { SafeLink as Link } from "~/components/ui/SafeLink";
import { auth } from "~/lib/auth-client";
import { useAppForm } from "~/lib/hooks/useAppForm";
import { authQueryKey } from "../auth.queries";
import { loginFormSchema } from "../auth.schemas";

type LoginFormProps = {
  redirectPath?: string | undefined;
};

export default function LoginForm(props?: LoginFormProps) {
  const queryClient = useQueryClient();
  const navigate = useNavigate();
  const router = useRouter();

  const safeRedirectPath = props?.redirectPath?.startsWith("/")
    ? props.redirectPath
    : "/dashboard";

  const [isHydrated, setIsHydrated] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [errorMessage, setErrorMessage] = useState("");

  useEffect(() => {
    // Form handlers need to wait for hydration; setting state here is intentional.
    // eslint-disable-next-line @eslint-react/hooks-extra/no-direct-set-state-in-use-effect
    setIsHydrated(true);
  }, []);

  const form = useAppForm({
    defaultValues: {
      email: "",
      password: "",
    },
    onSubmit: async ({ value }) => {
      setIsLoading(true);
      setErrorMessage("");

      try {
        const result = await auth.signIn.email(value);

        if (result?.error) {
          throw new Error(result.error.message || "Invalid email or password");
        }

        // Success path
        await queryClient.invalidateQueries({ queryKey: authQueryKey });
        await router.invalidate();
        await navigate({ to: safeRedirectPath });
      } catch (error) {
        // Error handling
        setErrorMessage((error as Error)?.message || "Invalid email or password");
        // Keep form values but reset submitting state by resetting with current values
        form.reset(value);
      } finally {
        // Always reset loading state
        setIsLoading(false);
      }
    },
  });

  return (
    <div className="flex flex-col gap-6">
      <form
        data-testid="login-form"
        data-hydrated={isHydrated ? "true" : "false"}
        onSubmit={async (e) => {
          e.preventDefault();
          e.stopPropagation();
          await form.handleSubmit();
        }}
      >
        <div className="flex flex-col gap-6">
          <div className="flex flex-col items-center gap-2">
            <a href="#" className="flex flex-col items-center gap-2 font-medium">
              <div className="flex h-8 w-8 items-center justify-center rounded-md">
                <LogoIcon className="size-6" />
              </div>
              <span className="sr-only">Quadball Canada</span>
            </a>
            <h1 className="text-xl font-bold">Welcome back to Quadball Canada</h1>
          </div>
          <div className="flex flex-col gap-5">
            <form.Field
              name="email"
              validators={{
                onChange: ({ value }) => {
                  try {
                    loginFormSchema.shape.email.parse(value);
                    return undefined;
                  } catch (error) {
                    if (error instanceof z.ZodError) {
                      return error.issues[0]?.message || "Invalid email";
                    }
                    return "Invalid email";
                  }
                },
              }}
            >
              {(field) => (
                <ValidatedInput
                  field={field}
                  label="Email"
                  type="email"
                  placeholder="hello@example.com"
                  autoComplete="email"
                  autoFocus
                />
              )}
            </form.Field>
            <form.Field
              name="password"
              validators={{
                onChange: ({ value }) => {
                  try {
                    loginFormSchema.shape.password.parse(value);
                    return undefined;
                  } catch (error) {
                    if (error instanceof z.ZodError) {
                      return error.issues[0]?.message || "Password is required";
                    }
                    return "Password is required";
                  }
                },
              }}
            >
              {(field) => (
                <ValidatedInput
                  field={field}
                  label="Password"
                  type="password"
                  placeholder="Password"
                  autoComplete="current-password"
                />
              )}
            </form.Field>
            <FormSubmitButton
              isSubmitting={form.state.isSubmitting || isLoading}
              className="mt-2 w-full"
              size="lg"
              loadingText="Logging in..."
            >
              Login
            </FormSubmitButton>
          </div>
          {errorMessage && (
            <span className="text-destructive text-center text-sm">{errorMessage}</span>
          )}
          <div className="after:border-border relative text-center text-sm after:absolute after:inset-0 after:top-1/2 after:z-0 after:flex after:items-center after:border-t">
            <span className="bg-background text-muted-foreground relative z-10 px-2">
              Or
            </span>
          </div>
          <Button
            variant="outline"
            className="w-full"
            type="button"
            disabled={isLoading || form.state.isSubmitting}
            onClick={() =>
              auth.signInWithOAuth(
                {
                  provider: "google",
                  callbackURL: safeRedirectPath,
                },
                {
                  onRequest: () => {
                    setIsLoading(true);
                    setErrorMessage("");
                  },
                  // eslint-disable-next-line @typescript-eslint/no-explicit-any
                  onError: (ctx: any) => {
                    setIsLoading(false);
                    setErrorMessage(ctx.error?.message || "OAuth login failed");
                  },
                },
              )
            }
          >
            <GoogleIcon />
            Login with Google
          </Button>
        </div>
      </form>

      <div className="text-center text-sm">
        Don&apos;t have an account?{" "}
        <Link to="/auth/signup" className="underline underline-offset-4">
          Sign up
        </Link>
      </div>
    </div>
  );
}
</file>

<file path="src/features/events/events.mutations.ts">
import { createServerFn } from "@tanstack/react-start";
import { and, eq, inArray, or, sql } from "drizzle-orm";
import type { EventRegistration } from "~/db/schema";
import {
  eventPaymentSessions,
  eventRegistrations,
  events,
  teamMembers,
} from "~/db/schema";
import { createEventInputSchema } from "~/db/schema/events.schema";
import { atomicJsonbMerge } from "~/lib/db/jsonb-utils";
import { getAuthMiddleware, requireUser } from "~/lib/server/auth";
import { zod$ } from "~/lib/server/fn-utils";
import type { EventPaymentMetadata } from "./events.db-types";
import {
  cancelEntireEventSchema,
  cancelEventRegistrationSchema,
  createEventSchema,
  markEtransferPaidSchema,
  markEtransferReminderSchema,
  registerForEventSchema,
  updateEventSchema,
} from "./events.schemas";
import type {
  CancelEventResult,
  EventOperationResult,
  EventRegistrationResultPayload,
  EventRegistrationWithDetails,
  EventWithDetails,
} from "./events.types";
import type { EventRegistrationWithRoster } from "./utils";
import {
  appendCancellationNote,
  buildEtransferSnapshot,
  calculateRegistrationAmountCents,
  castEventJsonbFields,
  castRegistrationJsonbFields,
  currentTimestamp,
  getClockFromContext,
  isoTimestamp,
  markEtransferPaidMetadata,
  markEtransferReminderMetadata,
} from "./utils";

/**
 * Cancel an entire event and cascade updates to registrations & payments.
 */
export const cancelEvent = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(cancelEntireEventSchema))
  .handler(
    async ({ data, context }): Promise<EventOperationResult<CancelEventResult>> => {
      const clock = getClockFromContext(context);
      const now = currentTimestamp(clock);
      const nowIso = isoTimestamp(clock);

      try {
        const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);
        const db = await getDb();
        const user = requireUser(context);

        const [eventRecord] = await db
          .select()
          .from(events)
          .where(eq(events.id, data.eventId))
          .limit(1);

        if (!eventRecord) {
          return {
            success: false,
            errors: [
              {
                code: "NOT_FOUND",
                message: "Event not found",
              },
            ],
          };
        }

        let authorized = eventRecord.organizerId === user.id;
        if (!authorized) {
          const { isAdmin } = await import("~/lib/auth/utils/admin-check");
          authorized = await isAdmin(user.id);
        }

        if (!authorized) {
          return {
            success: false,
            errors: [
              {
                code: "FORBIDDEN",
                message: "You cannot cancel this event",
              },
            ],
          };
        }

        await db
          .update(events)
          .set({
            status: "cancelled",
            updatedAt: now,
            metadata: atomicJsonbMerge(events.metadata, {
              cancelledAt: nowIso,
              cancelledBy: user.id,
              cancellationReason: data.reason ?? null,
            }),
          })
          .where(eq(events.id, data.eventId));

        const registrations = await db
          .select()
          .from(eventRegistrations)
          .where(eq(eventRegistrations.eventId, data.eventId));

        const paymentSessions = await db
          .select()
          .from(eventPaymentSessions)
          .where(eq(eventPaymentSessions.eventId, data.eventId));

        const latestSessionByRegistration = new Map<
          string,
          (typeof paymentSessions)[number]
        >();
        for (const session of paymentSessions) {
          const current = latestSessionByRegistration.get(session.registrationId);
          if (!current || (session.createdAt ?? now) > (current.createdAt ?? now)) {
            latestSessionByRegistration.set(session.registrationId, session);
          }
        }

        const result: CancelEventResult = {
          eventId: data.eventId,
          affected: {
            totalRegistrations: registrations.length,
            cancelled: 0,
            alreadyCancelled: 0,
            squareRefunded: 0,
            etransferMarkedForRefund: 0,
            freeOrUnpaid: 0,
          },
          errors: [],
        };

        const squareService =
          data.refundMode === "auto" ? await getSquarePaymentService() : null;

        for (const registration of registrations) {
          if (registration.status === "cancelled") {
            result.affected.alreadyCancelled += 1;
            continue;
          }

          const existingMetadata = (registration.paymentMetadata ??
            {}) as EventPaymentMetadata;
          const noteParts = [`Event cancelled by ${user.id} at ${nowIso}`];
          if (data.reason) {
            noteParts.push(`Reason: ${data.reason}`);
          }
          const cancellationNote = noteParts.join(" â ");

          const paymentMetadata = appendCancellationNote(
            existingMetadata,
            cancellationNote,
          );
          const existingNotes = registration.internalNotes ?? "";
          const hasNoteAlready = existingNotes.split("\n").includes(cancellationNote);
          const internalNotes = hasNoteAlready
            ? existingNotes
            : [cancellationNote, existingNotes].filter(Boolean).join("\n");

          const baseUpdate: Partial<typeof eventRegistrations.$inferInsert> = {
            status: "cancelled",
            cancelledAt: now,
            updatedAt: now,
            internalNotes,
            paymentMetadata,
          };

          let finalPaymentStatus = registration.paymentStatus;
          let sessionUpdated = false;
          const session = latestSessionByRegistration.get(registration.id);
          const amountPaid = registration.amountPaidCents ?? 0;
          const amountDue = registration.amountDueCents ?? 0;
          const amountToRefund = amountPaid > 0 ? amountPaid : amountDue;

          if (registration.paymentMethod === "square" && amountToRefund > 0) {
            if (data.refundMode === "none") {
              result.affected.freeOrUnpaid += 1;
            } else if (!squareService || data.refundMode === "manual") {
              finalPaymentStatus = "refund_required";
              result.affected.etransferMarkedForRefund += 1;
            } else {
              let paymentId = session?.squarePaymentId ?? null;

              if (!paymentId && session?.squareCheckoutId) {
                const verification = await squareService.verifyPayment(
                  session.squareCheckoutId,
                );
                if (verification.success && verification.paymentId) {
                  paymentId = verification.paymentId;
                  await db
                    .update(eventPaymentSessions)
                    .set({
                      squarePaymentId: paymentId,
                      updatedAt: now,
                    })
                    .where(eq(eventPaymentSessions.id, session.id));
                }
              }

              if (!paymentId) {
                finalPaymentStatus = "refund_required";
                result.affected.etransferMarkedForRefund += 1;
                result.errors.push({
                  registrationId: registration.id,
                  code: "NO_PAYMENT_SESSION",
                  message:
                    "Square payment could not be resolved; flagged for manual refund.",
                });
              } else {
                try {
                  const refund = await squareService.createRefund(
                    paymentId,
                    amountToRefund,
                    "Event cancelled",
                  );

                  if (refund.success) {
                    finalPaymentStatus = "refunded";
                    result.affected.squareRefunded += 1;
                    if (session) {
                      await db
                        .update(eventPaymentSessions)
                        .set({
                          status: "refunded",
                          metadata: atomicJsonbMerge(eventPaymentSessions.metadata, {
                            refundedAt: nowIso,
                            refundId: refund.refundId ?? null,
                            cancelledBy: user.id,
                          }),
                          updatedAt: now,
                        })
                        .where(eq(eventPaymentSessions.id, session.id));
                      sessionUpdated = true;
                    }
                  } else {
                    finalPaymentStatus = "refund_required";
                    result.affected.etransferMarkedForRefund += 1;
                    result.errors.push({
                      registrationId: registration.id,
                      code: "REFUND_FAILED",
                      message: refund.error ?? "Square refund failed",
                      paymentId,
                    });
                  }
                } catch (refundError) {
                  finalPaymentStatus = "refund_required";
                  result.affected.etransferMarkedForRefund += 1;
                  result.errors.push({
                    registrationId: registration.id,
                    code: "REFUND_FAILED",
                    message:
                      refundError instanceof Error
                        ? refundError.message
                        : "Square refund threw an unexpected error",
                    paymentId,
                  });
                }
              }
            }
          } else if (registration.paymentMethod === "etransfer" && amountToRefund > 0) {
            finalPaymentStatus = "refund_required";
            result.affected.etransferMarkedForRefund += 1;
          } else {
            result.affected.freeOrUnpaid += 1;
          }

          const update = {
            ...baseUpdate,
            paymentStatus: finalPaymentStatus,
          } satisfies Partial<typeof eventRegistrations.$inferInsert>;

          await db
            .update(eventRegistrations)
            .set(update)
            .where(eq(eventRegistrations.id, registration.id));

          if (session && !sessionUpdated) {
            await db
              .update(eventPaymentSessions)
              .set({
                status: "cancelled",
                metadata: atomicJsonbMerge(eventPaymentSessions.metadata, {
                  cancelledAt: nowIso,
                  cancelledBy: user.id,
                }),
                updatedAt: now,
              })
              .where(eq(eventPaymentSessions.id, session.id));
          }

          result.affected.cancelled += 1;
        }

        if (data.notify !== false) {
          try {
            const { sendEventCancellationNotifications } = await import(
              "~/lib/server/notifications/events/cancellation"
            );
            await sendEventCancellationNotifications({
              db,
              event: eventRecord,
              ...(data.reason ? { reason: data.reason } : {}),
            });
          } catch (notificationError) {
            console.warn("Failed to send cancellation notifications:", notificationError);
          }
        }

        return {
          success: true,
          data: result,
        };
      } catch (error) {
        console.error("Error cancelling event:", error);
        return {
          success: false,
          errors: [
            {
              code: "DATABASE_ERROR",
              message: "Failed to cancel event",
            },
          ],
        };
      }
    },
  );

/**
 * Create a new event
 */
export const createEvent = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(createEventSchema))
  .handler(async ({ data, context }): Promise<EventOperationResult<EventWithDetails>> => {
    try {
      // Import server-only modules inside the handler
      const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);

      const db = await getDb();
      const user = requireUser(context);

      // Validate input
      const validationResult = createEventInputSchema.safeParse(data);
      if (!validationResult.success) {
        return {
          success: false,
          errors: validationResult.error.issues.map((issue) => ({
            code: "VALIDATION_ERROR" as const,
            message: issue.message,
            field: issue.path.join("."),
          })),
        };
      }

      // Check for duplicate slug
      const [existingEvent] = await db
        .select({ id: events.id })
        .from(events)
        .where(eq(events.slug, data.slug))
        .limit(1);

      if (existingEvent) {
        return {
          success: false,
          errors: [
            {
              code: "DUPLICATE_SLUG",
              message: "An event with this slug already exists",
              field: "slug",
            },
          ],
        };
      }

      // Validate dates
      const startDate = new Date(data.startDate);
      const endDate = new Date(data.endDate);

      if (startDate > endDate) {
        return {
          success: false,
          errors: [
            {
              code: "INVALID_DATES",
              message: "Start date must be before end date",
            },
          ],
        };
      }

      const [newEvent] = await db
        .insert(events)
        .values({
          ...data,
          organizerId: user.id,
          startDate: data.startDate,
          endDate: data.endDate,
        })
        .returning();

      return {
        success: true,
        data: castEventJsonbFields(newEvent),
      };
    } catch (error) {
      console.error("Error creating event:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to create event",
          },
        ],
      };
    }
  });

/**
 * Update an event
 */
export const updateEvent = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(updateEventSchema))
  .handler(async ({ data, context }): Promise<EventOperationResult<EventWithDetails>> => {
    try {
      // Import server-only modules inside the handler
      const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);

      const db = await getDb();
      const user = requireUser(context);

      // Check if event exists and user is organizer
      const [existingEvent] = await db
        .select()
        .from(events)
        .where(eq(events.id, data.eventId))
        .limit(1);

      if (!existingEvent) {
        return {
          success: false,
          errors: [
            {
              code: "NOT_FOUND",
              message: "Event not found",
            },
          ],
        };
      }

      // Check if user is organizer or admin
      const { isAdmin } = await import("~/lib/auth/utils/admin-check");
      const userIsAdmin = await isAdmin(user.id);

      if (existingEvent.organizerId !== user.id && !userIsAdmin) {
        return {
          success: false,
          errors: [
            {
              code: "FORBIDDEN",
              message: "Only the event organizer or an admin can update this event",
            },
          ],
        };
      }

      // Check for duplicate slug if updating
      if (data.data.slug && data.data.slug !== existingEvent.slug) {
        const [duplicateEvent] = await db
          .select({ id: events.id })
          .from(events)
          .where(
            and(eq(events.slug, data.data.slug), sql`${events.id} != ${data.eventId}`),
          )
          .limit(1);

        if (duplicateEvent) {
          return {
            success: false,
            errors: [
              {
                code: "DUPLICATE_SLUG",
                message: "An event with this slug already exists",
                field: "slug",
              },
            ],
          };
        }
      }

      // Validate dates if provided
      if (data.data.startDate || data.data.endDate) {
        const startDate = new Date(data.data.startDate || existingEvent.startDate);
        const endDate = new Date(data.data.endDate || existingEvent.endDate);

        if (startDate > endDate) {
          return {
            success: false,
            errors: [
              {
                code: "INVALID_DATES",
                message: "Start date must be before end date",
              },
            ],
          };
        }
      }

      // Update event
      const [updatedEvent] = await db
        .update(events)
        .set({
          ...data.data,
          updatedAt: new Date(),
        })
        .where(eq(events.id, data.eventId))
        .returning();

      return {
        success: true,
        data: castEventJsonbFields(updatedEvent),
      };
    } catch (error) {
      console.error("Error updating event:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to update event",
          },
        ],
      };
    }
  });

const getSquarePaymentService = async () => {
  const { getSquarePaymentService: loadSquareService } = await import(
    "~/lib/payments/square"
  );
  return loadSquareService();
};

/**
 * Register for an event
 */
export const registerForEvent = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(registerForEventSchema))
  .handler(
    async ({
      data,
      context,
    }): Promise<EventOperationResult<EventRegistrationResultPayload>> => {
      try {
        const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);

        const db = await getDb();
        const user = requireUser(context);
        const clock = getClockFromContext(context);

        const [event] = await db
          .select()
          .from(events)
          .where(eq(events.id, data.eventId))
          .limit(1);

        if (!event) {
          return {
            success: false,
            errors: [
              {
                code: "NOT_FOUND",
                message: "Event not found",
              },
            ],
          };
        }

        if (event.status !== "registration_open") {
          return {
            success: false,
            errors: [
              {
                code: "REGISTRATION_CLOSED",
                message: "Registration is not open for this event",
              },
            ],
          };
        }

        const now = currentTimestamp(clock);
        const registrationOpens = event.registrationOpensAt;
        const registrationCloses = event.registrationClosesAt;

        if (registrationOpens && now < registrationOpens) {
          return {
            success: false,
            errors: [
              {
                code: "REGISTRATION_CLOSED",
                message: "Registration has not opened yet",
              },
            ],
          };
        }

        if (registrationCloses && now > registrationCloses) {
          return {
            success: false,
            errors: [
              {
                code: "REGISTRATION_CLOSED",
                message: "Registration has closed",
              },
            ],
          };
        }

        const paymentMethod = data.paymentMethod ?? "square";
        if (paymentMethod === "etransfer" && !event.allowEtransfer) {
          return {
            success: false,
            errors: [
              {
                code: "FORBIDDEN",
                message: "E-transfer is not available for this event",
              },
            ],
          };
        }

        const registrationType: EventRegistration["registrationType"] = data.teamId
          ? "team"
          : "individual";

        if (event.registrationType === "team" && registrationType !== "team") {
          return {
            success: false,
            errors: [
              {
                code: "FORBIDDEN",
                message: "Only team registrations are allowed for this event",
              },
            ],
          };
        }

        if (
          event.registrationType === "individual" &&
          registrationType !== "individual"
        ) {
          return {
            success: false,
            errors: [
              {
                code: "FORBIDDEN",
                message: "Only individual registrations are allowed for this event",
              },
            ],
          };
        }

        // Check for existing registration with any active status (pending, confirmed, waitlisted)
        // This prevents duplicate registrations and checkout sessions
        const existingRegistration = await db
          .select()
          .from(eventRegistrations)
          .where(
            and(
              eq(eventRegistrations.eventId, data.eventId),
              or(
                eq(eventRegistrations.userId, user.id),
                data.teamId ? eq(eventRegistrations.teamId, data.teamId) : undefined,
              ),
              inArray(eventRegistrations.status, ["pending", "confirmed", "waitlisted"]),
            ),
          )
          .limit(1);

        if (existingRegistration.length > 0) {
          const status = existingRegistration[0].status;
          const message =
            status === "pending"
              ? "You have a pending registration. Please complete payment or cancel it first."
              : "You or your team are already registered for this event";
          return {
            success: false,
            errors: [
              {
                code: "ALREADY_REGISTERED",
                message,
              },
            ],
          };
        }

        const registrationCount = await db
          .select({ count: sql<number>`count(*)::int` })
          .from(eventRegistrations)
          .where(
            and(
              eq(eventRegistrations.eventId, data.eventId),
              eq(eventRegistrations.status, "confirmed"),
            ),
          );

        const confirmedCount = registrationCount[0].count;

        if (
          event.registrationType === "team" &&
          event.maxTeams &&
          confirmedCount >= event.maxTeams
        ) {
          return {
            success: false,
            errors: [
              {
                code: "EVENT_FULL",
                message: "This event is full",
              },
            ],
          };
        }

        if (
          event.registrationType === "individual" &&
          event.maxParticipants &&
          confirmedCount >= event.maxParticipants
        ) {
          return {
            success: false,
            errors: [
              {
                code: "EVENT_FULL",
                message: "This event is full",
              },
            ],
          };
        }

        if (data.teamId) {
          const [membership] = await db
            .select()
            .from(teamMembers)
            .where(
              and(
                eq(teamMembers.teamId, data.teamId),
                eq(teamMembers.userId, user.id),
                eq(teamMembers.status, "active"),
              ),
            )
            .limit(1);

          if (!membership) {
            return {
              success: false,
              errors: [
                {
                  code: "FORBIDDEN",
                  message: "You must be an active member of the team to register",
                },
              ],
            };
          }

          if (membership.role !== "captain" && membership.role !== "coach") {
            return {
              success: false,
              errors: [
                {
                  code: "FORBIDDEN",
                  message:
                    "Only team captains and coaches can register the team for events",
                },
              ],
            };
          }
        }

        const amountDueCents = calculateRegistrationAmountCents(
          event,
          registrationType,
          now,
        );

        let paymentStatus: EventRegistration["paymentStatus"] = "pending";
        let amountPaidCents: number | null = null;
        let paymentCompletedAt: Date | null = null;

        if (amountDueCents === 0) {
          paymentStatus = "paid";
          amountPaidCents = 0;
          paymentCompletedAt = now;
        } else if (paymentMethod === "etransfer") {
          paymentStatus = "awaiting_etransfer";
        }

        const paymentMetadata =
          paymentMethod === "etransfer"
            ? buildEtransferSnapshot(
                event.etransferInstructions,
                event.etransferRecipient,
              )
            : null;

        const [registration] = await db
          .insert(eventRegistrations)
          .values({
            eventId: data.eventId,
            userId: user.id,
            teamId: data.teamId,
            registrationType,
            division: data.division,
            notes: data.notes,
            // Store directly as JSONB - Drizzle handles serialization
            // Normalize to object format if array is passed
            roster: data.roster
              ? Array.isArray(data.roster)
                ? { players: data.roster }
                : data.roster
              : null,
            status: amountDueCents === 0 ? "confirmed" : "pending",
            paymentStatus,
            paymentMethod,
            paymentId: null,
            amountDueCents,
            amountPaidCents,
            paymentCompletedAt,
            paymentMetadata,
          })
          .returning();

        let paymentResponse: EventRegistrationResultPayload["payment"];

        if (paymentMethod === "square" && amountDueCents > 0) {
          const squareService = await getSquarePaymentService();
          const checkoutSession = await squareService.createEventCheckoutSession({
            eventId: event.id,
            registrationId: registration.id,
            userId: user.id,
            amount: amountDueCents,
            eventName: event.name,
          });

          await db
            .insert(eventPaymentSessions)
            .values({
              registrationId: registration.id,
              eventId: event.id,
              userId: user.id,
              squareCheckoutId: checkoutSession.id,
              squarePaymentLinkUrl: checkoutSession.checkoutUrl,
              squareOrderId: checkoutSession.orderId ?? null,
              amountCents: amountDueCents,
              currency: checkoutSession.currency,
              metadata: {
                eventName: event.name,
                registrationType,
                paymentMethod,
              },
            })
            .onConflictDoUpdate({
              target: eventPaymentSessions.squareCheckoutId,
              set: {
                registrationId: registration.id,
                eventId: event.id,
                userId: user.id,
                squarePaymentLinkUrl: checkoutSession.checkoutUrl,
                squareOrderId: checkoutSession.orderId ?? null,
                amountCents: amountDueCents,
                currency: checkoutSession.currency,
                metadata: {
                  eventName: event.name,
                  registrationType,
                  paymentMethod,
                },
                updatedAt: currentTimestamp(clock),
              },
            });

          paymentResponse = {
            method: "square",
            checkoutUrl: checkoutSession.checkoutUrl,
            sessionId: checkoutSession.id,
          };
        } else if (amountDueCents === 0) {
          paymentResponse = { method: "free" };
        } else {
          paymentResponse = {
            method: "etransfer",
            instructions: event.etransferInstructions ?? null,
            recipient: event.etransferRecipient ?? null,
          };
        }

        const parsedRegistration = castRegistrationJsonbFields(registration);

        const registrationWithDetails: EventRegistrationWithDetails = {
          ...parsedRegistration,
          event: castEventJsonbFields(event),
          user: {
            id: user.id,
            name: user.name ?? user.email ?? "",
            email: user.email ?? "",
          },
        };

        return {
          success: true,
          data: {
            registration: registrationWithDetails,
            payment: paymentResponse,
          },
        };
      } catch (error) {
        console.error("Error registering for event:", error);
        return {
          success: false,
          errors: [
            {
              code: "DATABASE_ERROR",
              message: "Failed to register for event",
            },
          ],
        };
      }
    },
  );

export const markEventEtransferPaid = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(markEtransferPaidSchema))
  .handler(
    async ({
      data,
      context,
    }): Promise<EventOperationResult<EventRegistrationWithRoster>> => {
      try {
        const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);

        const db = await getDb();
        const user = requireUser(context);
        const clock = getClockFromContext(context);

        const registrationWithEvent = await db
          .select({
            registration: eventRegistrations,
            event: events,
          })
          .from(eventRegistrations)
          .innerJoin(events, eq(eventRegistrations.eventId, events.id))
          .where(eq(eventRegistrations.id, data.registrationId))
          .limit(1);

        if (registrationWithEvent.length === 0) {
          return {
            success: false,
            errors: [
              {
                code: "NOT_FOUND",
                message: "Registration not found",
              },
            ],
          };
        }

        const [{ registration, event }] = registrationWithEvent;

        const isOrganizer = event.organizerId === user.id;
        let isGlobalAdmin = false;
        if (!isOrganizer) {
          const { isAdmin } = await import("~/lib/auth/utils/admin-check");
          isGlobalAdmin = await isAdmin(user.id);
        }

        if (!isOrganizer && !isGlobalAdmin) {
          return {
            success: false,
            errors: [
              {
                code: "FORBIDDEN",
                message: "You do not have permission to update this registration",
              },
            ],
          };
        }

        if (registration.paymentMethod !== "etransfer") {
          return {
            success: false,
            errors: [
              {
                code: "VALIDATION_ERROR",
                message: "Only e-transfer registrations can be marked as paid manually",
              },
            ],
          };
        }

        const now = currentTimestamp(clock);
        const existingMetadata = (registration.paymentMetadata ||
          {}) as EventPaymentMetadata;
        const updatedMetadata = markEtransferPaidMetadata(
          existingMetadata,
          user.id,
          clock,
        );

        const [updatedRegistration] = await db
          .update(eventRegistrations)
          .set({
            paymentStatus: "paid",
            status:
              registration.status === "cancelled" ? registration.status : "confirmed",
            paymentCompletedAt: now,
            amountPaidCents: registration.amountDueCents,
            paymentMetadata: updatedMetadata,
            updatedAt: now,
          })
          .where(eq(eventRegistrations.id, data.registrationId))
          .returning();

        return {
          success: true,
          data: castRegistrationJsonbFields(updatedRegistration),
        };
      } catch (error) {
        console.error("Error marking e-transfer as paid:", error);
        return {
          success: false,
          errors: [
            {
              code: "DATABASE_ERROR",
              message: "Failed to update registration",
            },
          ],
        };
      }
    },
  );

export const markEventEtransferReminder = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(markEtransferReminderSchema))
  .handler(
    async ({
      data,
      context,
    }): Promise<EventOperationResult<EventRegistrationWithRoster>> => {
      try {
        const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);

        const db = await getDb();
        const user = requireUser(context);
        const clock = getClockFromContext(context);

        const registrationWithEvent = await db
          .select({
            registration: eventRegistrations,
            event: events,
          })
          .from(eventRegistrations)
          .innerJoin(events, eq(eventRegistrations.eventId, events.id))
          .where(eq(eventRegistrations.id, data.registrationId))
          .limit(1);

        if (registrationWithEvent.length === 0) {
          return {
            success: false,
            errors: [
              {
                code: "NOT_FOUND",
                message: "Registration not found",
              },
            ],
          };
        }

        const [{ registration, event }] = registrationWithEvent;

        const isOrganizer = event.organizerId === user.id;
        let isGlobalAdmin = false;
        if (!isOrganizer) {
          const { isAdmin } = await import("~/lib/auth/utils/admin-check");
          isGlobalAdmin = await isAdmin(user.id);
        }

        if (!isOrganizer && !isGlobalAdmin) {
          return {
            success: false,
            errors: [
              {
                code: "FORBIDDEN",
                message: "You do not have permission to update this registration",
              },
            ],
          };
        }

        if (registration.paymentMethod !== "etransfer") {
          return {
            success: false,
            errors: [
              {
                code: "VALIDATION_ERROR",
                message: "Only e-transfer registrations can receive reminders",
              },
            ],
          };
        }

        const now = currentTimestamp(clock);
        const existingMetadata = (registration.paymentMetadata ||
          {}) as EventPaymentMetadata;
        const updatedMetadata = markEtransferReminderMetadata(
          existingMetadata,
          user.id,
          clock,
        );

        const [updatedRegistration] = await db
          .update(eventRegistrations)
          .set({
            paymentMetadata: updatedMetadata,
            updatedAt: now,
          })
          .where(eq(eventRegistrations.id, data.registrationId))
          .returning();

        return {
          success: true,
          data: castRegistrationJsonbFields(updatedRegistration),
        };
      } catch (error) {
        console.error("Error marking e-transfer reminder:", error);
        return {
          success: false,
          errors: [
            {
              code: "DATABASE_ERROR",
              message: "Failed to update registration",
            },
          ],
        };
      }
    },
  );

/**
 * Cancel event registration
 */
export const cancelEventRegistration = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(cancelEventRegistrationSchema))
  .handler(
    async ({
      data,
      context,
    }): Promise<EventOperationResult<EventRegistrationWithRoster>> => {
      try {
        const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);

        const db = await getDb();
        const user = requireUser(context);

        // Get registration
        const [registration] = await db
          .select()
          .from(eventRegistrations)
          .where(eq(eventRegistrations.id, data.registrationId))
          .limit(1);

        if (!registration) {
          return {
            success: false,
            errors: [
              {
                code: "NOT_FOUND",
                message: "Registration not found",
              },
            ],
          };
        }

        // Check if user can cancel
        if (registration.userId !== user.id) {
          // Check if user is team captain/coach
          if (registration.teamId) {
            const [membership] = await db
              .select()
              .from(teamMembers)
              .where(
                and(
                  eq(teamMembers.teamId, registration.teamId),
                  eq(teamMembers.userId, user.id),
                  eq(teamMembers.status, "active"),
                ),
              )
              .limit(1);

            if (
              !membership ||
              (membership.role !== "captain" && membership.role !== "coach")
            ) {
              return {
                success: false,
                errors: [
                  {
                    code: "FORBIDDEN",
                    message:
                      "Only the registrant or team leaders can cancel this registration",
                  },
                ],
              };
            }
          } else {
            return {
              success: false,
              errors: [
                {
                  code: "FORBIDDEN",
                  message: "You can only cancel your own registration",
                },
              ],
            };
          }
        }

        // Update registration
        const [cancelledRegistration] = await db
          .update(eventRegistrations)
          .set({
            status: "cancelled",
            cancelledAt: new Date(),
            internalNotes: data.reason,
            updatedAt: new Date(),
          })
          .where(eq(eventRegistrations.id, data.registrationId))
          .returning();

        return {
          success: true,
          data: castRegistrationJsonbFields(cancelledRegistration),
        };
      } catch (error) {
        console.error("Error cancelling registration:", error);
        return {
          success: false,
          errors: [
            {
              code: "DATABASE_ERROR",
              message: "Failed to cancel registration",
            },
          ],
        };
      }
    },
  );
</file>

<file path="src/features/events/events.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { and, asc, desc, eq, gte, inArray, lte, sql } from "drizzle-orm";
import { z } from "zod";
import type { EventRegistration } from "~/db/schema";
import { eventRegistrations, events, teams, user } from "~/db/schema";
import { getAuthMiddleware, requireUser } from "~/lib/server/auth";
import { forbidden } from "~/lib/server/errors";
import { zod$ } from "~/lib/server/fn-utils";
import type {
  EventAmenities,
  EventDivisions,
  EventMetadata,
  EventPaymentMetadata,
  EventRequirements,
  EventRules,
  EventSchedule,
} from "./events.db-types";
import {
  checkEventRegistrationSchema,
  getEventSchema,
  getUpcomingEventsSchema,
  listEventsSchema,
} from "./events.schemas";
import type {
  EventListResult,
  EventOperationResult,
  EventPaymentMethod,
  EventPaymentStatus,
  EventWithDetails,
} from "./events.types";
import { castRegistrationJsonbFields, type EventRegistrationWithRoster } from "./utils";

export type EventRegistrationSummary = {
  id: string;
  userId: string | null;
  teamId: string | null;
  eventId: string;
  registrationType: EventRegistration["registrationType"];
  status: EventRegistration["status"];
  paymentStatus: EventPaymentStatus;
  paymentMethod: EventPaymentMethod;
  paymentId: string | null;
  amountDueCents: number;
  amountPaidCents: number | null;
  paymentCompletedAt: Date | null;
  paymentMetadata: EventPaymentMetadata | null;
  createdAt: Date;
  userName: string | null;
  userEmail: string | null;
  teamName: string | null;
};

/**
 * List events with filters and pagination
 */
export const listEvents = createServerFn({ method: "GET" })
  .inputValidator(zod$(listEventsSchema))
  .handler(async ({ data }): Promise<EventListResult> => {
    // Import server-only modules inside the handler
    const { getDb } = await import("~/db/server-helpers");
    const db = await getDb();

    const filters = data.filters || {};
    const page = Math.max(1, data.page || 1);
    const pageSize = Math.min(100, Math.max(1, data.pageSize || 20));
    const offset = (page - 1) * pageSize;
    const sortBy = data.sortBy || "startDate";
    const sortOrder = data.sortOrder || "asc";

    // Build filter conditions
    const conditions: ReturnType<typeof eq>[] = [];

    if (filters.status) {
      const statuses = Array.isArray(filters.status) ? filters.status : [filters.status];
      conditions.push(
        inArray(events.status, statuses as (typeof events.status._.data)[]),
      );
    }

    if (filters.type) {
      const types = Array.isArray(filters.type) ? filters.type : [filters.type];
      conditions.push(inArray(events.type, types as (typeof events.type._.data)[]));
    }

    if (filters.organizerId) {
      conditions.push(eq(events.organizerId, filters.organizerId));
    }

    if (filters.startDateFrom) {
      conditions.push(
        gte(events.startDate, filters.startDateFrom.toISOString().split("T")[0]),
      );
    }

    if (filters.startDateTo) {
      conditions.push(
        lte(events.startDate, filters.startDateTo.toISOString().split("T")[0]),
      );
    }

    if (filters.city) {
      conditions.push(eq(events.city, filters.city));
    }

    if (filters.province) {
      conditions.push(eq(events.province, filters.province));
    }

    const whereClause = conditions.length > 0 ? and(...conditions) : undefined;

    // Get total count
    const [{ count }] = await db
      .select({ count: sql<number>`count(*)::int` })
      .from(events)
      .where(whereClause);

    // Get events with details
    const orderByColumn =
      sortBy === "name"
        ? events.name
        : sortBy === "createdAt"
          ? events.createdAt
          : events.startDate;

    const eventsList = await db
      .select({
        event: events,
        organizer: {
          id: user.id,
          name: user.name,
          email: user.email,
        },
        registrationCount: sql<number>`(
          SELECT COUNT(*)::int 
          FROM ${eventRegistrations} 
          WHERE ${eventRegistrations.eventId} = ${events.id}
          AND ${eventRegistrations.status} != 'cancelled'
        )`,
      })
      .from(events)
      .leftJoin(user, eq(events.organizerId, user.id))
      .where(whereClause)
      .orderBy(sortOrder === "desc" ? desc(orderByColumn) : asc(orderByColumn))
      .limit(pageSize)
      .offset(offset);

    // Transform results
    const eventsWithDetails: EventWithDetails[] = eventsList.map(
      ({ event, organizer, registrationCount }) => {
        const now = new Date();
        const registrationOpens = event.registrationOpensAt
          ? new Date(event.registrationOpensAt)
          : null;
        const registrationCloses = event.registrationClosesAt
          ? new Date(event.registrationClosesAt)
          : null;

        const isRegistrationOpen =
          event.status === "registration_open" &&
          (!registrationOpens || now >= registrationOpens) &&
          (!registrationCloses || now <= registrationCloses);

        let availableSpots: number | undefined;
        if (event.registrationType === "team" && event.maxTeams) {
          availableSpots = Math.max(0, event.maxTeams - registrationCount);
        } else if (event.registrationType === "individual" && event.maxParticipants) {
          availableSpots = Math.max(0, event.maxParticipants - registrationCount);
        }

        return {
          ...event,
          rules: (event.rules as EventRules) || {},
          schedule: (event.schedule as EventSchedule) || {},
          divisions: (event.divisions as EventDivisions) || {},
          amenities: (event.amenities as EventAmenities) || {},
          requirements: (event.requirements as EventRequirements) || {},
          metadata: (event.metadata as EventMetadata) || {},
          organizer: organizer!,
          registrationCount,
          isRegistrationOpen,
          availableSpots,
        };
      },
    );

    const totalPages = Math.ceil(count / pageSize);

    return {
      events: eventsWithDetails,
      totalCount: count,
      pageInfo: {
        currentPage: page,
        pageSize,
        totalPages,
        hasNextPage: page < totalPages,
        hasPreviousPage: page > 1,
      },
    };
  });

/**
 * Get a single event by ID or slug
 */
export const getEvent = createServerFn({ method: "GET" })
  .inputValidator(zod$(getEventSchema))
  .handler(async ({ data }): Promise<EventOperationResult<EventWithDetails>> => {
    try {
      if (!data.id && !data.slug) {
        return {
          success: false,
          errors: [
            {
              code: "VALIDATION_ERROR",
              message: "Either id or slug must be provided",
            },
          ],
        };
      }

      // Import server-only modules inside the handler
      const { getDb } = await import("~/db/server-helpers");
      const db = await getDb();

      const condition = data.id ? eq(events.id, data.id) : eq(events.slug, data.slug!);

      const result = await db
        .select({
          event: events,
          organizer: {
            id: user.id,
            name: user.name,
            email: user.email,
          },
          registrationCount: sql<number>`(
            SELECT COUNT(*)::int 
            FROM ${eventRegistrations} 
            WHERE ${eventRegistrations.eventId} = ${events.id}
            AND ${eventRegistrations.status} != 'cancelled'
          )`,
        })
        .from(events)
        .leftJoin(user, eq(events.organizerId, user.id))
        .where(condition)
        .limit(1);

      if (result.length === 0) {
        return {
          success: false,
          errors: [
            {
              code: "NOT_FOUND",
              message: "Event not found",
            },
          ],
        };
      }

      const { event, organizer, registrationCount } = result[0];
      const now = new Date();
      const registrationOpens = event.registrationOpensAt
        ? new Date(event.registrationOpensAt)
        : null;
      const registrationCloses = event.registrationClosesAt
        ? new Date(event.registrationClosesAt)
        : null;

      const isRegistrationOpen =
        event.status === "registration_open" &&
        (!registrationOpens || now >= registrationOpens) &&
        (!registrationCloses || now <= registrationCloses);

      let availableSpots: number | undefined;
      if (event.registrationType === "team" && event.maxTeams) {
        availableSpots = Math.max(0, event.maxTeams - registrationCount);
      } else if (event.registrationType === "individual" && event.maxParticipants) {
        availableSpots = Math.max(0, event.maxParticipants - registrationCount);
      }

      return {
        success: true,
        data: {
          ...event,
          rules: (event.rules as EventRules) || {},
          schedule: (event.schedule as EventSchedule) || {},
          divisions: (event.divisions as EventDivisions) || {},
          amenities: (event.amenities as EventAmenities) || {},
          requirements: (event.requirements as EventRequirements) || {},
          metadata: (event.metadata as EventMetadata) || {},
          organizer: organizer!,
          registrationCount,
          isRegistrationOpen,
          availableSpots,
        },
      };
    } catch (error) {
      console.error("Error fetching event:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to fetch event",
          },
        ],
      };
    }
  });

/**
 * Get upcoming events for the dashboard
 */
export const getUpcomingEvents = createServerFn({ method: "GET" })
  .inputValidator(zod$(getUpcomingEventsSchema))
  .handler(async ({ data }): Promise<EventWithDetails[]> => {
    const limit = Math.min(10, data.limit || 3);

    const result = (await listEvents({
      data: {
        filters: {
          status: ["published", "registration_open"],
          startDateFrom: new Date(),
        },
        pageSize: limit,
        sortBy: "startDate",
        sortOrder: "asc",
      },
    })) as EventListResult;

    return result.events;
  });

/**
 * Get all registrations for an event (organizer or admin only)
 * Returns user emails and payment data - must be protected
 */
export const getEventRegistrations = createServerFn({ method: "GET" })
  .middleware(getAuthMiddleware())
  .inputValidator(z.object({ eventId: z.uuid() }).parse)
  .handler(async ({ data, context }): Promise<EventRegistrationSummary[]> => {
    const authUser = requireUser(context);
    const { getDb } = await import("~/db/server-helpers");
    const { isAdmin } = await import("~/lib/auth/utils/admin-check");
    const db = await getDb();

    // Check if user is organizer or admin
    const [event] = await db
      .select({ organizerId: events.organizerId })
      .from(events)
      .where(eq(events.id, data.eventId))
      .limit(1);

    if (!event) {
      throw forbidden("Event not found");
    }

    const userIsAdmin = await isAdmin(authUser.id);
    if (event.organizerId !== authUser.id && !userIsAdmin) {
      throw forbidden("Only event organizers or admins can view registrations");
    }

    const registrations = await db
      .select({
        id: eventRegistrations.id,
        userId: eventRegistrations.userId,
        teamId: eventRegistrations.teamId,
        eventId: eventRegistrations.eventId,
        registrationType: eventRegistrations.registrationType,
        status: eventRegistrations.status,
        paymentStatus: eventRegistrations.paymentStatus,
        paymentMethod: eventRegistrations.paymentMethod,
        paymentId: eventRegistrations.paymentId,
        amountDueCents: eventRegistrations.amountDueCents,
        amountPaidCents: eventRegistrations.amountPaidCents,
        paymentCompletedAt: eventRegistrations.paymentCompletedAt,
        paymentMetadata: eventRegistrations.paymentMetadata,
        createdAt: eventRegistrations.createdAt,
        userName: user.name,
        userEmail: user.email,
        teamName: teams.name,
      })
      .from(eventRegistrations)
      .leftJoin(user, eq(eventRegistrations.userId, user.id))
      .leftJoin(teams, eq(eventRegistrations.teamId, teams.id))
      .where(eq(eventRegistrations.eventId, data.eventId))
      .orderBy(desc(eventRegistrations.createdAt));

    return registrations.map((registration) => ({
      ...registration,
      userName: registration.userName ?? null,
      userEmail: registration.userEmail ?? null,
      teamName: registration.teamName ?? null,
      paymentMetadata: registration.paymentMetadata
        ? (registration.paymentMetadata as EventPaymentMetadata)
        : null,
    }));
  });

/**
 * Check if a user is registered for an event
 */
export const checkEventRegistration = createServerFn({ method: "GET" })
  .inputValidator(zod$(checkEventRegistrationSchema))
  .handler(
    async ({
      data,
    }): Promise<{
      isRegistered: boolean;
      registration?: EventRegistrationWithRoster;
    }> => {
      // Get user from session - not from client input
      const { getRequest } = await import("@tanstack/react-start/server");
      const { getAuth } = await import("~/lib/auth/server-helpers");
      const auth = await getAuth();
      const { headers } = getRequest();
      const session = await auth.api.getSession({ headers });
      const userId = session?.user?.id;

      if (!userId && !data.teamId) {
        return { isRegistered: false };
      }

      // Import server-only modules inside the handler
      const { getDb } = await import("~/db/server-helpers");
      const db = await getDb();

      const conditions: ReturnType<typeof eq>[] = [
        eq(eventRegistrations.eventId, data.eventId),
        eq(eventRegistrations.status, "confirmed"),
      ];

      if (userId) {
        conditions.push(eq(eventRegistrations.userId, userId));
      }

      if (data.teamId) {
        conditions.push(eq(eventRegistrations.teamId, data.teamId));
      }

      const [registration] = await db
        .select()
        .from(eventRegistrations)
        .where(and(...conditions))
        .limit(1);

      if (!registration) {
        return { isRegistered: false };
      }

      return {
        isRegistered: true,
        registration: castRegistrationJsonbFields(registration),
      };
    },
  );
</file>

<file path="src/components/ui/admin-sidebar.tsx">
import { useQueryClient } from "@tanstack/react-query";
import { useNavigate, useRouteContext, useRouter } from "@tanstack/react-router";
import { LogOut } from "lucide-react";
import { useMemo, useState } from "react";
import { SafeLink as Link } from "~/components/ui/SafeLink";
import { authQueryKey } from "~/features/auth/auth.queries";
import { ADMIN_PRIMARY_NAV, ADMIN_SECONDARY_NAV } from "~/features/layouts/admin-nav";
import { userHasRole } from "~/features/roles/permission.service";
import { auth } from "~/lib/auth-client";

export function AdminSidebar() {
  const queryClient = useQueryClient();
  const [isLoggingOut, setIsLoggingOut] = useState(false);
  const router = useRouter();
  const navigate = useNavigate();
  const context = useRouteContext({ strict: false });
  const user = context?.user || null;

  // Filter sidebar items based on user roles
  const sidebarItems = useMemo(
    () =>
      ADMIN_PRIMARY_NAV.filter((item) => {
        if (!item.roles || item.roles.length === 0) {
          return true;
        }
        if (!user) {
          return false;
        }
        return item.roles.some((roleName) => userHasRole(user, roleName));
      }),
    [user],
  );

  const secondaryItems = ADMIN_SECONDARY_NAV;

  const handleLogout = async () => {
    if (isLoggingOut) return;
    setIsLoggingOut(true);

    try {
      await auth.signOut({
        fetchOptions: {
          onResponse: async () => {
            queryClient.setQueryData(authQueryKey, null);
            await router.invalidate();
          },
        },
      });

      await navigate({ to: "/auth/login" });
    } catch (error) {
      console.error("Logout failed:", error);
      setIsLoggingOut(false);
      return;
    }

    setIsLoggingOut(false);
  };

  return (
    <aside className="flex w-64 flex-col border-r border-gray-200 bg-white">
      <div className="p-6">
        <Link to="/" className="transition-opacity hover:opacity-80">
          <h1 className="text-admin-text-primary text-xl font-bold">Quadball Canada</h1>
          <p className="text-admin-text-secondary text-sm">Dashboard</p>
        </Link>
      </div>
      <nav className="flex-1 space-y-2 px-4 py-2">
        {sidebarItems.map((item) => {
          const Icon = item.icon;
          return (
            <Link
              key={item.to}
              to={item.to}
              className="nav-item"
              {...(item.exact ? { activeOptions: { exact: true as const } } : {})}
              activeProps={{
                className: "nav-item-active",
                "aria-current": "page",
                "data-status": "active",
              }}
            >
              <Icon className="pointer-events-none h-5 w-5" />
              <span>{item.label}</span>
            </Link>
          );
        })}
      </nav>
      <div className="space-y-2 border-t border-gray-200 px-4 py-4">
        {secondaryItems.map((item) => {
          const Icon = item.icon;
          return (
            <Link
              key={item.to}
              to={item.to}
              className="nav-item"
              {...(item.exact ? { activeOptions: { exact: true as const } } : {})}
              activeProps={{
                className: "nav-item-active",
                "aria-current": "page",
                "data-status": "active",
              }}
            >
              <Icon className="pointer-events-none h-5 w-5" />
              <span>{item.label}</span>
            </Link>
          );
        })}
        <button
          type="button"
          onClick={handleLogout}
          className="nav-item w-full text-left hover:bg-red-50 hover:text-red-600 disabled:opacity-60"
          disabled={isLoggingOut}
        >
          <LogOut className="h-5 w-5" />
          <span>{isLoggingOut ? "Logging out..." : "Logout"}</span>
        </button>
      </div>
    </aside>
  );
}
</file>

</files>
