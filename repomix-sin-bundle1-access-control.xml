This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/features/reports/reports.queries.ts, src/features/reports/reports.mutations.ts, src/features/reports/components/report-builder-shell.tsx, src/features/organizations/organizations.queries.ts, src/features/organizations/organizations.mutations.ts, src/features/organizations/organizations.access.ts, src/features/privacy/privacy.mutations.ts, src/features/privacy/privacy.queries.ts, src/features/reporting/reporting.queries.ts, src/features/reporting/reporting.mutations.ts, src/features/notifications/notifications.mutations.ts, src/features/notifications/notifications.queries.ts, src/lib/auth/guards/org-guard.ts, src/lib/auth/guards/org-context.ts, src/lib/auth/middleware/auth-guard.ts, src/lib/auth/utils/admin-check.ts, src/lib/server/errors.ts, src/features/roles/permission.service.ts, src/features/roles/permission.server.ts, docs/sin-rfp/route-tree-implementation-review.md, docs/sin-rfp/route-tree-implementation-plan.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<user_provided_header>
# Review Task: Security & Access Control Audit

## Focus
Review this code for **security vulnerabilities and access control gaps** identified in `route-tree-implementation-review.md`.

## Key Questions
1. Are server functions properly enforcing authentication (`requireSession`, `requireAdmin`)?
2. Are organization-scoped queries properly checking `requireOrganizationAccess` vs `requireOrganizationMembership`?
3. Can unauthenticated users access sensitive data?
4. Are there privilege escalation risks (e.g., any authenticated user can perform admin actions)?
5. Is org context properly validated before allowing access to org-scoped resources?

## Known Issues to Verify/Expand
The `route-tree-implementation-review.md` file contains findings - verify these and identify any additional issues:
- Saved reports not scoped to organization
- SIN admin endpoints missing admin enforcement
- Privacy admin mutations missing admin checks
- Reporting queries allowing unauthenticated access
- Notification mutations lacking proper auth

## Output Format
For each issue found:
1. **Severity**: High/Medium/Low
2. **Location**: file:line
3. **Issue**: What's wrong
4. **Impact**: What could happen
5. **Fix**: Suggested remediation
</user_provided_header>

<directory_structure>
docs/
  sin-rfp/
    route-tree-implementation-plan.md
    route-tree-implementation-review.md
src/
  features/
    notifications/
      notifications.mutations.ts
      notifications.queries.ts
    organizations/
      organizations.access.ts
      organizations.mutations.ts
      organizations.queries.ts
    privacy/
      privacy.mutations.ts
      privacy.queries.ts
    reporting/
      reporting.mutations.ts
      reporting.queries.ts
    reports/
      components/
        report-builder-shell.tsx
      reports.mutations.ts
      reports.queries.ts
    roles/
      permission.server.ts
      permission.service.ts
  lib/
    auth/
      guards/
        org-context.ts
        org-guard.ts
      middleware/
        auth-guard.ts
      utils/
        admin-check.ts
    server/
      errors.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/sin-rfp/route-tree-implementation-plan.md">
# Tenant Distribution + Route Tree Implementation Plan

This plan converts the current single-tenant QC-centric app into a dual-distribution
(QC + viaSport) platform with a tenant-driven route tree, feature gating, org context,
and branding. It is a file-by-file implementation plan with explicit sequencing.

## Context to Read Before Implementing

### High-level RFP + architecture context
- `docs/sin-rfp/Gpt-5.2-pro-conversaion.md`
- `docs/sin-rfp/system-requirements-addendum.md`
- `docs/sin-rfp/viasport-sin-rfp.md`
- `docs/sin-rfp/tickets/SIN-IMPLEMENTATION-BACKLOG-V2.md`
- `docs/sin-rfp/phase-0/architecture-reference.md`
- `docs/sin-rfp/phase-0/security-controls.md`
- `docs/sin-rfp/phase-0/audit-retention-policy.md`

### Repo-wide rules + architecture notes
- `AGENTS.md`
- `CLAUDE.md`
- `CODE_GUIDE.md`
- `.cursor/rules/*` (expected, but not present; only `.cursor/rules_unused/` exists)
- `docs/quadball-plan/*` (read as needed for feature-specific decisions)

### Existing layout + navigation
- `src/features/layouts/admin-layout.tsx`
- `src/features/layouts/admin-nav.ts`
- `src/components/ui/admin-sidebar.tsx`
- `src/components/ui/mobile-admin-header.tsx`
- `src/components/ui/breadcrumbs.tsx`
- `src/styles.css`

### Existing routing
- [x] `src/routes/__root.tsx`
- `src/routes/index.tsx`
- `src/routes/onboarding/route.tsx`
- `src/routes/dashboard/route.tsx`
- `src/routes/dashboard/index.tsx`
- `src/routes/dashboard/forbidden.tsx`
- `src/routes/dashboard/admin/route.tsx`
- `src/routes/dashboard/admin/roles.tsx`
- `src/routes/dashboard/admin/sin.tsx`
- `src/routes/dashboard/events.tsx` + `src/routes/dashboard/events/*`
- `src/routes/dashboard/teams.tsx` + `src/routes/dashboard/teams/*`
- `src/routes/api/*` (Square callbacks/webhooks)
- `src/routes/api/health.ts`

### Org context + auth guards
- `src/lib/auth/guards/route-guards.ts`
- `src/lib/auth/guards/org-guard.ts`
- `src/lib/auth/guards/org-context.ts`
- `src/lib/auth/middleware/auth-guard.ts`
- `src/lib/auth/utils/admin-check.ts`
- `src/lib/server/errors.ts`

### Tenant-sensitive features to gate
- `src/features/organizations/*`
- `src/features/audit/*`
- `src/features/forms/*`
- `src/features/imports/*`
- `src/features/reporting/*`
- `src/features/reports/*`
- `src/features/security/*`
- `src/features/privacy/*`
- `src/features/notifications/*`
- `src/features/membership/*`
- `src/features/events/*`
- `src/features/teams/*`
- `src/features/members/*`

### Branding + auth
- `src/features/auth/components/login.tsx`
- `src/features/auth/components/signup.tsx`
- `src/features/dashboard/PublicPortalPage.tsx`
- `src/components/ui/logo.tsx`
- `src/lib/auth/server-helpers.ts`
- `src/lib/email/sendgrid.ts`
- `vite.config.ts` (PWA manifest)

### Environment + infra
- `src/lib/env.client.ts`
- `src/lib/env.server.ts`
- `sst.config.ts`
- `sst-env.d.ts`
- `.env`, `.env.local`, `.env.e2e` (values only, do not commit)
- `src/db/schema/organizations.schema.ts`
- `src/db/migrations/*` (org type enum migration)

---

## End State (Route Tree)

This is the target route tree. It keeps `/dashboard/*` as the main authenticated shell
and splits SIN admin into sub-routes. It introduces `/dashboard/sin/*` for viaSport
user-facing SIN features and `/dashboard/select-org` for org context selection.

```txt
src/routes/
  __root.tsx
  index.tsx

  auth/
    route.tsx
    login.tsx
    signup.tsx

  onboarding/
    route.tsx
    index.tsx

  api/
    ... (unchanged)

  dashboard/
    route.tsx                 # AppLayout
    index.tsx                 # QC dashboard OR redirect to /dashboard/sin
    forbidden.tsx
    profile.tsx
    settings.tsx
    privacy.tsx
    select-org.tsx            # NEW

    # QC product (existing)
    membership.tsx
    members.tsx
    reports.tsx

    events.tsx
    events/
      index.tsx
      create.tsx
      $slug.tsx
      $slug.index.tsx
      $slug.register.tsx
      $eventId.manage.tsx

    teams.tsx
    teams/
      index.tsx
      browse.tsx
      create.tsx
      $teamId.tsx
      $teamId.index.tsx
      $teamId.manage.tsx
      $teamId.members.tsx

    # viaSport product (NEW)
    sin.tsx                   # layout + org selection guard
    sin/
      index.tsx
      reporting.tsx
      forms.tsx
      forms/
        $formId.tsx
      submissions/
        $submissionId.tsx
      imports.tsx
      analytics.tsx

    admin/
      route.tsx               # admin subnav layout inside AppLayout
      index.tsx               # admin landing
      roles.tsx

      sin.tsx                 # SIN Admin layout (subnav + outlet)
      sin/
        index.tsx
        organizations.tsx
        audit.tsx
        notifications.tsx
        security.tsx
        privacy.tsx
        forms.tsx
        imports.tsx
        reporting.tsx
        analytics.tsx
```

**Adjustment to the GPT conversation tree:** keep a single AppLayout for `/dashboard/*`
so the sidebar is consistent and we avoid double sidebars. Admin and SIN Admin
subnavs render inside the content area for `/dashboard/admin/*` and
`/dashboard/admin/sin/*`.

---

## Phase 0 — Tenant Model & Feature Flags (Foundation)

### Create tenant config and feature gating
- [x] `src/tenant/tenant.types.ts`
  - Define `TenantKey`, `FeatureKey`, `TenantConfig`, `BrandConfig`.
  - Add `OrgTypeLabelMap`, `OrgHierarchyRules`, `AdminRoleNames`.
  - FeatureKey set should include baseline vs SIN features, for example:
    - Distribution: `qc_portal`, `sin_portal`
    - QC modules: `qc_membership`, `qc_events`, `qc_teams`, `qc_members_directory`,
      `qc_reports`, `qc_payments_square`
    - SIN admin modules: `sin_admin`, `sin_admin_orgs`, `sin_admin_audit`,
      `sin_admin_notifications`, `sin_admin_security`, `sin_admin_privacy`,
      `sin_admin_forms`, `sin_admin_imports`, `sin_admin_reporting`,
      `sin_admin_analytics`
    - SIN user modules: `sin_reporting`, `sin_forms`, `sin_imports`, `sin_analytics`
    - Platform baseline: `security_core`, `notifications_core`
  - Default baseline features to `true` for both tenants unless explicitly disabled.
- [x] `src/tenant/tenant-env.ts`
  - Read `TENANT_KEY` (server) and `VITE_TENANT_KEY` (client).
  - Default to `qc`, validate against allowed values.
  - Hard-fail on mismatch if both are present (canonical rule):
    - Server: `TENANT_KEY ?? VITE_TENANT_KEY ?? "qc"`
    - Client: `VITE_TENANT_KEY ?? "qc"`
    - If both exist and differ: throw (dev + prod)
- [x] `src/tenant/tenants/qc.ts`
  - QC branding, feature flags, org labels, hierarchy rules.
- [x] `src/tenant/tenants/viasport.ts`
  - viaSport branding, feature flags, org labels, hierarchy rules.
- [x] `src/tenant/index.ts`
  - Export `tenant`, `getTenantConfig()`, `isTenant()`, `getBrand()`.
- [x] `src/tenant/feature-gates.ts`
  - `isFeatureEnabled(key)`
  - `assertFeatureEnabled(key)` for server calls
  - `requireFeatureInRoute(key)` for route `beforeLoad`
  - `filterNavItems(items, user)` helper for UI gating

### Wire env values
- [x] `src/lib/env.client.ts`
  - Add `VITE_TENANT_KEY` to client env schema.
- [x] `src/lib/env.server.ts`
  - Add `TENANT_KEY` and `VITE_TENANT_KEY` to server env schema.
  - Suggested schema:
    - `TENANT_KEY: z.enum([\"qc\", \"viasport\"]).prefault(\"qc\")`
    - `VITE_TENANT_KEY: z.enum([\"qc\", \"viasport\"]).optional()`
- [x] `sst.config.ts`
  - Set `TENANT_KEY` and `VITE_TENANT_KEY` in `environment`.
  - Use different values per AWS account/stage.
  - Prefer canonical stages: `qc-dev`, `sin-dev`, `qc-perf`, `sin-perf`,
    `qc-prod`, `sin-prod` (prefix selects tenant, suffix selects env class).
    Hard-fail if canonical stage implies a tenant that disagrees with
    `TENANT_KEY`/`VITE_TENANT_KEY`.
  - Optional: derive `app.name` from tenant (e.g., `solstice-qc`, `solstice-viasport`)
    if you want separate stack names. Decide before changing to avoid state churn.

### Add real `league` org type (Decision: Option A)
- [x] `src/db/schema/organizations.schema.ts`
  - Add `league` to `organizationTypeEnum`.
- [x] `src/features/organizations/organizations.schemas.ts`
  - Add `league` to `organizationTypeSchema`.
- [x] `src/features/organizations/components/organization-admin-panel.tsx`
  - Add `league` to org type options.
- [x] `src/features/reporting/reporting.schemas.ts`
  - Add `league` to `reportingOrganizationTypeSchema`.
- [x] `src/features/reporting/components/reporting-dashboard-shell.tsx`
  - Add `league` to `organizationTypeOptions`.
- [x] `src/db/migrations/*`
  - Generate + apply enum migration (`organization_type`).
  - Org hierarchy note:
    - viaSport: `governing_body → pso → league → club → (teams)`
    - QC: `pso → league → club → (teams)` (QC can set root as `pso` or `governing_body`)

---

## Phase 1 — Global Admin Roles + Tenant-Aware Permissions

### Replace hard-coded role names with tenant config
- [x] `src/lib/auth/utils/admin-check.ts`
  - Use `tenant.admin.globalRoleNames` for global admin checks.
- [x] `src/features/roles/permission.service.ts`
  - Use tenant role names in `isGlobalAdmin()` and `isAnyAdmin()`.
- [x] `src/features/roles/permission.server.ts`
  - Use tenant role names in server checks.
  - Ensure tenant role names match existing seeded roles (or update seeds/tests).

### Update role UI + tests
- [x] `src/features/roles/components/role-management-dashboard.tsx`
  - Replace “Solstice/Quadball” copy with tenant brand.
- [x] `src/features/roles/__tests__/permission.service.test.ts`
  - Update expected global role names.
- [x] `src/features/roles/components/__tests__/role-management-dashboard.test.tsx`
  - Update snapshot/copy expectations.

### Seed scripts
- [x] `scripts/seed-global-admins.ts`
  - Derive default global roles from tenant config.
  - Add viaSport global admin role(s) if absent.

---

## Phase 2 — Server-Side Feature Gating (Non-negotiable)

Add `assertFeatureEnabled()` at the top of each server function to ensure
QC cannot call viaSport-only endpoints even if URLs are guessed.

### QC-only features
- [x] `src/features/membership/membership.queries.ts`
- [x] `src/features/membership/membership.mutations.ts`
- [x] `src/features/membership/membership.admin-queries.ts`
- [x] `src/features/events/events.queries.ts`
- [x] `src/features/events/events.mutations.ts`
- [x] `src/features/teams/teams.queries.ts`
- [x] `src/features/teams/teams.mutations.ts`
- [x] `src/features/teams/teams.cleanup.ts`
- [x] `src/features/members/members.queries.ts`

### viaSport SIN features
- [x] `src/features/organizations/organizations.queries.ts`
- [x] `src/features/organizations/organizations.mutations.ts`
- [x] `src/features/audit/audit.queries.ts`
- [x] `src/features/forms/forms.queries.ts`
- [x] `src/features/forms/forms.mutations.ts`
- [x] `src/features/imports/imports.queries.ts`
- [x] `src/features/imports/imports.mutations.ts`
- [x] `src/features/reporting/reporting.queries.ts`
- [x] `src/features/reporting/reporting.mutations.ts`
- [x] `src/features/reports/reports.queries.ts`
- [x] `src/features/reports/reports.mutations.ts`
- [x] `src/features/security/security.queries.ts`
- [x] `src/features/security/security.mutations.ts`
- [x] `src/features/privacy/privacy.queries.ts`
- [x] `src/features/privacy/privacy.mutations.ts`
- [x] `src/features/notifications/notifications.queries.ts`
- [x] `src/features/notifications/notifications.mutations.ts`
  - Template CRUD guarded by `sin_admin_*`; user preference endpoints stay
    enabled under `notifications_core`.
  - Keep core security/notification protections enabled even when SIN admin is off.

### API routes to gate
- [x] `src/routes/api/payments/square/callback.ts`
- [x] `src/routes/api/webhooks/square.ts`
- [x] `src/routes/api/test-square.ts`
- [x] `src/routes/api/debug-square.ts`

---

## Phase 3 — Navigation + Layout Refactor

### Navigation types and generators
- [x] `src/features/layouts/nav.types.ts`
  - `NavItem` type with `feature`, `requiresGlobalAdmin`, `requiresOrgRole`.
- [x] `src/features/layouts/app-nav.ts`
  - Build nav lists for QC vs viaSport based on feature flags.
- [x] `src/features/layouts/admin-nav.ts`
  - Convert from static arrays to `getAdminNav()`.
- [x] `src/features/layouts/sin-admin-nav.ts`
  - Add SIN Admin subnav items.

### Layout components
- [x] `src/features/layouts/app-layout.tsx`
  - New AppLayout used by `/dashboard/route.tsx`.
- [x] `src/components/ui/app-sidebar.tsx`
  - Single sidebar with sections (Portal / Admin Console / Account).
- [x] `src/features/layouts/admin-layout.tsx`
  - Either remove or convert to a lightweight AdminSectionLayout
    (no sidebar; AppLayout already provides it).
- [x] `src/components/ui/mobile-app-header.tsx`
  - New mobile header for AppLayout with brand + NotificationBell.
- [x] `src/components/ui/mobile-admin-header.tsx`
  - Tenant-driven brand text and “Admin Console”.
- [x] `src/components/ui/breadcrumbs.tsx`
  - Add labels for `sin`, `organizations`, `audit`, `notifications`, etc.

---

## Phase 4 — Route Refactor to Target Tree

### Base layout
- [x] `src/routes/dashboard/route.tsx`
  - Render `AppLayout` and keep `requireAuthAndProfile` guard.
- [x] `src/routes/onboarding/route.tsx`
  - Use AppLayout or a minimal layout; keep redirect logic.

### QC routes (gated)
- [x] `src/routes/dashboard/index.tsx`
  - Redirect to `/dashboard/sin` for viaSport tenant.
- [x] `src/routes/dashboard/membership.tsx`
  - Add `beforeLoad` feature gate `qc_membership`.
- [x] `src/routes/dashboard/members.tsx`
  - Add `beforeLoad` feature gate `qc_members_directory`.
- [x] `src/routes/dashboard/reports.tsx`
  - Add `beforeLoad` feature gate `qc_reports`.
- [x] `src/routes/dashboard/events.tsx`
  - Add `beforeLoad` feature gate `qc_events` (covers child routes).
- [x] `src/routes/dashboard/teams.tsx`
  - Add `beforeLoad` feature gate `qc_teams` (covers child routes).

### viaSport SIN user portal
- [x] `src/routes/dashboard/sin.tsx` (NEW)
  - Layout route: `requireFeatureInRoute("sin_portal")`
  - Enforce active org selection or redirect to `/dashboard/select-org`.
- [x] `src/routes/dashboard/sin/index.tsx` (NEW)
  - SIN landing with cards linking to reporting/forms/imports/analytics.
- [x] `src/routes/dashboard/sin/reporting.tsx` (NEW)
  - Render reporting user dashboard (subset of `ReportingDashboardShell`).
- [x] `src/routes/dashboard/sin/forms.tsx` (NEW)
  - List assigned forms for active org.
- [x] `src/routes/dashboard/sin/forms/$formId.tsx` (NEW)
  - Form submission view using existing form renderer.
- [x] `src/routes/dashboard/sin/submissions/$submissionId.tsx` (NEW)
  - Submission detail and history view.
- [x] `src/routes/dashboard/sin/imports.tsx` (NEW)
  - Read-only status view for imports (if needed for users).
- [x] `src/routes/dashboard/sin/analytics.tsx` (NEW)
  - Report builder/export UI gated by org role.

### Admin routes
- [x] `src/routes/dashboard/admin/route.tsx`
  - Render AdminSectionLayout and keep `requireGlobalAdmin` guard.
- [x] `src/routes/dashboard/admin/index.tsx` (NEW)
  - Admin landing links: Roles + SIN Admin.
- [x] `src/routes/dashboard/admin/sin.tsx`
  - Convert to layout route with `SinAdminSubnav` + `<Outlet />`.
  - Gate at the parent layout route whenever possible to avoid per-page misses.
- [x] `src/routes/dashboard/admin/sin/index.tsx` (NEW)
  - Overview cards for SIN admin modules.
- [x] `src/routes/dashboard/admin/sin/organizations.tsx`
  - Render `OrganizationAdminPanel`.
- [x] `src/routes/dashboard/admin/sin/audit.tsx`
  - Render `AuditLogTable`.
- [x] `src/routes/dashboard/admin/sin/notifications.tsx`
  - Render notification admin UI.
- [x] `src/routes/dashboard/admin/sin/security.tsx`
  - Render `SecurityDashboard`.
- [x] `src/routes/dashboard/admin/sin/privacy.tsx`
  - Render `PrivacyDashboard`, `PrivacyAdminPanel`, `RetentionPolicyPanel`.
- [x] `src/routes/dashboard/admin/sin/forms.tsx`
  - Render `FormBuilderShell`.
- [x] `src/routes/dashboard/admin/sin/imports.tsx`
  - Render `ImportWizardShell`.
- [x] `src/routes/dashboard/admin/sin/reporting.tsx`
  - Render `ReportingDashboardShell`.
- [x] `src/routes/dashboard/admin/sin/analytics.tsx`
  - Render `ReportBuilderShell`.

### Org selection
- [x] `src/routes/dashboard/select-org.tsx` (NEW)
  - Org selection UI (see Phase 5).

---

## Phase 5 — Org Context & Org Switcher

### Org access model
- [x] `src/features/organizations/organizations.access.ts` (NEW)
  - Compute accessible orgs for a user via membership + delegated access + descendants.
- [x] `src/features/organizations/organizations.queries.ts`
  - Add `listAccessibleOrganizations()` for OrgSwitcher.
- [x] `src/features/organizations/organizations.mutations.ts`
  - Enforce tenant hierarchy rules on create/update.

### Client org context
- [x] `src/features/organizations/components/org-switcher.tsx` (NEW)
  - Render accessible orgs and set `active_org_id` cookie.
- [x] `src/features/organizations/org-context.tsx` (NEW)
  - React context and hook for active org id.

### Server org context
- [x] `src/lib/auth/guards/org-context.ts`
  - Prefer cookie (`active_org_id`), allow `x-organization-id` override,
    always verify membership server-side.
- [x] `src/lib/auth/middleware/auth-guard.ts`
  - Include resolved org id/role in function context.
- [x] `src/start.ts`
  - Add client-side function middleware to pass active org if needed.
  - Cookie config (if set via server response):
    - `httpOnly: true`, `secure: isProduction()`, `sameSite: \"lax\"`
    - `maxAge: 60 * 60 * 24 * 30` (30 days)

---

## Phase 6 — Tenant Branding + Copy

Replace hard-coded QC copy with tenant-driven branding.

- `src/routes/__root.tsx`
  - Use tenant brand for `<title>` and meta description.
  - Add `data-tenant` attribute for CSS overrides.
- [x] `src/styles.css`
  - Add `[data-tenant="viasport"]` CSS variable overrides.
- [x] `src/components/ui/logo.tsx`
  - Use tenant-specific logo and alt text.
- [x] `src/components/ui/app-sidebar.tsx`
  - Brand name + subtitle from tenant config.
- [x] `src/components/ui/mobile-app-header.tsx`
  - Tenant brand + subtitle.
- [x] `src/components/ui/admin-sidebar.tsx`
  - Tenant brand + “Admin Console” label.
- [x] `src/components/ui/mobile-admin-header.tsx`
  - Tenant brand + “Admin Console” label.
- [x] `src/features/auth/components/login.tsx`
- [x] `src/features/auth/components/signup.tsx`
- [x] `src/features/dashboard/PublicPortalPage.tsx`
- [x] `src/features/dashboard/MemberDashboard.tsx`
- [x] `src/routes/dashboard/index.tsx`
- [x] `src/routes/dashboard/membership.tsx`
- [x] `src/routes/dashboard/members.tsx`
- [x] `src/routes/dashboard/forbidden.tsx`
- [x] `src/lib/auth/server-helpers.ts`
  - Use tenant brand for `appName` and 2FA issuer.
- [x] `src/lib/email/sendgrid.ts`
- [x] `vite.config.ts`
  - Make PWA manifest tenant-aware (name, short_name, theme_color, icons).
  - Store tenant-specific icons under `public/icons/` (e.g., `viasport-icon.svg`).

---

## Phase 7 — QA, Tests, and Docs

### Tests
- [x] `src/features/layouts/__tests__/admin-layout.test.tsx`
  - Update for AppLayout + tenant branding.
- [x] `src/features/roles/__tests__/permission.service.test.ts`
- [x] `src/features/roles/components/__tests__/role-management-dashboard.test.tsx`
- [x] `src/tenant/__tests__/feature-gates.test.ts`
- [x] `src/tenant/__tests__/tenant-env.test.ts`
- [x] `e2e/tests/*`
  - Add checks: QC cannot access `/dashboard/sin/*`.
  - viaSport redirects `/dashboard` → `/dashboard/sin`.

### Documentation
- [x] `docs/sin-rfp/phase-0/architecture-reference.md`
  - Add tenant distribution layer explanation.
- [x] `docs/sin-rfp/phase-0/security-controls.md`
  - Add note on server-side feature gating.
- [x] `docs/sin-rfp/phase-0/audit-retention-policy.md`
  - Ensure policy references org-scoped auditing.
- [x] `docs/sin-rfp/route-tree-implementation-plan.md`
  - Keep environment mismatch hard-fail requirements and org hierarchy notes.

---

## Notes & Guardrails

- Do not introduce non-ASCII content in code files unless it already exists.
- Server-only imports must remain inside `handler()` (TanStack Start rule).
- Feature gating must be done in three layers: UI, route guard, server fn.
- Prefer a single AppLayout for `/dashboard/*` to avoid double sidebars.
- Org type labels can be tenant-specific, but the DB enum must include `league`.
- Tenant key mismatch must hard-fail (dev + prod).

---

## Sequencing Summary

1. Tenant model + env wiring (Phase 0)
2. Global admin role + permission wiring (Phase 1)
3. Server-side feature gating (Phase 2)
4. AppLayout + nav refactor (Phase 3)
5. Route tree refactor (Phase 4)
6. Org context + org switcher (Phase 5)
7. Branding + tenant copy (Phase 6)
8. Tests + docs (Phase 7)

This sequence minimizes churn and prevents QC from accessing viaSport-only endpoints
at any step.
</file>

<file path="docs/sin-rfp/route-tree-implementation-review.md">
# Route Tree Implementation Review (In Progress)

## Scope
- Compare current working tree changes against `docs/sin-rfp/route-tree-implementation-plan.md`.
- Focus on correctness, regressions, security/tenant gating, and missing tests.

## Progress Log
- 2025-02-??: Collected git status + diffs for tenant config, routing, layouts, org context, feature gating, branding, tests, and docs.
- 2025-02-??: Reviewed org admin, privacy, notification, and reporting server functions for access control gaps.

## Findings (Partial)

## Notes
- This document will be appended throughout the review, not only at the end.

### High
1. Saved report endpoints are not scoped to organization access.
   - `listSavedReports` returns all saved reports when no `organizationId` is provided, and mutations allow any authenticated user with `sin_analytics` to create/update/delete reports for arbitrary org IDs.
   - Impact: cross-org report metadata exposure and potential data tampering (saved report definitions) across tenants/orgs; `listSavedReports` has no auth guard, so unauth callers can enumerate reports.
   - Evidence: `src/features/reports/reports.queries.ts:13`, `src/features/reports/reports.queries.ts:23`, `src/features/reports/reports.mutations.ts:130`, `src/features/reports/reports.mutations.ts:171`, `src/features/reports/components/report-builder-shell.tsx:296`.
   - Suggested fix: enforce `requireOrganizationAccess` for organization-scoped saved reports and scope list queries to the caller’s active org or accessible org list.

2. SIN organization admin endpoints are missing admin enforcement (privilege escalation).
   - `createOrganization` only checks `sin_admin_orgs` + session, so any signed-in user can create orgs and become owner. `searchOrganizations` and `listAllOrganizations` are labeled admin-only but have no auth/role guard.
   - Impact: non-admin users can create orgs and enumerate all orgs, bypassing intended SIN admin controls.
   - Evidence: `src/features/organizations/organizations.mutations.ts:120`, `src/features/organizations/organizations.queries.ts:96`, `src/features/organizations/organizations.queries.ts:123`.
   - Suggested fix: require `requireAdmin`/`PermissionService.isGlobalAdmin` for admin-only org mutations and list-all queries.

3. Privacy admin mutations are missing admin enforcement.
   - Admin-only actions (create policy documents, update privacy requests, retention policy upserts) only check `sin_admin_privacy` + session.
   - Impact: any authenticated user can publish privacy policy versions, change privacy request outcomes, or alter retention rules.
   - Evidence: `src/features/privacy/privacy.mutations.ts:23`, `src/features/privacy/privacy.mutations.ts:133`, `src/features/privacy/privacy.mutations.ts:171`.
   - Suggested fix: require `requireAdmin` for all `sin_admin_privacy` mutations.

4. Reporting queries allow unauthenticated access to sensitive org data.
   - `listReportingTasks` and `listReportingSubmissions` skip auth when no session exists; `listReportingTasks` returns all tasks when no filters are supplied; `listReportingCycles` is also unauthenticated.
   - Impact: unauth callers can enumerate reporting cycles, tasks, and submissions across orgs.
   - Evidence: `src/features/reporting/reporting.queries.ts:36`, `src/features/reporting/reporting.queries.ts:46`, `src/features/reporting/reporting.queries.ts:80`.
   - Suggested fix: require session and org access for all reporting queries, and block unauth access early.

### Medium
1. Active org selection can be bypassed or go stale across sessions.
   - `/dashboard/sin` relies on `context.activeOrganizationId` from `__root`, which reads localStorage/cookie without validating access. Logout does not clear `active_org_id`, so a new user can inherit a stale org and skip `/dashboard/select-org`.
   - Impact: users can land in SIN routes without a valid org selection; server functions still validate access, but the route guard no longer guarantees a valid org context.
   - Evidence: `src/routes/dashboard/sin.tsx:5`, `src/routes/__root.tsx:56`, `src/routes/__root.tsx:68`, `src/components/ui/app-sidebar.tsx:38`, `src/features/organizations/org-context.tsx:23`, `src/features/organizations/components/org-switcher.tsx:22`.
   - Suggested fix: clear `active_org_id` on logout and/or validate the active org against accessible orgs in `beforeLoad` before allowing SIN routes.

2. Report export relies on headers/filters that portal UI does not set.
   - `exportReport` looks for `x-organization-id` or `filters.organizationId`, but the analytics UI does not send either, so non-admin exports fail unless users hand-edit JSON filters.
   - Impact: portal analytics export is broken for non-admin users; delegated org access is ignored because `requireOrganizationMembership` is used.
   - Evidence: `src/features/reports/reports.mutations.ts:287`, `src/features/reports/reports.mutations.ts:301`, `src/features/reports/components/report-builder-shell.tsx:301`.
   - Suggested fix: derive org context from function middleware (`context.organizationId`) and use `requireOrganizationAccess` to support delegated access.

3. Delegated analytics scope does not grant access to analytics UI.
   - Delegated scope `analytics` maps to role `viewer`, but the SIN analytics route requires `owner|admin|reporter`.
   - Impact: users granted analytics-only delegated access are blocked from analytics.
   - Evidence: `src/features/organizations/organizations.access.ts:29`, `src/routes/dashboard/sin/analytics.tsx:16`.
   - Suggested fix: map `analytics` scope to a role allowed by the analytics route (or expand allowed roles).

4. Tenant env resolution imports client env in server contexts.
   - `tenant-env.ts` imports `env.client.ts`, which reads `import.meta.env` directly. This can throw in Node scripts (e.g., `tsx` seed scripts) where `import.meta.env` is undefined.
   - Impact: seed scripts that now call `getTenantConfig()` may crash outside Vite/SSR.
   - Evidence: `src/tenant/tenant-env.ts:2`, `src/lib/env.client.ts:19`, `scripts/seed-global-admins.ts:12`.
   - Suggested fix: avoid importing `env.client` in server contexts or guard `import.meta.env` access.

5. Global admins cannot manage orgs unless they are members.
   - Org admin endpoints rely on `requireOrganizationMembership` instead of `requireOrganizationAccess`, so global admins (or delegated access) are blocked from listing members, updating orgs, or reviewing delegated access unless they are explicitly added to the org. Admin UIs also call `listOrganizations` (member-scoped), so org dropdowns can be empty for global admins.
   - Impact: SIN admin workflows break for global admins who are not members of every org.
   - Evidence: `src/features/organizations/organizations.mutations.ts:205`, `src/features/organizations/organizations.queries.ts:156`, `src/features/forms/components/form-builder-shell.tsx:618`, `src/features/reporting/components/reporting-dashboard-shell.tsx:72`.
   - Suggested fix: use `requireOrganizationAccess` for admin flows or explicitly allow global admins.

6. Organization lookup by ID lacks auth/membership checks.
   - `getOrganization` only checks `sin_portal` and returns org data by ID without verifying access.
   - Impact: org metadata can be fetched by any caller who can reach the server function.
   - Evidence: `src/features/organizations/organizations.queries.ts:31`.
   - Suggested fix: require session and `requireOrganizationAccess` (or limit to active org).

7. Notification admin mutations lack admin checks, and notification creation is unauthenticated.
   - `createNotificationTemplate` and `scheduleNotification` only check `sin_admin_notifications` + session; `createNotification` has no session guard at all.
   - Impact: any authenticated (or unauthenticated) caller could create templates, schedule notifications, or send notifications for arbitrary users/orgs.
   - Evidence: `src/features/notifications/notifications.mutations.ts:122`, `src/features/notifications/notifications.mutations.ts:159`, `src/features/notifications/notifications.mutations.ts:248`.
   - Suggested fix: require `requireAdmin` for admin templates/scheduling and enforce actor identity for direct notification creation.

### Low
1. Analytics feature flag coupling is stricter than the plan implies.
   - Admin routes gate with `sin_admin_analytics`, but report server functions only check `sin_analytics`. If tenant config ever disables portal analytics while keeping admin analytics, admin analytics would break.
   - Evidence: `src/features/reports/reports.queries.ts:13`, `src/features/reports/reports.mutations.ts:267`, `src/routes/dashboard/admin/sin/analytics.tsx:9`.
   - Suggested fix: align server gating with `sin_admin_analytics` (or explicitly document that `sin_admin_analytics` implies `sin_analytics`).

2. Admin section copy references SIN even when SIN admin is disabled.
   - The admin section description always mentions “SIN administration,” which is misleading for QC-only tenants.
   - Evidence: `src/features/layouts/admin-layout.tsx:21`.
   - Suggested fix: conditional copy based on `sin_admin` feature flag.

3. New migration includes `form_submissions.import_job_id` outside the route-tree plan.
   - The plan only called for the `organization_type` enum update; this migration also adds `import_job_id`.
   - Impact: extra schema change without documentation; may be fine but should be tracked in plan/docs.
   - Evidence: `src/db/migrations/0011_curly_iron_man.sql:1`.
   - Suggested fix: update plan or document why this schema change is bundled here.

## Review Status
- In progress. Findings will continue to be appended.
</file>

<file path="src/features/organizations/organizations.access.ts">
import { and, eq, gt, isNull, or } from "drizzle-orm";
import { getDb } from "~/db/server-helpers";
import { delegatedAccess, organizationMembers, organizations } from "~/db/schema";
import type { OrganizationRole } from "~/lib/auth/guards/org-guard";
import type { AccessibleOrganization } from "./organizations.types";

const rolePriority: Record<OrganizationRole, number> = {
  owner: 5,
  admin: 4,
  reporter: 3,
  viewer: 2,
  member: 1,
};

const pickHighestRole = (roles: Array<OrganizationRole | null | undefined>) => {
  let highest: OrganizationRole | null = null;
  let max = 0;
  for (const role of roles) {
    if (!role) continue;
    const rank = rolePriority[role] ?? 0;
    if (rank > max) {
      max = rank;
      highest = role;
    }
  }
  return highest;
};

const deriveRoleFromScopes = (scopes: string[]): OrganizationRole | null => {
  if (scopes.includes("admin")) return "admin";
  if (scopes.includes("reporting")) return "reporter";
  if (scopes.includes("analytics")) return "viewer";
  return null;
};

const buildOrgMaps = (orgs: Array<{ id: string; parentOrgId: string | null }>) => {
  const parentById = new Map<string, string | null>();
  const childrenByParent = new Map<string | null, string[]>();

  orgs.forEach((org) => {
    parentById.set(org.id, org.parentOrgId ?? null);
    const parentKey = org.parentOrgId ?? null;
    const children = childrenByParent.get(parentKey) ?? [];
    children.push(org.id);
    childrenByParent.set(parentKey, children);
  });

  return { parentById, childrenByParent };
};

const collectDescendants = (
  childrenByParent: Map<string | null, string[]>,
  rootIds: Iterable<string>,
) => {
  const queue = [...rootIds];
  const result = new Set(queue);

  while (queue.length > 0) {
    const current = queue.shift();
    if (!current) continue;
    const children = childrenByParent.get(current) ?? [];
    for (const child of children) {
      if (result.has(child)) continue;
      result.add(child);
      queue.push(child);
    }
  }

  return result;
};

export const listAccessibleOrganizationsForUser = async (
  userId: string,
): Promise<AccessibleOrganization[]> => {
  const { PermissionService } = await import("~/features/roles/permission.service");
  const isAdmin = await PermissionService.isGlobalAdmin(userId);

  const db = await getDb();
  const orgRows = await db
    .select({
      id: organizations.id,
      name: organizations.name,
      slug: organizations.slug,
      type: organizations.type,
      status: organizations.status,
      parentOrgId: organizations.parentOrgId,
      createdAt: organizations.createdAt,
      updatedAt: organizations.updatedAt,
    })
    .from(organizations);

  if (isAdmin) {
    return orgRows.map((org) => ({
      ...org,
      role: "admin",
    }));
  }

  const memberships = await db
    .select({
      organizationId: organizationMembers.organizationId,
      role: organizationMembers.role,
    })
    .from(organizationMembers)
    .where(
      and(
        eq(organizationMembers.userId, userId),
        eq(organizationMembers.status, "active"),
      ),
    );

  const now = new Date();
  const delegated = await db
    .select({
      organizationId: delegatedAccess.organizationId,
      scope: delegatedAccess.scope,
    })
    .from(delegatedAccess)
    .where(
      and(
        eq(delegatedAccess.delegateUserId, userId),
        isNull(delegatedAccess.revokedAt),
        or(isNull(delegatedAccess.expiresAt), gt(delegatedAccess.expiresAt, now)),
      ),
    );

  const membershipByOrg = new Map<string, OrganizationRole>(
    memberships.map((membership) => [
      membership.organizationId,
      membership.role as OrganizationRole,
    ]),
  );

  const delegatedScopesByOrg = new Map<string, string[]>();
  delegated.forEach((entry) => {
    const scopes = delegatedScopesByOrg.get(entry.organizationId) ?? [];
    scopes.push(entry.scope);
    delegatedScopesByOrg.set(entry.organizationId, scopes);
  });

  const baseOrgIds = new Set<string>([
    ...membershipByOrg.keys(),
    ...delegatedScopesByOrg.keys(),
  ]);

  if (baseOrgIds.size === 0) {
    return [];
  }

  const { parentById, childrenByParent } = buildOrgMaps(orgRows);
  const accessibleIds = collectDescendants(childrenByParent, baseOrgIds);

  const resolveRole = (orgId: string) => {
    const roles: OrganizationRole[] = [];
    let currentId: string | null | undefined = orgId;
    while (currentId) {
      const membershipRole = membershipByOrg.get(currentId);
      if (membershipRole) roles.push(membershipRole);
      const scopes = delegatedScopesByOrg.get(currentId);
      if (scopes && scopes.length > 0) {
        const delegatedRole = deriveRoleFromScopes(scopes);
        if (delegatedRole) roles.push(delegatedRole);
      }
      currentId = parentById.get(currentId) ?? null;
    }

    return pickHighestRole(roles);
  };

  return orgRows
    .filter((org) => accessibleIds.has(org.id))
    .map((org): AccessibleOrganization => ({
      ...org,
      role: resolveRole(org.id),
      delegatedScopes: delegatedScopesByOrg.get(org.id) ?? [],
    }));
};

export const resolveOrganizationAccess = async (params: {
  userId: string;
  organizationId: string;
}) => {
  const { userId, organizationId } = params;
  const { PermissionService } = await import("~/features/roles/permission.service");
  const isAdmin = await PermissionService.isGlobalAdmin(userId);
  if (isAdmin) {
    return { organizationId, role: "admin" };
  }

  const db = await getDb();
  const orgRows = await db
    .select({
      id: organizations.id,
      parentOrgId: organizations.parentOrgId,
    })
    .from(organizations);

  const { parentById } = buildOrgMaps(orgRows);
  const membershipRows = await db
    .select({
      organizationId: organizationMembers.organizationId,
      role: organizationMembers.role,
    })
    .from(organizationMembers)
    .where(
      and(
        eq(organizationMembers.userId, userId),
        eq(organizationMembers.status, "active"),
      ),
    );

  const now = new Date();
  const delegatedRows = await db
    .select({
      organizationId: delegatedAccess.organizationId,
      scope: delegatedAccess.scope,
    })
    .from(delegatedAccess)
    .where(
      and(
        eq(delegatedAccess.delegateUserId, userId),
        isNull(delegatedAccess.revokedAt),
        or(isNull(delegatedAccess.expiresAt), gt(delegatedAccess.expiresAt, now)),
      ),
    );

  const membershipByOrg = new Map<string, OrganizationRole>(
    membershipRows.map((membership) => [
      membership.organizationId,
      membership.role as OrganizationRole,
    ]),
  );

  const delegatedScopesByOrg = new Map<string, string[]>();
  delegatedRows.forEach((entry) => {
    const scopes = delegatedScopesByOrg.get(entry.organizationId) ?? [];
    scopes.push(entry.scope);
    delegatedScopesByOrg.set(entry.organizationId, scopes);
  });

  const roles: OrganizationRole[] = [];
  let currentId: string | null | undefined = organizationId;
  while (currentId) {
    const membershipRole = membershipByOrg.get(currentId);
    if (membershipRole) roles.push(membershipRole);
    const scopes = delegatedScopesByOrg.get(currentId);
    if (scopes && scopes.length > 0) {
      const delegatedRole = deriveRoleFromScopes(scopes);
      if (delegatedRole) roles.push(delegatedRole);
    }
    currentId = parentById.get(currentId) ?? null;
  }

  const role = pickHighestRole(roles);
  if (!role) {
    return null;
  }

  return { organizationId, role };
};
</file>

<file path="src/features/notifications/notifications.mutations.ts">
import { createServerFn } from "@tanstack/react-start";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import { zod$ } from "~/lib/server/fn-utils";
import {
  createNotificationSchema,
  createNotificationTemplateSchema,
  deleteNotificationTemplateSchema,
  dismissNotificationSchema,
  markNotificationReadSchema,
  scheduleNotificationSchema,
  updateNotificationPreferencesSchema,
  updateNotificationTemplateSchema,
} from "./notifications.schemas";
import type { NotificationPreferenceRow, NotificationRow } from "./notifications.types";

const getSessionUserId = async () => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const { getRequest } = await import("@tanstack/react-start/server");
  const auth = await getAuth();
  const { headers } = getRequest();
  const session = await auth.api.getSession({ headers });
  return session?.user?.id ?? null;
};

export const markNotificationRead = createServerFn({ method: "POST" })
  .inputValidator(zod$(markNotificationReadSchema))
  .handler(async ({ data }): Promise<NotificationRow | null> => {
    await assertFeatureEnabled("notifications_core");
    const userId = await getSessionUserId();
    if (!userId) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { notifications } = await import("~/db/schema");
    const { and, eq } = await import("drizzle-orm");

    const db = await getDb();
    const [updated] = await db
      .update(notifications)
      .set({ readAt: new Date() })
      .where(
        and(eq(notifications.id, data.notificationId), eq(notifications.userId, userId)),
      )
      .returning();

    return updated ?? null;
  });

export const dismissNotification = createServerFn({ method: "POST" })
  .inputValidator(zod$(dismissNotificationSchema))
  .handler(async ({ data }): Promise<NotificationRow | null> => {
    await assertFeatureEnabled("notifications_core");
    const userId = await getSessionUserId();
    if (!userId) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { notifications } = await import("~/db/schema");
    const { and, eq } = await import("drizzle-orm");

    const db = await getDb();
    const [updated] = await db
      .update(notifications)
      .set({ dismissedAt: new Date() })
      .where(
        and(eq(notifications.id, data.notificationId), eq(notifications.userId, userId)),
      )
      .returning();

    return updated ?? null;
  });

export const updateNotificationPreferences = createServerFn({ method: "POST" })
  .inputValidator(zod$(updateNotificationPreferencesSchema))
  .handler(async ({ data }): Promise<NotificationPreferenceRow | null> => {
    await assertFeatureEnabled("notifications_core");
    const userId = await getSessionUserId();
    if (!userId) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { notificationPreferences } = await import("~/db/schema");
    const { and, eq } = await import("drizzle-orm");

    const db = await getDb();
    const [existing] = await db
      .select()
      .from(notificationPreferences)
      .where(
        and(
          eq(notificationPreferences.userId, userId),
          eq(notificationPreferences.category, data.category),
        ),
      )
      .limit(1);

    if (existing) {
      const [updated] = await db
        .update(notificationPreferences)
        .set({
          channelEmail: data.channelEmail ?? existing.channelEmail,
          channelInApp: data.channelInApp ?? existing.channelInApp,
          emailFrequency: data.emailFrequency ?? existing.emailFrequency,
        })
        .where(eq(notificationPreferences.id, existing.id))
        .returning();

      return updated ?? null;
    }

    const [created] = await db
      .insert(notificationPreferences)
      .values({
        userId,
        category: data.category,
        channelEmail: data.channelEmail ?? true,
        channelInApp: data.channelInApp ?? true,
        emailFrequency: data.emailFrequency ?? "immediate",
      })
      .returning();

    return created ?? null;
  });

export const createNotification = createServerFn({ method: "POST" })
  .inputValidator(zod$(createNotificationSchema))
  .handler(async ({ data }): Promise<NotificationRow | null> => {
    await assertFeatureEnabled("notifications_core");
    const { getDb } = await import("~/db/server-helpers");
    const { notifications } = await import("~/db/schema");
    const db = await getDb();

    const [created] = await db
      .insert(notifications)
      .values({
        userId: data.userId,
        organizationId: data.organizationId ?? null,
        type: data.type,
        category: data.category,
        title: data.title,
        body: data.body,
        link: data.link ?? null,
        metadata: data.metadata ?? {},
      })
      .returning();

    if (created) {
      const { logDataChange } = await import("~/lib/audit");
      await logDataChange({
        action: "NOTIFICATION_CREATE",
        actorUserId: data.userId,
        actorOrgId: data.organizationId ?? null,
        targetType: "notification",
        targetId: created.id,
        targetOrgId: data.organizationId ?? null,
      });
    }

    return created ?? null;
  });

export const createNotificationTemplate = createServerFn({ method: "POST" })
  .inputValidator(zod$(createNotificationTemplateSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_notifications");
    const userId = await getSessionUserId();
    if (!userId) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { notificationTemplates } = await import("~/db/schema");
    const db = await getDb();

    const [created] = await db
      .insert(notificationTemplates)
      .values({
        key: data.key,
        category: data.category,
        subject: data.subject,
        bodyTemplate: data.bodyTemplate,
        isSystem: data.isSystem ?? false,
        createdBy: userId,
      })
      .returning();

    if (created) {
      const { logAdminAction } = await import("~/lib/audit");
      await logAdminAction({
        action: "NOTIFICATION_TEMPLATE_CREATE",
        actorUserId: userId,
        targetType: "notification_template",
        targetId: created.id,
      });
    }

    return created ?? null;
  });

export const updateNotificationTemplate = createServerFn({ method: "POST" })
  .inputValidator(zod$(updateNotificationTemplateSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_notifications");
    const userId = await getSessionUserId();
    if (!userId) return null;

    const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
    await requireAdmin(userId);

    const { getDb } = await import("~/db/server-helpers");
    const { notificationTemplates } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");
    const db = await getDb();

    const [updated] = await db
      .update(notificationTemplates)
      .set({
        key: data.data.key,
        category: data.data.category,
        subject: data.data.subject,
        bodyTemplate: data.data.bodyTemplate,
        isSystem: data.data.isSystem,
      })
      .where(eq(notificationTemplates.id, data.templateId))
      .returning();

    return updated ?? null;
  });

export const deleteNotificationTemplate = createServerFn({ method: "POST" })
  .inputValidator(zod$(deleteNotificationTemplateSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_notifications");
    const userId = await getSessionUserId();
    if (!userId) return null;

    const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
    await requireAdmin(userId);

    const { getDb } = await import("~/db/server-helpers");
    const { notificationTemplates } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");
    const db = await getDb();

    const [deleted] = await db
      .delete(notificationTemplates)
      .where(eq(notificationTemplates.id, data.templateId))
      .returning();

    return deleted ?? null;
  });

export const scheduleNotification = createServerFn({ method: "POST" })
  .inputValidator(zod$(scheduleNotificationSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_notifications");
    const userId = await getSessionUserId();
    if (!userId) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { scheduledNotifications } = await import("~/db/schema");
    const db = await getDb();

    const [created] = await db
      .insert(scheduledNotifications)
      .values({
        templateKey: data.templateKey,
        userId: data.userId ?? null,
        organizationId: data.organizationId ?? null,
        roleFilter: data.roleFilter ?? null,
        scheduledFor: new Date(data.scheduledFor),
        variables: data.variables ?? {},
      })
      .returning();

    if (created) {
      const { logDataChange } = await import("~/lib/audit");
      await logDataChange({
        action: "NOTIFICATION_SCHEDULE_CREATE",
        actorUserId: userId,
        targetType: "scheduled_notification",
        targetId: created.id,
      });
    }

    return created ?? null;
  });
</file>

<file path="src/features/notifications/notifications.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import { zod$ } from "~/lib/server/fn-utils";
import { listNotificationsSchema } from "./notifications.schemas";
import type { NotificationRow } from "./notifications.types";

const getSessionUserId = async () => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const { getRequest } = await import("@tanstack/react-start/server");
  const auth = await getAuth();
  const { headers } = getRequest();
  const session = await auth.api.getSession({ headers });
  return session?.user?.id ?? null;
};

export const listNotifications = createServerFn({ method: "GET" })
  .inputValidator(zod$(listNotificationsSchema))
  .handler(async ({ data }): Promise<NotificationRow[]> => {
    await assertFeatureEnabled("notifications_core");
    const userId = await getSessionUserId();
    if (!userId) return [];

    const { getDb } = await import("~/db/server-helpers");
    const { notifications } = await import("~/db/schema");
    const { and, desc, eq, isNull } = await import("drizzle-orm");

    const db = await getDb();
    const conditions = data.unreadOnly
      ? and(eq(notifications.userId, userId), isNull(notifications.readAt))
      : eq(notifications.userId, userId);

    const rows = await db
      .select({
        id: notifications.id,
        userId: notifications.userId,
        organizationId: notifications.organizationId,
        type: notifications.type,
        category: notifications.category,
        title: notifications.title,
        body: notifications.body,
        link: notifications.link,
        readAt: notifications.readAt,
        dismissedAt: notifications.dismissedAt,
        createdAt: notifications.createdAt,
      })
      .from(notifications)
      .where(conditions)
      .orderBy(desc(notifications.createdAt))
      .limit(data.limit ?? 25);

    return rows;
  });

export const getUnreadNotificationCount = createServerFn({ method: "GET" }).handler(
  async () => {
    await assertFeatureEnabled("notifications_core");
    const userId = await getSessionUserId();
    if (!userId) return 0;

    const { getDb } = await import("~/db/server-helpers");
    const { notifications } = await import("~/db/schema");
    const { and, count, eq, isNull } = await import("drizzle-orm");

    const db = await getDb();
    const [result] = await db
      .select({ total: count() })
      .from(notifications)
      .where(and(eq(notifications.userId, userId), isNull(notifications.readAt)));

    return result?.total ?? 0;
  },
);

export const getNotificationPreferences = createServerFn({ method: "GET" }).handler(
  async () => {
    await assertFeatureEnabled("notifications_core");
    const userId = await getSessionUserId();
    if (!userId) return [];

    const { getDb } = await import("~/db/server-helpers");
    const { notificationPreferences } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    return db
      .select()
      .from(notificationPreferences)
      .where(eq(notificationPreferences.userId, userId));
  },
);

export const listNotificationTemplates = createServerFn({ method: "GET" }).handler(
  async () => {
    await assertFeatureEnabled("sin_admin_notifications");
    const userId = await getSessionUserId();
    if (!userId) return [];

    const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
    await requireAdmin(userId);

    const { getDb } = await import("~/db/server-helpers");
    const { notificationTemplates } = await import("~/db/schema");
    const { desc } = await import("drizzle-orm");

    const db = await getDb();
    return db
      .select()
      .from(notificationTemplates)
      .orderBy(desc(notificationTemplates.createdAt));
  },
);
</file>

<file path="src/features/organizations/organizations.mutations.ts">
import { createServerFn } from "@tanstack/react-start";
import { zod$ } from "~/lib/server/fn-utils";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import { getOrgHierarchy } from "~/tenant";
import type { OrganizationType } from "~/tenant/tenant.types";
import {
  approveOrganizationMemberSchema,
  createDelegatedAccessSchema,
  createOrganizationSchema,
  inviteOrganizationMemberSchema,
  removeOrganizationMemberSchema,
  revokeDelegatedAccessSchema,
  setActiveOrganizationSchema,
  updateOrganizationMemberRoleSchema,
  updateOrganizationSchema,
} from "./organizations.schemas";
import type {
  DelegatedAccessRow,
  OrganizationMemberRow,
  OrganizationOperationErrorCode,
  OrganizationOperationResult,
  OrganizationSummary,
} from "./organizations.types";

const errorResult = (code: OrganizationOperationErrorCode, message: string) => ({
  success: false,
  errors: [{ code, message }],
});

const validateOrgHierarchy = async (params: {
  type: OrganizationType;
  parentOrgId: string | null;
}) => {
  const { type, parentOrgId } = params;
  const hierarchy = getOrgHierarchy();

  if (!parentOrgId) {
    if (!hierarchy.rootTypes.includes(type)) {
      return errorResult(
        "VALIDATION_ERROR",
        `Organization type "${type}" cannot be a root organization.`,
      );
    }
    return null;
  }

  const { getDb } = await import("~/db/server-helpers");
  const { organizations } = await import("~/db/schema");
  const { eq } = await import("drizzle-orm");

  const db = await getDb();
  const [parent] = await db
    .select({ id: organizations.id, type: organizations.type })
    .from(organizations)
    .where(eq(organizations.id, parentOrgId))
    .limit(1);

  if (!parent) {
    return errorResult("NOT_FOUND", "Parent organization not found");
  }

  const allowed = hierarchy.allowedChildren[parent.type] ?? [];
  if (!allowed.includes(type)) {
    return errorResult(
      "VALIDATION_ERROR",
      `Organization type "${type}" cannot be created under "${parent.type}".`,
    );
  }

  return null;
};

const getSessionUser = async () => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const { getRequest } = await import("@tanstack/react-start/server");
  const auth = await getAuth();
  const { headers } = getRequest();
  const session = await auth.api.getSession({ headers });
  return session?.user ?? null;
};

const serializeCookie = (
  name: string,
  value: string,
  options: {
    httpOnly?: boolean;
    secure?: boolean;
    sameSite?: "lax" | "strict" | "none";
    path?: string;
    domain?: string;
    maxAge?: number;
  },
) => {
  const segments = [`${name}=${value}`];

  if (options.maxAge !== undefined) {
    segments.push(`Max-Age=${options.maxAge}`);
  }
  if (options.domain) {
    segments.push(`Domain=${options.domain}`);
  }
  if (options.path) {
    segments.push(`Path=${options.path}`);
  }
  if (options.sameSite) {
    const normalized =
      options.sameSite.charAt(0).toUpperCase() + options.sameSite.slice(1);
    segments.push(`SameSite=${normalized}`);
  }
  if (options.secure) {
    segments.push("Secure");
  }
  if (options.httpOnly) {
    segments.push("HttpOnly");
  }

  return segments.join("; ");
};

export const createOrganization = createServerFn({ method: "POST" })
  .inputValidator(zod$(createOrganizationSchema))
  .handler(
    async ({ data }): Promise<OrganizationOperationResult<OrganizationSummary>> => {
      await assertFeatureEnabled("sin_admin_orgs");
      const sessionUser = await getSessionUser();
      if (!sessionUser?.id) {
        return errorResult("UNAUTHORIZED", "User not authenticated");
      }

      try {
        const { getDb } = await import("~/db/server-helpers");
        const { organizationMembers, organizations } = await import("~/db/schema");

        const db = await getDb();
        const hierarchyError = await validateOrgHierarchy({
          type: data.type,
          parentOrgId: data.parentOrgId ?? null,
        });
        if (hierarchyError) {
          return hierarchyError;
        }
        const [organization] = await db.transaction(async (tx) => {
          const [org] = await tx
            .insert(organizations)
            .values({
              name: data.name,
              slug: data.slug,
              type: data.type,
              parentOrgId: data.parentOrgId ?? null,
              settings: data.settings ?? {},
              metadata: data.metadata ?? {},
            })
            .returning();

          if (!org) return [];

          await tx.insert(organizationMembers).values({
            userId: sessionUser.id,
            organizationId: org.id,
            role: "owner",
            status: "active",
            approvedBy: sessionUser.id,
            approvedAt: new Date(),
          });

          return [org];
        });

        if (!organization) {
          return errorResult("DATABASE_ERROR", "Failed to create organization");
        }

        const { logAdminAction } = await import("~/lib/audit");
        await logAdminAction({
          action: "ORG_CREATE",
          actorUserId: sessionUser.id,
          actorOrgId: organization.id,
          targetType: "organization",
          targetId: organization.id,
          targetOrgId: organization.id,
          changes: { name: { new: organization.name } },
          metadata: { slug: organization.slug },
        });

        return {
          success: true,
          data: {
            id: organization.id,
            name: organization.name,
            slug: organization.slug,
            type: organization.type,
            status: organization.status,
            parentOrgId: organization.parentOrgId,
            createdAt: organization.createdAt,
            updatedAt: organization.updatedAt,
          },
        };
      } catch (error) {
        console.error("Failed to create organization", error);
        return errorResult("DATABASE_ERROR", "Failed to create organization");
      }
    },
  );

export const updateOrganization = createServerFn({ method: "POST" })
  .inputValidator(zod$(updateOrganizationSchema))
  .handler(
    async ({ data }): Promise<OrganizationOperationResult<OrganizationSummary>> => {
      await assertFeatureEnabled("sin_admin_orgs");
      const sessionUser = await getSessionUser();
      if (!sessionUser?.id) {
        return errorResult("UNAUTHORIZED", "User not authenticated");
      }

      const { requireOrganizationMembership, ORG_ADMIN_ROLES } =
        await import("~/lib/auth/guards/org-guard");
      await requireOrganizationMembership(
        { userId: sessionUser.id, organizationId: data.organizationId },
        { roles: ORG_ADMIN_ROLES },
      );

      try {
        const { getDb } = await import("~/db/server-helpers");
        const { organizations } = await import("~/db/schema");
        const { eq } = await import("drizzle-orm");

        const db = await getDb();
        const [existing] = await db
          .select()
          .from(organizations)
          .where(eq(organizations.id, data.organizationId))
          .limit(1);

        if (!existing) {
          return errorResult("NOT_FOUND", "Organization not found");
        }

        const nextType = data.data.type ?? existing.type;
        const nextParentOrgId = Object.prototype.hasOwnProperty.call(
          data.data,
          "parentOrgId",
        )
          ? data.data.parentOrgId ?? null
          : existing.parentOrgId;

        const shouldValidate =
          data.data.type !== undefined ||
          Object.prototype.hasOwnProperty.call(data.data, "parentOrgId");

        if (shouldValidate) {
          const hierarchyError = await validateOrgHierarchy({
            type: nextType,
            parentOrgId: nextParentOrgId,
          });
          if (hierarchyError) {
            return hierarchyError;
          }
        }

        const [updated] = await db
          .update(organizations)
          .set({
            name: data.data.name,
            slug: data.data.slug,
            type: data.data.type,
            parentOrgId: data.data.parentOrgId ?? null,
            status: data.data.status,
            settings: data.data.settings,
            metadata: data.data.metadata,
          })
          .where(eq(organizations.id, data.organizationId))
          .returning();

        if (!updated) {
          return errorResult("NOT_FOUND", "Organization not found");
        }

        const changeEntries = Object.entries(data.data).filter(
          ([, value]) => value !== undefined,
        );
        const { createAuditDiff, logAdminAction } = await import("~/lib/audit");
        const changes =
          changeEntries.length > 0
            ? await createAuditDiff(
                Object.fromEntries(
                  changeEntries.map(([key]) => [
                    key,
                    existing[key as keyof typeof existing],
                  ]),
                ),
                Object.fromEntries(
                  changeEntries.map(([key]) => [
                    key,
                    updated[key as keyof typeof updated],
                  ]),
                ),
              )
            : null;
        await logAdminAction({
          action: "ORG_UPDATE",
          actorUserId: sessionUser.id,
          actorOrgId: updated.id,
          targetType: "organization",
          targetId: updated.id,
          targetOrgId: updated.id,
          changes,
        });

        return {
          success: true,
          data: {
            id: updated.id,
            name: updated.name,
            slug: updated.slug,
            type: updated.type,
            status: updated.status,
            parentOrgId: updated.parentOrgId,
            createdAt: updated.createdAt,
            updatedAt: updated.updatedAt,
          },
        };
      } catch (error) {
        console.error("Failed to update organization", error);
        return errorResult("DATABASE_ERROR", "Failed to update organization");
      }
    },
  );

export const inviteOrganizationMember = createServerFn({ method: "POST" })
  .inputValidator(zod$(inviteOrganizationMemberSchema))
  .handler(
    async ({ data }): Promise<OrganizationOperationResult<OrganizationMemberRow>> => {
      await assertFeatureEnabled("sin_admin_orgs");
      const sessionUser = await getSessionUser();
      if (!sessionUser?.id) {
        return errorResult("UNAUTHORIZED", "User not authenticated");
      }

      const { requireOrganizationMembership, ORG_ADMIN_ROLES } =
        await import("~/lib/auth/guards/org-guard");
      await requireOrganizationMembership(
        { userId: sessionUser.id, organizationId: data.organizationId },
        { roles: ORG_ADMIN_ROLES },
      );

      try {
        const { getDb } = await import("~/db/server-helpers");
        const { organizationMembers, user } = await import("~/db/schema");
        const { eq } = await import("drizzle-orm");

        const db = await getDb();
        const [targetUser] = await db
          .select({ id: user.id, email: user.email, name: user.name })
          .from(user)
          .where(eq(user.email, data.email.toLowerCase()))
          .limit(1);

        if (!targetUser) {
          return errorResult("NOT_FOUND", "User not found");
        }

        const [membership] = await db
          .insert(organizationMembers)
          .values({
            userId: targetUser.id,
            organizationId: data.organizationId,
            role: data.role,
            status: "pending",
            invitedBy: sessionUser.id,
            invitedAt: new Date(),
          })
          .returning();

        if (!membership) {
          return errorResult("DATABASE_ERROR", "Failed to invite member");
        }

        const { logAdminAction } = await import("~/lib/audit");
        await logAdminAction({
          action: "ORG_MEMBER_INVITE",
          actorUserId: sessionUser.id,
          actorOrgId: data.organizationId,
          targetType: "organization_member",
          targetId: membership.id,
          targetOrgId: data.organizationId,
          metadata: { invitedUserId: targetUser.id, role: data.role },
        });

        return {
          success: true,
          data: {
            id: membership.id,
            organizationId: membership.organizationId,
            userId: targetUser.id,
            userName: targetUser.name,
            userEmail: targetUser.email,
            role: membership.role,
            status: membership.status,
            invitedBy: membership.invitedBy,
            invitedAt: membership.invitedAt,
            approvedBy: membership.approvedBy,
            approvedAt: membership.approvedAt,
            createdAt: membership.createdAt,
            updatedAt: membership.updatedAt,
          },
        };
      } catch (error) {
        console.error("Failed to invite organization member", error);
        return errorResult("DATABASE_ERROR", "Failed to invite member");
      }
    },
  );

export const approveOrganizationMember = createServerFn({ method: "POST" })
  .inputValidator(zod$(approveOrganizationMemberSchema))
  .handler(
    async ({ data }): Promise<OrganizationOperationResult<OrganizationMemberRow>> => {
      await assertFeatureEnabled("sin_admin_orgs");
      const sessionUser = await getSessionUser();
      if (!sessionUser?.id) {
        return errorResult("UNAUTHORIZED", "User not authenticated");
      }

      try {
        const { getDb } = await import("~/db/server-helpers");
        const { organizationMembers, user } = await import("~/db/schema");
        const { eq } = await import("drizzle-orm");

        const db = await getDb();
        const [membership] = await db
          .select()
          .from(organizationMembers)
          .where(eq(organizationMembers.id, data.membershipId))
          .limit(1);

        if (!membership) {
          return errorResult("NOT_FOUND", "Membership not found");
        }

        const { requireOrganizationMembership, ORG_ADMIN_ROLES } =
          await import("~/lib/auth/guards/org-guard");
        await requireOrganizationMembership(
          { userId: sessionUser.id, organizationId: membership.organizationId },
          { roles: ORG_ADMIN_ROLES },
        );

        const [updated] = await db
          .update(organizationMembers)
          .set({
            status: "active",
            approvedBy: sessionUser.id,
            approvedAt: new Date(),
          })
          .where(eq(organizationMembers.id, data.membershipId))
          .returning();

        if (!updated) {
          return errorResult("DATABASE_ERROR", "Failed to approve member");
        }

        const [memberUser] = await db
          .select({ id: user.id, email: user.email, name: user.name })
          .from(user)
          .where(eq(user.id, updated.userId))
          .limit(1);

        const { logAdminAction } = await import("~/lib/audit");
        await logAdminAction({
          action: "ORG_MEMBER_APPROVE",
          actorUserId: sessionUser.id,
          actorOrgId: updated.organizationId,
          targetType: "organization_member",
          targetId: updated.id,
          targetOrgId: updated.organizationId,
          metadata: { approvedUserId: updated.userId },
        });

        return {
          success: true,
          data: {
            id: updated.id,
            organizationId: updated.organizationId,
            userId: updated.userId,
            userName: memberUser?.name ?? null,
            userEmail: memberUser?.email ?? "",
            role: updated.role,
            status: updated.status,
            invitedBy: updated.invitedBy,
            invitedAt: updated.invitedAt,
            approvedBy: updated.approvedBy,
            approvedAt: updated.approvedAt,
            createdAt: updated.createdAt,
            updatedAt: updated.updatedAt,
          },
        };
      } catch (error) {
        console.error("Failed to approve organization member", error);
        return errorResult("DATABASE_ERROR", "Failed to approve member");
      }
    },
  );

export const updateOrganizationMemberRole = createServerFn({ method: "POST" })
  .inputValidator(zod$(updateOrganizationMemberRoleSchema))
  .handler(
    async ({ data }): Promise<OrganizationOperationResult<OrganizationMemberRow>> => {
      await assertFeatureEnabled("sin_admin_orgs");
      const sessionUser = await getSessionUser();
      if (!sessionUser?.id) {
        return errorResult("UNAUTHORIZED", "User not authenticated");
      }

      try {
        const { getDb } = await import("~/db/server-helpers");
        const { organizationMembers, user } = await import("~/db/schema");
        const { eq } = await import("drizzle-orm");

        const db = await getDb();
        const [membership] = await db
          .select()
          .from(organizationMembers)
          .where(eq(organizationMembers.id, data.membershipId))
          .limit(1);

        if (!membership) {
          return errorResult("NOT_FOUND", "Membership not found");
        }

        const { requireOrganizationMembership, ORG_ADMIN_ROLES } =
          await import("~/lib/auth/guards/org-guard");
        await requireOrganizationMembership(
          { userId: sessionUser.id, organizationId: membership.organizationId },
          { roles: ORG_ADMIN_ROLES },
        );

        const [updated] = await db
          .update(organizationMembers)
          .set({ role: data.role })
          .where(eq(organizationMembers.id, data.membershipId))
          .returning();

        if (!updated) {
          return errorResult("DATABASE_ERROR", "Failed to update member");
        }

        const [memberUser] = await db
          .select({ id: user.id, email: user.email, name: user.name })
          .from(user)
          .where(eq(user.id, updated.userId))
          .limit(1);

        const { logAdminAction } = await import("~/lib/audit");
        await logAdminAction({
          action: "ORG_MEMBER_ROLE_UPDATE",
          actorUserId: sessionUser.id,
          actorOrgId: updated.organizationId,
          targetType: "organization_member",
          targetId: updated.id,
          targetOrgId: updated.organizationId,
          changes: { role: { new: updated.role } },
        });

        return {
          success: true,
          data: {
            id: updated.id,
            organizationId: updated.organizationId,
            userId: updated.userId,
            userName: memberUser?.name ?? null,
            userEmail: memberUser?.email ?? "",
            role: updated.role,
            status: updated.status,
            invitedBy: updated.invitedBy,
            invitedAt: updated.invitedAt,
            approvedBy: updated.approvedBy,
            approvedAt: updated.approvedAt,
            createdAt: updated.createdAt,
            updatedAt: updated.updatedAt,
          },
        };
      } catch (error) {
        console.error("Failed to update organization member role", error);
        return errorResult("DATABASE_ERROR", "Failed to update member");
      }
    },
  );

export const removeOrganizationMember = createServerFn({ method: "POST" })
  .inputValidator(zod$(removeOrganizationMemberSchema))
  .handler(
    async ({ data }): Promise<OrganizationOperationResult<OrganizationMemberRow>> => {
      await assertFeatureEnabled("sin_admin_orgs");
      const sessionUser = await getSessionUser();
      if (!sessionUser?.id) {
        return errorResult("UNAUTHORIZED", "User not authenticated");
      }

      try {
        const { getDb } = await import("~/db/server-helpers");
        const { organizationMembers, user } = await import("~/db/schema");
        const { eq } = await import("drizzle-orm");

        const db = await getDb();
        const [membership] = await db
          .select()
          .from(organizationMembers)
          .where(eq(organizationMembers.id, data.membershipId))
          .limit(1);

        if (!membership) {
          return errorResult("NOT_FOUND", "Membership not found");
        }

        const { requireOrganizationMembership, ORG_ADMIN_ROLES } =
          await import("~/lib/auth/guards/org-guard");
        await requireOrganizationMembership(
          { userId: sessionUser.id, organizationId: membership.organizationId },
          { roles: ORG_ADMIN_ROLES },
        );

        const [updated] = await db
          .update(organizationMembers)
          .set({ status: "removed" })
          .where(eq(organizationMembers.id, data.membershipId))
          .returning();

        if (!updated) {
          return errorResult("DATABASE_ERROR", "Failed to remove member");
        }

        const [memberUser] = await db
          .select({ id: user.id, email: user.email, name: user.name })
          .from(user)
          .where(eq(user.id, updated.userId))
          .limit(1);

        const { logAdminAction } = await import("~/lib/audit");
        await logAdminAction({
          action: "ORG_MEMBER_REMOVE",
          actorUserId: sessionUser.id,
          actorOrgId: updated.organizationId,
          targetType: "organization_member",
          targetId: updated.id,
          targetOrgId: updated.organizationId,
          metadata: { removedUserId: updated.userId },
        });

        return {
          success: true,
          data: {
            id: updated.id,
            organizationId: updated.organizationId,
            userId: updated.userId,
            userName: memberUser?.name ?? null,
            userEmail: memberUser?.email ?? "",
            role: updated.role,
            status: updated.status,
            invitedBy: updated.invitedBy,
            invitedAt: updated.invitedAt,
            approvedBy: updated.approvedBy,
            approvedAt: updated.approvedAt,
            createdAt: updated.createdAt,
            updatedAt: updated.updatedAt,
          },
        };
      } catch (error) {
        console.error("Failed to remove organization member", error);
        return errorResult("DATABASE_ERROR", "Failed to remove member");
      }
    },
  );

export const createDelegatedAccess = createServerFn({ method: "POST" })
  .inputValidator(zod$(createDelegatedAccessSchema))
  .handler(async ({ data }): Promise<OrganizationOperationResult<DelegatedAccessRow>> => {
    await assertFeatureEnabled("sin_admin_orgs");
    const sessionUser = await getSessionUser();
    if (!sessionUser?.id) {
      return errorResult("UNAUTHORIZED", "User not authenticated");
    }

    const { requireOrganizationMembership, ORG_ADMIN_ROLES } =
      await import("~/lib/auth/guards/org-guard");
    await requireOrganizationMembership(
      { userId: sessionUser.id, organizationId: data.organizationId },
      { roles: ORG_ADMIN_ROLES },
    );

    try {
      const { getDb } = await import("~/db/server-helpers");
      const { delegatedAccess, user } = await import("~/db/schema");
      const { eq } = await import("drizzle-orm");

      const db = await getDb();
      const expiresAt = data.expiresAt ? new Date(data.expiresAt) : null;

      const [access] = await db
        .insert(delegatedAccess)
        .values({
          organizationId: data.organizationId,
          delegateUserId: data.delegateUserId,
          scope: data.scope,
          grantedBy: sessionUser.id,
          expiresAt,
          notes: data.notes ?? null,
        })
        .returning();

      if (!access) {
        return errorResult("DATABASE_ERROR", "Failed to grant delegated access");
      }

      const [delegateUser] = await db
        .select({ email: user.email })
        .from(user)
        .where(eq(user.id, access.delegateUserId))
        .limit(1);

      const { logAdminAction } = await import("~/lib/audit");
      await logAdminAction({
        action: "ORG_DELEGATED_ACCESS_GRANT",
        actorUserId: sessionUser.id,
        actorOrgId: access.organizationId,
        targetType: "delegated_access",
        targetId: access.id,
        targetOrgId: access.organizationId,
        metadata: { delegateUserId: access.delegateUserId, scope: access.scope },
      });

      return {
        success: true,
        data: {
          id: access.id,
          organizationId: access.organizationId,
          delegateUserId: access.delegateUserId,
          delegateEmail: delegateUser?.email ?? null,
          scope: access.scope,
          grantedBy: access.grantedBy,
          grantedAt: access.grantedAt,
          expiresAt: access.expiresAt,
          revokedAt: access.revokedAt,
          revokedBy: access.revokedBy,
          notes: access.notes,
        },
      };
    } catch (error) {
      console.error("Failed to grant delegated access", error);
      return errorResult("DATABASE_ERROR", "Failed to grant delegated access");
    }
  });

export const revokeDelegatedAccess = createServerFn({ method: "POST" })
  .inputValidator(zod$(revokeDelegatedAccessSchema))
  .handler(async ({ data }): Promise<OrganizationOperationResult<DelegatedAccessRow>> => {
    await assertFeatureEnabled("sin_admin_orgs");
    const sessionUser = await getSessionUser();
    if (!sessionUser?.id) {
      return errorResult("UNAUTHORIZED", "User not authenticated");
    }

    try {
      const { getDb } = await import("~/db/server-helpers");
      const { delegatedAccess, user } = await import("~/db/schema");
      const { eq } = await import("drizzle-orm");

      const db = await getDb();
      const [access] = await db
        .select()
        .from(delegatedAccess)
        .where(eq(delegatedAccess.id, data.accessId))
        .limit(1);

      if (!access) {
        return errorResult("NOT_FOUND", "Delegated access not found");
      }

      const { requireOrganizationMembership, ORG_ADMIN_ROLES } =
        await import("~/lib/auth/guards/org-guard");
      await requireOrganizationMembership(
        { userId: sessionUser.id, organizationId: access.organizationId },
        { roles: ORG_ADMIN_ROLES },
      );

      const [updated] = await db
        .update(delegatedAccess)
        .set({
          revokedAt: new Date(),
          revokedBy: sessionUser.id,
          notes: data.notes ?? access.notes,
        })
        .where(eq(delegatedAccess.id, data.accessId))
        .returning();

      if (!updated) {
        return errorResult("DATABASE_ERROR", "Failed to revoke access");
      }

      const [delegateUser] = await db
        .select({ email: user.email })
        .from(user)
        .where(eq(user.id, updated.delegateUserId))
        .limit(1);

      const { logAdminAction } = await import("~/lib/audit");
      await logAdminAction({
        action: "ORG_DELEGATED_ACCESS_REVOKE",
        actorUserId: sessionUser.id,
        actorOrgId: updated.organizationId,
        targetType: "delegated_access",
        targetId: updated.id,
        targetOrgId: updated.organizationId,
        metadata: { delegateUserId: updated.delegateUserId },
      });

      return {
        success: true,
        data: {
          id: updated.id,
          organizationId: updated.organizationId,
          delegateUserId: updated.delegateUserId,
          delegateEmail: delegateUser?.email ?? null,
          scope: updated.scope,
          grantedBy: updated.grantedBy,
          grantedAt: updated.grantedAt,
          expiresAt: updated.expiresAt,
          revokedAt: updated.revokedAt,
          revokedBy: updated.revokedBy,
          notes: updated.notes,
        },
      };
    } catch (error) {
      console.error("Failed to revoke delegated access", error);
      return errorResult("DATABASE_ERROR", "Failed to revoke access");
    }
  });

export const setActiveOrganization = createServerFn({ method: "POST" })
  .inputValidator(zod$(setActiveOrganizationSchema))
  .handler(
    async ({
      data,
    }): Promise<OrganizationOperationResult<{ organizationId: string | null }>> => {
      await assertFeatureEnabled("sin_portal");
      const sessionUser = await getSessionUser();
      if (!sessionUser?.id) {
        return errorResult("UNAUTHORIZED", "User not authenticated");
      }

      if (data.organizationId) {
        const { resolveOrganizationAccess } = await import("./organizations.access");
        const access = await resolveOrganizationAccess({
          userId: sessionUser.id,
          organizationId: data.organizationId,
        });

        if (!access) {
          return errorResult("FORBIDDEN", "Organization access required");
        }
      }

      const { setResponseHeader } = await import("@tanstack/react-start/server");
      const { securityConfig } = await import("~/lib/security/config");
      const maxAge = 60 * 60 * 24 * 30;
      const cookieValue = data.organizationId
        ? encodeURIComponent(data.organizationId)
        : "";

      const cookie = serializeCookie("active_org_id", cookieValue, {
        ...securityConfig.cookies,
        maxAge: data.organizationId ? maxAge : 0,
      });

      setResponseHeader("Set-Cookie", cookie);

      return {
        success: true,
        data: {
          organizationId: data.organizationId,
        },
      };
    },
  );
</file>

<file path="src/features/organizations/organizations.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { z } from "zod";
import { zod$ } from "~/lib/server/fn-utils";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import {
  getOrganizationSchema,
  listDelegatedAccessSchema,
  listOrganizationMembersSchema,
  listOrganizationsSchema,
  searchOrganizationsSchema,
} from "./organizations.schemas";
import type {
  DelegatedAccessRow,
  AccessibleOrganization,
  OrganizationMemberRow,
  OrganizationSummary,
} from "./organizations.types";

const getSessionUserId = async () => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const { getRequest } = await import("@tanstack/react-start/server");
  const auth = await getAuth();
  const { headers } = getRequest();
  const session = await auth.api.getSession({ headers });

  return session?.user?.id ?? null;
};

const listAccessibleOrganizationsSchema = z.void().nullish();

export const getOrganization = createServerFn({ method: "GET" })
  .inputValidator(zod$(getOrganizationSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_portal");
    const { getDb } = await import("~/db/server-helpers");
    const { organizations } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    const [org] = await db
      .select()
      .from(organizations)
      .where(eq(organizations.id, data.organizationId))
      .limit(1);

    return org ?? null;
  });

export const listOrganizations = createServerFn({ method: "GET" })
  .inputValidator(zod$(listOrganizationsSchema))
  .handler(async ({ data }): Promise<OrganizationSummary[]> => {
    await assertFeatureEnabled("sin_portal");
    const userId = await getSessionUserId();
    if (!userId) return [];

    const { getDb } = await import("~/db/server-helpers");
    const { organizationMembers, organizations } = await import("~/db/schema");
    const { and, eq } = await import("drizzle-orm");

    const db = await getDb();
    const conditions = data?.includeArchived
      ? eq(organizationMembers.userId, userId)
      : and(eq(organizationMembers.userId, userId), eq(organizations.status, "active"));

    const rows = await db
      .select({
        id: organizations.id,
        name: organizations.name,
        slug: organizations.slug,
        type: organizations.type,
        status: organizations.status,
        parentOrgId: organizations.parentOrgId,
        createdAt: organizations.createdAt,
        updatedAt: organizations.updatedAt,
      })
      .from(organizationMembers)
      .innerJoin(organizations, eq(organizationMembers.organizationId, organizations.id))
      .where(conditions);

    return rows;
  });

export const listAccessibleOrganizations = createServerFn({ method: "GET" })
  .inputValidator(zod$(listAccessibleOrganizationsSchema))
  .handler(async (): Promise<AccessibleOrganization[]> => {
    await assertFeatureEnabled("sin_portal");
    const userId = await getSessionUserId();
    if (!userId) return [];

    const { listAccessibleOrganizationsForUser } = await import(
      "./organizations.access"
    );
    return listAccessibleOrganizationsForUser(userId);
  });

export const searchOrganizations = createServerFn({ method: "GET" })
  .inputValidator(zod$(searchOrganizationsSchema))
  .handler(async ({ data }): Promise<OrganizationSummary[]> => {
    await assertFeatureEnabled("sin_admin_orgs");
    const { getDb } = await import("~/db/server-helpers");
    const { organizations } = await import("~/db/schema");
    const { ilike } = await import("drizzle-orm");

    const db = await getDb();
    const rows = await db
      .select({
        id: organizations.id,
        name: organizations.name,
        slug: organizations.slug,
        type: organizations.type,
        status: organizations.status,
        parentOrgId: organizations.parentOrgId,
        createdAt: organizations.createdAt,
        updatedAt: organizations.updatedAt,
      })
      .from(organizations)
      .where(ilike(organizations.name, `%${data.query}%`))
      .limit(25);

    return rows;
  });

/**
 * Admin-only query to list all organizations (not filtered by membership).
 * Requires sin_admin_orgs feature flag.
 */
export const listAllOrganizations = createServerFn({ method: "GET" })
  .inputValidator(zod$(listOrganizationsSchema))
  .handler(async ({ data }): Promise<OrganizationSummary[]> => {
    await assertFeatureEnabled("sin_admin_orgs");

    const { getDb } = await import("~/db/server-helpers");
    const { organizations } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    const conditions = data?.includeArchived ? undefined : eq(organizations.status, "active");

    const rows = await db
      .select({
        id: organizations.id,
        name: organizations.name,
        slug: organizations.slug,
        type: organizations.type,
        status: organizations.status,
        parentOrgId: organizations.parentOrgId,
        createdAt: organizations.createdAt,
        updatedAt: organizations.updatedAt,
      })
      .from(organizations)
      .where(conditions);

    return rows;
  });

export const listOrganizationMembers = createServerFn({ method: "GET" })
  .inputValidator(zod$(listOrganizationMembersSchema))
  .handler(async ({ data }): Promise<OrganizationMemberRow[]> => {
    await assertFeatureEnabled("sin_admin_orgs");
    const userId = await getSessionUserId();
    if (!userId) return [];

    const { requireOrganizationMembership } = await import("~/lib/auth/guards/org-guard");
    await requireOrganizationMembership({
      userId,
      organizationId: data.organizationId,
    });

    const { getDb } = await import("~/db/server-helpers");
    const { organizationMembers, user } = await import("~/db/schema");
    const { and, eq } = await import("drizzle-orm");

    const db = await getDb();
    const conditions = data.includeInactive
      ? eq(organizationMembers.organizationId, data.organizationId)
      : and(
          eq(organizationMembers.organizationId, data.organizationId),
          eq(organizationMembers.status, "active"),
        );

    const rows = await db
      .select({
        id: organizationMembers.id,
        organizationId: organizationMembers.organizationId,
        userId: organizationMembers.userId,
        userName: user.name,
        userEmail: user.email,
        role: organizationMembers.role,
        status: organizationMembers.status,
        invitedBy: organizationMembers.invitedBy,
        invitedAt: organizationMembers.invitedAt,
        approvedBy: organizationMembers.approvedBy,
        approvedAt: organizationMembers.approvedAt,
        createdAt: organizationMembers.createdAt,
        updatedAt: organizationMembers.updatedAt,
      })
      .from(organizationMembers)
      .innerJoin(user, eq(organizationMembers.userId, user.id))
      .where(conditions);

    return rows;
  });

export const listDelegatedAccess = createServerFn({ method: "GET" })
  .inputValidator(zod$(listDelegatedAccessSchema))
  .handler(async ({ data }): Promise<DelegatedAccessRow[]> => {
    await assertFeatureEnabled("sin_admin_orgs");
    const userId = await getSessionUserId();
    if (!userId) return [];

    const { requireOrganizationMembership, ORG_ADMIN_ROLES } =
      await import("~/lib/auth/guards/org-guard");
    await requireOrganizationMembership(
      { userId, organizationId: data.organizationId },
      { roles: ORG_ADMIN_ROLES },
    );

    const { getDb } = await import("~/db/server-helpers");
    const { delegatedAccess, user } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    const rows = await db
      .select({
        id: delegatedAccess.id,
        organizationId: delegatedAccess.organizationId,
        delegateUserId: delegatedAccess.delegateUserId,
        delegateEmail: user.email,
        scope: delegatedAccess.scope,
        grantedBy: delegatedAccess.grantedBy,
        grantedAt: delegatedAccess.grantedAt,
        expiresAt: delegatedAccess.expiresAt,
        revokedAt: delegatedAccess.revokedAt,
        revokedBy: delegatedAccess.revokedBy,
        notes: delegatedAccess.notes,
      })
      .from(delegatedAccess)
      .innerJoin(user, eq(delegatedAccess.delegateUserId, user.id))
      .where(eq(delegatedAccess.organizationId, data.organizationId));

    return rows;
  });
</file>

<file path="src/features/privacy/privacy.mutations.ts">
import { createServerFn } from "@tanstack/react-start";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import { zod$ } from "~/lib/server/fn-utils";
import {
  acceptPolicySchema,
  applyPrivacyErasureSchema,
  createPolicyDocumentSchema,
  createPrivacyRequestSchema,
  generatePrivacyExportSchema,
  updatePrivacyRequestSchema,
  upsertRetentionPolicySchema,
} from "./privacy.schemas";

const getSessionUser = async () => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const { getRequest } = await import("@tanstack/react-start/server");
  const auth = await getAuth();
  const { headers } = getRequest();
  const session = await auth.api.getSession({ headers });
  return session?.user ?? null;
};

export const createPolicyDocument = createServerFn({ method: "POST" })
  .inputValidator(zod$(createPolicyDocumentSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_privacy");
    const sessionUser = await getSessionUser();
    if (!sessionUser?.id) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { policyDocuments } = await import("~/db/schema");

    const db = await getDb();
    const [created] = await db
      .insert(policyDocuments)
      .values({
        type: data.type,
        version: data.version,
        contentUrl: data.contentUrl ?? null,
        contentHash: data.contentHash,
        effectiveDate: data.effectiveDate,
        publishedAt: new Date(),
        publishedBy: sessionUser.id,
      })
      .returning();

    if (created) {
      const { logAdminAction } = await import("~/lib/audit");
      await logAdminAction({
        action: "POLICY_CREATE",
        actorUserId: sessionUser.id,
        targetType: "policy_document",
        targetId: created.id,
      });
    }

    return created ?? null;
  });

export const acceptPolicy = createServerFn({ method: "POST" })
  .inputValidator(zod$(acceptPolicySchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("security_core");
    const sessionUser = await getSessionUser();
    if (!sessionUser?.id) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { userPolicyAcceptances } = await import("~/db/schema");
    const { getRequest } = await import("@tanstack/react-start/server");

    const request = getRequest();
    const ipAddress =
      request.headers.get("x-forwarded-for") ?? request.headers.get("x-real-ip");
    const userAgent = request.headers.get("user-agent");

    const db = await getDb();
    const [accepted] = await db
      .insert(userPolicyAcceptances)
      .values({
        userId: sessionUser.id,
        policyId: data.policyId,
        ipAddress: ipAddress ?? null,
        userAgent: userAgent ?? null,
      })
      .returning();

    if (accepted) {
      const { logDataChange } = await import("~/lib/audit");
      await logDataChange({
        action: "POLICY_ACCEPT",
        actorUserId: sessionUser.id,
        targetType: "policy_acceptance",
        targetId: accepted.id,
      });
    }

    return accepted ?? null;
  });

export const createPrivacyRequest = createServerFn({ method: "POST" })
  .inputValidator(zod$(createPrivacyRequestSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("security_core");
    const sessionUser = await getSessionUser();
    if (!sessionUser?.id) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { privacyRequests } = await import("~/db/schema");
    const db = await getDb();

    const [created] = await db
      .insert(privacyRequests)
      .values({
        userId: sessionUser.id,
        type: data.type,
        status: "pending",
      })
      .returning();

    if (created) {
      const { logDataChange } = await import("~/lib/audit");
      await logDataChange({
        action: "PRIVACY_REQUEST_CREATE",
        actorUserId: sessionUser.id,
        targetType: "privacy_request",
        targetId: created.id,
      });
    }

    return created ?? null;
  });

export const updatePrivacyRequest = createServerFn({ method: "POST" })
  .inputValidator(zod$(updatePrivacyRequestSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_privacy");
    const sessionUser = await getSessionUser();
    if (!sessionUser?.id) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { privacyRequests } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");
    const db = await getDb();

    const [updated] = await db
      .update(privacyRequests)
      .set({
        status: data.status,
        processedBy: sessionUser.id,
        processedAt: new Date(),
        resultUrl: data.resultUrl ?? null,
        resultNotes: data.resultNotes ?? null,
        rejectionReason: data.rejectionReason ?? null,
      })
      .where(eq(privacyRequests.id, data.requestId))
      .returning();

    if (updated) {
      const { logAdminAction } = await import("~/lib/audit");
      await logAdminAction({
        action: "PRIVACY_REQUEST_UPDATE",
        actorUserId: sessionUser.id,
        targetType: "privacy_request",
        targetId: updated.id,
      });
    }

    return updated ?? null;
  });

export const upsertRetentionPolicy = createServerFn({ method: "POST" })
  .inputValidator(zod$(upsertRetentionPolicySchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_privacy");
    const sessionUser = await getSessionUser();
    if (!sessionUser?.id) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { retentionPolicies } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    const [existing] = await db
      .select()
      .from(retentionPolicies)
      .where(eq(retentionPolicies.dataType, data.dataType))
      .limit(1);

    if (existing) {
      const [updated] = await db
        .update(retentionPolicies)
        .set({
          retentionDays: data.retentionDays,
          archiveAfterDays: data.archiveAfterDays ?? null,
          purgeAfterDays: data.purgeAfterDays ?? null,
          legalHold: data.legalHold ?? existing.legalHold,
        })
        .where(eq(retentionPolicies.id, existing.id))
        .returning();

      return updated ?? null;
    }

    const [created] = await db
      .insert(retentionPolicies)
      .values({
        dataType: data.dataType,
        retentionDays: data.retentionDays,
        archiveAfterDays: data.archiveAfterDays ?? null,
        purgeAfterDays: data.purgeAfterDays ?? null,
        legalHold: data.legalHold ?? false,
      })
      .returning();

    return created ?? null;
  });

export const generatePrivacyExport = createServerFn({ method: "POST" })
  .inputValidator(zod$(generatePrivacyExportSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_privacy");
    const sessionUser = await getSessionUser();
    if (!sessionUser?.id) return null;

    const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
    await requireAdmin(sessionUser.id);

    const { getDb } = await import("~/db/server-helpers");
    const {
      account,
      auditLogs,
      delegatedAccess,
      formSubmissionVersions,
      formSubmissions,
      notificationPreferences,
      notifications,
      organizationMembers,
      organizations,
      privacyRequests,
      reportingSubmissionHistory,
      reportingSubmissions,
      securityEvents,
      session,
      submissionFiles,
      twoFactor,
      user,
      userPolicyAcceptances,
      userRoles,
      verification,
      roles,
    } = await import("~/db/schema");
    const { and, eq, inArray, or } = await import("drizzle-orm");

    const db = await getDb();
    const [request] = await db
      .select()
      .from(privacyRequests)
      .where(eq(privacyRequests.id, data.requestId))
      .limit(1);

    if (!request) return null;

    await db
      .update(privacyRequests)
      .set({
        status: "processing",
        processedBy: sessionUser.id,
        processedAt: new Date(),
      })
      .where(eq(privacyRequests.id, data.requestId));

    const [userRecord] = await db
      .select()
      .from(user)
      .where(eq(user.id, request.userId))
      .limit(1);

    if (!userRecord) return null;

    const orgMemberships = await db
      .select()
      .from(organizationMembers)
      .where(eq(organizationMembers.userId, request.userId));
    const orgIds = orgMemberships.map((membership) => membership.organizationId);
    const orgRecords = orgIds.length
      ? await db.select().from(organizations).where(inArray(organizations.id, orgIds))
      : [];

    const delegated = await db
      .select()
      .from(delegatedAccess)
      .where(eq(delegatedAccess.delegateUserId, request.userId));

    const roleAssignments = await db
      .select({
        id: userRoles.id,
        roleId: userRoles.roleId,
        roleName: roles.name,
        teamId: userRoles.teamId,
        eventId: userRoles.eventId,
        assignedBy: userRoles.assignedBy,
        assignedAt: userRoles.assignedAt,
        expiresAt: userRoles.expiresAt,
        notes: userRoles.notes,
      })
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(eq(userRoles.userId, request.userId));

    const submissions = await db
      .select()
      .from(formSubmissions)
      .where(eq(formSubmissions.submitterId, request.userId));
    const submissionIds = submissions.map((submission) => submission.id);
    const submissionVersions = submissionIds.length
      ? await db
          .select()
          .from(formSubmissionVersions)
          .where(inArray(formSubmissionVersions.submissionId, submissionIds))
      : [];
    const submissionFileRows = submissionIds.length
      ? await db
          .select()
          .from(submissionFiles)
          .where(inArray(submissionFiles.submissionId, submissionIds))
      : [];

    const reporting = await db
      .select()
      .from(reportingSubmissions)
      .where(eq(reportingSubmissions.submittedBy, request.userId));
    const reportingIds = reporting.map((item) => item.id);
    const reportingHistory = reportingIds.length
      ? await db
          .select()
          .from(reportingSubmissionHistory)
          .where(inArray(reportingSubmissionHistory.reportingSubmissionId, reportingIds))
      : [];

    const privacyRequestsByUser = await db
      .select()
      .from(privacyRequests)
      .where(eq(privacyRequests.userId, request.userId));
    const policyAcceptances = await db
      .select()
      .from(userPolicyAcceptances)
      .where(eq(userPolicyAcceptances.userId, request.userId));
    const userNotifications = await db
      .select()
      .from(notifications)
      .where(eq(notifications.userId, request.userId));
    const userPreferences = await db
      .select()
      .from(notificationPreferences)
      .where(eq(notificationPreferences.userId, request.userId));
    const security = await db
      .select()
      .from(securityEvents)
      .where(eq(securityEvents.userId, request.userId));

    const audit = await db
      .select()
      .from(auditLogs)
      .where(
        or(
          eq(auditLogs.actorUserId, request.userId),
          and(eq(auditLogs.targetType, "user"), eq(auditLogs.targetId, request.userId)),
        ),
      );

    const accounts = await db
      .select()
      .from(account)
      .where(eq(account.userId, request.userId));
    const sessions = await db
      .select()
      .from(session)
      .where(eq(session.userId, request.userId));
    const twoFactorRows = await db
      .select()
      .from(twoFactor)
      .where(eq(twoFactor.userId, request.userId));
    const verifications = await db
      .select()
      .from(verification)
      .where(eq(verification.identifier, userRecord.email));

    const exportPayload = {
      generatedAt: new Date().toISOString(),
      requestId: request.id,
      user: userRecord,
      organizations: orgRecords,
      organizationMemberships: orgMemberships,
      delegatedAccess: delegated,
      roleAssignments,
      accounts,
      sessions,
      twoFactor: twoFactorRows,
      verifications,
      policyAcceptances,
      privacyRequests: privacyRequestsByUser,
      notifications: userNotifications,
      notificationPreferences: userPreferences,
      securityEvents: security,
      auditLogs: audit,
      formSubmissions: submissions,
      formSubmissionVersions: submissionVersions,
      submissionFiles: submissionFileRows,
      reportingSubmissions: reporting,
      reportingSubmissionHistory: reportingHistory,
    };

    const { PutObjectCommand } = await import("@aws-sdk/client-s3");
    const { getArtifactsBucketName, getS3Client } =
      await import("~/lib/storage/artifacts");

    const bucket = await getArtifactsBucketName();
    const storageKey = `privacy/exports/${request.userId}/${request.id}.json`;
    const client = await getS3Client();

    await client.send(
      new PutObjectCommand({
        Bucket: bucket,
        Key: storageKey,
        Body: JSON.stringify(exportPayload, null, 2),
        ContentType: "application/json",
      }),
    );

    const resultUrl = `s3://${bucket}/${storageKey}`;

    const [updated] = await db
      .update(privacyRequests)
      .set({
        status: "completed",
        processedBy: sessionUser.id,
        processedAt: new Date(),
        resultUrl,
        resultNotes: "Export generated and stored in SIN artifacts bucket.",
      })
      .where(eq(privacyRequests.id, data.requestId))
      .returning();

    if (updated) {
      const { logAdminAction } = await import("~/lib/audit");
      await logAdminAction({
        action: "PRIVACY_EXPORT_GENERATE",
        actorUserId: sessionUser.id,
        targetType: "privacy_request",
        targetId: updated.id,
        metadata: { storageKey },
      });
    }

    return updated ?? null;
  });

export const applyPrivacyErasure = createServerFn({ method: "POST" })
  .inputValidator(zod$(applyPrivacyErasureSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_privacy");
    const sessionUser = await getSessionUser();
    if (!sessionUser?.id) return null;

    const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
    await requireAdmin(sessionUser.id);

    const { getDb } = await import("~/db/server-helpers");
    const {
      account,
      accountLocks,
      delegatedAccess,
      formSubmissionVersions,
      formSubmissions,
      notifications,
      organizationMembers,
      privacyRequests,
      reportingSubmissionHistory,
      reportingSubmissions,
      securityEvents,
      session,
      submissionFiles,
      twoFactor,
      user,
      userPolicyAcceptances,
      userRoles,
      verification,
    } = await import("~/db/schema");
    const { eq, inArray, or } = await import("drizzle-orm");

    const db = await getDb();
    const [request] = await db
      .select()
      .from(privacyRequests)
      .where(eq(privacyRequests.id, data.requestId))
      .limit(1);

    if (!request) return null;

    // Mark request as processing early (so UI/admin can see it in-flight)
    await db
      .update(privacyRequests)
      .set({
        status: "processing",
        processedBy: sessionUser.id,
        processedAt: new Date(),
        resultNotes:
          "Processing erasure request (deleting stored artifacts and anonymizing user record).",
      })
      .where(eq(privacyRequests.id, data.requestId));

    const [userRecord] = await db
      .select({ email: user.email })
      .from(user)
      .where(eq(user.id, request.userId))
      .limit(1);

    const anonymizedEmail = `deleted+${request.userId}@example.invalid`;

    // ISSUE 06 FIX: Find submission files tied to this user and delete S3 objects first.
    const userSubmissions = await db
      .select({ id: formSubmissions.id })
      .from(formSubmissions)
      .where(eq(formSubmissions.submitterId, request.userId));
    const submissionIds = userSubmissions.map((row) => row.id);

    const fileConditions = [eq(submissionFiles.uploadedBy, request.userId)];
    if (submissionIds.length) {
      fileConditions.push(inArray(submissionFiles.submissionId, submissionIds));
    }

    const fileWhere =
      fileConditions.length === 1 ? fileConditions[0] : or(...fileConditions);

    const filesToErase = fileWhere
      ? await db.select().from(submissionFiles).where(fileWhere)
      : [];

    let erasedFilesAttempted = 0;
    let erasedFilesDeleted = 0;
    if (filesToErase.length) {
      const { deleteFormSubmissionFiles } =
        await import("~/lib/privacy/submission-files");
      const result = await deleteFormSubmissionFiles({ items: filesToErase });
      erasedFilesAttempted = result.attempted;
      erasedFilesDeleted = result.deleted;
    }

    await db.transaction(async (tx) => {
      await tx
        .update(user)
        .set({
          name: "Deleted User",
          email: anonymizedEmail,
          image: null,
          profileComplete: false,
          dateOfBirth: null,
          emergencyContact: null,
          gender: null,
          pronouns: null,
          phone: null,
          privacySettings: null,
          mfaRequired: false,
          mfaEnrolledAt: null,
          twoFactorEnabled: false,
        })
        .where(eq(user.id, request.userId));

      await tx.delete(account).where(eq(account.userId, request.userId));
      await tx.delete(session).where(eq(session.userId, request.userId));
      await tx.delete(twoFactor).where(eq(twoFactor.userId, request.userId));
      await tx.delete(userRoles).where(eq(userRoles.userId, request.userId));
      await tx
        .delete(userPolicyAcceptances)
        .where(eq(userPolicyAcceptances.userId, request.userId));
      await tx.delete(notifications).where(eq(notifications.userId, request.userId));
      await tx.delete(accountLocks).where(eq(accountLocks.userId, request.userId));
      await tx
        .update(securityEvents)
        .set({ userId: null })
        .where(eq(securityEvents.userId, request.userId));

      if (userRecord?.email) {
        await tx
          .delete(verification)
          .where(eq(verification.identifier, userRecord.email));
      }

      await tx
        .update(organizationMembers)
        .set({ status: "removed" })
        .where(eq(organizationMembers.userId, request.userId));

      await tx
        .update(delegatedAccess)
        .set({
          revokedAt: new Date(),
          revokedBy: sessionUser.id,
          notes: data.reason ?? "DSAR erasure request",
        })
        .where(eq(delegatedAccess.delegateUserId, request.userId));

      await tx
        .update(formSubmissions)
        .set({ submitterId: null })
        .where(eq(formSubmissions.submitterId, request.userId));
      await tx
        .update(formSubmissionVersions)
        .set({ changedBy: null })
        .where(eq(formSubmissionVersions.changedBy, request.userId));

      // Files are deleted from S3, so remove their DB rows to avoid dangling pointers / metadata retention
      if (filesToErase.length) {
        await tx.delete(submissionFiles).where(
          inArray(
            submissionFiles.id,
            filesToErase.map((row) => row.id),
          ),
        );
      }

      await tx
        .update(reportingSubmissions)
        .set({ submittedBy: null })
        .where(eq(reportingSubmissions.submittedBy, request.userId));
      await tx
        .update(reportingSubmissionHistory)
        .set({ actorId: null })
        .where(eq(reportingSubmissionHistory.actorId, request.userId));

      await tx
        .update(privacyRequests)
        .set({
          status: "completed",
          processedBy: sessionUser.id,
          processedAt: new Date(),
          resultNotes:
            (data.reason ?? "User data anonymized per DSAR request.") +
            ` Removed ${erasedFilesDeleted}/${erasedFilesAttempted} file artifact(s) from object storage.`,
        })
        .where(eq(privacyRequests.id, data.requestId));
    });

    const { logAdminAction } = await import("~/lib/audit");
    await logAdminAction({
      action: "PRIVACY_ERASURE_APPLY",
      actorUserId: sessionUser.id,
      targetType: "privacy_request",
      targetId: request.id,
      metadata: {
        userId: request.userId,
        reason: data.reason ?? null,
        erasedFilesAttempted,
        erasedFilesDeleted,
      },
    });

    return { success: true };
  });
</file>

<file path="src/features/privacy/privacy.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import { zod$ } from "~/lib/server/fn-utils";
import { getPrivacyExportUrlSchema, policyTypeSchema } from "./privacy.schemas";

const getSessionUserId = async () => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const { getRequest } = await import("@tanstack/react-start/server");
  const auth = await getAuth();
  const { headers } = getRequest();
  const session = await auth.api.getSession({ headers });
  return session?.user?.id ?? null;
};

export const listPolicyDocuments = createServerFn({ method: "GET" }).handler(async () => {
  await assertFeatureEnabled("security_core");
  const { getDb } = await import("~/db/server-helpers");
  const { policyDocuments } = await import("~/db/schema");
  const { desc } = await import("drizzle-orm");

  const db = await getDb();
  return db.select().from(policyDocuments).orderBy(desc(policyDocuments.createdAt));
});

export const getLatestPolicyDocument = createServerFn({ method: "GET" })
  .inputValidator(zod$(policyTypeSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("security_core");
    const { getDb } = await import("~/db/server-helpers");
    const { policyDocuments } = await import("~/db/schema");
    const { desc, eq } = await import("drizzle-orm");

    const db = await getDb();
    const [policy] = await db
      .select()
      .from(policyDocuments)
      .where(eq(policyDocuments.type, data))
      .orderBy(desc(policyDocuments.effectiveDate))
      .limit(1);

    return policy ?? null;
  });

export const listUserPolicyAcceptances = createServerFn({ method: "GET" }).handler(
  async () => {
    await assertFeatureEnabled("security_core");
    const userId = await getSessionUserId();
    if (!userId) return [];

    const { getDb } = await import("~/db/server-helpers");
    const { userPolicyAcceptances } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    return db
      .select()
      .from(userPolicyAcceptances)
      .where(eq(userPolicyAcceptances.userId, userId));
  },
);

export const listPrivacyRequests = createServerFn({ method: "GET" }).handler(async () => {
  await assertFeatureEnabled("security_core");
  const userId = await getSessionUserId();
  if (!userId) return [];

  const { getDb } = await import("~/db/server-helpers");
  const { privacyRequests } = await import("~/db/schema");
  const { desc, eq } = await import("drizzle-orm");

  const db = await getDb();
  return db
    .select()
    .from(privacyRequests)
    .where(eq(privacyRequests.userId, userId))
    .orderBy(desc(privacyRequests.createdAt));
});

export const listAllPrivacyRequests = createServerFn({ method: "GET" }).handler(
  async () => {
    await assertFeatureEnabled("sin_admin_privacy");
    const userId = await getSessionUserId();
    if (!userId) return [];

    const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
    await requireAdmin(userId);

    const { getDb } = await import("~/db/server-helpers");
    const { privacyRequests } = await import("~/db/schema");
    const { desc } = await import("drizzle-orm");

    const db = await getDb();
    return db.select().from(privacyRequests).orderBy(desc(privacyRequests.createdAt));
  },
);

export const listRetentionPolicies = createServerFn({ method: "GET" }).handler(
  async () => {
    await assertFeatureEnabled("sin_admin_privacy");
    const userId = await getSessionUserId();
    if (!userId) return [];

    const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
    await requireAdmin(userId);

    const { getDb } = await import("~/db/server-helpers");
    const { retentionPolicies } = await import("~/db/schema");
    const { asc } = await import("drizzle-orm");

    const db = await getDb();
    return db.select().from(retentionPolicies).orderBy(asc(retentionPolicies.dataType));
  },
);

export const getPrivacyExportDownloadUrl = createServerFn({ method: "GET" })
  .inputValidator(zod$(getPrivacyExportUrlSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_privacy");
    const userId = await getSessionUserId();
    if (!userId) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { privacyRequests } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    const [request] = await db
      .select()
      .from(privacyRequests)
      .where(eq(privacyRequests.id, data.requestId))
      .limit(1);

    if (!request?.resultUrl) return null;

    if (request.userId !== userId) {
      const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
      await requireAdmin(userId);
    }

    const { GetObjectCommand } = await import("@aws-sdk/client-s3");
    const { getSignedUrl } = await import("@aws-sdk/s3-request-presigner");
    const { getArtifactsBucketName, getS3Client } =
      await import("~/lib/storage/artifacts");

    const bucket = request.resultUrl.startsWith("s3://")
      ? request.resultUrl.replace("s3://", "").split("/")[0]
      : await getArtifactsBucketName();
    const key = request.resultUrl.startsWith("s3://")
      ? request.resultUrl.replace(`s3://${bucket}/`, "")
      : request.resultUrl;

    const client = await getS3Client();
    const command = new GetObjectCommand({ Bucket: bucket, Key: key });
    const url = await getSignedUrl(client, command, { expiresIn: 900 });
    return url;
  });
</file>

<file path="src/features/reporting/reporting.mutations.ts">
import { createServerFn } from "@tanstack/react-start";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import { zod$ } from "~/lib/server/fn-utils";
import {
  createReportingCycleSchema,
  createReportingTaskSchema,
  updateReportingSubmissionSchema,
} from "./reporting.schemas";

const getSession = async () => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const { getRequest } = await import("@tanstack/react-start/server");
  const auth = await getAuth();
  const { headers } = getRequest();
  const session = await auth.api.getSession({ headers });
  return session ?? null;
};

const requireSession = async () => {
  const session = await getSession();
  const { unauthorized } = await import("~/lib/server/errors");
  if (!session?.user?.id) {
    throw unauthorized("User not authenticated");
  }
  return session;
};

const requireGlobalAdmin = async (userId: string) => {
  const { forbidden } = await import("~/lib/server/errors");
  const { PermissionService } = await import("~/features/roles/permission.service");
  const isAdmin = await PermissionService.isGlobalAdmin(userId);
  if (!isAdmin) {
    throw forbidden("Global admin access required");
  }
};

export const createReportingCycle = createServerFn({ method: "POST" })
  .inputValidator(zod$(createReportingCycleSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_reporting");
    const session = await requireSession();
    const actorUserId = session.user.id;
    await requireGlobalAdmin(actorUserId);

    const { requireRecentAuth } = await import("~/lib/auth/guards/step-up");
    await requireRecentAuth(actorUserId, session);

    const { getDb } = await import("~/db/server-helpers");
    const { reportingCycles } = await import("~/db/schema");

    const db = await getDb();
    const [created] = await db
      .insert(reportingCycles)
      .values({
        name: data.name,
        description: data.description ?? null,
        startDate: data.startDate,
        endDate: data.endDate,
        createdBy: actorUserId,
      })
      .returning();

    if (created) {
      const { logAdminAction } = await import("~/lib/audit");
      await logAdminAction({
        action: "REPORTING_CYCLE_CREATE",
        actorUserId,
        targetType: "reporting_cycle",
        targetId: created.id,
      });
    }

    return created ?? null;
  });

export const createReportingTask = createServerFn({ method: "POST" })
  .inputValidator(zod$(createReportingTaskSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_reporting");
    const session = await requireSession();
    const actorUserId = session.user.id;
    await requireGlobalAdmin(actorUserId);

    const { requireRecentAuth } = await import("~/lib/auth/guards/step-up");
    await requireRecentAuth(actorUserId, session);

    const { getDb } = await import("~/db/server-helpers");
    const {
      notificationTemplates,
      organizationMembers,
      organizations,
      reportingSubmissions,
      reportingTasks,
    } = await import("~/db/schema");
    const { and, eq, inArray } = await import("drizzle-orm");

    const db = await getDb();
    const [created] = await db
      .insert(reportingTasks)
      .values({
        cycleId: data.cycleId,
        formId: data.formId,
        organizationId: data.organizationId ?? null,
        organizationType: data.organizationType ?? null,
        title: data.title,
        description: data.description ?? null,
        dueDate: data.dueDate,
        reminderConfig: data.reminderConfig ?? {},
      })
      .returning();

    if (created) {
      const targetOrgs = data.organizationId
        ? await db
            .select({ id: organizations.id, name: organizations.name })
            .from(organizations)
            .where(eq(organizations.id, data.organizationId))
        : await db
            .select({ id: organizations.id, name: organizations.name })
            .from(organizations)
            .where(
              and(
                eq(organizations.status, "active"),
                ...(data.organizationType
                  ? [eq(organizations.type, data.organizationType)]
                  : []),
              ),
            );

      if (targetOrgs.length > 0) {
        const defaultStatus: (typeof reportingSubmissions.$inferInsert)["status"] =
          "not_started";
        await db.insert(reportingSubmissions).values(
          targetOrgs.map((org) => ({
            taskId: created.id,
            organizationId: org.id,
            status: defaultStatus,
          })),
        );
      }

      const templateKey = "reporting_reminder";
      const [template] = await db
        .select()
        .from(notificationTemplates)
        .where(eq(notificationTemplates.key, templateKey))
        .limit(1);

      if (!template) {
        await db.insert(notificationTemplates).values({
          key: templateKey,
          category: "reporting",
          subject: "Reporting reminder: {{title}} due {{dueDate}}",
          bodyTemplate:
            'Your reporting task "{{title}}" for {{orgName}} is due on {{dueDate}}.',
          isSystem: true,
          createdBy: actorUserId,
        });
      }

      const reminderConfig = data.reminderConfig ?? {};
      const daysBeforeRaw = Array.isArray(reminderConfig["days_before"])
        ? reminderConfig["days_before"]
        : Array.isArray(reminderConfig["daysBefore"])
          ? reminderConfig["daysBefore"]
          : [14, 7, 3, 1];
      const daysBefore = daysBeforeRaw
        .map((value) => Number(value))
        .filter((value) => !Number.isNaN(value));
      const dueDate = new Date(data.dueDate);

      const { scheduleNotification } = await import("~/lib/notifications/scheduler");
      const notifyRoles: Array<"owner" | "admin" | "reporter"> = [
        "owner",
        "admin",
        "reporter",
      ];

      for (const org of targetOrgs) {
        const members = await db
          .select({
            userId: organizationMembers.userId,
            role: organizationMembers.role,
          })
          .from(organizationMembers)
          .where(
            and(
              eq(organizationMembers.organizationId, org.id),
              eq(organizationMembers.status, "active"),
              inArray(organizationMembers.role, notifyRoles),
            ),
          );

        for (const member of members) {
          for (const offset of daysBefore) {
            const scheduledFor = new Date(
              dueDate.getTime() - Number(offset) * 24 * 60 * 60 * 1000,
            );
            if (scheduledFor <= new Date()) continue;

            await scheduleNotification({
              templateKey,
              userId: member.userId,
              organizationId: org.id,
              scheduledFor,
              variables: {
                title: data.title,
                dueDate: dueDate.toDateString(),
                orgName: org.name,
              },
            });
          }
        }
      }

      const { logAdminAction } = await import("~/lib/audit");
      await logAdminAction({
        action: "REPORTING_TASK_CREATE",
        actorUserId,
        targetType: "reporting_task",
        targetId: created.id,
      });
    }

    return created ?? null;
  });

export const updateReportingSubmission = createServerFn({ method: "POST" })
  .inputValidator(zod$(updateReportingSubmissionSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_reporting");
    const session = await requireSession();
    const actorUserId = session.user.id;
    const { getDb } = await import("~/db/server-helpers");
    const { reportingSubmissionHistory, reportingSubmissions } =
      await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();

    // Load submission first so we can enforce org-scoped authorization
    const [existing] = await db
      .select({
        id: reportingSubmissions.id,
        organizationId: reportingSubmissions.organizationId,
      })
      .from(reportingSubmissions)
      .where(eq(reportingSubmissions.id, data.submissionId))
      .limit(1);

    if (!existing) {
      return null;
    }

    const { PermissionService } = await import("~/features/roles/permission.service");
    const isGlobalAdmin = await PermissionService.isGlobalAdmin(actorUserId);

    if (!isGlobalAdmin) {
      const { requireOrganizationAccess, ORG_ADMIN_ROLES } =
        await import("~/lib/auth/guards/org-guard");

      const reviewStatuses = new Set([
        "under_review",
        "changes_requested",
        "approved",
        "rejected",
      ]);
      const adminOnlyStatuses = new Set(["overdue", ...reviewStatuses]);

      if (adminOnlyStatuses.has(data.status)) {
        await requireOrganizationAccess(
          { userId: actorUserId, organizationId: existing.organizationId },
          { roles: ORG_ADMIN_ROLES },
        );
      } else {
        await requireOrganizationAccess(
          { userId: actorUserId, organizationId: existing.organizationId },
          { roles: ["owner", "admin", "reporter"] },
        );
      }
    }

    const isReviewStatus = [
      "under_review",
      "changes_requested",
      "approved",
      "rejected",
    ].includes(data.status);
    const isSubmitStatus = data.status === "submitted";

    const [updated] = await db
      .update(reportingSubmissions)
      .set({
        status: data.status,
        ...(isSubmitStatus ? { submittedAt: new Date(), submittedBy: actorUserId } : {}),
        ...(isReviewStatus
          ? {
              reviewedBy: actorUserId,
              reviewedAt: new Date(),
              reviewNotes: data.reviewNotes ?? null,
            }
          : {}),
        ...(data.formSubmissionId ? { formSubmissionId: data.formSubmissionId } : {}),
      })
      .where(eq(reportingSubmissions.id, data.submissionId))
      .returning();

    if (!updated) {
      return null;
    }

    await db.insert(reportingSubmissionHistory).values({
      reportingSubmissionId: updated.id,
      action: data.status,
      actorId: actorUserId,
      notes: data.reviewNotes ?? null,
      formSubmissionVersionId: data.formSubmissionVersionId ?? null,
    });

    const { logDataChange } = await import("~/lib/audit");
    await logDataChange({
      action: "REPORTING_SUBMISSION_UPDATE",
      actorUserId,
      targetType: "reporting_submission",
      targetId: updated.id,
      targetOrgId: updated.organizationId,
    });

    return updated;
  });
</file>

<file path="src/features/reporting/reporting.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import { z } from "zod";
import { zod$ } from "~/lib/server/fn-utils";
import { reportingSubmissionStatusSchema } from "./reporting.schemas";

const getSessionUserId = async () => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const { getRequest } = await import("@tanstack/react-start/server");
  const auth = await getAuth();
  const { headers } = getRequest();
  const session = await auth.api.getSession({ headers });
  return session?.user?.id ?? null;
};

const listReportingTasksSchema = z
  .object({
    cycleId: z.uuid().optional(),
    organizationId: z.uuid().optional(),
  })
  .nullish()
  .transform((value) => value ?? {});

const listReportingOverviewSchema = z
  .object({
    organizationId: z.uuid().optional(),
    status: reportingSubmissionStatusSchema.optional(),
  })
  .nullish()
  .transform((value) => value ?? {});

const listReportingSubmissionHistorySchema = z.object({
  submissionId: z.uuid(),
});

export const listReportingCycles = createServerFn({ method: "GET" }).handler(async () => {
  await assertFeatureEnabled("sin_reporting");
  const { getDb } = await import("~/db/server-helpers");
  const { reportingCycles } = await import("~/db/schema");
  const { desc } = await import("drizzle-orm");

  const db = await getDb();
  return db.select().from(reportingCycles).orderBy(desc(reportingCycles.createdAt));
});

export const listReportingTasks = createServerFn({ method: "GET" })
  .inputValidator(zod$(listReportingTasksSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_reporting");
    const { getDb } = await import("~/db/server-helpers");
    const { reportingTasks } = await import("~/db/schema");
    const { and, eq } = await import("drizzle-orm");

    const db = await getDb();
    const conditions = [];

    if (data.cycleId) {
      conditions.push(eq(reportingTasks.cycleId, data.cycleId));
    }

    if (data.organizationId) {
      const userId = await getSessionUserId();
      if (userId) {
        const { requireOrganizationAccess } =
          await import("~/lib/auth/guards/org-guard");
        await requireOrganizationAccess({
          userId,
          organizationId: data.organizationId,
        });
      }
      conditions.push(eq(reportingTasks.organizationId, data.organizationId));
    }

    return db
      .select()
      .from(reportingTasks)
      .where(conditions.length ? and(...conditions) : undefined);
  });

export const listReportingSubmissions = createServerFn({ method: "GET" })
  .inputValidator(
    zod$(
      z.object({
        organizationId: z.uuid(),
      }),
    ),
  )
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_reporting");
    const { getDb } = await import("~/db/server-helpers");
    const { reportingSubmissions } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const userId = await getSessionUserId();
    if (userId) {
      const { requireOrganizationAccess } =
        await import("~/lib/auth/guards/org-guard");
      await requireOrganizationAccess({
        userId,
        organizationId: data.organizationId,
      });
    }

    const db = await getDb();
    return db
      .select()
      .from(reportingSubmissions)
      .where(eq(reportingSubmissions.organizationId, data.organizationId));
  });

export const listReportingOverview = createServerFn({ method: "GET" })
  .inputValidator(zod$(listReportingOverviewSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_reporting");
    const userId = await getSessionUserId();
    if (!userId) return [];

    const { getDb } = await import("~/db/server-helpers");
    const {
      organizationMembers,
      organizations,
      reportingCycles,
      reportingSubmissions,
      reportingTasks,
    } = await import("~/db/schema");
    const { and, eq, inArray } = await import("drizzle-orm");
    const db = await getDb();

    let orgIds: string[] = [];
    const { PermissionService } = await import("~/features/roles/permission.service");
    const isAdmin = await PermissionService.isGlobalAdmin(userId);

    if (data.organizationId) {
      const { requireOrganizationAccess } =
        await import("~/lib/auth/guards/org-guard");
      await requireOrganizationAccess({
        userId,
        organizationId: data.organizationId,
      });
      orgIds = [data.organizationId];
    } else if (!isAdmin) {
      const memberships = await db
        .select({ organizationId: organizationMembers.organizationId })
        .from(organizationMembers)
        .where(
          and(
            eq(organizationMembers.userId, userId),
            eq(organizationMembers.status, "active"),
          ),
        );

      orgIds = memberships.map((membership) => membership.organizationId);
      if (orgIds.length === 0) return [];
    }

    const conditions = [];
    if (orgIds.length > 0) {
      conditions.push(inArray(reportingSubmissions.organizationId, orgIds));
    }
    if (data.status) {
      conditions.push(eq(reportingSubmissions.status, data.status));
    }

    return db
      .select({
        submissionId: reportingSubmissions.id,
        status: reportingSubmissions.status,
        submittedAt: reportingSubmissions.submittedAt,
        dueDate: reportingTasks.dueDate,
        taskTitle: reportingTasks.title,
        taskId: reportingTasks.id,
        cycleId: reportingCycles.id,
        cycleName: reportingCycles.name,
        organizationId: organizations.id,
        organizationName: organizations.name,
        formId: reportingTasks.formId,
        formSubmissionId: reportingSubmissions.formSubmissionId,
      })
      .from(reportingSubmissions)
      .innerJoin(reportingTasks, eq(reportingSubmissions.taskId, reportingTasks.id))
      .innerJoin(reportingCycles, eq(reportingTasks.cycleId, reportingCycles.id))
      .innerJoin(organizations, eq(reportingSubmissions.organizationId, organizations.id))
      .where(conditions.length ? and(...conditions) : undefined);
  });

export const listReportingSubmissionHistory = createServerFn({ method: "GET" })
  .inputValidator(zod$(listReportingSubmissionHistorySchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_reporting");
    const userId = await getSessionUserId();
    if (!userId) return [];

    const { getDb } = await import("~/db/server-helpers");
    const { organizationMembers, reportingSubmissionHistory, reportingSubmissions } =
      await import("~/db/schema");
    const { and, eq } = await import("drizzle-orm");
    const db = await getDb();

    const [submission] = await db
      .select({
        organizationId: reportingSubmissions.organizationId,
      })
      .from(reportingSubmissions)
      .where(eq(reportingSubmissions.id, data.submissionId))
      .limit(1);

    if (!submission) return [];

    const { PermissionService } = await import("~/features/roles/permission.service");
    const isAdmin = await PermissionService.isGlobalAdmin(userId);
    if (!isAdmin) {
      const [membership] = await db
        .select()
        .from(organizationMembers)
        .where(
          and(
            eq(organizationMembers.userId, userId),
            eq(organizationMembers.organizationId, submission.organizationId),
          ),
        )
        .limit(1);
      if (!membership) return [];
    }

    return db
      .select()
      .from(reportingSubmissionHistory)
      .where(eq(reportingSubmissionHistory.reportingSubmissionId, data.submissionId));
  });
</file>

<file path="src/features/reports/components/report-builder-shell.tsx">
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { useCallback, useMemo, useState } from "react";
import { toast } from "sonner";
import { FormSubmitButton } from "~/components/form-fields/FormSubmitButton";
import { Button } from "~/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";
import { Checkbox } from "~/components/ui/checkbox";
import { Input } from "~/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "~/components/ui/table";
import { Textarea } from "~/components/ui/textarea";
import { getStepUpErrorMessage, useStepUpPrompt } from "~/features/auth/step-up";
import { listOrganizations } from "~/features/organizations/organizations.queries";
import { useAppForm } from "~/lib/hooks/useAppForm";
import {
  createSavedReport,
  deleteSavedReport,
  exportReport,
  updateSavedReport,
} from "../reports.mutations";
import { listSavedReports } from "../reports.queries";

const dataSourceOptions = [
  { value: "organizations", label: "Organizations" },
  { value: "reporting_submissions", label: "Reporting submissions" },
  { value: "form_submissions", label: "Form submissions" },
];

const exportTypeOptions = [
  { value: "csv", label: "CSV" },
  { value: "excel", label: "Excel" },
  { value: "pdf", label: "PDF" },
];

const parseJsonInput = (value: string) => {
  if (!value.trim()) return undefined;
  try {
    return JSON.parse(value) as Record<string, unknown>;
  } catch {
    return null;
  }
};

const parseListInput = (value: string) =>
  value
    .split(",")
    .map((entry) => entry.trim())
    .filter(Boolean);

function SavedReportRow({
  report,
  onUpdated,
  onDeleted,
}: {
  report: {
    id: string;
    name: string;
    description: string | null;
    dataSource: string;
    organizationId: string | null;
    sharedWith: string[] | null;
    isOrgWide: boolean;
    filters: Record<string, unknown>;
    columns: string[] | null;
    sort: Record<string, unknown> | null;
  };
  onUpdated: () => void;
  onDeleted: () => void;
}) {
  const [isEditing, setIsEditing] = useState(false);
  const form = useAppForm({
    defaultValues: {
      name: report.name,
      description: report.description ?? "",
      dataSource: report.dataSource,
      organizationId: report.organizationId ?? "",
      sharedWith: report.sharedWith?.join(", ") ?? "",
      isOrgWide: report.isOrgWide,
      filters: JSON.stringify(report.filters ?? {}, null, 2),
      columns: report.columns?.join(", ") ?? "",
      sort: JSON.stringify(report.sort ?? {}, null, 2),
    },
    onSubmit: async ({ value }) => {
      const filters = parseJsonInput(value.filters);
      const sort = parseJsonInput(value.sort);
      if (filters === null || sort === null) {
        toast.error("Filters or sort JSON is invalid.");
        return;
      }

      const updated = await updateSavedReport({
        data: {
          reportId: report.id,
          data: {
            name: value.name,
            description: value.description || undefined,
            dataSource: value.dataSource,
            organizationId: value.organizationId || undefined,
            sharedWith: parseListInput(value.sharedWith),
            isOrgWide: value.isOrgWide,
            filters: filters ?? undefined,
            columns: parseListInput(value.columns),
            sort: sort ?? undefined,
          },
        },
      });

      if (updated) {
        toast.success("Report updated.");
        setIsEditing(false);
        onUpdated();
      } else {
        toast.error("Failed to update report.");
      }
    },
  });

  return (
    <>
      <TableRow>
        <TableCell className="text-xs font-semibold">{report.name}</TableCell>
        <TableCell className="text-xs">{report.dataSource}</TableCell>
        <TableCell className="text-xs">
          {report.isOrgWide ? "Org-wide" : "Private"}
        </TableCell>
        <TableCell className="text-right">
          <div className="flex items-center justify-end gap-2">
            <Button
              type="button"
              size="sm"
              variant="outline"
              onClick={() => setIsEditing((prev) => !prev)}
            >
              {isEditing ? "Close" : "Edit"}
            </Button>
            <Button type="button" size="sm" variant="ghost" onClick={onDeleted}>
              Delete
            </Button>
          </div>
        </TableCell>
      </TableRow>
      {isEditing ? (
        <TableRow>
          <TableCell colSpan={4} className="pt-4">
            <form
              onSubmit={(event) => {
                event.preventDefault();
                event.stopPropagation();
                void form.handleSubmit();
              }}
              className="space-y-3"
            >
              <div className="grid gap-3 md:grid-cols-2">
                <form.Field name="name">
                  {(field) => (
                    <Input
                      placeholder="Report name"
                      value={(field.state.value as string) ?? ""}
                      onChange={(event) => field.handleChange(event.target.value)}
                      onBlur={field.handleBlur}
                    />
                  )}
                </form.Field>
                <form.Field name="dataSource">
                  {(field) => (
                    <Select value={field.state.value} onValueChange={field.handleChange}>
                      <SelectTrigger>
                        <SelectValue placeholder="Data source" />
                      </SelectTrigger>
                      <SelectContent>
                        {dataSourceOptions.map((option) => (
                          <SelectItem key={option.value} value={option.value}>
                            {option.label}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  )}
                </form.Field>
              </div>
              <form.Field name="description">
                {(field) => (
                  <Input
                    placeholder="Description (optional)"
                    value={(field.state.value as string) ?? ""}
                    onChange={(event) => field.handleChange(event.target.value)}
                    onBlur={field.handleBlur}
                  />
                )}
              </form.Field>
              <div className="grid gap-3 md:grid-cols-2">
                <form.Field name="organizationId">
                  {(field) => (
                    <Input
                      placeholder="Organization ID (optional)"
                      value={(field.state.value as string) ?? ""}
                      onChange={(event) => field.handleChange(event.target.value)}
                      onBlur={field.handleBlur}
                    />
                  )}
                </form.Field>
                <form.Field name="sharedWith">
                  {(field) => (
                    <Input
                      placeholder="Share with (comma-separated IDs)"
                      value={(field.state.value as string) ?? ""}
                      onChange={(event) => field.handleChange(event.target.value)}
                      onBlur={field.handleBlur}
                    />
                  )}
                </form.Field>
              </div>
              <form.Field name="filters">
                {(field) => (
                  <Textarea
                    rows={3}
                    placeholder='Filters JSON (e.g., {"status":"active"})'
                    value={(field.state.value as string) ?? ""}
                    onChange={(event) => field.handleChange(event.target.value)}
                    onBlur={field.handleBlur}
                  />
                )}
              </form.Field>
              <div className="grid gap-3 md:grid-cols-2">
                <form.Field name="columns">
                  {(field) => (
                    <Input
                      placeholder="Columns (comma-separated)"
                      value={(field.state.value as string) ?? ""}
                      onChange={(event) => field.handleChange(event.target.value)}
                      onBlur={field.handleBlur}
                    />
                  )}
                </form.Field>
                <form.Field name="sort">
                  {(field) => (
                    <Textarea
                      rows={3}
                      placeholder='Sort JSON (e.g., {"created_at":"desc"})'
                      value={(field.state.value as string) ?? ""}
                      onChange={(event) => field.handleChange(event.target.value)}
                      onBlur={field.handleBlur}
                    />
                  )}
                </form.Field>
              </div>
              <form.Field name="isOrgWide">
                {(field) => (
                  <label className="flex items-center gap-2 text-sm">
                    <Checkbox
                      checked={Boolean(field.state.value)}
                      onCheckedChange={(checked) => field.handleChange(Boolean(checked))}
                    />
                    Org-wide (share with all org members)
                  </label>
                )}
              </form.Field>
              <FormSubmitButton className="w-fit">Save changes</FormSubmitButton>
            </form>
          </TableCell>
        </TableRow>
      ) : null}
    </>
  );
}

export function ReportBuilderShell() {
  const queryClient = useQueryClient();
  const { requestStepUp } = useStepUpPrompt();
  const handleStepUpError = useCallback(
    (error: unknown) => {
      const message = getStepUpErrorMessage(error);
      if (!message) return false;
      requestStepUp(message);
      return true;
    },
    [requestStepUp],
  );
  const { data: organizations = [] } = useQuery({
    queryKey: ["organizations", "list"],
    queryFn: () => listOrganizations({ data: { includeArchived: false } }),
  });
  const { data: reports = [] } = useQuery({
    queryKey: ["reports", "saved"],
    queryFn: () => listSavedReports({ data: {} }),
  });

  const exportMutation = useMutation({
    mutationFn: exportReport,
    onSuccess: (result, variables) => {
      if (!result?.data) return;
      const exportType =
        typeof variables === "object" && variables && "data" in variables
          ? (variables as { data?: { exportType?: "csv" | "excel" | "pdf" } }).data
              ?.exportType
          : undefined;
      const extension = exportType === "pdf" ? "pdf" : "csv";
      const blob = new Blob([result.data], {
        type: exportType === "pdf" ? "application/pdf" : "text/csv",
      });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = `report-export.${extension}`;
      link.click();
      URL.revokeObjectURL(url);
    },
    onError: (error) => {
      if (handleStepUpError(error)) return;
      const message = error instanceof Error ? error.message : "Failed to export report.";
      toast.error(message);
    },
  });

  const createForm = useAppForm({
    defaultValues: {
      name: "",
      description: "",
      dataSource: "",
      organizationId: "__all__",
      sharedWith: "",
      isOrgWide: false,
      filters: "",
      columns: "",
      sort: "",
    },
    onSubmit: async ({ value }) => {
      const filters = parseJsonInput(value.filters);
      const sort = parseJsonInput(value.sort);
      if (filters === null || sort === null) {
        toast.error("Filters or sort JSON is invalid.");
        return;
      }

      const created = await createSavedReport({
        data: {
          name: value.name,
          description: value.description || undefined,
          dataSource: value.dataSource,
          organizationId:
            value.organizationId === "__all__" ? undefined : value.organizationId,
          sharedWith: parseListInput(value.sharedWith),
          isOrgWide: value.isOrgWide,
          filters: filters ?? undefined,
          columns: parseListInput(value.columns),
          sort: sort ?? undefined,
        },
      });

      if (created) {
        toast.success("Report saved.");
        createForm.reset();
        await queryClient.invalidateQueries({ queryKey: ["reports", "saved"] });
      } else {
        toast.error("Failed to save report.");
      }
    },
  });

  const exportForm = useAppForm({
    defaultValues: {
      dataSource: "",
      exportType: "csv",
      filters: "",
      columns: "",
    },
    onSubmit: async ({ value }) => {
      const filters = parseJsonInput(value.filters);
      if (filters === null) {
        toast.error("Filters JSON is invalid.");
        return;
      }

      exportMutation.mutate({
        data: {
          dataSource: value.dataSource,
          exportType: value.exportType as "csv" | "excel" | "pdf",
          filters: filters ?? undefined,
          columns: parseListInput(value.columns),
        },
      });
    },
  });

  const normalizedReports = useMemo(() => reports, [reports]);

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Export data</CardTitle>
        </CardHeader>
        <CardContent>
          <form
            onSubmit={(event) => {
              event.preventDefault();
              event.stopPropagation();
              void exportForm.handleSubmit();
            }}
            className="space-y-3"
          >
            <div className="grid gap-3 md:grid-cols-2">
              <exportForm.Field name="dataSource">
                {(field) => (
                  <Select value={field.state.value} onValueChange={field.handleChange}>
                    <SelectTrigger>
                      <SelectValue placeholder="Data source" />
                    </SelectTrigger>
                    <SelectContent>
                      {dataSourceOptions.map((option) => (
                        <SelectItem key={option.value} value={option.value}>
                          {option.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                )}
              </exportForm.Field>
              <exportForm.Field name="exportType">
                {(field) => (
                  <Select value={field.state.value} onValueChange={field.handleChange}>
                    <SelectTrigger>
                      <SelectValue placeholder="Export type" />
                    </SelectTrigger>
                    <SelectContent>
                      {exportTypeOptions.map((option) => (
                        <SelectItem key={option.value} value={option.value}>
                          {option.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                )}
              </exportForm.Field>
            </div>
            <exportForm.Field name="columns">
              {(field) => (
                <Input
                  placeholder="Columns (comma-separated)"
                  value={(field.state.value as string) ?? ""}
                  onChange={(event) => field.handleChange(event.target.value)}
                  onBlur={field.handleBlur}
                />
              )}
            </exportForm.Field>
            <exportForm.Field name="filters">
              {(field) => (
                <Textarea
                  rows={3}
                  placeholder='Filters JSON (e.g., {"status":"active"})'
                  value={(field.state.value as string) ?? ""}
                  onChange={(event) => field.handleChange(event.target.value)}
                  onBlur={field.handleBlur}
                />
              )}
            </exportForm.Field>
            <FormSubmitButton className="w-fit">
              {exportMutation.isPending ? "Exporting..." : "Export"}
            </FormSubmitButton>
          </form>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Saved reports</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          {normalizedReports.length === 0 ? (
            <p className="text-muted-foreground text-sm">No saved reports yet.</p>
          ) : (
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Name</TableHead>
                  <TableHead>Source</TableHead>
                  <TableHead>Sharing</TableHead>
                  <TableHead className="text-right">Actions</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {normalizedReports.map((report) => (
                  <SavedReportRow
                    key={report.id}
                    report={report}
                    onUpdated={() =>
                      queryClient.invalidateQueries({ queryKey: ["reports", "saved"] })
                    }
                    onDeleted={async () => {
                      await deleteSavedReport({ data: { reportId: report.id } });
                      await queryClient.invalidateQueries({
                        queryKey: ["reports", "saved"],
                      });
                    }}
                  />
                ))}
              </TableBody>
            </Table>
          )}
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Create saved report</CardTitle>
        </CardHeader>
        <CardContent>
          <form
            onSubmit={(event) => {
              event.preventDefault();
              event.stopPropagation();
              void createForm.handleSubmit();
            }}
            className="space-y-3"
          >
            <div className="grid gap-3 md:grid-cols-2">
              <createForm.Field name="name">
                {(field) => (
                  <Input
                    placeholder="Report name"
                    value={(field.state.value as string) ?? ""}
                    onChange={(event) => field.handleChange(event.target.value)}
                    onBlur={field.handleBlur}
                  />
                )}
              </createForm.Field>
              <createForm.Field name="dataSource">
                {(field) => (
                  <Select value={field.state.value} onValueChange={field.handleChange}>
                    <SelectTrigger>
                      <SelectValue placeholder="Data source" />
                    </SelectTrigger>
                    <SelectContent>
                      {dataSourceOptions.map((option) => (
                        <SelectItem key={option.value} value={option.value}>
                          {option.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                )}
              </createForm.Field>
            </div>
            <createForm.Field name="description">
              {(field) => (
                <Input
                  placeholder="Description (optional)"
                  value={(field.state.value as string) ?? ""}
                  onChange={(event) => field.handleChange(event.target.value)}
                  onBlur={field.handleBlur}
                />
              )}
            </createForm.Field>
            <div className="grid gap-3 md:grid-cols-2">
              <createForm.Field name="organizationId">
                {(field) => (
                  <Select value={field.state.value} onValueChange={field.handleChange}>
                    <SelectTrigger>
                      <SelectValue placeholder="Organization scope" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="__all__">All organizations</SelectItem>
                      {organizations.map((org) => (
                        <SelectItem key={org.id} value={org.id}>
                          {org.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                )}
              </createForm.Field>
              <createForm.Field name="sharedWith">
                {(field) => (
                  <Input
                    placeholder="Share with (comma-separated IDs)"
                    value={(field.state.value as string) ?? ""}
                    onChange={(event) => field.handleChange(event.target.value)}
                    onBlur={field.handleBlur}
                  />
                )}
              </createForm.Field>
            </div>
            <createForm.Field name="filters">
              {(field) => (
                <Textarea
                  rows={3}
                  placeholder='Filters JSON (e.g., {"status":"active"})'
                  value={(field.state.value as string) ?? ""}
                  onChange={(event) => field.handleChange(event.target.value)}
                  onBlur={field.handleBlur}
                />
              )}
            </createForm.Field>
            <div className="grid gap-3 md:grid-cols-2">
              <createForm.Field name="columns">
                {(field) => (
                  <Input
                    placeholder="Columns (comma-separated)"
                    value={(field.state.value as string) ?? ""}
                    onChange={(event) => field.handleChange(event.target.value)}
                    onBlur={field.handleBlur}
                  />
                )}
              </createForm.Field>
              <createForm.Field name="sort">
                {(field) => (
                  <Textarea
                    rows={3}
                    placeholder='Sort JSON (e.g., {"created_at":"desc"})'
                    value={(field.state.value as string) ?? ""}
                    onChange={(event) => field.handleChange(event.target.value)}
                    onBlur={field.handleBlur}
                  />
                )}
              </createForm.Field>
            </div>
            <createForm.Field name="isOrgWide">
              {(field) => (
                <label className="flex items-center gap-2 text-sm">
                  <Checkbox
                    checked={Boolean(field.state.value)}
                    onCheckedChange={(checked) => field.handleChange(Boolean(checked))}
                  />
                  Org-wide (share with all org members)
                </label>
              )}
            </createForm.Field>
            <FormSubmitButton className="w-fit">Save report</FormSubmitButton>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/features/reports/reports.mutations.ts">
import { createServerFn } from "@tanstack/react-start";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import { zod$ } from "~/lib/server/fn-utils";
import {
  createSavedReportSchema,
  deleteSavedReportSchema,
  exportReportSchema,
  updateSavedReportSchema,
} from "./reports.schemas";

const SENSITIVE_FIELDS = [
  "email",
  "phone",
  "dateOfBirth",
  "emergencyContact",
  "emergencyContactPhone",
  "emergencyContactEmail",
];

const extractPermissionSet = (
  roleAssignments: Array<{ role?: { permissions?: Record<string, boolean> } }>,
) => {
  const permissions = new Set<string>();
  for (const assignment of roleAssignments) {
    const perms = assignment.role?.permissions ?? {};
    for (const [key, value] of Object.entries(perms)) {
      if (value) permissions.add(key);
    }
  }
  return permissions;
};

const canViewSensitiveFields = ({
  isGlobalAdmin,
  orgRole,
  permissions,
}: {
  isGlobalAdmin: boolean;
  orgRole: string | null;
  permissions: Set<string>;
}) => {
  if (isGlobalAdmin) return true;
  if (permissions.has("*")) return true;
  if (
    permissions.has("pii.read") ||
    permissions.has("pii:read") ||
    permissions.has("data.pii.read")
  ) {
    return true;
  }

  // Default: org owners/admins can view sensitive fields *within their org scope*
  if (orgRole && ["owner", "admin"].includes(orgRole)) return true;

  return false;
};

const applyFieldLevelAcl = (
  rows: Array<Record<string, unknown>>,
  opts: { canViewSensitiveFields: boolean },
) => {
  if (opts.canViewSensitiveFields) return rows;
  return rows.map((row) => {
    const next = { ...row };
    for (const field of SENSITIVE_FIELDS) {
      if (Object.prototype.hasOwnProperty.call(next, field)) {
        next[field] = "***";
      }
    }
    return next;
  });
};

const getSession = async () => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const { getRequest } = await import("@tanstack/react-start/server");
  const auth = await getAuth();
  const { headers } = getRequest();
  const session = await auth.api.getSession({ headers });
  return session ?? null;
};

const getSessionUser = async () => {
  const session = await getSession();
  return session?.user ?? null;
};

const loadReportData = async ({
  dataSource,
  organizationId,
  isGlobalAdmin,
}: {
  dataSource: string;
  organizationId: string | null;
  isGlobalAdmin: boolean;
}) => {
  const { getDb } = await import("~/db/server-helpers");
  const { organizations, reportingSubmissions, formSubmissions } =
    await import("~/db/schema");
  const { eq } = await import("drizzle-orm");

  const db = await getDb();
  if (dataSource === "organizations") {
    if (isGlobalAdmin && !organizationId) return db.select().from(organizations);
    if (!organizationId) return [];
    return db.select().from(organizations).where(eq(organizations.id, organizationId));
  }

  if (dataSource === "reporting_submissions") {
    if (isGlobalAdmin && !organizationId) return db.select().from(reportingSubmissions);
    if (!organizationId) return [];
    return db
      .select()
      .from(reportingSubmissions)
      .where(eq(reportingSubmissions.organizationId, organizationId));
  }

  if (dataSource === "form_submissions") {
    if (isGlobalAdmin && !organizationId) return db.select().from(formSubmissions);
    if (!organizationId) return [];
    return db
      .select()
      .from(formSubmissions)
      .where(eq(formSubmissions.organizationId, organizationId));
  }

  return [];
};

export const createSavedReport = createServerFn({ method: "POST" })
  .inputValidator(zod$(createSavedReportSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_analytics");
    const sessionUser = await getSessionUser();
    if (!sessionUser?.id) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { savedReports } = await import("~/db/schema");

    const db = await getDb();
    const [created] = await db
      .insert(savedReports)
      .values({
        organizationId: data.organizationId ?? null,
        name: data.name,
        description: data.description ?? null,
        dataSource: data.dataSource,
        filters: data.filters ?? {},
        columns: data.columns ?? [],
        sort: data.sort ?? {},
        ownerId: sessionUser.id,
        sharedWith: data.sharedWith ?? [],
        isOrgWide: data.isOrgWide ?? false,
      })
      .returning();

    if (created) {
      const { logDataChange } = await import("~/lib/audit");
      await logDataChange({
        action: "REPORT_SAVE",
        actorUserId: sessionUser.id,
        targetType: "saved_report",
        targetId: created.id,
        targetOrgId: created.organizationId ?? null,
      });
    }

    return created ?? null;
  });

export const updateSavedReport = createServerFn({ method: "POST" })
  .inputValidator(zod$(updateSavedReportSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_analytics");
    const sessionUser = await getSessionUser();
    if (!sessionUser?.id) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { savedReports } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    const [existing] = await db
      .select()
      .from(savedReports)
      .where(eq(savedReports.id, data.reportId))
      .limit(1);

    if (!existing) return null;

    if (existing.ownerId !== sessionUser.id) {
      const { PermissionService } = await import("~/features/roles/permission.service");
      const isAdmin = await PermissionService.isGlobalAdmin(sessionUser.id);
      if (!isAdmin) return null;
    }

    const [updated] = await db
      .update(savedReports)
      .set({
        organizationId: data.data.organizationId ?? existing.organizationId,
        name: data.data.name ?? existing.name,
        description: data.data.description ?? existing.description,
        dataSource: data.data.dataSource ?? existing.dataSource,
        filters: data.data.filters ?? existing.filters,
        columns: data.data.columns ?? existing.columns,
        sort: data.data.sort ?? existing.sort,
        sharedWith: data.data.sharedWith ?? existing.sharedWith,
        isOrgWide: data.data.isOrgWide ?? existing.isOrgWide,
      })
      .where(eq(savedReports.id, data.reportId))
      .returning();

    if (updated) {
      const { logDataChange } = await import("~/lib/audit");
      await logDataChange({
        action: "REPORT_UPDATE",
        actorUserId: sessionUser.id,
        targetType: "saved_report",
        targetId: updated.id,
        targetOrgId: updated.organizationId ?? null,
      });
    }

    return updated ?? null;
  });

export const deleteSavedReport = createServerFn({ method: "POST" })
  .inputValidator(zod$(deleteSavedReportSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_analytics");
    const sessionUser = await getSessionUser();
    if (!sessionUser?.id) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { savedReports } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    const [existing] = await db
      .select()
      .from(savedReports)
      .where(eq(savedReports.id, data.reportId))
      .limit(1);

    if (!existing) return null;

    if (existing.ownerId !== sessionUser.id) {
      const { PermissionService } = await import("~/features/roles/permission.service");
      const isAdmin = await PermissionService.isGlobalAdmin(sessionUser.id);
      if (!isAdmin) return null;
    }

    await db.delete(savedReports).where(eq(savedReports.id, data.reportId));

    const { logDataChange } = await import("~/lib/audit");
    await logDataChange({
      action: "REPORT_DELETE",
      actorUserId: sessionUser.id,
      targetType: "saved_report",
      targetId: data.reportId,
      targetOrgId: existing.organizationId ?? null,
    });

    return { success: true };
  });

export const exportReport = createServerFn({ method: "POST" })
  .inputValidator(zod$(exportReportSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_analytics");
    const session = await getSession();
    const sessionUser = session?.user ?? null;
    if (!sessionUser?.id) return null;

    const { requireRecentAuth } = await import("~/lib/auth/guards/step-up");
    await requireRecentAuth(sessionUser.id, session);

    const { toCsv } = await import("~/shared/lib/csv");
    const { exportHistory } = await import("~/db/schema");
    const { getDb } = await import("~/db/server-helpers");
    const { PermissionService } = await import("~/features/roles/permission.service");
    const db = await getDb();

    const { forbidden } = await import("~/lib/server/errors");
    const isGlobalAdmin = await PermissionService.isGlobalAdmin(sessionUser.id);

    const { getRequest } = await import("@tanstack/react-start/server");
    const request = getRequest();
    const orgIdFromHeader = request.headers.get("x-organization-id");
    const filtersRecord = data.filters as Record<string, unknown> | undefined;
    const orgIdValue = filtersRecord?.["organizationId"];
    const orgIdFromFilters = typeof orgIdValue === "string" ? orgIdValue : null;
    const scopedOrganizationId = orgIdFromHeader ?? orgIdFromFilters ?? null;

    let orgRole: string | null = null;
    if (!isGlobalAdmin) {
      if (!scopedOrganizationId) {
        throw forbidden("Organization context required");
      }

      const { requireOrganizationMembership } =
        await import("~/lib/auth/guards/org-guard");
      const membership = await requireOrganizationMembership({
        userId: sessionUser.id,
        organizationId: scopedOrganizationId,
      });
      orgRole = membership.role;
    }

    const roleAssignments = await PermissionService.getUserRoles(sessionUser.id);
    const permissions = extractPermissionSet(
      roleAssignments as Array<{ role?: { permissions?: Record<string, boolean> } }>,
    );
    const canViewPii = canViewSensitiveFields({
      isGlobalAdmin,
      orgRole,
      permissions,
    });

    const rows = await loadReportData({
      dataSource: data.dataSource,
      organizationId: scopedOrganizationId,
      isGlobalAdmin,
    });

    const filteredRows = applyFieldLevelAcl(rows as Array<Record<string, unknown>>, {
      canViewSensitiveFields: canViewPii,
    });

    const exportPayload =
      data.exportType === "csv" || data.exportType === "excel"
        ? toCsv(filteredRows)
        : JSON.stringify(filteredRows);

    await db.insert(exportHistory).values({
      userId: sessionUser.id,
      organizationId: scopedOrganizationId,
      reportId: null,
      exportType: data.exportType,
      dataSource: data.dataSource,
      filtersUsed: data.filters ?? {},
      rowCount: filteredRows.length,
      fileKey: null,
    });

    const { logExportEvent } = await import("~/lib/audit");
    await logExportEvent({
      action: "REPORT_EXPORT",
      actorUserId: sessionUser.id,
      metadata: {
        type: data.exportType,
        rows: filteredRows.length,
        organizationId: scopedOrganizationId,
        dataSource: data.dataSource,
      },
    });

    return { data: exportPayload };
  });
</file>

<file path="src/features/reports/reports.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import { z } from "zod";
import { zod$ } from "~/lib/server/fn-utils";

const listSavedReportsSchema = z
  .object({
    organizationId: z.uuid().optional(),
  })
  .nullish()
  .transform((value) => value ?? {});

export const listSavedReports = createServerFn({ method: "GET" })
  .inputValidator(zod$(listSavedReportsSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_analytics");
    const { getDb } = await import("~/db/server-helpers");
    const { savedReports } = await import("~/db/schema");
    const { eq, or } = await import("drizzle-orm");

    const db = await getDb();

    if (data.organizationId) {
      return db
        .select()
        .from(savedReports)
        .where(
          or(
            eq(savedReports.organizationId, data.organizationId),
            eq(savedReports.isOrgWide, true),
          ),
        );
    }

    return db.select().from(savedReports);
  });
</file>

<file path="src/lib/auth/guards/org-context.ts">
import { createMiddleware } from "@tanstack/react-start";

const getSessionUserId = async (headers: Headers) => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const auth = await getAuth();
  const session = await auth.api.getSession({ headers });
  return session?.user?.id ?? null;
};

const getCookieValue = (headers: Headers, name: string) => {
  const cookieHeader = headers.get("cookie");
  if (!cookieHeader) return null;
  const cookies = cookieHeader.split(";").map((entry) => entry.trim());
  const prefix = `${name}=`;
  for (const cookie of cookies) {
    if (cookie.startsWith(prefix)) {
      return decodeURIComponent(cookie.slice(prefix.length));
    }
  }
  return null;
};

export const orgContextMiddleware = createMiddleware({ type: "function" })
  .client(async ({ next }) => {
    const activeOrganizationId =
      typeof window === "undefined"
        ? undefined
        : window.localStorage.getItem("active_org_id") ?? undefined;
    return next({
      sendContext: {
        activeOrganizationId,
      },
    });
  })
  .server(async ({ next, context }) => {
    const { getRequest } = await import("@tanstack/react-start/server");
    const request = getRequest();
    const headers = request.headers;
    const userId = await getSessionUserId(headers);

    const contextOrgId = (context as { activeOrganizationId?: string } | undefined)
      ?.activeOrganizationId;
    const headerOrgId = headers.get("x-organization-id");
    const cookieOrgId = getCookieValue(headers, "active_org_id");
    const requestedOrgId = headerOrgId ?? contextOrgId ?? cookieOrgId ?? null;

    let resolvedOrgId: string | null = null;
    let resolvedRole: string | null = null;

    if (requestedOrgId && userId) {
      const { resolveOrganizationAccess } = await import(
        "~/features/organizations/organizations.access"
      );
      const access = await resolveOrganizationAccess({
        userId,
        organizationId: requestedOrgId,
      });
      if (access) {
        resolvedOrgId = access.organizationId;
        resolvedRole = access.role;
      }
    }

    return next({
      context: {
        ...(context as Record<string, unknown> | undefined),
        userId,
        organizationId: resolvedOrgId,
        organizationRole: resolvedRole,
      },
    });
  });
</file>

<file path="src/lib/auth/guards/org-guard.ts">
import { forbidden, unauthorized } from "~/lib/server/errors";

export type OrganizationRole = "owner" | "admin" | "reporter" | "viewer" | "member";

export const ORG_ADMIN_ROLES: OrganizationRole[] = ["owner", "admin"];

type MembershipLookup = {
  userId: string;
  organizationId: string;
};

export async function getOrganizationMembership({
  userId,
  organizationId,
}: MembershipLookup) {
  const { getDb } = await import("~/db/server-helpers");
  const { organizationMembers } = await import("~/db/schema");
  const { and, eq } = await import("drizzle-orm");

  const db = await getDb();
  const [membership] = await db
    .select()
    .from(organizationMembers)
    .where(
      and(
        eq(organizationMembers.userId, userId),
        eq(organizationMembers.organizationId, organizationId),
      ),
    )
    .limit(1);

  return membership ?? null;
}

export async function requireOrganizationMembership(
  { userId, organizationId }: MembershipLookup,
  options?: { roles?: OrganizationRole[]; allowPending?: boolean },
) {
  if (!userId) {
    throw unauthorized("User not authenticated");
  }

  const membership = await getOrganizationMembership({ userId, organizationId });

  if (!membership) {
    throw forbidden("Organization membership required");
  }

  if (!options?.allowPending && membership.status !== "active") {
    throw forbidden("Organization membership is not active");
  }

  if (options?.roles && !options.roles.includes(membership.role as OrganizationRole)) {
    throw forbidden("Insufficient organization role");
  }

  return membership;
}

export async function requireOrganizationAccess(
  { userId, organizationId }: MembershipLookup,
  options?: { roles?: OrganizationRole[] },
) {
  if (!userId) {
    throw unauthorized("User not authenticated");
  }

  const { resolveOrganizationAccess } = await import(
    "~/features/organizations/organizations.access"
  );
  const access = await resolveOrganizationAccess({ userId, organizationId });

  if (!access) {
    throw forbidden("Organization access required");
  }

  if (options?.roles && !options.roles.includes(access.role as OrganizationRole)) {
    throw forbidden("Insufficient organization role");
  }

  return access;
}
</file>

<file path="src/features/roles/permission.server.ts">
import { createServerOnlyFn } from "@tanstack/react-start";
import { and, eq, inArray } from "drizzle-orm";
import { roles, userRoles } from "~/db/schema";
import { getTenantConfig } from "~/tenant";

/**
 * Server-side permission service
 * All methods here use database queries and should only be called on the server
 */
export class PermissionService {
  /**
   * Check if a user has global admin permissions
   */
  static isGlobalAdmin = createServerOnlyFn(async (userId: string): Promise<boolean> => {
    const { getDb } = await import("~/db/server-helpers");
    const db = await getDb();
    const globalRoleNames = getTenantConfig().admin.globalRoleNames;

    const [row] = await db
      .select()
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(
        and(eq(userRoles.userId, userId), inArray(roles.name, globalRoleNames)),
      )
      .limit(1);

    return !!row;
  });

  /**
   * Check if a user can manage a specific team
   */
  static canManageTeam = createServerOnlyFn(
    async (userId: string, teamId: string): Promise<boolean> => {
      // Global admins can manage any team
      if (await PermissionService.isGlobalAdmin(userId)) return true;

      const { getDb } = await import("~/db/server-helpers");
      const db = await getDb();

      // Check for team-specific admin role
      const [row] = await db
        .select()
        .from(userRoles)
        .innerJoin(roles, eq(userRoles.roleId, roles.id))
        .where(
          and(
            eq(userRoles.userId, userId),
            eq(roles.name, "Team Admin"),
            eq(userRoles.teamId, teamId),
          ),
        )
        .limit(1);

      return !!row;
    },
  );

  /**
   * Check if a user can manage a specific event
   */
  static canManageEvent = createServerOnlyFn(
    async (userId: string, eventId: string): Promise<boolean> => {
      // Global admins can manage any event
      if (await PermissionService.isGlobalAdmin(userId)) return true;

      const { getDb } = await import("~/db/server-helpers");
      const db = await getDb();

      // Check for event-specific admin role
      const [row] = await db
        .select()
        .from(userRoles)
        .innerJoin(roles, eq(userRoles.roleId, roles.id))
        .where(
          and(
            eq(userRoles.userId, userId),
            eq(roles.name, "Event Admin"),
            eq(userRoles.eventId, eventId),
          ),
        )
        .limit(1);

      return !!row;
    },
  );

  /**
   * Get all roles for a user including scope information
   */
  static getUserRoles = createServerOnlyFn(async (userId: string) => {
    const { getDb } = await import("~/db/server-helpers");
    const db = await getDb();

    const userRolesList = await db
      .select({
        id: userRoles.id,
        userId: userRoles.userId,
        roleId: userRoles.roleId,
        teamId: userRoles.teamId,
        eventId: userRoles.eventId,
        assignedBy: userRoles.assignedBy,
        assignedAt: userRoles.assignedAt,
        expiresAt: userRoles.expiresAt,
        notes: userRoles.notes,
        role: {
          id: roles.id,
          name: roles.name,
          description: roles.description,
          permissions: roles.permissions,
        },
      })
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(eq(userRoles.userId, userId));

    return userRolesList;
  });
}
</file>

<file path="src/features/roles/permission.service.ts">
import { and, eq, inArray } from "drizzle-orm";
import { roles, userRoles } from "~/db/schema";
import { getTenantConfig } from "~/tenant";

const GLOBAL_ADMIN_ROLE_NAMES = getTenantConfig().admin.globalRoleNames;
const ANY_ADMIN_ROLE_NAMES = [...GLOBAL_ADMIN_ROLE_NAMES, "Team Admin", "Event Admin"];

export class PermissionService {
  /**
   * Check if a user has global admin permissions
   */
  static async isGlobalAdmin(userId: string): Promise<boolean> {
    const { db } = await import("~/db");
    const database = await db();
    const [row] = await database
      .select()
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(
        and(eq(userRoles.userId, userId), inArray(roles.name, GLOBAL_ADMIN_ROLE_NAMES)),
      )
      .limit(1);

    return !!row;
  }

  static async getGlobalAdminUserIds(): Promise<string[]> {
    const { db } = await import("~/db");
    const database = await db();
    const rows = await database
      .select({ userId: userRoles.userId })
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(inArray(roles.name, GLOBAL_ADMIN_ROLE_NAMES));

    return Array.from(new Set(rows.map((row) => row.userId)));
  }

  /**
   * Check if a user can manage a specific team
   */
  static async canManageTeam(userId: string, teamId: string): Promise<boolean> {
    // Global admins can manage any team
    if (await this.isGlobalAdmin(userId)) return true;

    // Check for team-specific admin role
    const { db } = await import("~/db");
    const database = await db();
    const [row] = await database
      .select()
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(
        and(
          eq(userRoles.userId, userId),
          eq(roles.name, "Team Admin"),
          eq(userRoles.teamId, teamId),
        ),
      )
      .limit(1);

    return !!row;
  }

  /**
   * Check if a user can manage a specific event
   */
  static async canManageEvent(userId: string, eventId: string): Promise<boolean> {
    // Global admins can manage any event
    if (await this.isGlobalAdmin(userId)) return true;

    // Check for event-specific admin role
    const { db } = await import("~/db");
    const database = await db();
    const [row] = await database
      .select()
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(
        and(
          eq(userRoles.userId, userId),
          eq(roles.name, "Event Admin"),
          eq(userRoles.eventId, eventId),
        ),
      )
      .limit(1);

    return !!row;
  }

  /**
   * Get all roles for a user including scope information
   */
  static async getUserRoles(userId: string) {
    const { db } = await import("~/db");
    const database = await db();
    const userRolesList = await database
      .select({
        id: userRoles.id,
        userId: userRoles.userId,
        roleId: userRoles.roleId,
        teamId: userRoles.teamId,
        eventId: userRoles.eventId,
        assignedBy: userRoles.assignedBy,
        assignedAt: userRoles.assignedAt,
        expiresAt: userRoles.expiresAt,
        notes: userRoles.notes,
        role: {
          id: roles.id,
          name: roles.name,
          description: roles.description,
          permissions: roles.permissions,
        },
      })
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(eq(userRoles.userId, userId));

    return userRolesList;
  }
}

/**
 * Client-side helper to check if a user has a specific role
 * This is for UI display purposes only - actual authorization happens server-side
 */
export function userHasRole(
  user: {
    roles?: Array<{
      role: { name: string };
      teamId?: string | null;
      eventId?: string | null;
    }>;
  },
  roleName: string,
  options?: { teamId?: string; eventId?: string },
): boolean {
  if (!user.roles) return false;

  return user.roles.some((userRole) => {
    if (userRole.role.name !== roleName) return false;

    // For global roles
    if (!options?.teamId && !options?.eventId) {
      return !userRole.teamId && !userRole.eventId;
    }

    // For team-specific roles
    if (options.teamId) {
      return userRole.teamId === options.teamId;
    }

    // For event-specific roles
    if (options.eventId) {
      return userRole.eventId === options.eventId;
    }

    return false;
  });
}

/**
 * Client-side helper to check if user is any kind of admin
 */
export function isAnyAdmin(user: { roles?: Array<{ role: { name: string } }> }): boolean {
  if (!user.roles) return false;

  return user.roles.some((userRole) => ANY_ADMIN_ROLE_NAMES.includes(userRole.role.name));
}
</file>

<file path="src/lib/server/errors.ts">
import { z } from "zod";

export const ServerErrorSchema = z.object({
  code: z.enum([
    "UNAUTHORIZED",
    "FORBIDDEN",
    "NOT_FOUND",
    "BAD_REQUEST",
    "VALIDATION",
    "INTERNAL",
  ]),
  message: z.string(),
  details: z.record(z.string(), z.unknown()).optional(),
});

export type ServerError = z.infer<typeof ServerErrorSchema>;

export class TypedServerError extends Error {
  public readonly error: ServerError;

  constructor(error: ServerError) {
    super(error.message);
    this.name = "TypedServerError";
    this.error = error;
  }
}

const createError = (
  code: ServerError["code"],
  message: string,
  details?: ServerError["details"],
) => new TypedServerError({ code, message, ...(details ? { details } : {}) });

export const unauthorized = (message = "Unauthorized") =>
  createError("UNAUTHORIZED", message);
export const forbidden = (message = "Forbidden") => createError("FORBIDDEN", message);
export const notFound = (message = "Resource not found") =>
  createError("NOT_FOUND", message);
export const badRequest = (message = "Bad request") =>
  createError("BAD_REQUEST", message);
export const validationError = (message: string, details?: ServerError["details"]) =>
  createError("VALIDATION", message, details);
export const internalError = (message = "Internal server error") =>
  createError("INTERNAL", message);

export const isTypedServerError = (error: unknown): error is TypedServerError =>
  error instanceof TypedServerError;
</file>

<file path="src/lib/auth/middleware/auth-guard.ts">
import { createMiddleware } from "@tanstack/react-start";
import type { AuthUser } from "~/lib/auth/types";
import { resolveRequestId } from "~/lib/server/request-id";

export type AuthedRequestContext = {
  user: NonNullable<AuthUser>;
  requestId: string;
  organizationId?: string | null;
  organizationRole?: string | null;
};

const getCookieValue = (headers: Headers, name: string) => {
  const cookieHeader = headers.get("cookie");
  if (!cookieHeader) return null;
  const cookies = cookieHeader.split(";").map((entry) => entry.trim());
  const prefix = `${name}=`;
  for (const cookie of cookies) {
    if (cookie.startsWith(prefix)) {
      return decodeURIComponent(cookie.slice(prefix.length));
    }
  }
  return null;
};

/**
 * Middleware to force authentication on a server function, and add the user to the context.
 */
export const authMiddleware = createMiddleware({ type: "function" }).server(
  async ({ next, context }) => {
    const { getRequest, setResponseHeader, setResponseStatus } =
      await import("@tanstack/react-start/server");
    const { getAuth } = await import("~/lib/auth/server-helpers");
    const auth = await getAuth();
    const request = getRequest();
    const headers = request.headers;

    const requestId =
      (context as { requestId?: string } | undefined)?.requestId ??
      resolveRequestId(headers);
    setResponseHeader("x-request-id", requestId);

    const session = await auth.api.getSession({
      headers,
      query: {
        disableCookieCache: true,
      },
    });

    const user = session?.user;

    if (!user) {
      setResponseStatus(401);
      const { unauthorized } = await import("~/lib/server/errors");
      throw unauthorized();
    }

    const { isAccountLocked } = await import("~/lib/security/lockout");
    const lock = await isAccountLocked(user.id);
    if (lock) {
      setResponseStatus(423);
      const { forbidden } = await import("~/lib/server/errors");
      throw forbidden("Account locked");
    }

    const authed: AuthedRequestContext = {
      user: user as NonNullable<AuthUser>,
      requestId,
    };

    const contextOrgId =
      (context as { organizationId?: string | null } | undefined)?.organizationId ??
      null;
    const contextOrgRole =
      (context as { organizationRole?: string | null } | undefined)?.organizationRole ??
      null;
    const headerOrgId = headers.get("x-organization-id");
    const cookieOrgId = getCookieValue(headers, "active_org_id");
    const requestedOrgId = headerOrgId ?? contextOrgId ?? cookieOrgId ?? null;

    if (requestedOrgId) {
      if (contextOrgId === requestedOrgId && contextOrgRole) {
        authed.organizationId = contextOrgId;
        authed.organizationRole = contextOrgRole;
      } else {
        const { resolveOrganizationAccess } = await import(
          "~/features/organizations/organizations.access"
        );
        const access = await resolveOrganizationAccess({
          userId: user.id,
          organizationId: requestedOrgId,
        });

        if (access) {
          authed.organizationId = access.organizationId;
          authed.organizationRole = access.role;
        }
      }
    }

    const mergedContext = {
      ...(context as Record<string, unknown> | undefined),
      ...authed,
    } as AuthedRequestContext;

    return next({ context: mergedContext });
  },
);
</file>

<file path="src/lib/auth/utils/admin-check.ts">
import { createServerOnlyFn } from "@tanstack/react-start";
import type { AuthUser } from "~/lib/auth/types";
import { getTenantConfig } from "~/tenant";

const GLOBAL_ADMIN_ROLE_NAMES = getTenantConfig().admin.globalRoleNames;

const getPermissionService = createServerOnlyFn(async () => {
  const { PermissionService } = await import("~/features/roles/permission.service");
  return PermissionService;
});

function hasGlobalAdminRole(user: AuthUser): boolean {
  if (!user?.roles || user.roles.length === 0) {
    return false;
  }

  return user.roles.some(({ role }) => GLOBAL_ADMIN_ROLE_NAMES.includes(role.name));
}

export async function isAdmin(userId: string | undefined | null): Promise<boolean> {
  if (!userId) return false;
  const PermissionService = await getPermissionService();
  return PermissionService.isGlobalAdmin(userId);
}

export async function requireAdmin(userId: string | undefined | null): Promise<void> {
  if (!(await isAdmin(userId))) {
    throw new Error("Unauthorized: Admin access required");
  }

  if (!userId) {
    throw new Error("Unauthorized: Admin access required");
  }

  const { getDb } = await import("~/db/server-helpers");
  const { user } = await import("~/db/schema");
  const { eq } = await import("drizzle-orm");
  const db = await getDb();
  const [record] = await db
    .select({ mfaRequired: user.mfaRequired, twoFactorEnabled: user.twoFactorEnabled })
    .from(user)
    .where(eq(user.id, userId))
    .limit(1);

  if (record?.mfaRequired && !record.twoFactorEnabled) {
    throw new Error("Multi-factor authentication required");
  }
}

export function isAdminClient(user: AuthUser): boolean {
  return hasGlobalAdminRole(user);
}

export { GLOBAL_ADMIN_ROLE_NAMES };
</file>

</files>
