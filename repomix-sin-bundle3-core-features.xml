This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/features/forms/**/*.ts, src/features/forms/**/*.tsx, src/features/imports/**/*.ts, src/features/imports/**/*.tsx, src/features/reporting/**/*.ts, src/features/reporting/**/*.tsx, src/features/reports/**/*.ts, src/features/reports/**/*.tsx
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<user_provided_header>
# Review Task: Core SIN Features Implementation

## Focus
Review **Forms, Imports, Reporting, and Reports** features for correctness, completeness, and alignment with SIN requirements.

## Key Questions
1. Are form definitions properly validated and versioned?
2. Is the import wizard handling both Lane 1 (interactive) and Lane 2 (batch) correctly?
3. Are reporting cycles and tasks properly scoped to organizations?
4. Is the report builder enforcing field-level ACL on exports?
5. Are all CRUD operations properly audit logged?

## Areas to Review
- Form builder: field types, validation, conditional logic, versioning
- Import wizard: mapping, validation preview, rollback capability
- Reporting: cycle management, task assignment, reminder scheduling
- Reports: saved reports, sharing, export with ACL

## Output Format
For each issue found:
1. **Feature**: Forms/Imports/Reporting/Reports
2. **Type**: Bug/Gap/Security/UX
3. **Location**: file:line
4. **Issue**: What's wrong or missing
5. **Impact**: How it affects users or compliance
6. **Fix**: Suggested remediation
</user_provided_header>

<directory_structure>
src/
  features/
    forms/
      components/
        form-builder-shell.tsx
      forms.mutations.ts
      forms.queries.ts
      forms.schemas.ts
      forms.utils.ts
    imports/
      components/
        import-wizard-shell.tsx
      imports.mutations.ts
      imports.queries.ts
      imports.schemas.ts
    reporting/
      components/
        reporting-dashboard-shell.tsx
      reporting.mutations.ts
      reporting.queries.ts
      reporting.schemas.ts
    reports/
      components/
        report-builder-shell.tsx
      reports.mutations.ts
      reports.queries.ts
      reports.schemas.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/features/forms/components/form-builder-shell.tsx">
import type { AnyFieldApi } from "@tanstack/react-form";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { useEffect, useMemo, useState } from "react";
import { FormSubmitButton } from "~/components/form-fields/FormSubmitButton";
import { ValidatedCheckbox } from "~/components/form-fields/ValidatedCheckbox";
import { ValidatedDatePicker } from "~/components/form-fields/ValidatedDatePicker";
import { ValidatedFileUpload } from "~/components/form-fields/ValidatedFileUpload";
import { ValidatedInput } from "~/components/form-fields/ValidatedInput";
import { ValidatedPhoneInput } from "~/components/form-fields/ValidatedPhoneInput";
import { ValidatedSelect } from "~/components/form-fields/ValidatedSelect";
import { Button } from "~/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";
import { Checkbox } from "~/components/ui/checkbox";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "~/components/ui/table";
import { Textarea } from "~/components/ui/textarea";
import { listOrganizations } from "~/features/organizations/organizations.queries";
import type { FieldComponentProps } from "~/lib/form";
import { useAppForm } from "~/lib/hooks/useAppForm";
import type { JsonRecord, JsonValue } from "~/shared/lib/json";
import {
  createForm,
  createFormUpload,
  publishForm,
  reviewFormSubmission,
  submitForm,
  updateForm,
} from "../forms.mutations";
import {
  getLatestFormVersion,
  getSubmissionFileDownloadUrl,
  listFormSubmissionVersions,
  listFormSubmissions,
  listForms,
  listSubmissionFiles,
} from "../forms.queries";
import type { FormDefinition } from "../forms.schemas";

const fieldTypeOptions = [
  { value: "text", label: "Text" },
  { value: "number", label: "Number" },
  { value: "email", label: "Email" },
  { value: "phone", label: "Phone" },
  { value: "date", label: "Date" },
  { value: "select", label: "Select" },
  { value: "multiselect", label: "Multi-select" },
  { value: "checkbox", label: "Checkbox" },
  { value: "file", label: "File" },
  { value: "textarea", label: "Textarea" },
  { value: "rich_text", label: "Rich text" },
];

const validationTypes = [
  { value: "", label: "None" },
  { value: "min_length", label: "Min length" },
  { value: "max_length", label: "Max length" },
  { value: "pattern", label: "Regex pattern" },
  { value: "min", label: "Min value" },
  { value: "max", label: "Max value" },
];

const conditionalOperators = [
  { value: "equals", label: "Equals" },
  { value: "not_equals", label: "Not equals" },
  { value: "contains", label: "Contains" },
  { value: "greater_than", label: "Greater than" },
];

const reviewStatusOptions = [
  { value: "under_review", label: "Under review" },
  { value: "changes_requested", label: "Changes requested" },
  { value: "approved", label: "Approved" },
  { value: "rejected", label: "Rejected" },
];

const slugify = (value: string) =>
  value
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/(^-|-$)+/g, "");

const formatPayloadValue = (value: JsonValue) => {
  if (value === null || value === undefined) return "-";
  if (typeof value === "string") return value;
  if (typeof value === "number" || typeof value === "boolean") {
    return String(value);
  }
  return JSON.stringify(value);
};

type FormValues = Record<string, JsonValue>;

type FieldDraft = {
  key: string;
  label: string;
  type: string;
  description: string;
  placeholder: string;
  required: boolean;
  optionsText: string;
  validationType: string;
  validationValue: string;
  validationMessage: string;
  conditionalField: string;
  conditionalOperator: string;
  conditionalValue: string;
  fileTypes: string;
  maxSizeMb: string;
  maxFiles: string;
};

type ValidationRuleType = NonNullable<
  FormDefinition["fields"][number]["validation"]
>[number]["type"];

type ConditionalOperator = NonNullable<
  FormDefinition["fields"][number]["conditional"]
>["operator"];

const emptyFieldDraft: FieldDraft = {
  key: "",
  label: "",
  type: "text",
  description: "",
  placeholder: "",
  required: false,
  optionsText: "",
  validationType: "",
  validationValue: "",
  validationMessage: "",
  conditionalField: "",
  conditionalOperator: "equals",
  conditionalValue: "",
  fileTypes: "",
  maxSizeMb: "5",
  maxFiles: "1",
};

const defaultSettings: FormDefinition["settings"] = {
  allowDraft: true,
  requireApproval: false,
  notifyOnSubmit: [],
};

const hashFile = async (file: File) => {
  const buffer = await file.arrayBuffer();
  const hashBuffer = await crypto.subtle.digest("SHA-256", buffer);
  return Array.from(new Uint8Array(hashBuffer))
    .map((byte) => byte.toString(16).padStart(2, "0"))
    .join("");
};

function TextareaField({ field, label, placeholder }: FieldComponentProps) {
  const inputId = `${field.name}-textarea`;
  const meta = field.state.meta;

  return (
    <div className="space-y-2">
      <Label htmlFor={inputId}>{label}</Label>
      <Textarea
        id={inputId}
        value={(field.state.value as string | undefined) ?? ""}
        placeholder={placeholder}
        onBlur={field.handleBlur}
        onChange={(event) => field.handleChange(event.target.value)}
        aria-invalid={meta.errors.length > 0}
      />
      {meta.isTouched && meta.errors.length > 0 && (
        <div className="text-destructive text-sm font-medium">
          {meta.errors.join(", ")}
        </div>
      )}
    </div>
  );
}

function MultiSelectField({
  field,
  label,
  options,
}: FieldComponentProps & {
  options: Array<{ value: string; label: string }>;
}) {
  const meta = field.state.meta;
  const selected = Array.isArray(field.state.value)
    ? (field.state.value as string[])
    : [];

  const toggle = (value: string) => {
    if (selected.includes(value)) {
      field.handleChange(selected.filter((item) => item !== value));
    } else {
      field.handleChange([...selected, value]);
    }
  };

  return (
    <div className="space-y-2">
      <Label>{label}</Label>
      <div className="grid gap-2 md:grid-cols-2">
        {options.map((option) => (
          <div key={option.value} className="flex items-center gap-2 text-sm">
            <Checkbox
              id={`${field.name}-${option.value}`}
              checked={selected.includes(option.value)}
              onCheckedChange={() => toggle(option.value)}
            />
            <Label htmlFor={`${field.name}-${option.value}`}>{option.label}</Label>
          </div>
        ))}
      </div>
      {meta.isTouched && meta.errors.length > 0 && (
        <div className="text-destructive text-sm font-medium">
          {meta.errors.join(", ")}
        </div>
      )}
    </div>
  );
}

function evaluateCondition(
  condition: NonNullable<FormDefinition["fields"][number]["conditional"]>,
  values: Record<string, JsonValue>,
) {
  const left = values[condition.field];
  const right = condition.value;

  if (condition.operator === "equals") {
    return left === right;
  }

  if (condition.operator === "not_equals") {
    return left !== right;
  }

  if (condition.operator === "contains") {
    if (Array.isArray(left)) {
      return left.includes(right as never);
    }
    if (typeof left === "string") {
      return left.includes(String(right));
    }
    return false;
  }

  if (condition.operator === "greater_than") {
    return Number(left) > Number(right);
  }

  return true;
}

function buildDefaultValues(definition: FormDefinition) {
  const values: Record<string, JsonValue> = {};
  definition.fields.forEach((field) => {
    if (field.type === "checkbox") {
      values[field.key] = false;
      return;
    }
    if (field.type === "multiselect") {
      values[field.key] = [];
      return;
    }
    if (field.type === "file") {
      values[field.key] = null;
      return;
    }
    values[field.key] = "";
  });
  return values;
}

async function normalizePayload(
  definition: FormDefinition,
  values: Record<string, JsonValue>,
  formId: string,
) {
  const payload: JsonRecord = {};

  definition.fields.forEach((field) => {
    if (field.conditional && !evaluateCondition(field.conditional, values)) {
      return;
    }

    const value = values[field.key];

    if (field.type === "number") {
      payload[field.key] = value === "" ? null : Number(value);
      return;
    }

    if (field.type === "file") {
      payload[field.key] = value ?? null;
      return;
    }

    payload[field.key] = value ?? null;
  });

  for (const field of definition.fields) {
    if (field.type !== "file") continue;
    if (field.conditional && !evaluateCondition(field.conditional, values)) {
      continue;
    }

    const value = values[field.key];
    if (!(value instanceof File)) {
      if (value) {
        payload[field.key] = value;
      }
      continue;
    }

    const checksum = await hashFile(value);
    const upload = await createFormUpload({
      data: {
        formId,
        fieldKey: field.key,
        fileName: value.name,
        mimeType: value.type || "application/octet-stream",
        sizeBytes: value.size,
      },
    });

    if (!upload?.uploadUrl || !upload.storageKey) {
      throw new Error("Upload URL not available.");
    }

    const response = await fetch(upload.uploadUrl, {
      method: "PUT",
      body: value,
      headers: {
        "Content-Type": value.type || "application/octet-stream",
      },
    });

    if (!response.ok) {
      throw new Error("Failed to upload file.");
    }

    payload[field.key] = {
      storageKey: upload.storageKey,
      fileName: value.name,
      mimeType: value.type || "application/octet-stream",
      sizeBytes: value.size,
      checksum,
    };
  }

  return payload;
}

export function DynamicFormRenderer(props: {
  formId: string;
  organizationId: string | null;
  definition: FormDefinition;
}) {
  const { formId, organizationId, definition } = props;
  const [submitMode, setSubmitMode] = useState<"draft" | "submitted">("submitted");
  const [submitError, setSubmitError] = useState<string | null>(null);

  const defaultValues = useMemo(() => buildDefaultValues(definition), [definition]);

  const form = useAppForm<Record<string, unknown>>({
    defaultValues: defaultValues as Record<string, unknown>,
    onSubmit: async ({ value }) => {
      setSubmitError(null);
      if (!organizationId) {
        setSubmitError("Organization is required to submit this form.");
        return;
      }

      try {
        const payload = await normalizePayload(definition, value as FormValues, formId);
        const result = await submitForm({
          data: {
            formId,
            organizationId,
            payload,
            status: submitMode,
          },
        });
        if (result && "error" in result && result.error) {
          setSubmitError(result.error);
        }
      } catch (error) {
        setSubmitError(error instanceof Error ? error.message : "Failed to submit form.");
      }
    },
  });

  useEffect(() => {
    form.reset(defaultValues);
  }, [defaultValues, form]);

  return (
    <form
      onSubmit={(event) => {
        event.preventDefault();
        void form.handleSubmit();
      }}
      className="space-y-4"
    >
      {definition.fields.map((field) => {
        const options = field.options ?? [];
        return (
          <form.Field
            key={field.key}
            name={field.key}
            validators={{
              onChangeListenTo: field.conditional ? [field.conditional.field] : [],
              onChange: ({
                value,
                fieldApi,
              }: {
                value: unknown;
                fieldApi: AnyFieldApi;
              }) => {
                const values = fieldApi.form.state.values as Record<string, JsonValue>;
                if (field.conditional) {
                  const isVisible = evaluateCondition(field.conditional, values);
                  if (!isVisible) return undefined;
                }

                const isEmpty =
                  value === null ||
                  value === undefined ||
                  (typeof value === "string" && value.trim() === "") ||
                  (Array.isArray(value) && value.length === 0);

                if (field.required && isEmpty) {
                  return "This field is required";
                }

                if (field.validation && !isEmpty) {
                  for (const rule of field.validation) {
                    if (rule.type === "min_length" && typeof value === "string") {
                      if (value.length < Number(rule.value)) return rule.message;
                    }
                    if (rule.type === "max_length" && typeof value === "string") {
                      if (value.length > Number(rule.value)) return rule.message;
                    }
                    if (rule.type === "min" && typeof value === "number") {
                      if (value < Number(rule.value)) return rule.message;
                    }
                    if (rule.type === "max" && typeof value === "number") {
                      if (value > Number(rule.value)) return rule.message;
                    }
                    if (rule.type === "pattern" && typeof value === "string") {
                      const regex = new RegExp(String(rule.value));
                      if (!regex.test(value)) return rule.message;
                    }
                  }
                }

                return undefined;
              },
            }}
          >
            {(fieldApi: AnyFieldApi) => {
              const values = fieldApi.form.state.values as Record<string, JsonValue>;
              if (field.conditional && !evaluateCondition(field.conditional, values)) {
                return null;
              }

              if (field.type === "checkbox") {
                const descriptionProps = field.description
                  ? { description: field.description }
                  : {};
                return (
                  <ValidatedCheckbox
                    field={fieldApi}
                    label={field.label}
                    {...descriptionProps}
                  />
                );
              }

              if (field.type === "date") {
                return <ValidatedDatePicker field={fieldApi} label={field.label} />;
              }

              if (field.type === "phone") {
                return <ValidatedPhoneInput field={fieldApi} label={field.label} />;
              }

              if (field.type === "file") {
                const accept = field.fileConfig?.allowedTypes?.join(",");
                const maxSizeMb = field.fileConfig?.maxSizeBytes
                  ? field.fileConfig.maxSizeBytes / (1024 * 1024)
                  : undefined;
                return (
                  <ValidatedFileUpload
                    field={fieldApi}
                    label={field.label}
                    {...(accept ? { accept } : {})}
                    {...(maxSizeMb ? { maxSizeMb } : {})}
                  />
                );
              }

              if (field.type === "select") {
                const placeholderText = field.placeholder
                  ? { placeholderText: field.placeholder }
                  : {};
                return (
                  <ValidatedSelect
                    field={fieldApi}
                    label={field.label}
                    options={options}
                    {...placeholderText}
                  />
                );
              }

              if (field.type === "multiselect") {
                return (
                  <MultiSelectField
                    field={fieldApi}
                    label={field.label}
                    options={options}
                  />
                );
              }

              if (field.type === "textarea" || field.type === "rich_text") {
                const placeholderProps = field.placeholder
                  ? { placeholder: field.placeholder }
                  : {};
                return (
                  <TextareaField
                    field={fieldApi}
                    label={field.label}
                    {...placeholderProps}
                  />
                );
              }

              if (field.type === "number") {
                const placeholderProps = field.placeholder
                  ? { placeholder: field.placeholder }
                  : {};
                return (
                  <ValidatedInput
                    field={fieldApi}
                    label={field.label}
                    type="number"
                    {...placeholderProps}
                    onValueChange={(value) =>
                      fieldApi.handleChange(value === "" ? "" : Number(value))
                    }
                  />
                );
              }

              const placeholderProps = field.placeholder
                ? { placeholder: field.placeholder }
                : {};
              return (
                <ValidatedInput
                  field={fieldApi}
                  label={field.label}
                  type={field.type === "email" ? "email" : "text"}
                  {...placeholderProps}
                />
              );
            }}
          </form.Field>
        );
      })}

      <div className="flex flex-wrap gap-3">
        {definition.settings.allowDraft && (
          <FormSubmitButton
            type="button"
            variant="outline"
            onClick={() => {
              setSubmitMode("draft");
              void form.handleSubmit();
            }}
          >
            Save draft
          </FormSubmitButton>
        )}
        <FormSubmitButton
          onClick={() => setSubmitMode("submitted")}
          isSubmitting={form.state.isSubmitting}
        >
          Submit
        </FormSubmitButton>
      </div>
      {submitError ? (
        <p className="text-destructive text-sm font-medium">{submitError}</p>
      ) : null}
    </form>
  );
}

export function FormBuilderShell() {
  const queryClient = useQueryClient();
  const [slugDirty, setSlugDirty] = useState(false);
  const [selectedFormId, setSelectedFormId] = useState<string | null>(null);
  const [selectedFieldKey, setSelectedFieldKey] = useState<string | null>(null);
  const [fieldError, setFieldError] = useState<string | null>(null);
  const [settings, setSettings] = useState<FormDefinition["settings"]>(defaultSettings);
  const [fields, setFields] = useState<FormDefinition["fields"]>([]);
  const [selectedSubmissionId, setSelectedSubmissionId] = useState<string | null>(null);

  const { data: organizations = [] } = useQuery({
    queryKey: ["organizations", "list"],
    queryFn: () => listOrganizations({ data: { includeArchived: true } }),
  });

  const { data: forms = [] } = useQuery({
    queryKey: ["forms", "list"],
    queryFn: () => listForms({ data: {} }),
  });

  const { data: latestVersion } = useQuery({
    queryKey: ["forms", "latest", selectedFormId],
    queryFn: () =>
      selectedFormId ? getLatestFormVersion({ data: { formId: selectedFormId } }) : null,
    enabled: Boolean(selectedFormId),
  });

  const { data: submissions = [] } = useQuery({
    queryKey: ["forms", "submissions", selectedFormId],
    queryFn: () =>
      selectedFormId ? listFormSubmissions({ data: { formId: selectedFormId } }) : [],
    enabled: Boolean(selectedFormId),
  });

  const { data: submissionVersions = [] } = useQuery({
    queryKey: ["forms", "submission-versions", selectedSubmissionId],
    queryFn: () =>
      selectedSubmissionId
        ? listFormSubmissionVersions({ data: { submissionId: selectedSubmissionId } })
        : [],
    enabled: Boolean(selectedSubmissionId),
  });

  const { data: submissionFiles = [] } = useQuery({
    queryKey: ["forms", "submission-files", selectedSubmissionId],
    queryFn: () =>
      selectedSubmissionId
        ? listSubmissionFiles({ data: { submissionId: selectedSubmissionId } })
        : [],
    enabled: Boolean(selectedSubmissionId),
  });

  const selectedSubmission = useMemo(
    () =>
      submissions.find((submission) => submission.id === selectedSubmissionId) ?? null,
    [submissions, selectedSubmissionId],
  );

  const submissionPayloadEntries = useMemo(() => {
    if (!selectedSubmission?.payload) return [];
    return Object.entries(selectedSubmission.payload as Record<string, JsonValue>);
  }, [selectedSubmission]);

  const downloadMutation = useMutation({
    mutationFn: (submissionFileId: string) =>
      getSubmissionFileDownloadUrl({ data: { submissionFileId } }),
    onSuccess: (result) => {
      if (result?.url) {
        window.open(result.url, "_blank", "noopener,noreferrer");
      }
    },
  });

  const reviewMutation = useMutation({
    mutationFn: (payload: {
      submissionId: string;
      status: string;
      reviewNotes?: string;
    }) =>
      reviewFormSubmission({
        data: {
          submissionId: payload.submissionId,
          status: payload.status as
            | "under_review"
            | "changes_requested"
            | "approved"
            | "rejected",
          reviewNotes: payload.reviewNotes,
        },
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: ["forms", "submissions"] });
      void queryClient.invalidateQueries({ queryKey: ["forms", "submission-versions"] });
    },
  });

  useEffect(() => {
    if (!latestVersion?.definition) return;
    const definition = latestVersion.definition as FormDefinition;
    // eslint-disable-next-line @eslint-react/hooks-extra/no-direct-set-state-in-use-effect
    setFields(definition.fields ?? []);
    // eslint-disable-next-line @eslint-react/hooks-extra/no-direct-set-state-in-use-effect
    setSettings(definition.settings ?? defaultSettings);
  }, [latestVersion]);

  const createMutation = useMutation({
    mutationFn: async (values: {
      name: string;
      slug: string;
      description?: string;
      organizationId?: string;
    }) =>
      createForm({
        data: {
          name: values.name,
          slug: values.slug,
          description: values.description,
          organizationId: values.organizationId || undefined,
        },
      }),
    onSuccess: (created) => {
      if (created?.id) {
        setSelectedFormId(created.id);
        setFields([]);
        setSettings(defaultSettings);
        setSelectedFieldKey(null);
        setFieldError(null);
        void queryClient.invalidateQueries({ queryKey: ["forms"] });
      }
    },
  });

  const updateMutation = useMutation({
    mutationFn: (payload: { formId: string; data: { name?: string; slug?: string } }) =>
      updateForm({ data: payload }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: ["forms"] });
    },
  });

  const publishMutation = useMutation({
    mutationFn: async () => {
      if (!selectedFormId) return null;
      const definition: FormDefinition = {
        fields,
        settings,
      };
      return publishForm({ data: { formId: selectedFormId, definition } });
    },
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: ["forms"] });
      void queryClient.invalidateQueries({ queryKey: ["forms", "latest"] });
    },
  });

  const createFormForm = useAppForm({
    defaultValues: {
      name: "",
      slug: "",
      description: "",
      organizationId: "",
    },
    onSubmit: async ({ value }) => {
      await createMutation.mutateAsync(value);
    },
  });

  const fieldForm = useAppForm<FieldDraft>({
    defaultValues: emptyFieldDraft,
    onSubmit: async ({ value }) => {
      setFieldError(null);
      const trimmedKey = value.key.trim();
      if (!trimmedKey) {
        setFieldError("Field key is required.");
        return;
      }

      const existing = fields.find((field) => field.key === trimmedKey);
      if (existing && selectedFieldKey !== trimmedKey) {
        setFieldError("Field key must be unique.");
        return;
      }

      const options = value.optionsText
        .split(",")
        .map((item) => item.trim())
        .filter(Boolean)
        .map((item) => ({ value: item, label: item }));

      const validation = value.validationType
        ? [
            {
              type: value.validationType as ValidationRuleType,
              value: value.validationValue,
              message: value.validationMessage || "Invalid value",
            },
          ]
        : undefined;

      const conditional = value.conditionalField
        ? {
            field: value.conditionalField,
            operator: value.conditionalOperator as ConditionalOperator,
            value: value.conditionalValue,
          }
        : undefined;

      const fileConfig = value.fileTypes
        ? {
            allowedTypes: value.fileTypes
              .split(",")
              .map((item) => item.trim())
              .filter(Boolean),
            maxSizeBytes: Math.max(1, Number(value.maxSizeMb || 5)) * 1024 * 1024,
            maxFiles: Math.max(1, Number(value.maxFiles || 1)),
          }
        : undefined;

      const nextField: FormDefinition["fields"][number] = {
        key: trimmedKey,
        type: value.type as FormDefinition["fields"][number]["type"],
        label: value.label,
        description: value.description || undefined,
        placeholder: value.placeholder || undefined,
        required: value.required,
        ...(validation ? { validation } : {}),
        ...(options.length ? { options } : {}),
        ...(conditional ? { conditional } : {}),
        ...(fileConfig ? { fileConfig } : {}),
      };

      setFields((prev) => {
        const without = prev.filter((field) => field.key !== trimmedKey);
        return [...without, nextField];
      });

      fieldForm.reset(emptyFieldDraft);
      setSelectedFieldKey(null);
    },
  });

  const reviewForm = useAppForm({
    defaultValues: {
      status: "under_review",
      reviewNotes: "",
    },
    onSubmit: async ({ value }) => {
      if (!selectedSubmissionId) return;
      const payload: { submissionId: string; status: string; reviewNotes?: string } = {
        submissionId: selectedSubmissionId,
        status: value.status,
      };
      if (value.reviewNotes.trim()) {
        payload.reviewNotes = value.reviewNotes.trim();
      }
      await reviewMutation.mutateAsync(payload);
    },
  });

  const prefillFieldDraft = (type: string) => {
    const label = fieldTypeOptions.find((option) => option.value === type)?.label ?? type;
    const keyBase = slugify(label).replace(/-/g, "_");
    setFieldError(null);
    setSelectedFieldKey(null);
    fieldForm.reset({
      ...emptyFieldDraft,
      type,
      label,
      key: keyBase,
    });
  };

  useEffect(() => {
    if (!selectedFieldKey) {
      fieldForm.reset(emptyFieldDraft);
      return;
    }
    const selected = fields.find((field) => field.key === selectedFieldKey);
    if (!selected) return;

    const draft: FieldDraft = {
      key: selected.key,
      label: selected.label,
      type: selected.type,
      description: selected.description ?? "",
      placeholder: selected.placeholder ?? "",
      required: selected.required,
      optionsText: selected.options?.map((item) => item.value).join(", ") ?? "",
      validationType: selected.validation?.[0]?.type ?? "",
      validationValue: selected.validation?.[0]?.value?.toString() ?? "",
      validationMessage: selected.validation?.[0]?.message ?? "",
      conditionalField: selected.conditional?.field ?? "",
      conditionalOperator: selected.conditional?.operator ?? "equals",
      conditionalValue: selected.conditional?.value?.toString() ?? "",
      fileTypes: selected.fileConfig?.allowedTypes?.join(", ") ?? "",
      maxSizeMb: selected.fileConfig?.maxSizeBytes
        ? String(Math.round(selected.fileConfig.maxSizeBytes / (1024 * 1024)))
        : "5",
      maxFiles: selected.fileConfig?.maxFiles?.toString() ?? "1",
    };

    fieldForm.reset(draft);
  }, [fieldForm, fields, selectedFieldKey]);

  useEffect(() => {
    if (!selectedSubmission) {
      reviewForm.reset({ status: "under_review", reviewNotes: "" });
      return;
    }

    const normalizedStatus = reviewStatusOptions.some(
      (option) => option.value === selectedSubmission.status,
    )
      ? selectedSubmission.status
      : "under_review";

    reviewForm.reset({
      status: normalizedStatus,
      reviewNotes: selectedSubmission.reviewNotes ?? "",
    });
  }, [reviewForm, selectedSubmission]);

  const definition = useMemo<FormDefinition>(
    () => ({
      fields,
      settings,
    }),
    [fields, settings],
  );

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Create form</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <form
            onSubmit={(event) => {
              event.preventDefault();
              void createFormForm.handleSubmit();
            }}
            className="space-y-4"
          >
            <div className="grid gap-3 md:grid-cols-2">
              <createFormForm.Field
                name="name"
                validators={{
                  onChange: ({ value }) => (!value ? "Name is required" : undefined),
                }}
              >
                {(field) => (
                  <ValidatedInput
                    field={field}
                    label="Form name"
                    placeholder="Annual report"
                    onValueChange={(value) => {
                      field.handleChange(value);
                      if (!slugDirty) {
                        createFormForm.setFieldValue("slug", slugify(value));
                      }
                    }}
                  />
                )}
              </createFormForm.Field>
              <createFormForm.Field
                name="slug"
                validators={{
                  onChange: ({ value }) => (!value ? "Slug is required" : undefined),
                }}
              >
                {(field) => (
                  <ValidatedInput
                    field={field}
                    label="Slug"
                    placeholder="annual-report"
                    onValueChange={(value) => {
                      setSlugDirty(true);
                      field.handleChange(value);
                    }}
                  />
                )}
              </createFormForm.Field>
            </div>
            <createFormForm.Field name="description">
              {(field) => (
                <TextareaField
                  field={field}
                  label="Description"
                  placeholder="Short summary for admins"
                />
              )}
            </createFormForm.Field>
            <createFormForm.Field name="organizationId">
              {(field) => (
                <ValidatedSelect
                  field={field}
                  label="Organization"
                  options={organizations.map((org) => ({
                    value: org.id,
                    label: org.name,
                  }))}
                  placeholderText="Optional"
                />
              )}
            </createFormForm.Field>
            <Button type="submit" disabled={createMutation.isPending}>
              {createMutation.isPending ? "Creating..." : "Create form"}
            </Button>
          </form>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Existing forms</CardTitle>
        </CardHeader>
        <CardContent className="space-y-2">
          {forms.length === 0 ? (
            <p className="text-muted-foreground text-sm">No forms yet.</p>
          ) : (
            forms.map((form) => (
              <Button
                key={form.id}
                type="button"
                variant="outline"
                className={`h-auto w-full items-start justify-between gap-4 px-3 py-2 text-left whitespace-normal ${
                  selectedFormId === form.id
                    ? "border-primary bg-primary/10"
                    : "border-input"
                }`}
                onClick={() => {
                  setSelectedFormId(form.id);
                  setSelectedFieldKey(null);
                  setSelectedSubmissionId(null);
                }}
              >
                <div>
                  <p className="font-semibold">{form.name}</p>
                  <p className="text-muted-foreground text-xs">
                    {form.slug} Â· {form.status}
                  </p>
                </div>
                <span className="text-muted-foreground text-xs">
                  {form.organizationId ? "Org" : "Global"}
                </span>
              </Button>
            ))
          )}
        </CardContent>
      </Card>

      {selectedFormId ? (
        <div className="grid gap-6 lg:grid-cols-3">
          <Card>
            <CardHeader>
              <CardTitle>Field palette</CardTitle>
            </CardHeader>
            <CardContent className="space-y-3">
              <div className="grid gap-2 sm:grid-cols-2 lg:grid-cols-1">
                {fieldTypeOptions.map((option) => (
                  <Button
                    key={option.value}
                    type="button"
                    variant="outline"
                    draggable
                    className="justify-start"
                    onClick={() => prefillFieldDraft(option.value)}
                    onDragStart={(event) => {
                      event.dataTransfer.setData("text/plain", option.value);
                      event.dataTransfer.effectAllowed = "copy";
                    }}
                  >
                    {option.label}
                  </Button>
                ))}
              </div>
              <p className="text-muted-foreground text-xs">
                Drag a field type into the configuration panel to prefill settings.
              </p>
            </CardContent>
          </Card>

          <Card className="lg:col-span-2">
            <CardHeader>
              <CardTitle>Field configuration</CardTitle>
            </CardHeader>
            <CardContent className="space-y-3">
              <form
                onSubmit={(event) => {
                  event.preventDefault();
                  void fieldForm.handleSubmit();
                }}
                onDragOver={(event) => event.preventDefault()}
                onDrop={(event) => {
                  event.preventDefault();
                  const droppedType = event.dataTransfer.getData("text/plain");
                  if (droppedType) {
                    prefillFieldDraft(droppedType);
                  }
                }}
                className="space-y-4"
              >
                <div className="grid gap-3 md:grid-cols-2">
                  <fieldForm.Field
                    name="key"
                    validators={{
                      onChange: ({ value }) =>
                        !value ? "Field key is required" : undefined,
                    }}
                  >
                    {(field) => (
                      <ValidatedInput
                        field={field}
                        label="Key"
                        placeholder="report_title"
                      />
                    )}
                  </fieldForm.Field>
                  <fieldForm.Field name="label">
                    {(field) => (
                      <ValidatedInput
                        field={field}
                        label="Label"
                        placeholder="Report title"
                      />
                    )}
                  </fieldForm.Field>
                </div>
                <div className="grid gap-3 md:grid-cols-2">
                  <fieldForm.Field name="type">
                    {(field) => (
                      <ValidatedSelect
                        field={field}
                        label="Type"
                        options={fieldTypeOptions}
                        placeholderText="Select type"
                      />
                    )}
                  </fieldForm.Field>
                  <fieldForm.Field name="placeholder">
                    {(field) => (
                      <ValidatedInput
                        field={field}
                        label="Placeholder"
                        placeholder="Optional placeholder"
                      />
                    )}
                  </fieldForm.Field>
                </div>
                <fieldForm.Field name="description">
                  {(field) => (
                    <TextareaField
                      field={field}
                      label="Description"
                      placeholder="Optional helper text"
                    />
                  )}
                </fieldForm.Field>
                <fieldForm.Field name="required">
                  {(field) => (
                    <ValidatedCheckbox
                      field={field}
                      label="Required field"
                      description="Submission cannot be completed without this value."
                    />
                  )}
                </fieldForm.Field>

                <fieldForm.Field name="optionsText">
                  {(field) => (
                    <TextareaField
                      field={field}
                      label="Options"
                      placeholder="Comma-separated values for select fields"
                    />
                  )}
                </fieldForm.Field>

                <div className="grid gap-3 md:grid-cols-3">
                  <fieldForm.Field name="validationType">
                    {(field) => (
                      <ValidatedSelect
                        field={field}
                        label="Validation rule"
                        options={validationTypes}
                        placeholderText="None"
                      />
                    )}
                  </fieldForm.Field>
                  <fieldForm.Field name="validationValue">
                    {(field) => (
                      <ValidatedInput
                        field={field}
                        label="Validation value"
                        placeholder="10"
                      />
                    )}
                  </fieldForm.Field>
                  <fieldForm.Field name="validationMessage">
                    {(field) => (
                      <ValidatedInput
                        field={field}
                        label="Validation message"
                        placeholder="Explain the rule"
                      />
                    )}
                  </fieldForm.Field>
                </div>

                <div className="grid gap-3 md:grid-cols-3">
                  <fieldForm.Field name="conditionalField">
                    {(field) => (
                      <ValidatedSelect
                        field={field}
                        label="Conditional field"
                        options={fields.map((item) => ({
                          value: item.key,
                          label: item.label,
                        }))}
                        placeholderText="None"
                      />
                    )}
                  </fieldForm.Field>
                  <fieldForm.Field name="conditionalOperator">
                    {(field) => (
                      <ValidatedSelect
                        field={field}
                        label="Operator"
                        options={conditionalOperators}
                        placeholderText="Equals"
                      />
                    )}
                  </fieldForm.Field>
                  <fieldForm.Field name="conditionalValue">
                    {(field) => (
                      <ValidatedInput
                        field={field}
                        label="Value"
                        placeholder="Match value"
                      />
                    )}
                  </fieldForm.Field>
                </div>

                <div className="grid gap-3 md:grid-cols-3">
                  <fieldForm.Field name="fileTypes">
                    {(field) => (
                      <ValidatedInput
                        field={field}
                        label="File types"
                        placeholder="image/*,application/pdf"
                      />
                    )}
                  </fieldForm.Field>
                  <fieldForm.Field name="maxSizeMb">
                    {(field) => (
                      <ValidatedInput
                        field={field}
                        label="Max size (MB)"
                        placeholder="5"
                        type="number"
                      />
                    )}
                  </fieldForm.Field>
                  <fieldForm.Field name="maxFiles">
                    {(field) => (
                      <ValidatedInput
                        field={field}
                        label="Max files"
                        placeholder="1"
                        type="number"
                      />
                    )}
                  </fieldForm.Field>
                </div>

                {fieldError && (
                  <p className="text-destructive text-sm font-medium">{fieldError}</p>
                )}

                <Button type="submit">
                  {selectedFieldKey ? "Update field" : "Add field"}
                </Button>
              </form>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle>Fields</CardTitle>
            </CardHeader>
            <CardContent>
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>Key</TableHead>
                    <TableHead>Label</TableHead>
                    <TableHead>Type</TableHead>
                    <TableHead>Actions</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {fields.length === 0 ? (
                    <TableRow>
                      <TableCell colSpan={4} className="text-center text-sm">
                        No fields yet.
                      </TableCell>
                    </TableRow>
                  ) : (
                    fields
                      .slice()
                      .sort((a, b) => a.key.localeCompare(b.key))
                      .map((field) => (
                        <TableRow key={field.key}>
                          <TableCell className="text-xs">{field.key}</TableCell>
                          <TableCell className="text-xs">{field.label}</TableCell>
                          <TableCell className="text-xs">{field.type}</TableCell>
                          <TableCell className="space-x-2">
                            <Button
                              type="button"
                              size="sm"
                              variant="outline"
                              onClick={() => setSelectedFieldKey(field.key)}
                            >
                              Edit
                            </Button>
                            <Button
                              type="button"
                              size="sm"
                              variant="ghost"
                              onClick={() => {
                                setFields((prev) =>
                                  prev.filter((item) => item.key !== field.key),
                                );
                                if (selectedFieldKey === field.key) {
                                  setSelectedFieldKey(null);
                                }
                              }}
                            >
                              Remove
                            </Button>
                          </TableCell>
                        </TableRow>
                      ))
                  )}
                </TableBody>
              </Table>
            </CardContent>
          </Card>
        </div>
      ) : null}

      {selectedFormId ? (
        <Card>
          <CardHeader>
            <CardTitle>Form settings</CardTitle>
          </CardHeader>
          <CardContent className="space-y-3">
            <div className="flex items-center gap-2 text-sm">
              <Checkbox
                id="allow-draft"
                checked={settings.allowDraft}
                onCheckedChange={(checked) =>
                  setSettings((prev) => ({
                    ...prev,
                    allowDraft: Boolean(checked),
                  }))
                }
              />
              <Label htmlFor="allow-draft">Allow draft submissions</Label>
            </div>
            <div className="flex items-center gap-2 text-sm">
              <Checkbox
                id="require-approval"
                checked={settings.requireApproval}
                onCheckedChange={(checked) =>
                  setSettings((prev) => ({
                    ...prev,
                    requireApproval: Boolean(checked),
                  }))
                }
              />
              <Label htmlFor="require-approval">Require approval after submission</Label>
            </div>
            <div>
              <Label>Notify on submit (comma-separated user IDs)</Label>
              <Input
                value={settings.notifyOnSubmit.join(", ")}
                onChange={(event) =>
                  setSettings((prev) => ({
                    ...prev,
                    notifyOnSubmit: event.target.value
                      .split(",")
                      .map((item) => item.trim())
                      .filter(Boolean),
                  }))
                }
                placeholder="user-id-1, user-id-2"
              />
            </div>
            <Button
              type="button"
              variant="outline"
              onClick={() => {
                if (selectedFormId) {
                  const selectedForm = forms.find((form) => form.id === selectedFormId);
                  const formData: { name?: string; slug?: string } = {};
                  if (selectedForm?.name) {
                    formData.name = selectedForm.name;
                  }
                  if (selectedForm?.slug) {
                    formData.slug = selectedForm.slug;
                  }
                  updateMutation.mutate({
                    formId: selectedFormId,
                    data: formData,
                  });
                }
                publishMutation.mutate();
              }}
              disabled={fields.length === 0 || publishMutation.isPending}
            >
              {publishMutation.isPending ? "Publishing..." : "Publish form"}
            </Button>
          </CardContent>
        </Card>
      ) : null}

      {selectedFormId ? (
        <Card>
          <CardHeader>
            <CardTitle>Preview & submit</CardTitle>
          </CardHeader>
          <CardContent>
            {fields.length === 0 ? (
              <p className="text-muted-foreground text-sm">
                Add at least one field to preview this form.
              </p>
            ) : (
              <DynamicFormRenderer
                formId={selectedFormId}
                organizationId={
                  forms.find((form) => form.id === selectedFormId)?.organizationId ?? null
                }
                definition={definition}
              />
            )}
          </CardContent>
        </Card>
      ) : null}

      {selectedFormId ? (
        <Card>
          <CardHeader>
            <CardTitle>Submissions</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            {submissions.length === 0 ? (
              <p className="text-muted-foreground text-sm">No submissions yet.</p>
            ) : (
              <div className="grid gap-2">
                {submissions.map((submission) => (
                  <Button
                    key={submission.id}
                    type="button"
                    variant="outline"
                    className={`h-auto w-full items-start justify-between gap-4 px-3 py-2 text-left whitespace-normal ${
                      selectedSubmissionId === submission.id
                        ? "border-primary bg-primary/10"
                        : "border-input"
                    }`}
                    onClick={() => setSelectedSubmissionId(submission.id)}
                  >
                    <div>
                      <p className="font-semibold">{submission.status}</p>
                      <p className="text-muted-foreground text-xs">
                        {new Date(submission.createdAt).toLocaleString()}
                      </p>
                    </div>
                    <span className="text-muted-foreground text-xs">
                      Score: {submission.completenessScore ?? "-"}
                    </span>
                  </Button>
                ))}
              </div>
            )}

            {selectedSubmission ? (
              <div className="space-y-4">
                <div className="space-y-2">
                  <p className="text-sm font-semibold">Submission details</p>
                  {submissionPayloadEntries.length === 0 ? (
                    <p className="text-muted-foreground text-sm">No payload values.</p>
                  ) : (
                    <Table>
                      <TableHeader>
                        <TableRow>
                          <TableHead>Field</TableHead>
                          <TableHead>Value</TableHead>
                        </TableRow>
                      </TableHeader>
                      <TableBody>
                        {submissionPayloadEntries.map(([key, value]) => (
                          <TableRow key={key}>
                            <TableCell className="text-xs font-medium">{key}</TableCell>
                            <TableCell className="text-xs">
                              {formatPayloadValue(value)}
                            </TableCell>
                          </TableRow>
                        ))}
                      </TableBody>
                    </Table>
                  )}
                </div>

                <div className="space-y-2">
                  <p className="text-sm font-semibold">Attachments</p>
                  {submissionFiles.length === 0 ? (
                    <p className="text-muted-foreground text-sm">No files attached.</p>
                  ) : (
                    <div className="space-y-2">
                      {submissionFiles.map((file) => (
                        <div
                          key={file.id}
                          className="flex flex-wrap items-center justify-between gap-2 rounded-md border border-gray-200 px-3 py-2 text-xs"
                        >
                          <div>
                            <p className="font-semibold">{file.fileName}</p>
                            <p className="text-muted-foreground">
                              {file.mimeType} Â· {(file.sizeBytes / 1024).toFixed(1)} KB
                            </p>
                          </div>
                          <Button
                            type="button"
                            size="sm"
                            variant="outline"
                            onClick={() => downloadMutation.mutate(file.id)}
                            disabled={downloadMutation.isPending}
                          >
                            {downloadMutation.isPending ? "Fetching..." : "Download"}
                          </Button>
                        </div>
                      ))}
                    </div>
                  )}
                </div>

                <div className="space-y-2">
                  <p className="text-sm font-semibold">Review workflow</p>
                  <form
                    onSubmit={(event) => {
                      event.preventDefault();
                      void reviewForm.handleSubmit();
                    }}
                    className="space-y-3"
                  >
                    <reviewForm.Field name="status">
                      {(field) => (
                        <ValidatedSelect
                          field={field}
                          label="Status"
                          options={reviewStatusOptions}
                          placeholderText="Select status"
                        />
                      )}
                    </reviewForm.Field>
                    <reviewForm.Field name="reviewNotes">
                      {(field) => (
                        <TextareaField
                          field={field}
                          label="Review notes"
                          placeholder="Optional notes for the submitter"
                        />
                      )}
                    </reviewForm.Field>
                    <FormSubmitButton
                      isSubmitting={reviewMutation.isPending}
                      loadingText="Updating..."
                    >
                      Update review
                    </FormSubmitButton>
                  </form>
                </div>

                <div className="space-y-2">
                  <p className="text-sm font-semibold">Submission history</p>
                  {submissionVersions.length === 0 ? (
                    <p className="text-muted-foreground text-sm">
                      No submission versions found.
                    </p>
                  ) : (
                    submissionVersions.map((version) => (
                      <div
                        key={version.id}
                        className="rounded-md border border-gray-200 px-3 py-2 text-xs"
                      >
                        <div className="flex items-center justify-between">
                          <span>Version {version.versionNumber}</span>
                          <span className="text-muted-foreground">
                            {new Date(version.createdAt).toLocaleString()}
                          </span>
                        </div>
                        {version.changeReason ? (
                          <p className="text-muted-foreground mt-1">
                            {version.changeReason}
                          </p>
                        ) : null}
                      </div>
                    ))
                  )}
                </div>
              </div>
            ) : null}
          </CardContent>
        </Card>
      ) : null}
    </div>
  );
}
</file>

<file path="src/features/forms/forms.mutations.ts">
import { createServerFn } from "@tanstack/react-start";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import { forbidden, notFound, unauthorized } from "~/lib/server/errors";
import { zod$ } from "~/lib/server/fn-utils";
import type { JsonRecord, JsonValue } from "~/shared/lib/json";
import {
  createFormSchema,
  createFormUploadSchema,
  publishFormSchema,
  reviewFormSubmissionSchema,
  submitFormSchema,
  updateFormSchema,
  updateFormSubmissionSchema,
  type FormDefinition,
} from "./forms.schemas";
import {
  getFileConfigForField,
  sanitizePayload,
  validateFileUpload,
  validateFormPayload,
} from "./forms.utils";

const requireSessionUserId = async () => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const { getRequest } = await import("@tanstack/react-start/server");
  const auth = await getAuth();
  const { headers } = getRequest();
  const session = await auth.api.getSession({ headers });

  if (!session?.user?.id) {
    throw unauthorized("User not authenticated");
  }

  return session.user.id;
};

const requireOrgAccess = async (
  userId: string,
  organizationId: string | null | undefined,
  options?: { roles?: Array<"owner" | "admin" | "reporter" | "viewer" | "member"> },
) => {
  if (!organizationId) {
    const { PermissionService } = await import("~/features/roles/permission.service");
    const isAdmin = await PermissionService.isGlobalAdmin(userId);
    if (!isAdmin) {
      throw forbidden("Organization access required");
    }
    return null;
  }

  const { requireOrganizationAccess } = await import("~/lib/auth/guards/org-guard");
  return requireOrganizationAccess({ userId, organizationId }, options);
};

const loadFormWithAccess = async (
  formId: string,
  userId: string,
  options?: { roles?: Array<"owner" | "admin" | "reporter" | "viewer" | "member"> },
) => {
  const { getDb } = await import("~/db/server-helpers");
  const { forms } = await import("~/db/schema");
  const { eq } = await import("drizzle-orm");

  const db = await getDb();
  const [form] = await db.select().from(forms).where(eq(forms.id, formId)).limit(1);

  if (!form) {
    throw notFound("Form not found");
  }

  await requireOrgAccess(userId, form.organizationId, options);
  return form;
};

type FilePayload = {
  storageKey: string;
  fileName: string;
  mimeType: string;
  sizeBytes: number;
  checksum?: string | null;
};

const isFilePayload = (value: JsonValue): value is FilePayload => {
  if (!value || typeof value !== "object" || Array.isArray(value)) return false;
  const record = value as Record<string, JsonValue>;
  return (
    typeof record["storageKey"] === "string" &&
    typeof record["fileName"] === "string" &&
    typeof record["mimeType"] === "string" &&
    typeof record["sizeBytes"] === "number"
  );
};

const buildSubmissionFiles = (
  definition: FormDefinition,
  payload: JsonRecord,
  submissionId: string,
  actorUserId: string,
) => {
  return definition.fields
    .filter((field) => field.type === "file")
    .map((field) => {
      const value = payload[field.key];
      if (!isFilePayload(value)) return null;
      return {
        submissionId,
        fieldKey: field.key,
        fileName: value.fileName,
        mimeType: value.mimeType,
        sizeBytes: Number(value.sizeBytes),
        checksum: typeof value.checksum === "string" ? value.checksum : "",
        storageKey: value.storageKey,
        uploadedBy: actorUserId,
      };
    })
    .filter((value): value is NonNullable<typeof value> => Boolean(value));
};

const insertSubmissionFiles = async (
  definition: FormDefinition,
  payload: JsonRecord,
  submissionId: string,
  actorUserId: string,
) => {
  const files = buildSubmissionFiles(definition, payload, submissionId, actorUserId);
  if (files.length === 0) return;

  const { getDb } = await import("~/db/server-helpers");
  const { submissionFiles } = await import("~/db/schema");
  const { eq } = await import("drizzle-orm");
  const db = await getDb();

  const existing = await db
    .select({ storageKey: submissionFiles.storageKey })
    .from(submissionFiles)
    .where(eq(submissionFiles.submissionId, submissionId));
  const existingKeys = new Set(existing.map((row) => row.storageKey));
  const toInsert = files.filter((file) => !existingKeys.has(file.storageKey));

  if (toInsert.length > 0) {
    await db.insert(submissionFiles).values(toInsert);
  }
};

export const createForm = createServerFn({ method: "POST" })
  .inputValidator(zod$(createFormSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_forms");
    const { getDb } = await import("~/db/server-helpers");
    const { forms } = await import("~/db/schema");
    const actorUserId = await requireSessionUserId();
    const { ORG_ADMIN_ROLES } = await import("~/lib/auth/guards/org-guard");
    await requireOrgAccess(actorUserId, data.organizationId ?? null, {
      roles: ORG_ADMIN_ROLES,
    });

    const db = await getDb();
    const [created] = await db
      .insert(forms)
      .values({
        organizationId: data.organizationId ?? null,
        name: data.name,
        slug: data.slug,
        description: data.description ?? null,
        createdBy: actorUserId,
      })
      .returning();

    if (created) {
      const { logDataChange } = await import("~/lib/audit");
      await logDataChange({
        action: "FORM_CREATE",
        actorUserId,
        targetType: "form",
        targetId: created.id,
        targetOrgId: created.organizationId ?? null,
      });
    }

    return created ?? null;
  });

export const updateForm = createServerFn({ method: "POST" })
  .inputValidator(zod$(updateFormSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_forms");
    const { getDb } = await import("~/db/server-helpers");
    const { forms } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");
    const actorUserId = await requireSessionUserId();
    const { ORG_ADMIN_ROLES } = await import("~/lib/auth/guards/org-guard");
    const existing = await loadFormWithAccess(data.formId, actorUserId, {
      roles: ORG_ADMIN_ROLES,
    });

    const db = await getDb();
    const [updated] = await db
      .update(forms)
      .set({
        name: data.data.name,
        slug: data.data.slug,
        description: data.data.description ?? null,
      })
      .where(eq(forms.id, data.formId))
      .returning();

    if (updated) {
      const { createAuditDiff, logAdminAction } = await import("~/lib/audit");
      const changes = await createAuditDiff(
        {
          name: existing.name,
          slug: existing.slug,
          description: existing.description,
        },
        {
          name: updated.name,
          slug: updated.slug,
          description: updated.description,
        },
      );
      await logAdminAction({
        action: "FORM_UPDATE",
        actorUserId,
        targetType: "form",
        targetId: updated.id,
        targetOrgId: updated.organizationId ?? null,
        changes,
      });
    }

    return updated ?? null;
  });

export const publishForm = createServerFn({ method: "POST" })
  .inputValidator(zod$(publishFormSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_forms");
    const { getDb } = await import("~/db/server-helpers");
    const { formVersions, forms } = await import("~/db/schema");
    const { desc, eq } = await import("drizzle-orm");
    const actorUserId = await requireSessionUserId();
    const { ORG_ADMIN_ROLES } = await import("~/lib/auth/guards/org-guard");
    const form = await loadFormWithAccess(data.formId, actorUserId, {
      roles: ORG_ADMIN_ROLES,
    });

    const db = await getDb();
    const [latest] = await db
      .select({ versionNumber: formVersions.versionNumber })
      .from(formVersions)
      .where(eq(formVersions.formId, data.formId))
      .orderBy(desc(formVersions.versionNumber))
      .limit(1);

    const versionNumber = (latest?.versionNumber ?? 0) + 1;
    const [created] = await db
      .insert(formVersions)
      .values({
        formId: data.formId,
        versionNumber,
        definition: data.definition,
        publishedAt: new Date(),
        publishedBy: actorUserId,
      })
      .returning();

    await db.update(forms).set({ status: "published" }).where(eq(forms.id, data.formId));

    if (created) {
      const { logAdminAction } = await import("~/lib/audit");
      await logAdminAction({
        action: "FORM_PUBLISH",
        actorUserId,
        targetType: "form",
        targetId: created.formId,
        targetOrgId: form.organizationId ?? null,
        metadata: { versionNumber },
      });
    }

    return created ?? null;
  });

export const submitForm = createServerFn({ method: "POST" })
  .inputValidator(zod$(submitFormSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_forms");
    const { getDb } = await import("~/db/server-helpers");
    const { forms, formSubmissionVersions, formSubmissions, formVersions } =
      await import("~/db/schema");
    const { desc, eq } = await import("drizzle-orm");
    const actorUserId = await requireSessionUserId();

    const db = await getDb();
    const [form] = await db
      .select()
      .from(forms)
      .where(eq(forms.id, data.formId))
      .limit(1);
    if (!form) {
      throw notFound("Form not found");
    }

    if (
      form.organizationId &&
      data.organizationId &&
      form.organizationId !== data.organizationId
    ) {
      throw forbidden("Organization mismatch for submission");
    }

    const organizationId = form.organizationId ?? data.organizationId ?? null;
    if (!organizationId) {
      throw forbidden("Organization is required for submissions");
    }

    await requireOrgAccess(actorUserId, organizationId);

    const [latestVersion] = await db
      .select()
      .from(formVersions)
      .where(eq(formVersions.formId, data.formId))
      .orderBy(desc(formVersions.versionNumber))
      .limit(1);

    if (!latestVersion) {
      return { error: "Form has no published versions." };
    }

    const definition = latestVersion.definition as FormDefinition;
    const sanitizedPayload = await sanitizePayload(definition, data.payload);
    const validation = validateFormPayload(definition, sanitizedPayload);

    const [submission] = await db
      .insert(formSubmissions)
      .values({
        formId: data.formId,
        formVersionId: latestVersion.id,
        organizationId,
        submitterId: actorUserId,
        status: data.status ?? "draft",
        payload: sanitizedPayload,
        completenessScore: validation.completenessScore,
        missingFields: validation.missingFields,
        validationErrors: validation.validationErrors,
        submittedAt: data.status === "submitted" ? new Date() : null,
        importJobId: data.importJobId ?? null,
      })
      .returning();

    if (!submission) {
      return { error: "Failed to save submission." };
    }

    await db.insert(formSubmissionVersions).values({
      submissionId: submission.id,
      versionNumber: 1,
      payloadSnapshot: sanitizedPayload,
      changedBy: actorUserId,
      changeReason: data.changeReason ?? null,
    });

    await insertSubmissionFiles(definition, sanitizedPayload, submission.id, actorUserId);

    const { logDataChange } = await import("~/lib/audit");
    await logDataChange({
      action: "FORM_SUBMISSION_CREATE",
      actorUserId,
      targetType: "form_submission",
      targetId: submission.id,
      targetOrgId: submission.organizationId,
    });

    return submission;
  });

export const createFormUpload = createServerFn({ method: "POST" })
  .inputValidator(zod$(createFormUploadSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_forms");
    const actorUserId = await requireSessionUserId();
    const form = await loadFormWithAccess(data.formId, actorUserId);

    // Load form version to get field definition for validation
    const { getDb } = await import("~/db/server-helpers");
    const { formVersions } = await import("~/db/schema");
    const { desc, eq } = await import("drizzle-orm");
    const { badRequest } = await import("~/lib/server/errors");

    const db = await getDb();
    const [latestVersion] = await db
      .select()
      .from(formVersions)
      .where(eq(formVersions.formId, data.formId))
      .orderBy(desc(formVersions.versionNumber))
      .limit(1);

    // Validate file against field configuration if form has a published version
    if (latestVersion) {
      const definition = latestVersion.definition as FormDefinition;
      const config = getFileConfigForField(definition, data.fieldKey);
      const validation = validateFileUpload(
        {
          fileName: data.fileName,
          mimeType: data.mimeType,
          size: data.sizeBytes,
        },
        config,
      );

      if (!validation.valid) {
        throw badRequest(validation.error ?? "File validation failed");
      }
    }

    const { createId } = await import("@paralleldrive/cuid2");
    const { PutObjectCommand } = await import("@aws-sdk/client-s3");
    const { getSignedUrl } = await import("@aws-sdk/s3-request-presigner");
    const { getArtifactsBucketName, getS3Client } =
      await import("~/lib/storage/artifacts");

    const safeFileName = data.fileName.replace(/[^a-zA-Z0-9_.-]/g, "_");
    const storageKey = `forms/${form.id}/${createId()}-${safeFileName}`;
    const bucket = await getArtifactsBucketName();
    const client = await getS3Client();

    const command = new PutObjectCommand({
      Bucket: bucket,
      Key: storageKey,
      ContentType: data.mimeType,
      ContentLength: data.sizeBytes,
    });

    const uploadUrl = await getSignedUrl(client, command, { expiresIn: 900 });

    const { logDataChange } = await import("~/lib/audit");
    await logDataChange({
      action: "FORM_UPLOAD_INIT",
      actorUserId,
      targetType: "form",
      targetId: form.id,
      targetOrgId: form.organizationId ?? null,
      metadata: {
        fieldKey: data.fieldKey,
        fileName: data.fileName,
        mimeType: data.mimeType,
        sizeBytes: data.sizeBytes,
        storageKey,
      },
    });

    return { uploadUrl, storageKey };
  });

export const updateFormSubmission = createServerFn({ method: "POST" })
  .inputValidator(zod$(updateFormSubmissionSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_forms");
    const actorUserId = await requireSessionUserId();
    const { getDb } = await import("~/db/server-helpers");
    const { formSubmissionVersions, formSubmissions, formVersions } =
      await import("~/db/schema");
    const { desc, eq } = await import("drizzle-orm");

    const db = await getDb();
    const [submission] = await db
      .select()
      .from(formSubmissions)
      .where(eq(formSubmissions.id, data.submissionId))
      .limit(1);

    if (!submission) {
      throw notFound("Submission not found");
    }

    await requireOrgAccess(actorUserId, submission.organizationId);

    const [version] = await db
      .select()
      .from(formVersions)
      .where(eq(formVersions.id, submission.formVersionId))
      .limit(1);

    if (!version) {
      throw notFound("Form version not found");
    }

    const definition = version.definition as FormDefinition;
    const sanitizedPayload = await sanitizePayload(definition, data.payload);
    const validation = validateFormPayload(definition, sanitizedPayload);
    const nextStatus = data.status ?? submission.status;

    const [updated] = await db
      .update(formSubmissions)
      .set({
        payload: sanitizedPayload,
        completenessScore: validation.completenessScore,
        missingFields: validation.missingFields,
        validationErrors: validation.validationErrors,
        status: nextStatus,
        submittedAt: nextStatus === "submitted" ? new Date() : submission.submittedAt,
        updatedAt: new Date(),
      })
      .where(eq(formSubmissions.id, data.submissionId))
      .returning();

    if (!updated) {
      return null;
    }

    const [latestVersion] = await db
      .select({ versionNumber: formSubmissionVersions.versionNumber })
      .from(formSubmissionVersions)
      .where(eq(formSubmissionVersions.submissionId, updated.id))
      .orderBy(desc(formSubmissionVersions.versionNumber))
      .limit(1);

    await db.insert(formSubmissionVersions).values({
      submissionId: updated.id,
      versionNumber: (latestVersion?.versionNumber ?? 0) + 1,
      payloadSnapshot: sanitizedPayload,
      changedBy: actorUserId,
      changeReason: data.changeReason ?? null,
    });

    await insertSubmissionFiles(definition, sanitizedPayload, updated.id, actorUserId);

    const { logDataChange } = await import("~/lib/audit");
    await logDataChange({
      action: "FORM_SUBMISSION_UPDATE",
      actorUserId,
      targetType: "form_submission",
      targetId: updated.id,
      targetOrgId: updated.organizationId,
    });

    return updated;
  });

export const reviewFormSubmission = createServerFn({ method: "POST" })
  .inputValidator(zod$(reviewFormSubmissionSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_forms");
    const actorUserId = await requireSessionUserId();
    const { getDb } = await import("~/db/server-helpers");
    const { formSubmissions } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");
    const { ORG_ADMIN_ROLES } = await import("~/lib/auth/guards/org-guard");

    const db = await getDb();
    const [submission] = await db
      .select()
      .from(formSubmissions)
      .where(eq(formSubmissions.id, data.submissionId))
      .limit(1);

    if (!submission) {
      throw notFound("Submission not found");
    }

    await requireOrgAccess(actorUserId, submission.organizationId, {
      roles: ORG_ADMIN_ROLES,
    });

    const [updated] = await db
      .update(formSubmissions)
      .set({
        status: data.status,
        reviewedBy: actorUserId,
        reviewedAt: new Date(),
        reviewNotes: data.reviewNotes ?? null,
      })
      .where(eq(formSubmissions.id, data.submissionId))
      .returning();

    if (updated) {
      const { logAdminAction } = await import("~/lib/audit");
      await logAdminAction({
        action: "FORM_SUBMISSION_REVIEW",
        actorUserId,
        targetType: "form_submission",
        targetId: updated.id,
        targetOrgId: updated.organizationId,
        metadata: { status: updated.status },
      });
    }

    return updated ?? null;
  });
</file>

<file path="src/features/forms/forms.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import { z } from "zod";
import { forbidden, notFound, unauthorized } from "~/lib/server/errors";
import { zod$ } from "~/lib/server/fn-utils";
import {
  getSubmissionFileDownloadSchema,
  listSubmissionFilesSchema,
} from "./forms.schemas";

const requireSessionUserId = async () => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const { getRequest } = await import("@tanstack/react-start/server");
  const auth = await getAuth();
  const { headers } = getRequest();
  const session = await auth.api.getSession({ headers });

  if (!session?.user?.id) {
    throw unauthorized("User not authenticated");
  }

  return session.user.id;
};

const requireOrgAccess = async (
  userId: string,
  organizationId: string | null | undefined,
) => {
  if (!organizationId) {
    const { PermissionService } = await import("~/features/roles/permission.service");
    const isAdmin = await PermissionService.isGlobalAdmin(userId);
    if (!isAdmin) {
      throw forbidden("Organization access required");
    }
    return null;
  }

  const { requireOrganizationAccess } = await import("~/lib/auth/guards/org-guard");
  return requireOrganizationAccess({ userId, organizationId });
};

const getFormSchema = z.object({
  formId: z.uuid(),
});

const listFormsSchema = z
  .object({
    organizationId: z.uuid().optional(),
  })
  .nullish()
  .transform((value) => value ?? {});

const listFormSubmissionsSchema = z.object({
  formId: z.uuid(),
});

const listSubmissionVersionsSchema = z.object({
  submissionId: z.uuid(),
});

const getFormSubmissionSchema = z.object({
  submissionId: z.uuid(),
});

export const getForm = createServerFn({ method: "GET" })
  .inputValidator(zod$(getFormSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_forms");
    const userId = await requireSessionUserId();
    const { getDb } = await import("~/db/server-helpers");
    const { forms } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    const [form] = await db
      .select()
      .from(forms)
      .where(eq(forms.id, data.formId))
      .limit(1);

    if (form) {
      await requireOrgAccess(userId, form.organizationId);
    }

    return form ?? null;
  });

export const listForms = createServerFn({ method: "GET" })
  .inputValidator(zod$(listFormsSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_forms");
    const userId = await requireSessionUserId();
    const { getDb } = await import("~/db/server-helpers");
    const { forms, organizationMembers } = await import("~/db/schema");
    const { and, eq, inArray, isNull, or } = await import("drizzle-orm");

    const db = await getDb();
    if (data.organizationId) {
      await requireOrgAccess(userId, data.organizationId);
      return db.select().from(forms).where(eq(forms.organizationId, data.organizationId));
    }

    const memberships = await db
      .select({ organizationId: organizationMembers.organizationId })
      .from(organizationMembers)
      .where(
        and(
          eq(organizationMembers.userId, userId),
          eq(organizationMembers.status, "active"),
        ),
      );

    const orgIds = memberships.map((membership) => membership.organizationId);
    const { PermissionService } = await import("~/features/roles/permission.service");
    const isAdmin = await PermissionService.isGlobalAdmin(userId);

    const conditions = [];
    if (orgIds.length > 0) {
      conditions.push(inArray(forms.organizationId, orgIds));
    }

    if (isAdmin) {
      conditions.push(isNull(forms.organizationId));
    }

    if (conditions.length === 0) return [];

    return db
      .select()
      .from(forms)
      .where(conditions.length === 1 ? conditions[0] : or(...conditions));
  });

export const getLatestFormVersion = createServerFn({ method: "GET" })
  .inputValidator(zod$(getFormSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_forms");
    const userId = await requireSessionUserId();
    const { getDb } = await import("~/db/server-helpers");
    const { forms, formVersions } = await import("~/db/schema");
    const { desc, eq } = await import("drizzle-orm");

    const db = await getDb();
    const [form] = await db
      .select()
      .from(forms)
      .where(eq(forms.id, data.formId))
      .limit(1);
    if (!form) {
      return null;
    }
    await requireOrgAccess(userId, form.organizationId);

    const [version] = await db
      .select()
      .from(formVersions)
      .where(eq(formVersions.formId, data.formId))
      .orderBy(desc(formVersions.versionNumber))
      .limit(1);

    return version ?? null;
  });

export const listFormSubmissions = createServerFn({ method: "GET" })
  .inputValidator(zod$(listFormSubmissionsSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_forms");
    const userId = await requireSessionUserId();
    const { getDb } = await import("~/db/server-helpers");
    const { forms, formSubmissions } = await import("~/db/schema");
    const { desc, eq } = await import("drizzle-orm");

    const db = await getDb();
    const [form] = await db
      .select()
      .from(forms)
      .where(eq(forms.id, data.formId))
      .limit(1);
    if (!form) {
      throw notFound("Form not found");
    }
    await requireOrgAccess(userId, form.organizationId);

    return db
      .select()
      .from(formSubmissions)
      .where(eq(formSubmissions.formId, data.formId))
      .orderBy(desc(formSubmissions.createdAt));
  });

export const getFormSubmission = createServerFn({ method: "GET" })
  .inputValidator(zod$(getFormSubmissionSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_forms");
    const userId = await requireSessionUserId();
    const { getDb } = await import("~/db/server-helpers");
    const { formSubmissions, forms } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    const [submission] = await db
      .select({
        id: formSubmissions.id,
        formId: formSubmissions.formId,
        organizationId: formSubmissions.organizationId,
        status: formSubmissions.status,
        createdAt: formSubmissions.createdAt,
        submittedAt: formSubmissions.submittedAt,
        reviewNotes: formSubmissions.reviewNotes,
        formName: forms.name,
      })
      .from(formSubmissions)
      .innerJoin(forms, eq(formSubmissions.formId, forms.id))
      .where(eq(formSubmissions.id, data.submissionId))
      .limit(1);

    if (!submission) {
      return null;
    }

    await requireOrgAccess(userId, submission.organizationId);

    return submission;
  });

export const listFormSubmissionVersions = createServerFn({ method: "GET" })
  .inputValidator(zod$(listSubmissionVersionsSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_forms");
    const userId = await requireSessionUserId();
    const { getDb } = await import("~/db/server-helpers");
    const { formSubmissionVersions, formSubmissions } = await import("~/db/schema");
    const { desc, eq } = await import("drizzle-orm");

    const db = await getDb();
    const [submission] = await db
      .select({ organizationId: formSubmissions.organizationId })
      .from(formSubmissions)
      .where(eq(formSubmissions.id, data.submissionId))
      .limit(1);

    if (!submission) {
      return [];
    }

    await requireOrgAccess(userId, submission.organizationId);

    return db
      .select()
      .from(formSubmissionVersions)
      .where(eq(formSubmissionVersions.submissionId, data.submissionId))
      .orderBy(desc(formSubmissionVersions.versionNumber));
  });

export const listSubmissionFiles = createServerFn({ method: "GET" })
  .inputValidator(zod$(listSubmissionFilesSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_forms");
    const userId = await requireSessionUserId();
    const { getDb } = await import("~/db/server-helpers");
    const { formSubmissions, submissionFiles } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    const [submission] = await db
      .select({ organizationId: formSubmissions.organizationId })
      .from(formSubmissions)
      .where(eq(formSubmissions.id, data.submissionId))
      .limit(1);

    if (!submission) {
      return [];
    }

    await requireOrgAccess(userId, submission.organizationId);

    return db
      .select()
      .from(submissionFiles)
      .where(eq(submissionFiles.submissionId, data.submissionId));
  });

export const getSubmissionFileDownloadUrl = createServerFn({ method: "GET" })
  .inputValidator(zod$(getSubmissionFileDownloadSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_forms");
    const userId = await requireSessionUserId();
    const { getDb } = await import("~/db/server-helpers");
    const { formSubmissions, submissionFiles } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    const [record] = await db
      .select({
        storageKey: submissionFiles.storageKey,
        fileName: submissionFiles.fileName,
        mimeType: submissionFiles.mimeType,
        organizationId: formSubmissions.organizationId,
      })
      .from(submissionFiles)
      .innerJoin(formSubmissions, eq(submissionFiles.submissionId, formSubmissions.id))
      .where(eq(submissionFiles.id, data.submissionFileId))
      .limit(1);

    if (!record) {
      return null;
    }

    await requireOrgAccess(userId, record.organizationId);

    const { GetObjectCommand } = await import("@aws-sdk/client-s3");
    const { getSignedUrl } = await import("@aws-sdk/s3-request-presigner");
    const { getArtifactsBucketName, getS3Client } =
      await import("~/lib/storage/artifacts");

    const bucket = await getArtifactsBucketName();
    const client = await getS3Client();
    const command = new GetObjectCommand({
      Bucket: bucket,
      Key: record.storageKey,
      ResponseContentDisposition: `attachment; filename="${record.fileName}"`,
      ResponseContentType: record.mimeType ?? undefined,
    });

    const url = await getSignedUrl(client, command, { expiresIn: 900 });
    return { url, fileName: record.fileName };
  });
</file>

<file path="src/features/forms/forms.schemas.ts">
import { z } from "zod";
import { jsonRecordSchema, jsonValueSchema } from "~/shared/lib/json";

export const formFieldTypeSchema = z.enum([
  "text",
  "number",
  "email",
  "phone",
  "date",
  "select",
  "multiselect",
  "checkbox",
  "file",
  "textarea",
  "rich_text",
]);

export const validationRuleSchema = z.object({
  type: z.enum(["min_length", "max_length", "pattern", "min", "max", "custom"]),
  value: z.union([z.string(), z.number()]),
  message: z.string(),
});

export const formFieldSchema = z.object({
  key: z.string().min(1),
  type: formFieldTypeSchema,
  label: z.string().min(1),
  description: z.string().optional(),
  placeholder: z.string().optional(),
  required: z.boolean(),
  validation: z.array(validationRuleSchema).optional(),
  options: z.array(z.object({ value: z.string(), label: z.string() })).optional(),
  conditional: z
    .object({
      field: z.string(),
      operator: z.enum(["equals", "not_equals", "contains", "greater_than"]),
      value: jsonValueSchema,
    })
    .optional(),
  fileConfig: z
    .object({
      allowedTypes: z.array(z.string()),
      maxSizeBytes: z.number().int(),
      maxFiles: z.number().int(),
    })
    .optional(),
});

export const formDefinitionSchema = z.object({
  fields: z.array(formFieldSchema),
  layout: z
    .object({
      sections: z.array(
        z.object({
          title: z.string(),
          fieldKeys: z.array(z.string()),
        }),
      ),
    })
    .optional(),
  settings: z.object({
    allowDraft: z.boolean(),
    requireApproval: z.boolean(),
    notifyOnSubmit: z.array(z.string()),
  }),
});

export type FormDefinition = z.infer<typeof formDefinitionSchema>;

export const formSubmissionStatusSchema = z.enum([
  "draft",
  "submitted",
  "under_review",
  "changes_requested",
  "approved",
  "rejected",
]);

export const createFormSchema = z.object({
  organizationId: z.uuid().optional().nullable(),
  name: z.string().min(1),
  slug: z.string().min(1),
  description: z.string().optional(),
});
export type CreateFormInput = z.infer<typeof createFormSchema>;

export const updateFormSchema = z.object({
  formId: z.uuid(),
  data: createFormSchema.partial(),
});
export type UpdateFormInput = z.infer<typeof updateFormSchema>;

export const publishFormSchema = z.object({
  formId: z.uuid(),
  definition: formDefinitionSchema,
});
export type PublishFormInput = z.infer<typeof publishFormSchema>;

export const submitFormSchema = z.object({
  formId: z.uuid(),
  organizationId: z.uuid().optional().nullable(),
  payload: jsonRecordSchema,
  status: z.enum(["draft", "submitted"]).optional(),
  changeReason: z.string().optional(),
  importJobId: z.uuid().optional().nullable(),
});
export type SubmitFormInput = z.infer<typeof submitFormSchema>;

export const updateFormSubmissionSchema = z.object({
  submissionId: z.uuid(),
  payload: jsonRecordSchema,
  status: z.enum(["draft", "submitted"]).optional(),
  changeReason: z.string().optional(),
});
export type UpdateFormSubmissionInput = z.infer<typeof updateFormSubmissionSchema>;

export const reviewFormSubmissionSchema = z.object({
  submissionId: z.uuid(),
  status: formSubmissionStatusSchema.exclude(["draft", "submitted"]),
  reviewNotes: z.string().optional(),
});
export type ReviewFormSubmissionInput = z.infer<typeof reviewFormSubmissionSchema>;

export const createFormUploadSchema = z.object({
  formId: z.uuid(),
  fieldKey: z.string().min(1),
  fileName: z.string().min(1),
  mimeType: z.string().min(1),
  sizeBytes: z.number().int().positive(),
});
export type CreateFormUploadInput = z.infer<typeof createFormUploadSchema>;

export const listSubmissionFilesSchema = z.object({
  submissionId: z.uuid(),
});
export type ListSubmissionFilesInput = z.infer<typeof listSubmissionFilesSchema>;

export const getSubmissionFileDownloadSchema = z.object({
  submissionFileId: z.uuid(),
});
export type GetSubmissionFileDownloadInput = z.infer<
  typeof getSubmissionFileDownloadSchema
>;
</file>

<file path="src/features/forms/forms.utils.ts">
import type { JsonRecord, JsonValue } from "~/shared/lib/json";
import type { FormDefinition } from "./forms.schemas";

const sanitizeRichText = async (value: JsonValue): Promise<JsonValue> => {
  if (typeof value !== "string") return value;
  const { default: sanitizeHtml } = await import("sanitize-html");

  return sanitizeHtml(value, {
    allowedTags: [
      "p",
      "br",
      "strong",
      "b",
      "em",
      "i",
      "u",
      "ul",
      "ol",
      "li",
      "blockquote",
      "a",
      "span",
    ],
    allowedAttributes: {
      a: ["href", "target", "rel"],
      span: ["class"],
    },
    allowedSchemes: ["http", "https", "mailto"],
    transformTags: {
      a: (tagName: string, attribs: Record<string, string>) => ({
        tagName,
        attribs: {
          ...attribs,
          rel: "noopener noreferrer",
          target: "_blank",
        },
      }),
    },
  });
};

const meetsCondition = (
  condition: NonNullable<FormDefinition["fields"][number]["conditional"]>,
  payload: JsonRecord,
) => {
  const left = payload[condition.field];
  const right = condition.value;

  if (condition.operator === "equals") {
    return left === right;
  }

  if (condition.operator === "not_equals") {
    return left !== right;
  }

  if (condition.operator === "contains") {
    if (Array.isArray(left)) {
      return left.includes(right as never);
    }
    if (typeof left === "string") {
      return left.includes(String(right));
    }
    return false;
  }

  if (condition.operator === "greater_than") {
    const leftNum = Number(left);
    const rightNum = Number(right);
    if (Number.isNaN(leftNum) || Number.isNaN(rightNum)) {
      return false;
    }
    return leftNum > rightNum;
  }

  return true;
};

const isFieldActive = (
  definition: FormDefinition,
  fieldKey: string,
  payload: JsonRecord,
) => {
  const field = definition.fields.find((item) => item.key === fieldKey);
  if (!field?.conditional) return true;
  return meetsCondition(field.conditional, payload);
};

export const validateFormPayload = (definition: FormDefinition, payload: JsonRecord) => {
  const missingFields: string[] = [];
  const validationErrors: Array<{ field: string; message: string }> = [];

  for (const field of definition.fields) {
    if (field.conditional && !isFieldActive(definition, field.key, payload)) {
      continue;
    }

    const hasValue = Object.prototype.hasOwnProperty.call(payload, field.key);
    const value = payload[field.key];
    const isEmpty =
      !hasValue || value === null || (typeof value === "string" && value.trim() === "");

    if (field.required && isEmpty) {
      missingFields.push(field.key);
    }

    if (field.validation && !isEmpty) {
      for (const rule of field.validation) {
        if (rule.type === "min_length" && typeof value === "string") {
          if (value.length < Number(rule.value)) {
            validationErrors.push({ field: field.key, message: rule.message });
          }
        }

        if (rule.type === "max_length" && typeof value === "string") {
          if (value.length > Number(rule.value)) {
            validationErrors.push({ field: field.key, message: rule.message });
          }
        }

        if (rule.type === "min" && typeof value === "number") {
          if (value < Number(rule.value)) {
            validationErrors.push({ field: field.key, message: rule.message });
          }
        }

        if (rule.type === "max" && typeof value === "number") {
          if (value > Number(rule.value)) {
            validationErrors.push({ field: field.key, message: rule.message });
          }
        }

        if (rule.type === "pattern" && typeof value === "string") {
          const regex = new RegExp(String(rule.value));
          if (!regex.test(value)) {
            validationErrors.push({ field: field.key, message: rule.message });
          }
        }
      }
    }
  }

  const totalFields = definition.fields.length || 1;
  const completenessScore = Math.max(
    0,
    Math.round(100 - (missingFields.length / totalFields) * 100),
  );

  return { missingFields, validationErrors, completenessScore };
};

export const sanitizePayload = async (
  definition: FormDefinition,
  payload: JsonRecord,
) => {
  const sanitized: JsonRecord = { ...payload };
  for (const field of definition.fields) {
    if (field.type === "rich_text" && field.key in payload) {
      sanitized[field.key] = await sanitizeRichText(payload[field.key]);
    }
  }
  return sanitized;
};

// ============================================================================
// FILE VALIDATION HELPERS (Issue 08 - Server-side file constraints)
// ============================================================================

/**
 * Represents a file upload payload from the client
 */
export type FilePayload = {
  fileName: string;
  mimeType: string;
  size: number;
  storageKey?: string;
};

/**
 * File configuration from form field definition
 */
export type FileConfig = {
  allowedTypes?: string[];
  maxSizeBytes?: number;
  maxFiles?: number;
};

/**
 * Default file config if not specified in form definition
 */
const DEFAULT_FILE_CONFIG: FileConfig = {
  allowedTypes: [
    "application/pdf",
    "image/jpeg",
    "image/png",
    "image/gif",
    "image/webp",
    "application/msword",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  ],
  maxSizeBytes: 10 * 1024 * 1024, // 10MB
  maxFiles: 5,
};

/**
 * Parse a file field value from the payload
 */
export const parseFileFieldValue = (value: JsonValue): FilePayload[] => {
  if (!value) return [];

  // Single file object
  if (typeof value === "object" && !Array.isArray(value) && value !== null) {
    const obj = value as Record<string, JsonValue>;
    const fileName = obj["fileName"];
    const mimeType = obj["mimeType"];
    const size = obj["size"];
    const storageKey = obj["storageKey"];
    if (typeof fileName === "string" && typeof mimeType === "string") {
      return [
        {
          fileName,
          mimeType,
          size: typeof size === "number" ? size : 0,
          ...(typeof storageKey === "string" ? { storageKey } : {}),
        },
      ];
    }
    return [];
  }

  // Array of file objects
  if (Array.isArray(value)) {
    return value
      .filter(
        (item): item is Record<string, JsonValue> =>
          typeof item === "object" && item !== null && !Array.isArray(item),
      )
      .filter((item) => {
        const fn = item["fileName"];
        const mt = item["mimeType"];
        return typeof fn === "string" && typeof mt === "string";
      })
      .map((item) => {
        const fn = item["fileName"] as string;
        const mt = item["mimeType"] as string;
        const sz = item["size"];
        const sk = item["storageKey"];
        return {
          fileName: fn,
          mimeType: mt,
          size: typeof sz === "number" ? sz : 0,
          ...(typeof sk === "string" ? { storageKey: sk } : {}),
        };
      });
  }

  return [];
};

/**
 * Get the file config for a specific field from the form definition
 */
export const getFileConfigForField = (
  definition: FormDefinition,
  fieldKey: string,
): FileConfig => {
  const field = definition.fields.find((f) => f.key === fieldKey);
  if (!field || field.type !== "file") {
    return DEFAULT_FILE_CONFIG;
  }

  const fileConfig = field.fileConfig;
  if (!fileConfig) {
    return DEFAULT_FILE_CONFIG;
  }

  return {
    allowedTypes: fileConfig.allowedTypes ?? DEFAULT_FILE_CONFIG.allowedTypes,
    maxSizeBytes: fileConfig.maxSizeBytes ?? DEFAULT_FILE_CONFIG.maxSizeBytes,
    maxFiles: fileConfig.maxFiles ?? DEFAULT_FILE_CONFIG.maxFiles,
  };
};

/**
 * Check if a mime type is allowed by the file config
 */
export const isMimeTypeAllowed = (mimeType: string, allowedTypes?: string[]): boolean => {
  if (!allowedTypes || allowedTypes.length === 0) return true;

  const normalizedMime = mimeType.toLowerCase().trim();

  for (const allowed of allowedTypes) {
    const normalizedAllowed = allowed.toLowerCase().trim();

    // Exact match
    if (normalizedMime === normalizedAllowed) return true;

    // Wildcard match (e.g., "image/*")
    if (normalizedAllowed.endsWith("/*")) {
      const category = normalizedAllowed.slice(0, -2);
      if (normalizedMime.startsWith(category + "/")) return true;
    }
  }

  return false;
};

/**
 * Validate a file upload against the form field's configuration
 */
export const validateFileUpload = (
  file: FilePayload,
  config: FileConfig,
): { valid: boolean; error?: string } => {
  // Validate mime type
  if (!isMimeTypeAllowed(file.mimeType, config.allowedTypes)) {
    return {
      valid: false,
      error: `File type "${file.mimeType}" is not allowed. Allowed types: ${config.allowedTypes?.join(", ")}`,
    };
  }

  // Validate file size
  if (config.maxSizeBytes && file.size > config.maxSizeBytes) {
    const maxMB = Math.round(config.maxSizeBytes / (1024 * 1024));
    const fileMB = Math.round((file.size / (1024 * 1024)) * 10) / 10;
    return {
      valid: false,
      error: `File size (${fileMB}MB) exceeds maximum allowed size (${maxMB}MB)`,
    };
  }

  return { valid: true };
};

/**
 * Validate all files for a file field against the form configuration
 */
export const validateFileField = (
  definition: FormDefinition,
  fieldKey: string,
  files: FilePayload[],
): { valid: boolean; errors: string[] } => {
  const config = getFileConfigForField(definition, fieldKey);
  const errors: string[] = [];

  // Check max files limit
  if (config.maxFiles && files.length > config.maxFiles) {
    errors.push(`Too many files (${files.length}). Maximum allowed: ${config.maxFiles}`);
  }

  // Validate each file
  for (const file of files) {
    const result = validateFileUpload(file, config);
    if (!result.valid && result.error) {
      errors.push(`${file.fileName}: ${result.error}`);
    }
  }

  return { valid: errors.length === 0, errors };
};

/**
 * Validate storage key prefix to prevent path traversal attacks
 */
export const isValidStorageKeyPrefix = (
  storageKey: string,
  expectedPrefix: string,
): boolean => {
  if (!storageKey || !expectedPrefix) return false;

  // Normalize and check prefix
  const normalizedKey = storageKey.replace(/^\/+/, "").toLowerCase();
  const normalizedPrefix = expectedPrefix.replace(/^\/+/, "").toLowerCase();

  // Check it starts with expected prefix
  if (!normalizedKey.startsWith(normalizedPrefix)) return false;

  // Check for path traversal attempts
  if (normalizedKey.includes("..")) return false;
  if (normalizedKey.includes("//")) return false;

  return true;
};
</file>

<file path="src/features/imports/components/import-wizard-shell.tsx">
import { useStore } from "@tanstack/react-form";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import type { ParseResult } from "papaparse";
import { useEffect, useMemo, useState } from "react";
import { FormSubmitButton } from "~/components/form-fields/FormSubmitButton";
import { ValidatedFileUpload } from "~/components/form-fields/ValidatedFileUpload";
import { ValidatedInput } from "~/components/form-fields/ValidatedInput";
import { ValidatedSelect } from "~/components/form-fields/ValidatedSelect";
import { Button } from "~/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";
import { Label } from "~/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "~/components/ui/table";
import { Textarea } from "~/components/ui/textarea";
import { getLatestFormVersion, listForms } from "~/features/forms/forms.queries";
import type { FormDefinition } from "~/features/forms/forms.schemas";
import { validateFormPayload } from "~/features/forms/forms.utils";
import { listOrganizations } from "~/features/organizations/organizations.queries";
import { useAppForm } from "~/lib/hooks/useAppForm";
import type { JsonRecord } from "~/shared/lib/json";
import {
  createImportJob,
  createImportUpload,
  createMappingTemplate,
  deleteMappingTemplate,
  rollbackImportJob,
  runBatchImport,
  runInteractiveImport,
  updateMappingTemplate,
} from "../imports.mutations";
import {
  listImportJobErrors,
  listImportJobs,
  listMappingTemplates,
} from "../imports.queries";

const laneOptions = [
  { value: "interactive", label: "Lane 1 (interactive)" },
  { value: "batch", label: "Lane 2 (batch)" },
];

const normalizeKey = (value: string) => value.toLowerCase().replace(/[^a-z0-9]/g, "");

const hashFile = async (file: File) => {
  const buffer = await file.arrayBuffer();
  const hashBuffer = await crypto.subtle.digest("SHA-256", buffer);
  return Array.from(new Uint8Array(hashBuffer))
    .map((byte) => byte.toString(16).padStart(2, "0"))
    .join("");
};

const parseCsvFile = async (file: File) => {
  const Papa = await import("papaparse");
  return new Promise<JsonRecord[]>((resolve, reject) => {
    Papa.parse(file, {
      header: true,
      skipEmptyLines: true,
      complete: (result: ParseResult<JsonRecord>) => resolve(result.data as JsonRecord[]),
      error: (error: Error) => reject(error),
    });
  });
};

const parseExcelFile = async (file: File) => {
  const { read, utils } = await import("xlsx");
  const data = new Uint8Array(await file.arrayBuffer());
  const workbook = read(data, { type: "array" });
  const sheetName = workbook.SheetNames[0];
  const sheet = workbook.Sheets[sheetName];
  return utils.sheet_to_json(sheet, { defval: "" }) as JsonRecord[];
};

const parseImportFile = async (file: File) => {
  if (file.name.toLowerCase().endsWith(".csv")) {
    return { type: "csv" as const, rows: await parseCsvFile(file) };
  }
  if (
    file.name.toLowerCase().endsWith(".xlsx") ||
    file.name.toLowerCase().endsWith(".xls")
  ) {
    return { type: "excel" as const, rows: await parseExcelFile(file) };
  }
  throw new Error("Unsupported file type. Please upload CSV or Excel.");
};

const buildPayloadFromRow = (
  row: JsonRecord,
  mapping: Record<string, string>,
  fieldLookup: Map<string, FormDefinition["fields"][number]>,
) => {
  const payload: JsonRecord = {};

  Object.entries(mapping).forEach(([sourceColumn, targetFieldKey]) => {
    if (!targetFieldKey) return;
    const field = fieldLookup.get(targetFieldKey);
    if (!field) return;
    const rawValue = row[sourceColumn];

    if (field.type === "number") {
      payload[targetFieldKey] = rawValue === "" ? null : Number(rawValue);
      return;
    }

    if (field.type === "checkbox") {
      const normalized = String(rawValue ?? "").toLowerCase();
      payload[targetFieldKey] = ["true", "1", "yes", "y"].includes(normalized);
      return;
    }

    if (field.type === "multiselect") {
      payload[targetFieldKey] =
        typeof rawValue === "string" ? rawValue.split(",").map((val) => val.trim()) : [];
      return;
    }

    payload[targetFieldKey] = rawValue ?? null;
  });

  return payload;
};

const autoMapHeaders = (
  headers: string[],
  fields: FormDefinition["fields"],
): Record<string, string> => {
  const normalizedFields = fields.map((field) => ({
    key: field.key,
    label: field.label,
    normalizedKey: normalizeKey(field.key),
    normalizedLabel: normalizeKey(field.label),
  }));

  return headers.reduce<Record<string, string>>((acc, header) => {
    const normalizedHeader = normalizeKey(header);
    const match = normalizedFields.find(
      (field) =>
        normalizedHeader === field.normalizedKey ||
        normalizedHeader === field.normalizedLabel ||
        normalizedHeader.includes(field.normalizedKey) ||
        normalizedHeader.includes(field.normalizedLabel),
    );
    if (match) {
      acc[header] = match.key;
    }
    return acc;
  }, {});
};

export function ImportWizardShell() {
  const queryClient = useQueryClient();
  const [sourceFileKey, setSourceFileKey] = useState<string | null>(null);
  const [sourceFileHash, setSourceFileHash] = useState<string | null>(null);
  const [importFileType, setImportFileType] = useState<"csv" | "excel" | null>(null);
  const [rows, setRows] = useState<JsonRecord[]>([]);
  const [headers, setHeaders] = useState<string[]>([]);
  const [mapping, setMapping] = useState<Record<string, string>>({});
  const [importJobId, setImportJobId] = useState<string | null>(null);
  const [selectedJobId, setSelectedJobId] = useState<string | null>(null);
  const [errorMessage, setErrorMessage] = useState("");

  const { data: organizations = [] } = useQuery({
    queryKey: ["organizations", "list"],
    queryFn: () => listOrganizations({ data: { includeArchived: true } }),
  });

  const { data: forms = [] } = useQuery({
    queryKey: ["forms", "list"],
    queryFn: () => listForms({ data: {} }),
  });

  const importForm = useAppForm({
    defaultValues: {
      organizationId: "",
      formId: "",
      lane: "interactive",
      mappingTemplateId: "",
      file: null as File | null,
    },
    onSubmit: async ({ value }) => {
      if (!sourceFileKey || !sourceFileHash || !importFileType) return;
      if (value.lane === "batch" && !value.mappingTemplateId) {
        setErrorMessage("Batch imports require a mapping template.");
        return;
      }

      const created = await createImportJob({
        data: {
          organizationId: value.organizationId,
          type: importFileType,
          lane: value.lane as "interactive" | "batch",
          sourceFileKey,
          sourceFileHash,
          sourceRowCount: rows.length,
          targetFormId: value.formId || undefined,
          mappingTemplateId: value.mappingTemplateId || undefined,
        },
      });

      if (created?.id) {
        setImportJobId(created.id);
        void queryClient.invalidateQueries({ queryKey: ["imports", "jobs"] });
      }
    },
  });

  const selectedOrganizationId = useStore(
    importForm.store,
    (state) => state.values.organizationId,
  );
  const selectedFormId = useStore(importForm.store, (state) => state.values.formId);
  const selectedLane = useStore(importForm.store, (state) => state.values.lane);
  const selectedTemplateId = useStore(
    importForm.store,
    (state) => state.values.mappingTemplateId,
  );
  const selectedFile = useStore(importForm.store, (state) => state.values.file);

  const { data: latestVersion } = useQuery({
    queryKey: ["forms", "latest", selectedFormId],
    queryFn: () =>
      selectedFormId ? getLatestFormVersion({ data: { formId: selectedFormId } }) : null,
    enabled: Boolean(selectedFormId),
  });

  const definition = latestVersion?.definition as FormDefinition | undefined;
  const fieldOptions = useMemo(
    () =>
      (definition?.fields ?? []).map((field) => ({
        value: field.key,
        label: field.label,
      })),
    [definition],
  );

  const { data: mappingTemplates = [] } = useQuery({
    queryKey: ["imports", "templates", selectedOrganizationId],
    queryFn: () =>
      listMappingTemplates({
        data: selectedOrganizationId ? { organizationId: selectedOrganizationId } : {},
      }),
    enabled: Boolean(selectedOrganizationId),
  });

  const { data: importJobs = [] } = useQuery({
    queryKey: ["imports", "jobs", selectedOrganizationId],
    queryFn: () =>
      listImportJobs({
        data: selectedOrganizationId ? { organizationId: selectedOrganizationId } : {},
      }),
    enabled: Boolean(selectedOrganizationId),
  });

  const { data: importErrors = [] } = useQuery({
    queryKey: ["imports", "errors", selectedJobId],
    queryFn: () =>
      selectedJobId ? listImportJobErrors({ data: { jobId: selectedJobId } }) : [],
    enabled: Boolean(selectedJobId),
  });

  const createTemplateMutation = useMutation({
    mutationFn: (payload: { name: string; description?: string }) =>
      createMappingTemplate({
        data: {
          organizationId: selectedOrganizationId || undefined,
          name: payload.name,
          description: payload.description,
          targetFormId: selectedFormId || undefined,
          mappings: mapping as JsonRecord,
        },
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: ["imports", "templates"] });
    },
  });

  const updateTemplateMutation = useMutation({
    mutationFn: () =>
      updateMappingTemplate({
        data: {
          templateId: selectedTemplateId,
          data: {
            organizationId: selectedOrganizationId || undefined,
            name:
              mappingTemplates.find((template) => template.id === selectedTemplateId)
                ?.name ?? "Template",
            mappings: mapping as JsonRecord,
            targetFormId: selectedFormId || undefined,
          },
        },
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: ["imports", "templates"] });
    },
  });

  const deleteTemplateMutation = useMutation({
    mutationFn: () =>
      deleteMappingTemplate({
        data: { templateId: selectedTemplateId },
      }),
    onSuccess: () => {
      importForm.setFieldValue("mappingTemplateId", "");
      void queryClient.invalidateQueries({ queryKey: ["imports", "templates"] });
    },
  });

  const runImportMutation = useMutation({
    mutationFn: () =>
      runInteractiveImport({
        data: {
          jobId: importJobId ?? "",
          formId: selectedFormId,
          mapping: mapping as JsonRecord,
          rows,
        },
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: ["imports", "jobs"] });
      void queryClient.invalidateQueries({ queryKey: ["imports", "errors"] });
    },
  });

  const runBatchMutation = useMutation({
    mutationFn: () =>
      runBatchImport({
        data: {
          jobId: importJobId ?? "",
        },
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: ["imports", "jobs"] });
      void queryClient.invalidateQueries({ queryKey: ["imports", "errors"] });
    },
  });

  const rollbackMutation = useMutation({
    mutationFn: (jobId: string) => rollbackImportJob({ data: { jobId } }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: ["imports", "jobs"] });
    },
  });

  useEffect(() => {
    if (!definition || headers.length === 0) return;
    // eslint-disable-next-line @eslint-react/hooks-extra/no-direct-set-state-in-use-effect
    setMapping((prev) => ({ ...autoMapHeaders(headers, definition.fields), ...prev }));
  }, [definition, headers]);

  useEffect(() => {
    if (!selectedTemplateId) return;
    const template = mappingTemplates.find((item) => item.id === selectedTemplateId);
    if (template?.mappings) {
      // eslint-disable-next-line @eslint-react/hooks-extra/no-direct-set-state-in-use-effect
      setMapping(template.mappings as Record<string, string>);
    }
  }, [mappingTemplates, selectedTemplateId]);

  useEffect(() => {
    if (!selectedFile || !selectedOrganizationId) return;

    const handleFile = async () => {
      try {
        setErrorMessage("");
        const { type, rows: parsedRows } = await parseImportFile(selectedFile);
        setImportFileType(type);
        setRows(parsedRows);
        setHeaders(parsedRows.length > 0 ? Object.keys(parsedRows[0]) : []);
        setMapping({});
        setImportJobId(null);
        setSourceFileKey(null);
        setSourceFileHash(null);

        const fileHash = await hashFile(selectedFile);
        const upload = await createImportUpload({
          data: {
            organizationId: selectedOrganizationId,
            fileName: selectedFile.name,
            mimeType: selectedFile.type || "application/octet-stream",
            sizeBytes: selectedFile.size,
          },
        });

        if (!upload?.uploadUrl || !upload.storageKey) {
          throw new Error("Upload URL not available.");
        }

        const response = await fetch(upload.uploadUrl, {
          method: "PUT",
          body: selectedFile,
          headers: {
            "Content-Type": selectedFile.type || "application/octet-stream",
          },
        });

        if (!response.ok) {
          throw new Error("Failed to upload file.");
        }

        setSourceFileKey(upload.storageKey);
        setSourceFileHash(fileHash);
      } catch (error) {
        setErrorMessage(error instanceof Error ? error.message : "Failed to parse file.");
      }
    };

    void handleFile();
  }, [selectedFile, selectedOrganizationId]);

  const previewRows = rows.slice(0, 10);
  const validationPreview = useMemo(() => {
    if (!definition) return [];
    const fieldLookup = new Map(definition.fields.map((field) => [field.key, field]));
    return previewRows.map((row, index) => {
      const payload = buildPayloadFromRow(row, mapping, fieldLookup);
      const validation = validateFormPayload(definition, payload);
      return {
        rowIndex: index + 1,
        missingFields: validation.missingFields,
        errors: validation.validationErrors,
      };
    });
  }, [definition, mapping, previewRows]);

  const validationErrorCount = validationPreview.reduce(
    (total, row) => total + row.errors.length + row.missingFields.length,
    0,
  );

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Import setup</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <form
            onSubmit={(event) => {
              event.preventDefault();
              void importForm.handleSubmit();
            }}
            className="space-y-4"
          >
            <div className="grid gap-3 md:grid-cols-2">
              <importForm.Field name="organizationId">
                {(field) => (
                  <ValidatedSelect
                    field={field}
                    label="Organization"
                    options={organizations.map((org) => ({
                      value: org.id,
                      label: org.name,
                    }))}
                    placeholderText="Select organization"
                  />
                )}
              </importForm.Field>
              <importForm.Field name="formId">
                {(field) => (
                  <ValidatedSelect
                    field={field}
                    label="Target form"
                    options={forms.map((form) => ({
                      value: form.id,
                      label: form.name,
                    }))}
                    placeholderText="Select form"
                  />
                )}
              </importForm.Field>
            </div>
            <div className="grid gap-3 md:grid-cols-2">
              <importForm.Field name="lane">
                {(field) => (
                  <ValidatedSelect
                    field={field}
                    label="Import lane"
                    options={laneOptions}
                    placeholderText="Select lane"
                  />
                )}
              </importForm.Field>
              <importForm.Field name="mappingTemplateId">
                {(field) => (
                  <ValidatedSelect
                    field={field}
                    label="Mapping template"
                    options={[
                      { value: "", label: "None" },
                      ...mappingTemplates.map((template) => ({
                        value: template.id,
                        label: template.name,
                      })),
                    ]}
                    placeholderText="Optional"
                  />
                )}
              </importForm.Field>
            </div>
            <importForm.Field name="file">
              {(field) => (
                <ValidatedFileUpload
                  field={field}
                  label="Source file"
                  accept=".csv,.xls,.xlsx"
                  helperText="Upload CSV or Excel. We'll parse the first sheet."
                />
              )}
            </importForm.Field>
            {errorMessage ? (
              <p className="text-destructive text-sm">{errorMessage}</p>
            ) : null}
            <FormSubmitButton
              disabled={
                !selectedOrganizationId ||
                !selectedFormId ||
                !sourceFileKey ||
                !sourceFileHash
              }
              isSubmitting={importForm.state.isSubmitting}
            >
              {importJobId ? "Import job created" : "Create import job"}
            </FormSubmitButton>
          </form>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Field mapping</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          {headers.length === 0 ? (
            <p className="text-muted-foreground text-sm">
              Upload a file to configure mappings.
            </p>
          ) : (
            <>
              <div className="flex flex-wrap items-center justify-between gap-3 text-sm">
                <div>
                  <p className="font-semibold">Columns detected: {headers.length}</p>
                  <p className="text-muted-foreground text-xs">
                    Auto-mapping applied based on column names.
                  </p>
                </div>
                <div className="flex flex-wrap items-center gap-2">
                  <Button
                    type="button"
                    variant="outline"
                    onClick={() => {
                      if (!definition) return;
                      setMapping(autoMapHeaders(headers, definition.fields));
                    }}
                  >
                    Re-run auto-map
                  </Button>
                  <Button
                    type="button"
                    variant="outline"
                    disabled={!selectedTemplateId || updateTemplateMutation.isPending}
                    onClick={() => updateTemplateMutation.mutate()}
                  >
                    Update template
                  </Button>
                  <Button
                    type="button"
                    variant="ghost"
                    disabled={!selectedTemplateId || deleteTemplateMutation.isPending}
                    onClick={() => deleteTemplateMutation.mutate()}
                  >
                    Delete template
                  </Button>
                </div>
              </div>

              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>Source column</TableHead>
                    <TableHead>Mapped field</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {headers.map((header) => (
                    <TableRow key={header}>
                      <TableCell className="text-xs">{header}</TableCell>
                      <TableCell className="text-xs">
                        <SelectField
                          options={fieldOptions}
                          value={mapping[header] ?? ""}
                          onChange={(value) =>
                            setMapping((prev) => ({ ...prev, [header]: value }))
                          }
                        />
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>

              <div className="rounded-md border border-gray-200 p-3 text-sm">
                <p className="font-semibold">Save mapping template</p>
                <MappingTemplateForm
                  onSubmit={(values) => {
                    const payload: { name: string; description?: string } = {
                      name: values.name,
                    };
                    if (values.description) {
                      payload.description = values.description;
                    }
                    createTemplateMutation.mutate(payload);
                  }}
                  isSubmitting={createTemplateMutation.isPending}
                />
              </div>
            </>
          )}
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Validation preview</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          {previewRows.length === 0 ? (
            <p className="text-muted-foreground text-sm">
              Upload a file to review validation.
            </p>
          ) : (
            <>
              <p className="text-muted-foreground text-sm">
                Showing first {previewRows.length} rows. Total errors:{" "}
                <strong>{validationErrorCount}</strong>
              </p>
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>Row</TableHead>
                    <TableHead>Errors</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {validationPreview.map((row) => (
                    <TableRow key={row.rowIndex}>
                      <TableCell className="text-xs">Row {row.rowIndex}</TableCell>
                      <TableCell className="text-xs">
                        {row.errors.length === 0 && row.missingFields.length === 0
                          ? "OK"
                          : [
                              ...row.errors.map((err) => err.message),
                              ...row.missingFields.map((field) => `${field}: required`),
                            ].join("; ")}
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>

              {selectedLane === "interactive" ? (
                <Button
                  type="button"
                  disabled={
                    !importJobId || !selectedFormId || runImportMutation.isPending
                  }
                  onClick={() => runImportMutation.mutate()}
                >
                  {runImportMutation.isPending ? "Importing..." : "Run import"}
                </Button>
              ) : (
                <Button
                  type="button"
                  disabled={!importJobId || runBatchMutation.isPending}
                  onClick={() => runBatchMutation.mutate()}
                >
                  {runBatchMutation.isPending ? "Importing..." : "Run batch import"}
                </Button>
              )}
            </>
          )}
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Import history</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          {importJobs.length === 0 ? (
            <p className="text-muted-foreground text-sm">No import jobs yet.</p>
          ) : (
            <div className="grid gap-2">
              {importJobs.map((job) => (
                <div
                  key={job.id}
                  className="flex flex-wrap items-center justify-between gap-2 rounded-md border border-gray-200 px-3 py-2 text-xs"
                >
                  <div>
                    <p className="font-semibold">{job.status}</p>
                    <p className="text-muted-foreground">
                      {job.type} Â· {new Date(job.createdAt).toLocaleString()}
                    </p>
                    {job.errorReportKey ? (
                      <p className="text-muted-foreground">
                        Error report: {job.errorReportKey}
                      </p>
                    ) : null}
                  </div>
                  <div className="flex items-center gap-2">
                    <Button
                      type="button"
                      size="sm"
                      variant="outline"
                      onClick={() => setSelectedJobId(job.id)}
                    >
                      View errors
                    </Button>
                    <Button
                      type="button"
                      size="sm"
                      variant="ghost"
                      disabled={
                        job.status === "rolled_back" || rollbackMutation.isPending
                      }
                      onClick={() => rollbackMutation.mutate(job.id)}
                    >
                      {rollbackMutation.isPending ? "Rolling back..." : "Rollback"}
                    </Button>
                  </div>
                </div>
              ))}
            </div>
          )}

          {selectedJobId ? (
            <div className="space-y-2">
              <p className="text-sm font-semibold">Import errors</p>
              {importErrors.length === 0 ? (
                <p className="text-muted-foreground text-sm">No errors recorded.</p>
              ) : (
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead>Row</TableHead>
                      <TableHead>Field</TableHead>
                      <TableHead>Message</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {importErrors.map((error) => (
                      <TableRow key={error.id}>
                        <TableCell className="text-xs">{error.rowNumber}</TableCell>
                        <TableCell className="text-xs">{error.fieldKey ?? "-"}</TableCell>
                        <TableCell className="text-xs">{error.errorMessage}</TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              )}
            </div>
          ) : null}
        </CardContent>
      </Card>
    </div>
  );
}

function SelectField(props: {
  options: Array<{ value: string; label: string }>;
  value: string;
  onChange: (value: string) => void;
}) {
  const effectiveValue = props.value || "__ignore__";
  return (
    <Select
      value={effectiveValue}
      onValueChange={(value) => props.onChange(value === "__ignore__" ? "" : value)}
    >
      <SelectTrigger className="h-8 w-48 text-xs">
        <SelectValue placeholder="Ignore" />
      </SelectTrigger>
      <SelectContent>
        <SelectItem value="__ignore__">Ignore</SelectItem>
        {props.options.map((option) => (
          <SelectItem key={option.value} value={option.value}>
            {option.label}
          </SelectItem>
        ))}
      </SelectContent>
    </Select>
  );
}

function MappingTemplateForm(props: {
  onSubmit: (values: { name: string; description?: string }) => void;
  isSubmitting: boolean;
}) {
  const form = useAppForm({
    defaultValues: {
      name: "",
      description: "",
    },
    onSubmit: async ({ value }) => {
      const payload: { name: string; description?: string } = { name: value.name };
      if (value.description.trim()) {
        payload.description = value.description.trim();
      }
      props.onSubmit(payload);
      form.reset();
    },
  });

  return (
    <form
      onSubmit={(event) => {
        event.preventDefault();
        void form.handleSubmit();
      }}
      className="space-y-2"
    >
      <form.Field name="name">
        {(field) => (
          <ValidatedInput
            field={field}
            label="Template name"
            placeholder="Default mapping"
          />
        )}
      </form.Field>
      <form.Field name="description">
        {(field) => (
          <div className="space-y-2">
            <Label>Template description</Label>
            <Textarea
              value={field.state.value}
              onChange={(event) => field.handleChange(event.target.value)}
            />
          </div>
        )}
      </form.Field>
      <FormSubmitButton isSubmitting={props.isSubmitting} loadingText="Saving...">
        Save template
      </FormSubmitButton>
    </form>
  );
}
</file>

<file path="src/features/imports/imports.mutations.ts">
import { createServerFn } from "@tanstack/react-start";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import type { FormDefinition } from "~/features/forms/forms.schemas";
import { sanitizePayload, validateFormPayload } from "~/features/forms/forms.utils";
import { forbidden, notFound, unauthorized } from "~/lib/server/errors";
import { zod$ } from "~/lib/server/fn-utils";
import type { JsonRecord } from "~/shared/lib/json";
import {
  createImportJobSchema,
  createImportUploadSchema,
  createMappingTemplateSchema,
  deleteMappingTemplateSchema,
  rollbackImportJobSchema,
  runBatchImportSchema,
  runInteractiveImportSchema,
  updateImportJobStatusSchema,
  updateMappingTemplateSchema,
} from "./imports.schemas";

const requireSessionUserId = async () => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const { getRequest } = await import("@tanstack/react-start/server");
  const auth = await getAuth();
  const { headers } = getRequest();
  const session = await auth.api.getSession({ headers });

  if (!session?.user?.id) {
    throw unauthorized("User not authenticated");
  }

  return session.user.id;
};

const requireOrgAccess = async (userId: string, organizationId: string) => {
  const { requireOrganizationAccess } = await import("~/lib/auth/guards/org-guard");
  return requireOrganizationAccess({ userId, organizationId });
};

export const createImportJob = createServerFn({ method: "POST" })
  .inputValidator(zod$(createImportJobSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_imports");
    const actorUserId = await requireSessionUserId();
    await requireOrgAccess(actorUserId, data.organizationId);
    const { getDb } = await import("~/db/server-helpers");
    const { importJobs } = await import("~/db/schema");

    const db = await getDb();
    const [created] = await db
      .insert(importJobs)
      .values({
        organizationId: data.organizationId,
        type: data.type,
        lane: data.lane,
        sourceFileKey: data.sourceFileKey,
        sourceFileHash: data.sourceFileHash,
        sourceRowCount: data.sourceRowCount ?? null,
        targetFormId: data.targetFormId ?? null,
        mappingTemplateId: data.mappingTemplateId ?? null,
        rollbackBefore: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
        createdBy: actorUserId,
      })
      .returning();

    if (created) {
      const { logDataChange } = await import("~/lib/audit");
      await logDataChange({
        action: "IMPORT_JOB_CREATE",
        actorUserId,
        targetType: "import_job",
        targetId: created.id,
        targetOrgId: created.organizationId,
      });
    }

    return created ?? null;
  });

export const updateImportJobStatus = createServerFn({ method: "POST" })
  .inputValidator(zod$(updateImportJobStatusSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_imports");
    const actorUserId = await requireSessionUserId();
    const { getDb } = await import("~/db/server-helpers");
    const { importJobs } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    const [existing] = await db
      .select({ organizationId: importJobs.organizationId })
      .from(importJobs)
      .where(eq(importJobs.id, data.jobId))
      .limit(1);

    if (!existing) {
      throw notFound("Import job not found");
    }

    await requireOrgAccess(actorUserId, existing.organizationId);

    const [updated] = await db
      .update(importJobs)
      .set({
        status: data.status,
        stats: data.stats ?? {},
        errorSummary: data.errorSummary ?? {},
      })
      .where(eq(importJobs.id, data.jobId))
      .returning();

    return updated ?? null;
  });

export const createMappingTemplate = createServerFn({ method: "POST" })
  .inputValidator(zod$(createMappingTemplateSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_imports");
    const actorUserId = await requireSessionUserId();
    if (data.organizationId) {
      await requireOrgAccess(actorUserId, data.organizationId);
    } else {
      const { PermissionService } = await import("~/features/roles/permission.service");
      const isAdmin = await PermissionService.isGlobalAdmin(actorUserId);
      if (!isAdmin) {
        throw forbidden("Global admin access required");
      }
    }
    const { getDb } = await import("~/db/server-helpers");
    const { importMappingTemplates } = await import("~/db/schema");

    const db = await getDb();
    const [created] = await db
      .insert(importMappingTemplates)
      .values({
        organizationId: data.organizationId ?? null,
        name: data.name,
        description: data.description ?? null,
        targetFormId: data.targetFormId ?? null,
        mappings: data.mappings,
        createdBy: actorUserId,
      })
      .returning();

    return created ?? null;
  });

export const updateMappingTemplate = createServerFn({ method: "POST" })
  .inputValidator(zod$(updateMappingTemplateSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_imports");
    const actorUserId = await requireSessionUserId();
    const { getDb } = await import("~/db/server-helpers");
    const { importMappingTemplates } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    const [existing] = await db
      .select()
      .from(importMappingTemplates)
      .where(eq(importMappingTemplates.id, data.templateId))
      .limit(1);

    if (!existing) {
      throw notFound("Mapping template not found");
    }

    if (existing.organizationId) {
      await requireOrgAccess(actorUserId, existing.organizationId);
    } else {
      const { PermissionService } = await import("~/features/roles/permission.service");
      const isAdmin = await PermissionService.isGlobalAdmin(actorUserId);
      if (!isAdmin) {
        throw forbidden("Global admin access required");
      }
    }

    const [updated] = await db
      .update(importMappingTemplates)
      .set({
        name: data.data.name ?? existing.name,
        description: data.data.description ?? existing.description,
        targetFormId: data.data.targetFormId ?? existing.targetFormId,
        mappings: data.data.mappings ?? existing.mappings,
      })
      .where(eq(importMappingTemplates.id, data.templateId))
      .returning();

    return updated ?? null;
  });

export const deleteMappingTemplate = createServerFn({ method: "POST" })
  .inputValidator(zod$(deleteMappingTemplateSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_imports");
    const actorUserId = await requireSessionUserId();
    const { getDb } = await import("~/db/server-helpers");
    const { importMappingTemplates } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    const [existing] = await db
      .select()
      .from(importMappingTemplates)
      .where(eq(importMappingTemplates.id, data.templateId))
      .limit(1);

    if (!existing) {
      throw notFound("Mapping template not found");
    }

    if (existing.organizationId) {
      await requireOrgAccess(actorUserId, existing.organizationId);
    } else {
      const { PermissionService } = await import("~/features/roles/permission.service");
      const isAdmin = await PermissionService.isGlobalAdmin(actorUserId);
      if (!isAdmin) {
        throw forbidden("Global admin access required");
      }
    }

    await db
      .delete(importMappingTemplates)
      .where(eq(importMappingTemplates.id, data.templateId));
    return { success: true };
  });

export const createImportUpload = createServerFn({ method: "POST" })
  .inputValidator(zod$(createImportUploadSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_imports");
    const actorUserId = await requireSessionUserId();
    await requireOrgAccess(actorUserId, data.organizationId);

    const { createId } = await import("@paralleldrive/cuid2");
    const { PutObjectCommand } = await import("@aws-sdk/client-s3");
    const { getSignedUrl } = await import("@aws-sdk/s3-request-presigner");
    const { getArtifactsBucketName, getS3Client } =
      await import("~/lib/storage/artifacts");

    const safeFileName = data.fileName.replace(/[^a-zA-Z0-9_.-]/g, "_");
    const storageKey = `imports/${data.organizationId}/${createId()}-${safeFileName}`;
    const bucket = await getArtifactsBucketName();
    const client = await getS3Client();

    const command = new PutObjectCommand({
      Bucket: bucket,
      Key: storageKey,
      ContentType: data.mimeType,
      ContentLength: data.sizeBytes,
    });

    const uploadUrl = await getSignedUrl(client, command, { expiresIn: 900 });

    const { logDataChange } = await import("~/lib/audit");
    await logDataChange({
      action: "IMPORT_UPLOAD_INIT",
      actorUserId,
      targetType: "import_job",
      targetOrgId: data.organizationId,
      metadata: { storageKey, fileName: data.fileName },
    });

    return { uploadUrl, storageKey };
  });

export const runInteractiveImport = createServerFn({ method: "POST" })
  .inputValidator(zod$(runInteractiveImportSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_imports");
    const actorUserId = await requireSessionUserId();
    const { getDb } = await import("~/db/server-helpers");
    const {
      formSubmissionVersions,
      formSubmissions,
      formVersions,
      importJobErrors,
      importJobs,
    } = await import("~/db/schema");
    const { desc, eq } = await import("drizzle-orm");

    const db = await getDb();
    const [job] = await db
      .select()
      .from(importJobs)
      .where(eq(importJobs.id, data.jobId))
      .limit(1);

    if (!job) {
      throw notFound("Import job not found");
    }

    await requireOrgAccess(actorUserId, job.organizationId);

    const [latestVersion] = await db
      .select()
      .from(formVersions)
      .where(eq(formVersions.formId, data.formId))
      .orderBy(desc(formVersions.versionNumber))
      .limit(1);

    if (!latestVersion) {
      throw notFound("Form has no published versions");
    }

    const definition = latestVersion.definition as FormDefinition;
    const fieldLookup = new Map(definition.fields.map((field) => [field.key, field]));

    const mapping = data.mapping as Record<string, string>;
    const errors: Array<{
      rowNumber: number;
      fieldKey: string | null;
      errorType: string;
      errorMessage: string;
      rawValue: string | null;
    }> = [];

    let inserted = 0;

    for (const [rowIndex, row] of data.rows.entries()) {
      const payload: JsonRecord = {};

      Object.entries(mapping).forEach(([sourceColumn, targetFieldKey]) => {
        if (!targetFieldKey) return;
        const field = fieldLookup.get(targetFieldKey);
        const rawValue = (row as JsonRecord)[sourceColumn];
        if (!field) return;

        if (field.type === "number") {
          payload[targetFieldKey] = rawValue === "" ? null : Number(rawValue);
          return;
        }

        if (field.type === "checkbox") {
          const normalized = String(rawValue).toLowerCase();
          payload[targetFieldKey] = ["true", "1", "yes", "y"].includes(normalized);
          return;
        }

        if (field.type === "multiselect") {
          payload[targetFieldKey] =
            typeof rawValue === "string" ? rawValue.split(",").map((v) => v.trim()) : [];
          return;
        }

        payload[targetFieldKey] = rawValue ?? null;
      });

      const sanitizedPayload = await sanitizePayload(definition, payload);
      const validation = validateFormPayload(definition, sanitizedPayload);

      if (validation.validationErrors.length > 0 || validation.missingFields.length > 0) {
        validation.validationErrors.forEach((error) => {
          errors.push({
            rowNumber: rowIndex + 1,
            fieldKey: error.field,
            errorType: "validation",
            errorMessage: error.message,
            rawValue: String(payload[error.field] ?? ""),
          });
        });
        validation.missingFields.forEach((fieldKey) => {
          errors.push({
            rowNumber: rowIndex + 1,
            fieldKey,
            errorType: "required",
            errorMessage: "Missing required field",
            rawValue: String(payload[fieldKey] ?? ""),
          });
        });
        continue;
      }

      const [submission] = await db
        .insert(formSubmissions)
        .values({
          formId: data.formId,
          formVersionId: latestVersion.id,
          organizationId: job.organizationId,
          submitterId: actorUserId,
          status: "submitted",
          payload: sanitizedPayload,
          completenessScore: validation.completenessScore,
          missingFields: validation.missingFields,
          validationErrors: validation.validationErrors,
          submittedAt: new Date(),
          importJobId: job.id,
        })
        .returning();

      if (submission) {
        inserted += 1;
        await db.insert(formSubmissionVersions).values({
          submissionId: submission.id,
          versionNumber: 1,
          payloadSnapshot: sanitizedPayload,
          changedBy: actorUserId,
          changeReason: "import",
        });
      }
    }

    if (errors.length > 0) {
      await db.insert(importJobErrors).values(
        errors.map((error) => ({
          jobId: job.id,
          rowNumber: error.rowNumber,
          fieldKey: error.fieldKey,
          errorType: error.errorType,
          errorMessage: error.errorMessage,
          rawValue: error.rawValue,
        })),
      );
    }

    const stats = {
      processed: data.rows.length,
      inserted,
      failed: errors.length,
    };

    await db
      .update(importJobs)
      .set({
        status: "completed",
        stats,
        errorSummary: errors.length > 0 ? { errors: errors.length } : {},
        completedAt: new Date(),
      })
      .where(eq(importJobs.id, job.id));

    const { logDataChange } = await import("~/lib/audit");
    await logDataChange({
      action: "IMPORT_JOB_COMPLETE",
      actorUserId,
      targetType: "import_job",
      targetId: job.id,
      targetOrgId: job.organizationId,
      metadata: stats,
    });

    return { success: true, stats, errorCount: errors.length };
  });

export const runBatchImport = createServerFn({ method: "POST" })
  .inputValidator(zod$(runBatchImportSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_imports");
    const actorUserId = await requireSessionUserId();
    const { runBatchImportJob } = await import("~/lib/imports/batch-runner");

    return runBatchImportJob({ jobId: data.jobId, actorUserId });
  });

export const rollbackImportJob = createServerFn({ method: "POST" })
  .inputValidator(zod$(rollbackImportJobSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_imports");
    const actorUserId = await requireSessionUserId();
    const { getDb } = await import("~/db/server-helpers");
    const { formSubmissions, importJobs } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    const [job] = await db
      .select()
      .from(importJobs)
      .where(eq(importJobs.id, data.jobId))
      .limit(1);

    if (!job) {
      throw notFound("Import job not found");
    }

    await requireOrgAccess(actorUserId, job.organizationId);

    if (job.canRollback === false) {
      throw forbidden("Rollback is disabled for this import.");
    }

    if (job.rollbackBefore && job.rollbackBefore < new Date()) {
      throw forbidden("Rollback window has expired.");
    }

    const deleted = await db
      .delete(formSubmissions)
      .where(eq(formSubmissions.importJobId, job.id))
      .returning();

    await db
      .update(importJobs)
      .set({
        status: "rolled_back",
        canRollback: false,
        completedAt: new Date(),
      })
      .where(eq(importJobs.id, job.id));

    const { logAdminAction } = await import("~/lib/audit");
    await logAdminAction({
      action: "IMPORT_JOB_ROLLBACK",
      actorUserId,
      targetType: "import_job",
      targetId: job.id,
      targetOrgId: job.organizationId,
      metadata: {
        deletedCount: deleted.length,
        reason: data.reason ?? null,
      },
    });

    return { success: true, deletedCount: deleted.length };
  });
</file>

<file path="src/features/imports/imports.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import { z } from "zod";
import { forbidden, notFound, unauthorized } from "~/lib/server/errors";
import { zod$ } from "~/lib/server/fn-utils";

const requireSessionUserId = async () => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const { getRequest } = await import("@tanstack/react-start/server");
  const auth = await getAuth();
  const { headers } = getRequest();
  const session = await auth.api.getSession({ headers });

  if (!session?.user?.id) {
    throw unauthorized("User not authenticated");
  }

  return session.user.id;
};

const requireOrgAccess = async (
  userId: string,
  organizationId: string | null | undefined,
) => {
  if (!organizationId) {
    const { PermissionService } = await import("~/features/roles/permission.service");
    const isAdmin = await PermissionService.isGlobalAdmin(userId);
    if (!isAdmin) {
      throw forbidden("Organization access required");
    }
    return null;
  }

  const { requireOrganizationAccess } = await import("~/lib/auth/guards/org-guard");
  return requireOrganizationAccess({ userId, organizationId });
};

const getImportJobSchema = z.object({
  jobId: z.uuid(),
});

const listImportJobsSchema = z
  .object({
    organizationId: z.uuid().optional(),
  })
  .nullish()
  .transform((value) => value ?? {});

const listMappingTemplatesSchema = z
  .object({
    organizationId: z.uuid().optional(),
  })
  .nullish()
  .transform((value) => value ?? {});

const listImportJobErrorsSchema = z.object({
  jobId: z.uuid(),
});

export const getImportJob = createServerFn({ method: "GET" })
  .inputValidator(zod$(getImportJobSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_imports");
    const userId = await requireSessionUserId();
    const { getDb } = await import("~/db/server-helpers");
    const { importJobs } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    const [job] = await db.select().from(importJobs).where(eq(importJobs.id, data.jobId));
    if (!job) return null;
    await requireOrgAccess(userId, job.organizationId);
    return job;
  });

export const listImportJobs = createServerFn({ method: "GET" })
  .inputValidator(zod$(listImportJobsSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_imports");
    const userId = await requireSessionUserId();
    const { getDb } = await import("~/db/server-helpers");
    const { importJobs, organizationMembers } = await import("~/db/schema");
    const { and, desc, eq, inArray, isNull, or } = await import("drizzle-orm");

    const db = await getDb();
    if (data.organizationId) {
      await requireOrgAccess(userId, data.organizationId);
      return db
        .select()
        .from(importJobs)
        .where(eq(importJobs.organizationId, data.organizationId))
        .orderBy(desc(importJobs.createdAt));
    }

    const memberships = await db
      .select({ organizationId: organizationMembers.organizationId })
      .from(organizationMembers)
      .where(
        and(
          eq(organizationMembers.userId, userId),
          eq(organizationMembers.status, "active"),
        ),
      );

    const orgIds = memberships.map((membership) => membership.organizationId);
    const { PermissionService } = await import("~/features/roles/permission.service");
    const isAdmin = await PermissionService.isGlobalAdmin(userId);

    if (!isAdmin && orgIds.length === 0) {
      return [];
    }

    if (isAdmin && orgIds.length === 0) {
      return db.select().from(importJobs).orderBy(desc(importJobs.createdAt));
    }

    const conditions = [];
    if (orgIds.length > 0) {
      conditions.push(inArray(importJobs.organizationId, orgIds));
    }
    if (isAdmin) {
      conditions.push(isNull(importJobs.organizationId));
    }

    return db
      .select()
      .from(importJobs)
      .where(conditions.length === 1 ? conditions[0] : or(...conditions))
      .orderBy(desc(importJobs.createdAt));
  });

export const listMappingTemplates = createServerFn({ method: "GET" })
  .inputValidator(zod$(listMappingTemplatesSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_imports");
    const userId = await requireSessionUserId();
    const { getDb } = await import("~/db/server-helpers");
    const { importMappingTemplates } = await import("~/db/schema");
    const { eq, isNull, or } = await import("drizzle-orm");

    const db = await getDb();

    if (data.organizationId) {
      await requireOrgAccess(userId, data.organizationId);
      return db
        .select()
        .from(importMappingTemplates)
        .where(
          or(
            eq(importMappingTemplates.organizationId, data.organizationId),
            isNull(importMappingTemplates.organizationId),
          ),
        );
    }

    const { PermissionService } = await import("~/features/roles/permission.service");
    const isAdmin = await PermissionService.isGlobalAdmin(userId);
    if (!isAdmin) {
      return db
        .select()
        .from(importMappingTemplates)
        .where(isNull(importMappingTemplates.organizationId));
    }

    return db.select().from(importMappingTemplates);
  });

export const listImportJobErrors = createServerFn({ method: "GET" })
  .inputValidator(zod$(listImportJobErrorsSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_imports");
    const userId = await requireSessionUserId();
    const { getDb } = await import("~/db/server-helpers");
    const { importJobErrors, importJobs } = await import("~/db/schema");
    const { desc, eq } = await import("drizzle-orm");

    const db = await getDb();
    const [job] = await db
      .select({ organizationId: importJobs.organizationId })
      .from(importJobs)
      .where(eq(importJobs.id, data.jobId))
      .limit(1);

    if (!job) {
      throw notFound("Import job not found");
    }

    await requireOrgAccess(userId, job.organizationId);

    return db
      .select()
      .from(importJobErrors)
      .where(eq(importJobErrors.jobId, data.jobId))
      .orderBy(desc(importJobErrors.rowNumber));
  });
</file>

<file path="src/features/imports/imports.schemas.ts">
import { z } from "zod";
import { jsonRecordSchema } from "~/shared/lib/json";

export const importTypeSchema = z.enum(["csv", "excel"]);
export const importLaneSchema = z.enum(["interactive", "batch"]);

export const createImportJobSchema = z.object({
  organizationId: z.uuid(),
  type: importTypeSchema,
  lane: importLaneSchema,
  sourceFileKey: z.string().min(1),
  sourceFileHash: z.string().min(1),
  sourceRowCount: z.number().int().optional(),
  targetFormId: z.uuid().optional(),
  mappingTemplateId: z.uuid().optional(),
});
export type CreateImportJobInput = z.infer<typeof createImportJobSchema>;

export const updateImportJobStatusSchema = z.object({
  jobId: z.uuid(),
  status: z.enum([
    "pending",
    "validating",
    "validated",
    "importing",
    "completed",
    "failed",
    "cancelled",
    "rolled_back",
  ]),
  stats: jsonRecordSchema.optional(),
  errorSummary: jsonRecordSchema.optional(),
});
export type UpdateImportJobStatusInput = z.infer<typeof updateImportJobStatusSchema>;

export const createMappingTemplateSchema = z.object({
  organizationId: z.uuid().optional(),
  name: z.string().min(1),
  description: z.string().optional(),
  targetFormId: z.uuid().optional(),
  mappings: jsonRecordSchema,
});
export type CreateMappingTemplateInput = z.infer<typeof createMappingTemplateSchema>;

export const createImportUploadSchema = z.object({
  organizationId: z.uuid(),
  fileName: z.string().min(1),
  mimeType: z.string().min(1),
  sizeBytes: z.number().int().positive(),
});
export type CreateImportUploadInput = z.infer<typeof createImportUploadSchema>;

export const runInteractiveImportSchema = z.object({
  jobId: z.uuid(),
  formId: z.uuid(),
  mapping: jsonRecordSchema,
  rows: z.array(jsonRecordSchema),
});
export type RunInteractiveImportInput = z.infer<typeof runInteractiveImportSchema>;

export const runBatchImportSchema = z.object({
  jobId: z.uuid(),
});
export type RunBatchImportInput = z.infer<typeof runBatchImportSchema>;

export const rollbackImportJobSchema = z.object({
  jobId: z.uuid(),
  reason: z.string().optional(),
});
export type RollbackImportJobInput = z.infer<typeof rollbackImportJobSchema>;

export const updateMappingTemplateSchema = z.object({
  templateId: z.uuid(),
  data: createMappingTemplateSchema.partial(),
});
export type UpdateMappingTemplateInput = z.infer<typeof updateMappingTemplateSchema>;

export const deleteMappingTemplateSchema = z.object({
  templateId: z.uuid(),
});
export type DeleteMappingTemplateInput = z.infer<typeof deleteMappingTemplateSchema>;
</file>

<file path="src/features/reporting/components/reporting-dashboard-shell.tsx">
import { useQuery, useQueryClient } from "@tanstack/react-query";
import { useCallback, useEffect, useMemo, useState } from "react";
import { toast } from "sonner";
import { FormSubmitButton } from "~/components/form-fields/FormSubmitButton";
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "~/components/ui/table";
import { Textarea } from "~/components/ui/textarea";
import { getStepUpErrorMessage, useStepUpPrompt } from "~/features/auth/step-up";
import { listForms } from "~/features/forms/forms.queries";
import { listOrganizations } from "~/features/organizations/organizations.queries";
import { useAppForm } from "~/lib/hooks/useAppForm";
import {
  createReportingCycle,
  createReportingTask,
  updateReportingSubmission,
} from "../reporting.mutations";
import {
  listReportingCycles,
  listReportingOverview,
  listReportingSubmissionHistory,
} from "../reporting.queries";

const organizationTypeOptions = [
  { value: "governing_body", label: "Governing body" },
  { value: "pso", label: "PSO" },
  { value: "league", label: "League" },
  { value: "club", label: "Club" },
  { value: "affiliate", label: "Affiliate" },
];

const submissionStatusOptions = [
  { value: "not_started", label: "Not started" },
  { value: "in_progress", label: "In progress" },
  { value: "submitted", label: "Submitted" },
  { value: "under_review", label: "Under review" },
  { value: "changes_requested", label: "Changes requested" },
  { value: "approved", label: "Approved" },
  { value: "overdue", label: "Overdue" },
  { value: "rejected", label: "Rejected" },
];

export function ReportingDashboardShell() {
  const queryClient = useQueryClient();
  const [selectedSubmissionId, setSelectedSubmissionId] = useState<string | null>(null);
  const { requestStepUp } = useStepUpPrompt();
  const handleStepUpError = useCallback(
    (error: unknown) => {
      const message = getStepUpErrorMessage(error);
      if (!message) return false;
      requestStepUp(message);
      return true;
    },
    [requestStepUp],
  );

  const { data: organizations = [] } = useQuery({
    queryKey: ["organizations", "list"],
    queryFn: () => listOrganizations({ data: { includeArchived: false } }),
  });

  const { data: forms = [] } = useQuery({
    queryKey: ["forms", "list"],
    queryFn: () => listForms({ data: {} }),
  });

  const { data: cycles = [] } = useQuery({
    queryKey: ["reporting", "cycles"],
    queryFn: () => listReportingCycles(),
  });

  const { data: overview = [] } = useQuery({
    queryKey: ["reporting", "overview"],
    queryFn: () => listReportingOverview({ data: {} }),
  });

  const { data: history = [] } = useQuery({
    queryKey: ["reporting", "history", selectedSubmissionId],
    queryFn: () =>
      selectedSubmissionId
        ? listReportingSubmissionHistory({ data: { submissionId: selectedSubmissionId } })
        : [],
    enabled: Boolean(selectedSubmissionId),
  });

  const selectedSubmission = useMemo(
    () => overview.find((item) => item.submissionId === selectedSubmissionId) ?? null,
    [overview, selectedSubmissionId],
  );

  const cycleForm = useAppForm({
    defaultValues: {
      name: "",
      description: "",
      startDate: "",
      endDate: "",
    },
    onSubmit: async ({ value }) => {
      try {
        const created = await createReportingCycle({
          data: {
            name: value.name,
            description: value.description || undefined,
            startDate: value.startDate,
            endDate: value.endDate,
          },
        });

        if (created) {
          cycleForm.reset();
          await queryClient.invalidateQueries({ queryKey: ["reporting", "cycles"] });
        }
      } catch (error) {
        if (handleStepUpError(error)) return;
        const message =
          error instanceof Error ? error.message : "Failed to create reporting cycle.";
        toast.error(message);
      }
    },
  });

  const taskForm = useAppForm({
    defaultValues: {
      cycleId: "",
      formId: "",
      organizationId: "__all__",
      organizationType: "__all__",
      title: "",
      description: "",
      dueDate: "",
      reminderDays: "14,7,3,1",
    },
    onSubmit: async ({ value }) => {
      try {
        const reminderDays = value.reminderDays
          .split(",")
          .map((entry) => Number(entry.trim()))
          .filter((entry) => !Number.isNaN(entry));

        const created = await createReportingTask({
          data: {
            cycleId: value.cycleId,
            formId: value.formId,
            organizationId:
              value.organizationId === "__all__" ? undefined : value.organizationId,
            organizationType:
              value.organizationType === "__all__" ? undefined : value.organizationType,
            title: value.title,
            description: value.description || undefined,
            dueDate: value.dueDate,
            reminderConfig: { days_before: reminderDays },
          },
        });

        if (created) {
          taskForm.reset();
          await queryClient.invalidateQueries({ queryKey: ["reporting", "overview"] });
        }
      } catch (error) {
        if (handleStepUpError(error)) return;
        const message =
          error instanceof Error ? error.message : "Failed to create reporting task.";
        toast.error(message);
      }
    },
  });

  const reviewForm = useAppForm({
    defaultValues: {
      status: "",
      reviewNotes: "",
      formSubmissionId: "",
      formSubmissionVersionId: "",
    },
    onSubmit: async ({ value }) => {
      if (!selectedSubmission) return;
      try {
        await updateReportingSubmission({
          data: {
            submissionId: selectedSubmission.submissionId,
            status: value.status,
            reviewNotes: value.reviewNotes || undefined,
            formSubmissionId: value.formSubmissionId || undefined,
            formSubmissionVersionId: value.formSubmissionVersionId || undefined,
          },
        });
        await queryClient.invalidateQueries({ queryKey: ["reporting", "overview"] });
        await queryClient.invalidateQueries({ queryKey: ["reporting", "history"] });
      } catch (error) {
        if (handleStepUpError(error)) return;
        const message =
          error instanceof Error
            ? error.message
            : "Failed to update reporting submission.";
        toast.error(message);
      }
    },
  });

  useEffect(() => {
    if (selectedSubmission) {
      reviewForm.reset({
        status: selectedSubmission.status,
        reviewNotes: "",
        formSubmissionId: selectedSubmission.formSubmissionId ?? "",
        formSubmissionVersionId: "",
      });
    }
  }, [reviewForm, selectedSubmission]);

  const overdueIds = useMemo(() => {
    const now = new Date();
    return new Set(
      overview
        .filter((item) => new Date(item.dueDate) < now && item.status !== "submitted")
        .map((item) => item.submissionId),
    );
  }, [overview]);

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Create reporting cycle</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <form
            onSubmit={(event) => {
              event.preventDefault();
              event.stopPropagation();
              void cycleForm.handleSubmit();
            }}
            className="space-y-3"
          >
            <div className="grid gap-3 md:grid-cols-2">
              <cycleForm.Field name="name">
                {(field) => (
                  <Input
                    placeholder="Cycle name"
                    value={(field.state.value as string) ?? ""}
                    onChange={(event) => field.handleChange(event.target.value)}
                    onBlur={field.handleBlur}
                  />
                )}
              </cycleForm.Field>
              <cycleForm.Field name="description">
                {(field) => (
                  <Input
                    placeholder="Description (optional)"
                    value={(field.state.value as string) ?? ""}
                    onChange={(event) => field.handleChange(event.target.value)}
                    onBlur={field.handleBlur}
                  />
                )}
              </cycleForm.Field>
            </div>
            <div className="grid gap-3 md:grid-cols-2">
              <cycleForm.Field name="startDate">
                {(field) => (
                  <Input
                    type="date"
                    value={(field.state.value as string) ?? ""}
                    onChange={(event) => field.handleChange(event.target.value)}
                    onBlur={field.handleBlur}
                  />
                )}
              </cycleForm.Field>
              <cycleForm.Field name="endDate">
                {(field) => (
                  <Input
                    type="date"
                    value={(field.state.value as string) ?? ""}
                    onChange={(event) => field.handleChange(event.target.value)}
                    onBlur={field.handleBlur}
                  />
                )}
              </cycleForm.Field>
            </div>
            <FormSubmitButton className="w-fit">Create cycle</FormSubmitButton>
          </form>
          <div className="space-y-1 text-sm">
            {cycles.length === 0 ? (
              <p className="text-muted-foreground">No cycles yet.</p>
            ) : (
              cycles.map((cycle) => (
                <div key={cycle.id} className="flex items-center justify-between">
                  <span className="font-semibold">{cycle.name}</span>
                  <span className="text-muted-foreground text-xs">
                    {new Date(cycle.startDate).toLocaleDateString()} â{" "}
                    {new Date(cycle.endDate).toLocaleDateString()}
                  </span>
                </div>
              ))
            )}
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Assign reporting task</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <form
            onSubmit={(event) => {
              event.preventDefault();
              event.stopPropagation();
              void taskForm.handleSubmit();
            }}
            className="space-y-3"
          >
            <div className="grid gap-3 md:grid-cols-2">
              <taskForm.Field name="cycleId">
                {(field) => (
                  <Select value={field.state.value} onValueChange={field.handleChange}>
                    <SelectTrigger>
                      <SelectValue placeholder="Cycle" />
                    </SelectTrigger>
                    <SelectContent>
                      {cycles.map((cycle) => (
                        <SelectItem key={cycle.id} value={cycle.id}>
                          {cycle.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                )}
              </taskForm.Field>
              <taskForm.Field name="formId">
                {(field) => (
                  <Select value={field.state.value} onValueChange={field.handleChange}>
                    <SelectTrigger>
                      <SelectValue placeholder="Form" />
                    </SelectTrigger>
                    <SelectContent>
                      {forms.map((form) => (
                        <SelectItem key={form.id} value={form.id}>
                          {form.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                )}
              </taskForm.Field>
            </div>
            <div className="grid gap-3 md:grid-cols-2">
              <taskForm.Field name="organizationId">
                {(field) => (
                  <Select value={field.state.value} onValueChange={field.handleChange}>
                    <SelectTrigger>
                      <SelectValue placeholder="Specific organization (optional)" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="__all__">All organizations</SelectItem>
                      {organizations.map((org) => (
                        <SelectItem key={org.id} value={org.id}>
                          {org.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                )}
              </taskForm.Field>
              <taskForm.Field name="organizationType">
                {(field) => (
                  <Select value={field.state.value} onValueChange={field.handleChange}>
                    <SelectTrigger>
                      <SelectValue placeholder="Organization type (optional)" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="__all__">All types</SelectItem>
                      {organizationTypeOptions.map((option) => (
                        <SelectItem key={option.value} value={option.value}>
                          {option.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                )}
              </taskForm.Field>
            </div>
            <div className="grid gap-3 md:grid-cols-2">
              <taskForm.Field name="title">
                {(field) => (
                  <Input
                    placeholder="Task title"
                    value={(field.state.value as string) ?? ""}
                    onChange={(event) => field.handleChange(event.target.value)}
                    onBlur={field.handleBlur}
                  />
                )}
              </taskForm.Field>
              <taskForm.Field name="dueDate">
                {(field) => (
                  <Input
                    type="date"
                    value={(field.state.value as string) ?? ""}
                    onChange={(event) => field.handleChange(event.target.value)}
                    onBlur={field.handleBlur}
                  />
                )}
              </taskForm.Field>
            </div>
            <taskForm.Field name="description">
              {(field) => (
                <Textarea
                  rows={2}
                  placeholder="Description (optional)"
                  value={(field.state.value as string) ?? ""}
                  onChange={(event) => field.handleChange(event.target.value)}
                  onBlur={field.handleBlur}
                />
              )}
            </taskForm.Field>
            <taskForm.Field name="reminderDays">
              {(field) => (
                <Input
                  placeholder="Reminder days before due date (comma-separated)"
                  value={(field.state.value as string) ?? ""}
                  onChange={(event) => field.handleChange(event.target.value)}
                  onBlur={field.handleBlur}
                />
              )}
            </taskForm.Field>
            <FormSubmitButton className="w-fit">Create task</FormSubmitButton>
          </form>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Reporting submissions</CardTitle>
        </CardHeader>
        <CardContent className="grid gap-6 lg:grid-cols-[2fr_1fr]">
          <div className="space-y-3">
            {overview.length === 0 ? (
              <p className="text-muted-foreground text-sm">No submissions yet.</p>
            ) : (
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>Organization</TableHead>
                    <TableHead>Task</TableHead>
                    <TableHead>Due</TableHead>
                    <TableHead>Status</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {overview.map((item) => (
                    <TableRow
                      key={item.submissionId}
                      className={`cursor-pointer ${overdueIds.has(item.submissionId) ? "bg-red-50" : ""}`}
                      onClick={() => setSelectedSubmissionId(item.submissionId)}
                    >
                      <TableCell className="text-xs font-semibold">
                        {item.organizationName}
                      </TableCell>
                      <TableCell className="text-xs">{item.taskTitle}</TableCell>
                      <TableCell className="text-xs">
                        {new Date(item.dueDate).toLocaleDateString()}
                      </TableCell>
                      <TableCell className="text-xs">{item.status}</TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            )}
          </div>

          <div className="space-y-3">
            {selectedSubmission ? (
              <Card>
                <CardHeader>
                  <CardTitle className="text-base">Review submission</CardTitle>
                </CardHeader>
                <CardContent className="space-y-3">
                  <div className="text-muted-foreground space-y-1 text-xs">
                    <p>Organization: {selectedSubmission.organizationName}</p>
                    <p>Task: {selectedSubmission.taskTitle}</p>
                    <p>Cycle: {selectedSubmission.cycleName}</p>
                  </div>
                  <form
                    onSubmit={(event) => {
                      event.preventDefault();
                      event.stopPropagation();
                      void reviewForm.handleSubmit();
                    }}
                    className="space-y-3"
                  >
                    <reviewForm.Field name="status">
                      {(field) => (
                        <Select
                          value={field.state.value}
                          onValueChange={field.handleChange}
                        >
                          <SelectTrigger>
                            <SelectValue placeholder="Status" />
                          </SelectTrigger>
                          <SelectContent>
                            {submissionStatusOptions.map((option) => (
                              <SelectItem key={option.value} value={option.value}>
                                {option.label}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                      )}
                    </reviewForm.Field>
                    <reviewForm.Field name="reviewNotes">
                      {(field) => (
                        <Textarea
                          rows={3}
                          placeholder="Review notes (optional)"
                          value={(field.state.value as string) ?? ""}
                          onChange={(event) => field.handleChange(event.target.value)}
                          onBlur={field.handleBlur}
                        />
                      )}
                    </reviewForm.Field>
                    <reviewForm.Field name="formSubmissionId">
                      {(field) => (
                        <Input
                          placeholder="Form submission ID (optional)"
                          value={(field.state.value as string) ?? ""}
                          onChange={(event) => field.handleChange(event.target.value)}
                          onBlur={field.handleBlur}
                        />
                      )}
                    </reviewForm.Field>
                    <reviewForm.Field name="formSubmissionVersionId">
                      {(field) => (
                        <Input
                          placeholder="Submission version ID (optional)"
                          value={(field.state.value as string) ?? ""}
                          onChange={(event) => field.handleChange(event.target.value)}
                          onBlur={field.handleBlur}
                        />
                      )}
                    </reviewForm.Field>
                    <FormSubmitButton className="w-full">Update status</FormSubmitButton>
                  </form>

                  <div>
                    <Label className="text-sm font-semibold">History</Label>
                    {history.length === 0 ? (
                      <p className="text-muted-foreground text-xs">No history yet.</p>
                    ) : (
                      <div className="mt-2 space-y-2 text-xs">
                        {history.map((entry) => (
                          <div key={entry.id} className="flex justify-between">
                            <span>{entry.action}</span>
                            <span className="text-muted-foreground">
                              {new Date(entry.createdAt).toLocaleDateString()}
                            </span>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                </CardContent>
              </Card>
            ) : (
              <div className="text-muted-foreground text-sm">
                Select a submission to review.
              </div>
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/features/reporting/reporting.mutations.ts">
import { createServerFn } from "@tanstack/react-start";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import { zod$ } from "~/lib/server/fn-utils";
import {
  createReportingCycleSchema,
  createReportingTaskSchema,
  updateReportingSubmissionSchema,
} from "./reporting.schemas";

const getSession = async () => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const { getRequest } = await import("@tanstack/react-start/server");
  const auth = await getAuth();
  const { headers } = getRequest();
  const session = await auth.api.getSession({ headers });
  return session ?? null;
};

const requireSession = async () => {
  const session = await getSession();
  const { unauthorized } = await import("~/lib/server/errors");
  if (!session?.user?.id) {
    throw unauthorized("User not authenticated");
  }
  return session;
};

const requireGlobalAdmin = async (userId: string) => {
  const { forbidden } = await import("~/lib/server/errors");
  const { PermissionService } = await import("~/features/roles/permission.service");
  const isAdmin = await PermissionService.isGlobalAdmin(userId);
  if (!isAdmin) {
    throw forbidden("Global admin access required");
  }
};

export const createReportingCycle = createServerFn({ method: "POST" })
  .inputValidator(zod$(createReportingCycleSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_reporting");
    const session = await requireSession();
    const actorUserId = session.user.id;
    await requireGlobalAdmin(actorUserId);

    const { requireRecentAuth } = await import("~/lib/auth/guards/step-up");
    await requireRecentAuth(actorUserId, session);

    const { getDb } = await import("~/db/server-helpers");
    const { reportingCycles } = await import("~/db/schema");

    const db = await getDb();
    const [created] = await db
      .insert(reportingCycles)
      .values({
        name: data.name,
        description: data.description ?? null,
        startDate: data.startDate,
        endDate: data.endDate,
        createdBy: actorUserId,
      })
      .returning();

    if (created) {
      const { logAdminAction } = await import("~/lib/audit");
      await logAdminAction({
        action: "REPORTING_CYCLE_CREATE",
        actorUserId,
        targetType: "reporting_cycle",
        targetId: created.id,
      });
    }

    return created ?? null;
  });

export const createReportingTask = createServerFn({ method: "POST" })
  .inputValidator(zod$(createReportingTaskSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_reporting");
    const session = await requireSession();
    const actorUserId = session.user.id;
    await requireGlobalAdmin(actorUserId);

    const { requireRecentAuth } = await import("~/lib/auth/guards/step-up");
    await requireRecentAuth(actorUserId, session);

    const { getDb } = await import("~/db/server-helpers");
    const {
      notificationTemplates,
      organizationMembers,
      organizations,
      reportingSubmissions,
      reportingTasks,
    } = await import("~/db/schema");
    const { and, eq, inArray } = await import("drizzle-orm");

    const db = await getDb();
    const [created] = await db
      .insert(reportingTasks)
      .values({
        cycleId: data.cycleId,
        formId: data.formId,
        organizationId: data.organizationId ?? null,
        organizationType: data.organizationType ?? null,
        title: data.title,
        description: data.description ?? null,
        dueDate: data.dueDate,
        reminderConfig: data.reminderConfig ?? {},
      })
      .returning();

    if (created) {
      const targetOrgs = data.organizationId
        ? await db
            .select({ id: organizations.id, name: organizations.name })
            .from(organizations)
            .where(eq(organizations.id, data.organizationId))
        : await db
            .select({ id: organizations.id, name: organizations.name })
            .from(organizations)
            .where(
              and(
                eq(organizations.status, "active"),
                ...(data.organizationType
                  ? [eq(organizations.type, data.organizationType)]
                  : []),
              ),
            );

      if (targetOrgs.length > 0) {
        const defaultStatus: (typeof reportingSubmissions.$inferInsert)["status"] =
          "not_started";
        await db.insert(reportingSubmissions).values(
          targetOrgs.map((org) => ({
            taskId: created.id,
            organizationId: org.id,
            status: defaultStatus,
          })),
        );
      }

      const templateKey = "reporting_reminder";
      const [template] = await db
        .select()
        .from(notificationTemplates)
        .where(eq(notificationTemplates.key, templateKey))
        .limit(1);

      if (!template) {
        await db.insert(notificationTemplates).values({
          key: templateKey,
          category: "reporting",
          subject: "Reporting reminder: {{title}} due {{dueDate}}",
          bodyTemplate:
            'Your reporting task "{{title}}" for {{orgName}} is due on {{dueDate}}.',
          isSystem: true,
          createdBy: actorUserId,
        });
      }

      const reminderConfig = data.reminderConfig ?? {};
      const daysBeforeRaw = Array.isArray(reminderConfig["days_before"])
        ? reminderConfig["days_before"]
        : Array.isArray(reminderConfig["daysBefore"])
          ? reminderConfig["daysBefore"]
          : [14, 7, 3, 1];
      const daysBefore = daysBeforeRaw
        .map((value) => Number(value))
        .filter((value) => !Number.isNaN(value));
      const dueDate = new Date(data.dueDate);

      const { scheduleNotification } = await import("~/lib/notifications/scheduler");
      const notifyRoles: Array<"owner" | "admin" | "reporter"> = [
        "owner",
        "admin",
        "reporter",
      ];

      for (const org of targetOrgs) {
        const members = await db
          .select({
            userId: organizationMembers.userId,
            role: organizationMembers.role,
          })
          .from(organizationMembers)
          .where(
            and(
              eq(organizationMembers.organizationId, org.id),
              eq(organizationMembers.status, "active"),
              inArray(organizationMembers.role, notifyRoles),
            ),
          );

        for (const member of members) {
          for (const offset of daysBefore) {
            const scheduledFor = new Date(
              dueDate.getTime() - Number(offset) * 24 * 60 * 60 * 1000,
            );
            if (scheduledFor <= new Date()) continue;

            await scheduleNotification({
              templateKey,
              userId: member.userId,
              organizationId: org.id,
              scheduledFor,
              variables: {
                title: data.title,
                dueDate: dueDate.toDateString(),
                orgName: org.name,
              },
            });
          }
        }
      }

      const { logAdminAction } = await import("~/lib/audit");
      await logAdminAction({
        action: "REPORTING_TASK_CREATE",
        actorUserId,
        targetType: "reporting_task",
        targetId: created.id,
      });
    }

    return created ?? null;
  });

export const updateReportingSubmission = createServerFn({ method: "POST" })
  .inputValidator(zod$(updateReportingSubmissionSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_reporting");
    const session = await requireSession();
    const actorUserId = session.user.id;
    const { getDb } = await import("~/db/server-helpers");
    const { reportingSubmissionHistory, reportingSubmissions } =
      await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();

    // Load submission first so we can enforce org-scoped authorization
    const [existing] = await db
      .select({
        id: reportingSubmissions.id,
        organizationId: reportingSubmissions.organizationId,
      })
      .from(reportingSubmissions)
      .where(eq(reportingSubmissions.id, data.submissionId))
      .limit(1);

    if (!existing) {
      return null;
    }

    const { PermissionService } = await import("~/features/roles/permission.service");
    const isGlobalAdmin = await PermissionService.isGlobalAdmin(actorUserId);

    if (!isGlobalAdmin) {
      const { requireOrganizationAccess, ORG_ADMIN_ROLES } =
        await import("~/lib/auth/guards/org-guard");

      const reviewStatuses = new Set([
        "under_review",
        "changes_requested",
        "approved",
        "rejected",
      ]);
      const adminOnlyStatuses = new Set(["overdue", ...reviewStatuses]);

      if (adminOnlyStatuses.has(data.status)) {
        await requireOrganizationAccess(
          { userId: actorUserId, organizationId: existing.organizationId },
          { roles: ORG_ADMIN_ROLES },
        );
      } else {
        await requireOrganizationAccess(
          { userId: actorUserId, organizationId: existing.organizationId },
          { roles: ["owner", "admin", "reporter"] },
        );
      }
    }

    const isReviewStatus = [
      "under_review",
      "changes_requested",
      "approved",
      "rejected",
    ].includes(data.status);
    const isSubmitStatus = data.status === "submitted";

    const [updated] = await db
      .update(reportingSubmissions)
      .set({
        status: data.status,
        ...(isSubmitStatus ? { submittedAt: new Date(), submittedBy: actorUserId } : {}),
        ...(isReviewStatus
          ? {
              reviewedBy: actorUserId,
              reviewedAt: new Date(),
              reviewNotes: data.reviewNotes ?? null,
            }
          : {}),
        ...(data.formSubmissionId ? { formSubmissionId: data.formSubmissionId } : {}),
      })
      .where(eq(reportingSubmissions.id, data.submissionId))
      .returning();

    if (!updated) {
      return null;
    }

    await db.insert(reportingSubmissionHistory).values({
      reportingSubmissionId: updated.id,
      action: data.status,
      actorId: actorUserId,
      notes: data.reviewNotes ?? null,
      formSubmissionVersionId: data.formSubmissionVersionId ?? null,
    });

    const { logDataChange } = await import("~/lib/audit");
    await logDataChange({
      action: "REPORTING_SUBMISSION_UPDATE",
      actorUserId,
      targetType: "reporting_submission",
      targetId: updated.id,
      targetOrgId: updated.organizationId,
    });

    return updated;
  });
</file>

<file path="src/features/reporting/reporting.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import { z } from "zod";
import { zod$ } from "~/lib/server/fn-utils";
import { reportingSubmissionStatusSchema } from "./reporting.schemas";

const getSessionUserId = async () => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const { getRequest } = await import("@tanstack/react-start/server");
  const auth = await getAuth();
  const { headers } = getRequest();
  const session = await auth.api.getSession({ headers });
  return session?.user?.id ?? null;
};

const listReportingTasksSchema = z
  .object({
    cycleId: z.uuid().optional(),
    organizationId: z.uuid().optional(),
  })
  .nullish()
  .transform((value) => value ?? {});

const listReportingOverviewSchema = z
  .object({
    organizationId: z.uuid().optional(),
    status: reportingSubmissionStatusSchema.optional(),
  })
  .nullish()
  .transform((value) => value ?? {});

const listReportingSubmissionHistorySchema = z.object({
  submissionId: z.uuid(),
});

export const listReportingCycles = createServerFn({ method: "GET" }).handler(async () => {
  await assertFeatureEnabled("sin_reporting");
  const { getDb } = await import("~/db/server-helpers");
  const { reportingCycles } = await import("~/db/schema");
  const { desc } = await import("drizzle-orm");

  const db = await getDb();
  return db.select().from(reportingCycles).orderBy(desc(reportingCycles.createdAt));
});

export const listReportingTasks = createServerFn({ method: "GET" })
  .inputValidator(zod$(listReportingTasksSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_reporting");
    const { getDb } = await import("~/db/server-helpers");
    const { reportingTasks } = await import("~/db/schema");
    const { and, eq } = await import("drizzle-orm");

    const db = await getDb();
    const conditions = [];

    if (data.cycleId) {
      conditions.push(eq(reportingTasks.cycleId, data.cycleId));
    }

    if (data.organizationId) {
      const userId = await getSessionUserId();
      if (userId) {
        const { requireOrganizationAccess } =
          await import("~/lib/auth/guards/org-guard");
        await requireOrganizationAccess({
          userId,
          organizationId: data.organizationId,
        });
      }
      conditions.push(eq(reportingTasks.organizationId, data.organizationId));
    }

    return db
      .select()
      .from(reportingTasks)
      .where(conditions.length ? and(...conditions) : undefined);
  });

export const listReportingSubmissions = createServerFn({ method: "GET" })
  .inputValidator(
    zod$(
      z.object({
        organizationId: z.uuid(),
      }),
    ),
  )
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_reporting");
    const { getDb } = await import("~/db/server-helpers");
    const { reportingSubmissions } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const userId = await getSessionUserId();
    if (userId) {
      const { requireOrganizationAccess } =
        await import("~/lib/auth/guards/org-guard");
      await requireOrganizationAccess({
        userId,
        organizationId: data.organizationId,
      });
    }

    const db = await getDb();
    return db
      .select()
      .from(reportingSubmissions)
      .where(eq(reportingSubmissions.organizationId, data.organizationId));
  });

export const listReportingOverview = createServerFn({ method: "GET" })
  .inputValidator(zod$(listReportingOverviewSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_reporting");
    const userId = await getSessionUserId();
    if (!userId) return [];

    const { getDb } = await import("~/db/server-helpers");
    const {
      organizationMembers,
      organizations,
      reportingCycles,
      reportingSubmissions,
      reportingTasks,
    } = await import("~/db/schema");
    const { and, eq, inArray } = await import("drizzle-orm");
    const db = await getDb();

    let orgIds: string[] = [];
    const { PermissionService } = await import("~/features/roles/permission.service");
    const isAdmin = await PermissionService.isGlobalAdmin(userId);

    if (data.organizationId) {
      const { requireOrganizationAccess } =
        await import("~/lib/auth/guards/org-guard");
      await requireOrganizationAccess({
        userId,
        organizationId: data.organizationId,
      });
      orgIds = [data.organizationId];
    } else if (!isAdmin) {
      const memberships = await db
        .select({ organizationId: organizationMembers.organizationId })
        .from(organizationMembers)
        .where(
          and(
            eq(organizationMembers.userId, userId),
            eq(organizationMembers.status, "active"),
          ),
        );

      orgIds = memberships.map((membership) => membership.organizationId);
      if (orgIds.length === 0) return [];
    }

    const conditions = [];
    if (orgIds.length > 0) {
      conditions.push(inArray(reportingSubmissions.organizationId, orgIds));
    }
    if (data.status) {
      conditions.push(eq(reportingSubmissions.status, data.status));
    }

    return db
      .select({
        submissionId: reportingSubmissions.id,
        status: reportingSubmissions.status,
        submittedAt: reportingSubmissions.submittedAt,
        dueDate: reportingTasks.dueDate,
        taskTitle: reportingTasks.title,
        taskId: reportingTasks.id,
        cycleId: reportingCycles.id,
        cycleName: reportingCycles.name,
        organizationId: organizations.id,
        organizationName: organizations.name,
        formId: reportingTasks.formId,
        formSubmissionId: reportingSubmissions.formSubmissionId,
      })
      .from(reportingSubmissions)
      .innerJoin(reportingTasks, eq(reportingSubmissions.taskId, reportingTasks.id))
      .innerJoin(reportingCycles, eq(reportingTasks.cycleId, reportingCycles.id))
      .innerJoin(organizations, eq(reportingSubmissions.organizationId, organizations.id))
      .where(conditions.length ? and(...conditions) : undefined);
  });

export const listReportingSubmissionHistory = createServerFn({ method: "GET" })
  .inputValidator(zod$(listReportingSubmissionHistorySchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_reporting");
    const userId = await getSessionUserId();
    if (!userId) return [];

    const { getDb } = await import("~/db/server-helpers");
    const { organizationMembers, reportingSubmissionHistory, reportingSubmissions } =
      await import("~/db/schema");
    const { and, eq } = await import("drizzle-orm");
    const db = await getDb();

    const [submission] = await db
      .select({
        organizationId: reportingSubmissions.organizationId,
      })
      .from(reportingSubmissions)
      .where(eq(reportingSubmissions.id, data.submissionId))
      .limit(1);

    if (!submission) return [];

    const { PermissionService } = await import("~/features/roles/permission.service");
    const isAdmin = await PermissionService.isGlobalAdmin(userId);
    if (!isAdmin) {
      const [membership] = await db
        .select()
        .from(organizationMembers)
        .where(
          and(
            eq(organizationMembers.userId, userId),
            eq(organizationMembers.organizationId, submission.organizationId),
          ),
        )
        .limit(1);
      if (!membership) return [];
    }

    return db
      .select()
      .from(reportingSubmissionHistory)
      .where(eq(reportingSubmissionHistory.reportingSubmissionId, data.submissionId));
  });
</file>

<file path="src/features/reporting/reporting.schemas.ts">
import { z } from "zod";
import { jsonRecordSchema } from "~/shared/lib/json";

export const reportingCycleStatusSchema = z.enum([
  "upcoming",
  "active",
  "closed",
  "archived",
]);

export const reportingSubmissionStatusSchema = z.enum([
  "not_started",
  "in_progress",
  "submitted",
  "under_review",
  "changes_requested",
  "approved",
  "overdue",
]);

export const reportingOrganizationTypeSchema = z.enum([
  "governing_body",
  "pso",
  "league",
  "club",
  "affiliate",
]);

export const createReportingCycleSchema = z.object({
  name: z.string().min(1),
  description: z.string().optional(),
  startDate: z.string().min(1),
  endDate: z.string().min(1),
});
export type CreateReportingCycleInput = z.infer<typeof createReportingCycleSchema>;

export const createReportingTaskSchema = z.object({
  cycleId: z.uuid(),
  formId: z.uuid(),
  organizationId: z.uuid().optional(),
  organizationType: reportingOrganizationTypeSchema.optional(),
  title: z.string().min(1),
  description: z.string().optional(),
  dueDate: z.string().min(1),
  reminderConfig: jsonRecordSchema.optional(),
});
export type CreateReportingTaskInput = z.infer<typeof createReportingTaskSchema>;

export const updateReportingSubmissionSchema = z.object({
  submissionId: z.uuid(),
  status: reportingSubmissionStatusSchema,
  reviewNotes: z.string().optional(),
  formSubmissionId: z.uuid().optional(),
  formSubmissionVersionId: z.uuid().optional(),
});
export type UpdateReportingSubmissionInput = z.infer<
  typeof updateReportingSubmissionSchema
>;
</file>

<file path="src/features/reports/components/report-builder-shell.tsx">
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { useCallback, useMemo, useState } from "react";
import { toast } from "sonner";
import { FormSubmitButton } from "~/components/form-fields/FormSubmitButton";
import { Button } from "~/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";
import { Checkbox } from "~/components/ui/checkbox";
import { Input } from "~/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "~/components/ui/table";
import { Textarea } from "~/components/ui/textarea";
import { getStepUpErrorMessage, useStepUpPrompt } from "~/features/auth/step-up";
import { listOrganizations } from "~/features/organizations/organizations.queries";
import { useAppForm } from "~/lib/hooks/useAppForm";
import {
  createSavedReport,
  deleteSavedReport,
  exportReport,
  updateSavedReport,
} from "../reports.mutations";
import { listSavedReports } from "../reports.queries";

const dataSourceOptions = [
  { value: "organizations", label: "Organizations" },
  { value: "reporting_submissions", label: "Reporting submissions" },
  { value: "form_submissions", label: "Form submissions" },
];

const exportTypeOptions = [
  { value: "csv", label: "CSV" },
  { value: "excel", label: "Excel" },
  { value: "pdf", label: "PDF" },
];

const parseJsonInput = (value: string) => {
  if (!value.trim()) return undefined;
  try {
    return JSON.parse(value) as Record<string, unknown>;
  } catch {
    return null;
  }
};

const parseListInput = (value: string) =>
  value
    .split(",")
    .map((entry) => entry.trim())
    .filter(Boolean);

function SavedReportRow({
  report,
  onUpdated,
  onDeleted,
}: {
  report: {
    id: string;
    name: string;
    description: string | null;
    dataSource: string;
    organizationId: string | null;
    sharedWith: string[] | null;
    isOrgWide: boolean;
    filters: Record<string, unknown>;
    columns: string[] | null;
    sort: Record<string, unknown> | null;
  };
  onUpdated: () => void;
  onDeleted: () => void;
}) {
  const [isEditing, setIsEditing] = useState(false);
  const form = useAppForm({
    defaultValues: {
      name: report.name,
      description: report.description ?? "",
      dataSource: report.dataSource,
      organizationId: report.organizationId ?? "",
      sharedWith: report.sharedWith?.join(", ") ?? "",
      isOrgWide: report.isOrgWide,
      filters: JSON.stringify(report.filters ?? {}, null, 2),
      columns: report.columns?.join(", ") ?? "",
      sort: JSON.stringify(report.sort ?? {}, null, 2),
    },
    onSubmit: async ({ value }) => {
      const filters = parseJsonInput(value.filters);
      const sort = parseJsonInput(value.sort);
      if (filters === null || sort === null) {
        toast.error("Filters or sort JSON is invalid.");
        return;
      }

      const updated = await updateSavedReport({
        data: {
          reportId: report.id,
          data: {
            name: value.name,
            description: value.description || undefined,
            dataSource: value.dataSource,
            organizationId: value.organizationId || undefined,
            sharedWith: parseListInput(value.sharedWith),
            isOrgWide: value.isOrgWide,
            filters: filters ?? undefined,
            columns: parseListInput(value.columns),
            sort: sort ?? undefined,
          },
        },
      });

      if (updated) {
        toast.success("Report updated.");
        setIsEditing(false);
        onUpdated();
      } else {
        toast.error("Failed to update report.");
      }
    },
  });

  return (
    <>
      <TableRow>
        <TableCell className="text-xs font-semibold">{report.name}</TableCell>
        <TableCell className="text-xs">{report.dataSource}</TableCell>
        <TableCell className="text-xs">
          {report.isOrgWide ? "Org-wide" : "Private"}
        </TableCell>
        <TableCell className="text-right">
          <div className="flex items-center justify-end gap-2">
            <Button
              type="button"
              size="sm"
              variant="outline"
              onClick={() => setIsEditing((prev) => !prev)}
            >
              {isEditing ? "Close" : "Edit"}
            </Button>
            <Button type="button" size="sm" variant="ghost" onClick={onDeleted}>
              Delete
            </Button>
          </div>
        </TableCell>
      </TableRow>
      {isEditing ? (
        <TableRow>
          <TableCell colSpan={4} className="pt-4">
            <form
              onSubmit={(event) => {
                event.preventDefault();
                event.stopPropagation();
                void form.handleSubmit();
              }}
              className="space-y-3"
            >
              <div className="grid gap-3 md:grid-cols-2">
                <form.Field name="name">
                  {(field) => (
                    <Input
                      placeholder="Report name"
                      value={(field.state.value as string) ?? ""}
                      onChange={(event) => field.handleChange(event.target.value)}
                      onBlur={field.handleBlur}
                    />
                  )}
                </form.Field>
                <form.Field name="dataSource">
                  {(field) => (
                    <Select value={field.state.value} onValueChange={field.handleChange}>
                      <SelectTrigger>
                        <SelectValue placeholder="Data source" />
                      </SelectTrigger>
                      <SelectContent>
                        {dataSourceOptions.map((option) => (
                          <SelectItem key={option.value} value={option.value}>
                            {option.label}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  )}
                </form.Field>
              </div>
              <form.Field name="description">
                {(field) => (
                  <Input
                    placeholder="Description (optional)"
                    value={(field.state.value as string) ?? ""}
                    onChange={(event) => field.handleChange(event.target.value)}
                    onBlur={field.handleBlur}
                  />
                )}
              </form.Field>
              <div className="grid gap-3 md:grid-cols-2">
                <form.Field name="organizationId">
                  {(field) => (
                    <Input
                      placeholder="Organization ID (optional)"
                      value={(field.state.value as string) ?? ""}
                      onChange={(event) => field.handleChange(event.target.value)}
                      onBlur={field.handleBlur}
                    />
                  )}
                </form.Field>
                <form.Field name="sharedWith">
                  {(field) => (
                    <Input
                      placeholder="Share with (comma-separated IDs)"
                      value={(field.state.value as string) ?? ""}
                      onChange={(event) => field.handleChange(event.target.value)}
                      onBlur={field.handleBlur}
                    />
                  )}
                </form.Field>
              </div>
              <form.Field name="filters">
                {(field) => (
                  <Textarea
                    rows={3}
                    placeholder='Filters JSON (e.g., {"status":"active"})'
                    value={(field.state.value as string) ?? ""}
                    onChange={(event) => field.handleChange(event.target.value)}
                    onBlur={field.handleBlur}
                  />
                )}
              </form.Field>
              <div className="grid gap-3 md:grid-cols-2">
                <form.Field name="columns">
                  {(field) => (
                    <Input
                      placeholder="Columns (comma-separated)"
                      value={(field.state.value as string) ?? ""}
                      onChange={(event) => field.handleChange(event.target.value)}
                      onBlur={field.handleBlur}
                    />
                  )}
                </form.Field>
                <form.Field name="sort">
                  {(field) => (
                    <Textarea
                      rows={3}
                      placeholder='Sort JSON (e.g., {"created_at":"desc"})'
                      value={(field.state.value as string) ?? ""}
                      onChange={(event) => field.handleChange(event.target.value)}
                      onBlur={field.handleBlur}
                    />
                  )}
                </form.Field>
              </div>
              <form.Field name="isOrgWide">
                {(field) => (
                  <label className="flex items-center gap-2 text-sm">
                    <Checkbox
                      checked={Boolean(field.state.value)}
                      onCheckedChange={(checked) => field.handleChange(Boolean(checked))}
                    />
                    Org-wide (share with all org members)
                  </label>
                )}
              </form.Field>
              <FormSubmitButton className="w-fit">Save changes</FormSubmitButton>
            </form>
          </TableCell>
        </TableRow>
      ) : null}
    </>
  );
}

export function ReportBuilderShell() {
  const queryClient = useQueryClient();
  const { requestStepUp } = useStepUpPrompt();
  const handleStepUpError = useCallback(
    (error: unknown) => {
      const message = getStepUpErrorMessage(error);
      if (!message) return false;
      requestStepUp(message);
      return true;
    },
    [requestStepUp],
  );
  const { data: organizations = [] } = useQuery({
    queryKey: ["organizations", "list"],
    queryFn: () => listOrganizations({ data: { includeArchived: false } }),
  });
  const { data: reports = [] } = useQuery({
    queryKey: ["reports", "saved"],
    queryFn: () => listSavedReports({ data: {} }),
  });

  const exportMutation = useMutation({
    mutationFn: exportReport,
    onSuccess: (result, variables) => {
      if (!result?.data) return;
      const exportType =
        typeof variables === "object" && variables && "data" in variables
          ? (variables as { data?: { exportType?: "csv" | "excel" | "pdf" } }).data
              ?.exportType
          : undefined;
      const extension = exportType === "pdf" ? "pdf" : "csv";
      const blob = new Blob([result.data], {
        type: exportType === "pdf" ? "application/pdf" : "text/csv",
      });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = `report-export.${extension}`;
      link.click();
      URL.revokeObjectURL(url);
    },
    onError: (error) => {
      if (handleStepUpError(error)) return;
      const message = error instanceof Error ? error.message : "Failed to export report.";
      toast.error(message);
    },
  });

  const createForm = useAppForm({
    defaultValues: {
      name: "",
      description: "",
      dataSource: "",
      organizationId: "__all__",
      sharedWith: "",
      isOrgWide: false,
      filters: "",
      columns: "",
      sort: "",
    },
    onSubmit: async ({ value }) => {
      const filters = parseJsonInput(value.filters);
      const sort = parseJsonInput(value.sort);
      if (filters === null || sort === null) {
        toast.error("Filters or sort JSON is invalid.");
        return;
      }

      const created = await createSavedReport({
        data: {
          name: value.name,
          description: value.description || undefined,
          dataSource: value.dataSource,
          organizationId:
            value.organizationId === "__all__" ? undefined : value.organizationId,
          sharedWith: parseListInput(value.sharedWith),
          isOrgWide: value.isOrgWide,
          filters: filters ?? undefined,
          columns: parseListInput(value.columns),
          sort: sort ?? undefined,
        },
      });

      if (created) {
        toast.success("Report saved.");
        createForm.reset();
        await queryClient.invalidateQueries({ queryKey: ["reports", "saved"] });
      } else {
        toast.error("Failed to save report.");
      }
    },
  });

  const exportForm = useAppForm({
    defaultValues: {
      dataSource: "",
      exportType: "csv",
      filters: "",
      columns: "",
    },
    onSubmit: async ({ value }) => {
      const filters = parseJsonInput(value.filters);
      if (filters === null) {
        toast.error("Filters JSON is invalid.");
        return;
      }

      exportMutation.mutate({
        data: {
          dataSource: value.dataSource,
          exportType: value.exportType as "csv" | "excel" | "pdf",
          filters: filters ?? undefined,
          columns: parseListInput(value.columns),
        },
      });
    },
  });

  const normalizedReports = useMemo(() => reports, [reports]);

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Export data</CardTitle>
        </CardHeader>
        <CardContent>
          <form
            onSubmit={(event) => {
              event.preventDefault();
              event.stopPropagation();
              void exportForm.handleSubmit();
            }}
            className="space-y-3"
          >
            <div className="grid gap-3 md:grid-cols-2">
              <exportForm.Field name="dataSource">
                {(field) => (
                  <Select value={field.state.value} onValueChange={field.handleChange}>
                    <SelectTrigger>
                      <SelectValue placeholder="Data source" />
                    </SelectTrigger>
                    <SelectContent>
                      {dataSourceOptions.map((option) => (
                        <SelectItem key={option.value} value={option.value}>
                          {option.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                )}
              </exportForm.Field>
              <exportForm.Field name="exportType">
                {(field) => (
                  <Select value={field.state.value} onValueChange={field.handleChange}>
                    <SelectTrigger>
                      <SelectValue placeholder="Export type" />
                    </SelectTrigger>
                    <SelectContent>
                      {exportTypeOptions.map((option) => (
                        <SelectItem key={option.value} value={option.value}>
                          {option.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                )}
              </exportForm.Field>
            </div>
            <exportForm.Field name="columns">
              {(field) => (
                <Input
                  placeholder="Columns (comma-separated)"
                  value={(field.state.value as string) ?? ""}
                  onChange={(event) => field.handleChange(event.target.value)}
                  onBlur={field.handleBlur}
                />
              )}
            </exportForm.Field>
            <exportForm.Field name="filters">
              {(field) => (
                <Textarea
                  rows={3}
                  placeholder='Filters JSON (e.g., {"status":"active"})'
                  value={(field.state.value as string) ?? ""}
                  onChange={(event) => field.handleChange(event.target.value)}
                  onBlur={field.handleBlur}
                />
              )}
            </exportForm.Field>
            <FormSubmitButton className="w-fit">
              {exportMutation.isPending ? "Exporting..." : "Export"}
            </FormSubmitButton>
          </form>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Saved reports</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          {normalizedReports.length === 0 ? (
            <p className="text-muted-foreground text-sm">No saved reports yet.</p>
          ) : (
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Name</TableHead>
                  <TableHead>Source</TableHead>
                  <TableHead>Sharing</TableHead>
                  <TableHead className="text-right">Actions</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {normalizedReports.map((report) => (
                  <SavedReportRow
                    key={report.id}
                    report={report}
                    onUpdated={() =>
                      queryClient.invalidateQueries({ queryKey: ["reports", "saved"] })
                    }
                    onDeleted={async () => {
                      await deleteSavedReport({ data: { reportId: report.id } });
                      await queryClient.invalidateQueries({
                        queryKey: ["reports", "saved"],
                      });
                    }}
                  />
                ))}
              </TableBody>
            </Table>
          )}
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Create saved report</CardTitle>
        </CardHeader>
        <CardContent>
          <form
            onSubmit={(event) => {
              event.preventDefault();
              event.stopPropagation();
              void createForm.handleSubmit();
            }}
            className="space-y-3"
          >
            <div className="grid gap-3 md:grid-cols-2">
              <createForm.Field name="name">
                {(field) => (
                  <Input
                    placeholder="Report name"
                    value={(field.state.value as string) ?? ""}
                    onChange={(event) => field.handleChange(event.target.value)}
                    onBlur={field.handleBlur}
                  />
                )}
              </createForm.Field>
              <createForm.Field name="dataSource">
                {(field) => (
                  <Select value={field.state.value} onValueChange={field.handleChange}>
                    <SelectTrigger>
                      <SelectValue placeholder="Data source" />
                    </SelectTrigger>
                    <SelectContent>
                      {dataSourceOptions.map((option) => (
                        <SelectItem key={option.value} value={option.value}>
                          {option.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                )}
              </createForm.Field>
            </div>
            <createForm.Field name="description">
              {(field) => (
                <Input
                  placeholder="Description (optional)"
                  value={(field.state.value as string) ?? ""}
                  onChange={(event) => field.handleChange(event.target.value)}
                  onBlur={field.handleBlur}
                />
              )}
            </createForm.Field>
            <div className="grid gap-3 md:grid-cols-2">
              <createForm.Field name="organizationId">
                {(field) => (
                  <Select value={field.state.value} onValueChange={field.handleChange}>
                    <SelectTrigger>
                      <SelectValue placeholder="Organization scope" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="__all__">All organizations</SelectItem>
                      {organizations.map((org) => (
                        <SelectItem key={org.id} value={org.id}>
                          {org.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                )}
              </createForm.Field>
              <createForm.Field name="sharedWith">
                {(field) => (
                  <Input
                    placeholder="Share with (comma-separated IDs)"
                    value={(field.state.value as string) ?? ""}
                    onChange={(event) => field.handleChange(event.target.value)}
                    onBlur={field.handleBlur}
                  />
                )}
              </createForm.Field>
            </div>
            <createForm.Field name="filters">
              {(field) => (
                <Textarea
                  rows={3}
                  placeholder='Filters JSON (e.g., {"status":"active"})'
                  value={(field.state.value as string) ?? ""}
                  onChange={(event) => field.handleChange(event.target.value)}
                  onBlur={field.handleBlur}
                />
              )}
            </createForm.Field>
            <div className="grid gap-3 md:grid-cols-2">
              <createForm.Field name="columns">
                {(field) => (
                  <Input
                    placeholder="Columns (comma-separated)"
                    value={(field.state.value as string) ?? ""}
                    onChange={(event) => field.handleChange(event.target.value)}
                    onBlur={field.handleBlur}
                  />
                )}
              </createForm.Field>
              <createForm.Field name="sort">
                {(field) => (
                  <Textarea
                    rows={3}
                    placeholder='Sort JSON (e.g., {"created_at":"desc"})'
                    value={(field.state.value as string) ?? ""}
                    onChange={(event) => field.handleChange(event.target.value)}
                    onBlur={field.handleBlur}
                  />
                )}
              </createForm.Field>
            </div>
            <createForm.Field name="isOrgWide">
              {(field) => (
                <label className="flex items-center gap-2 text-sm">
                  <Checkbox
                    checked={Boolean(field.state.value)}
                    onCheckedChange={(checked) => field.handleChange(Boolean(checked))}
                  />
                  Org-wide (share with all org members)
                </label>
              )}
            </createForm.Field>
            <FormSubmitButton className="w-fit">Save report</FormSubmitButton>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/features/reports/reports.mutations.ts">
import { createServerFn } from "@tanstack/react-start";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import { zod$ } from "~/lib/server/fn-utils";
import {
  createSavedReportSchema,
  deleteSavedReportSchema,
  exportReportSchema,
  updateSavedReportSchema,
} from "./reports.schemas";

const SENSITIVE_FIELDS = [
  "email",
  "phone",
  "dateOfBirth",
  "emergencyContact",
  "emergencyContactPhone",
  "emergencyContactEmail",
];

const extractPermissionSet = (
  roleAssignments: Array<{ role?: { permissions?: Record<string, boolean> } }>,
) => {
  const permissions = new Set<string>();
  for (const assignment of roleAssignments) {
    const perms = assignment.role?.permissions ?? {};
    for (const [key, value] of Object.entries(perms)) {
      if (value) permissions.add(key);
    }
  }
  return permissions;
};

const canViewSensitiveFields = ({
  isGlobalAdmin,
  orgRole,
  permissions,
}: {
  isGlobalAdmin: boolean;
  orgRole: string | null;
  permissions: Set<string>;
}) => {
  if (isGlobalAdmin) return true;
  if (permissions.has("*")) return true;
  if (
    permissions.has("pii.read") ||
    permissions.has("pii:read") ||
    permissions.has("data.pii.read")
  ) {
    return true;
  }

  // Default: org owners/admins can view sensitive fields *within their org scope*
  if (orgRole && ["owner", "admin"].includes(orgRole)) return true;

  return false;
};

const applyFieldLevelAcl = (
  rows: Array<Record<string, unknown>>,
  opts: { canViewSensitiveFields: boolean },
) => {
  if (opts.canViewSensitiveFields) return rows;
  return rows.map((row) => {
    const next = { ...row };
    for (const field of SENSITIVE_FIELDS) {
      if (Object.prototype.hasOwnProperty.call(next, field)) {
        next[field] = "***";
      }
    }
    return next;
  });
};

const getSession = async () => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const { getRequest } = await import("@tanstack/react-start/server");
  const auth = await getAuth();
  const { headers } = getRequest();
  const session = await auth.api.getSession({ headers });
  return session ?? null;
};

const getSessionUser = async () => {
  const session = await getSession();
  return session?.user ?? null;
};

const loadReportData = async ({
  dataSource,
  organizationId,
  isGlobalAdmin,
}: {
  dataSource: string;
  organizationId: string | null;
  isGlobalAdmin: boolean;
}) => {
  const { getDb } = await import("~/db/server-helpers");
  const { organizations, reportingSubmissions, formSubmissions } =
    await import("~/db/schema");
  const { eq } = await import("drizzle-orm");

  const db = await getDb();
  if (dataSource === "organizations") {
    if (isGlobalAdmin && !organizationId) return db.select().from(organizations);
    if (!organizationId) return [];
    return db.select().from(organizations).where(eq(organizations.id, organizationId));
  }

  if (dataSource === "reporting_submissions") {
    if (isGlobalAdmin && !organizationId) return db.select().from(reportingSubmissions);
    if (!organizationId) return [];
    return db
      .select()
      .from(reportingSubmissions)
      .where(eq(reportingSubmissions.organizationId, organizationId));
  }

  if (dataSource === "form_submissions") {
    if (isGlobalAdmin && !organizationId) return db.select().from(formSubmissions);
    if (!organizationId) return [];
    return db
      .select()
      .from(formSubmissions)
      .where(eq(formSubmissions.organizationId, organizationId));
  }

  return [];
};

export const createSavedReport = createServerFn({ method: "POST" })
  .inputValidator(zod$(createSavedReportSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_analytics");
    const sessionUser = await getSessionUser();
    if (!sessionUser?.id) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { savedReports } = await import("~/db/schema");

    const db = await getDb();
    const [created] = await db
      .insert(savedReports)
      .values({
        organizationId: data.organizationId ?? null,
        name: data.name,
        description: data.description ?? null,
        dataSource: data.dataSource,
        filters: data.filters ?? {},
        columns: data.columns ?? [],
        sort: data.sort ?? {},
        ownerId: sessionUser.id,
        sharedWith: data.sharedWith ?? [],
        isOrgWide: data.isOrgWide ?? false,
      })
      .returning();

    if (created) {
      const { logDataChange } = await import("~/lib/audit");
      await logDataChange({
        action: "REPORT_SAVE",
        actorUserId: sessionUser.id,
        targetType: "saved_report",
        targetId: created.id,
        targetOrgId: created.organizationId ?? null,
      });
    }

    return created ?? null;
  });

export const updateSavedReport = createServerFn({ method: "POST" })
  .inputValidator(zod$(updateSavedReportSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_analytics");
    const sessionUser = await getSessionUser();
    if (!sessionUser?.id) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { savedReports } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    const [existing] = await db
      .select()
      .from(savedReports)
      .where(eq(savedReports.id, data.reportId))
      .limit(1);

    if (!existing) return null;

    if (existing.ownerId !== sessionUser.id) {
      const { PermissionService } = await import("~/features/roles/permission.service");
      const isAdmin = await PermissionService.isGlobalAdmin(sessionUser.id);
      if (!isAdmin) return null;
    }

    const [updated] = await db
      .update(savedReports)
      .set({
        organizationId: data.data.organizationId ?? existing.organizationId,
        name: data.data.name ?? existing.name,
        description: data.data.description ?? existing.description,
        dataSource: data.data.dataSource ?? existing.dataSource,
        filters: data.data.filters ?? existing.filters,
        columns: data.data.columns ?? existing.columns,
        sort: data.data.sort ?? existing.sort,
        sharedWith: data.data.sharedWith ?? existing.sharedWith,
        isOrgWide: data.data.isOrgWide ?? existing.isOrgWide,
      })
      .where(eq(savedReports.id, data.reportId))
      .returning();

    if (updated) {
      const { logDataChange } = await import("~/lib/audit");
      await logDataChange({
        action: "REPORT_UPDATE",
        actorUserId: sessionUser.id,
        targetType: "saved_report",
        targetId: updated.id,
        targetOrgId: updated.organizationId ?? null,
      });
    }

    return updated ?? null;
  });

export const deleteSavedReport = createServerFn({ method: "POST" })
  .inputValidator(zod$(deleteSavedReportSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_analytics");
    const sessionUser = await getSessionUser();
    if (!sessionUser?.id) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { savedReports } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    const [existing] = await db
      .select()
      .from(savedReports)
      .where(eq(savedReports.id, data.reportId))
      .limit(1);

    if (!existing) return null;

    if (existing.ownerId !== sessionUser.id) {
      const { PermissionService } = await import("~/features/roles/permission.service");
      const isAdmin = await PermissionService.isGlobalAdmin(sessionUser.id);
      if (!isAdmin) return null;
    }

    await db.delete(savedReports).where(eq(savedReports.id, data.reportId));

    const { logDataChange } = await import("~/lib/audit");
    await logDataChange({
      action: "REPORT_DELETE",
      actorUserId: sessionUser.id,
      targetType: "saved_report",
      targetId: data.reportId,
      targetOrgId: existing.organizationId ?? null,
    });

    return { success: true };
  });

export const exportReport = createServerFn({ method: "POST" })
  .inputValidator(zod$(exportReportSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_analytics");
    const session = await getSession();
    const sessionUser = session?.user ?? null;
    if (!sessionUser?.id) return null;

    const { requireRecentAuth } = await import("~/lib/auth/guards/step-up");
    await requireRecentAuth(sessionUser.id, session);

    const { toCsv } = await import("~/shared/lib/csv");
    const { exportHistory } = await import("~/db/schema");
    const { getDb } = await import("~/db/server-helpers");
    const { PermissionService } = await import("~/features/roles/permission.service");
    const db = await getDb();

    const { forbidden } = await import("~/lib/server/errors");
    const isGlobalAdmin = await PermissionService.isGlobalAdmin(sessionUser.id);

    const { getRequest } = await import("@tanstack/react-start/server");
    const request = getRequest();
    const orgIdFromHeader = request.headers.get("x-organization-id");
    const filtersRecord = data.filters as Record<string, unknown> | undefined;
    const orgIdValue = filtersRecord?.["organizationId"];
    const orgIdFromFilters = typeof orgIdValue === "string" ? orgIdValue : null;
    const scopedOrganizationId = orgIdFromHeader ?? orgIdFromFilters ?? null;

    let orgRole: string | null = null;
    if (!isGlobalAdmin) {
      if (!scopedOrganizationId) {
        throw forbidden("Organization context required");
      }

      const { requireOrganizationMembership } =
        await import("~/lib/auth/guards/org-guard");
      const membership = await requireOrganizationMembership({
        userId: sessionUser.id,
        organizationId: scopedOrganizationId,
      });
      orgRole = membership.role;
    }

    const roleAssignments = await PermissionService.getUserRoles(sessionUser.id);
    const permissions = extractPermissionSet(
      roleAssignments as Array<{ role?: { permissions?: Record<string, boolean> } }>,
    );
    const canViewPii = canViewSensitiveFields({
      isGlobalAdmin,
      orgRole,
      permissions,
    });

    const rows = await loadReportData({
      dataSource: data.dataSource,
      organizationId: scopedOrganizationId,
      isGlobalAdmin,
    });

    const filteredRows = applyFieldLevelAcl(rows as Array<Record<string, unknown>>, {
      canViewSensitiveFields: canViewPii,
    });

    const exportPayload =
      data.exportType === "csv" || data.exportType === "excel"
        ? toCsv(filteredRows)
        : JSON.stringify(filteredRows);

    await db.insert(exportHistory).values({
      userId: sessionUser.id,
      organizationId: scopedOrganizationId,
      reportId: null,
      exportType: data.exportType,
      dataSource: data.dataSource,
      filtersUsed: data.filters ?? {},
      rowCount: filteredRows.length,
      fileKey: null,
    });

    const { logExportEvent } = await import("~/lib/audit");
    await logExportEvent({
      action: "REPORT_EXPORT",
      actorUserId: sessionUser.id,
      metadata: {
        type: data.exportType,
        rows: filteredRows.length,
        organizationId: scopedOrganizationId,
        dataSource: data.dataSource,
      },
    });

    return { data: exportPayload };
  });
</file>

<file path="src/features/reports/reports.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import { z } from "zod";
import { zod$ } from "~/lib/server/fn-utils";

const listSavedReportsSchema = z
  .object({
    organizationId: z.uuid().optional(),
  })
  .nullish()
  .transform((value) => value ?? {});

export const listSavedReports = createServerFn({ method: "GET" })
  .inputValidator(zod$(listSavedReportsSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_analytics");
    const { getDb } = await import("~/db/server-helpers");
    const { savedReports } = await import("~/db/schema");
    const { eq, or } = await import("drizzle-orm");

    const db = await getDb();

    if (data.organizationId) {
      return db
        .select()
        .from(savedReports)
        .where(
          or(
            eq(savedReports.organizationId, data.organizationId),
            eq(savedReports.isOrgWide, true),
          ),
        );
    }

    return db.select().from(savedReports);
  });
</file>

<file path="src/features/reports/reports.schemas.ts">
import { z } from "zod";
import { jsonRecordSchema } from "~/shared/lib/json";

export const exportTypeSchema = z.enum(["csv", "excel", "pdf"]);

export const createSavedReportSchema = z.object({
  organizationId: z.uuid().optional(),
  name: z.string().min(1),
  description: z.string().optional(),
  dataSource: z.string().min(1),
  filters: jsonRecordSchema.optional(),
  columns: z.array(z.string()).optional(),
  sort: jsonRecordSchema.optional(),
  sharedWith: z.array(z.string()).optional(),
  isOrgWide: z.boolean().optional(),
});
export type CreateSavedReportInput = z.infer<typeof createSavedReportSchema>;

export const exportReportSchema = z.object({
  dataSource: z.string().min(1),
  filters: jsonRecordSchema.optional(),
  columns: z.array(z.string()).optional(),
  exportType: exportTypeSchema,
});
export type ExportReportInput = z.infer<typeof exportReportSchema>;

export const updateSavedReportSchema = z.object({
  reportId: z.uuid(),
  data: createSavedReportSchema.partial(),
});
export type UpdateSavedReportInput = z.infer<typeof updateSavedReportSchema>;

export const deleteSavedReportSchema = z.object({
  reportId: z.uuid(),
});
export type DeleteSavedReportInput = z.infer<typeof deleteSavedReportSchema>;
</file>

</files>
