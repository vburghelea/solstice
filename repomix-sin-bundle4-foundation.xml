This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/features/organizations/**/*.ts, src/features/organizations/**/*.tsx, src/features/security/**/*.ts, src/features/security/**/*.tsx, src/db/schema/organizations.schema.ts, src/db/schema/security.schema.ts, src/lib/security/**/*.ts, docs/sin-rfp/tickets/SIN-IMPLEMENTATION-BACKLOG-V2.md, docs/sin-rfp/system-requirements-addendum.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<user_provided_header>
# Review Task: Organizations & Security Infrastructure

## Focus
Review **organization tenancy model and security infrastructure** for correctness and compliance with SIN requirements.

## Key Questions
1. Is the org hierarchy (governing_body → PSO → league → club) properly enforced?
2. Are org membership and delegated access properly validated?
3. Is the security event detection and lockout system working correctly?
4. Are global admins properly distinguished from org admins?
5. Is sensitive data properly protected?

## Reference Documents
- `SIN-IMPLEMENTATION-BACKLOG-V2.md`: Contains requirements for F-001 (Organizations) and S-002 (Security Monitoring)
- `system-requirements-addendum.md`: Contains SEC-AGG requirements

## Areas to Review
- Organization schema and hierarchy rules
- Membership and delegated access validation
- Security event capture and risk scoring
- Account lockout thresholds and behavior
- Global vs org-level admin permissions

## Output Format
For each issue found:
1. **Category**: Orgs/Security/Permissions
2. **Severity**: High/Medium/Low
3. **Location**: file:line
4. **Issue**: What's wrong
5. **Requirement**: Which SIN requirement is affected
6. **Fix**: Suggested remediation
</user_provided_header>

<directory_structure>
docs/
  sin-rfp/
    tickets/
      SIN-IMPLEMENTATION-BACKLOG-V2.md
    system-requirements-addendum.md
src/
  db/
    schema/
      organizations.schema.ts
      security.schema.ts
  features/
    organizations/
      __tests__/
        organizations.access.test.ts
      components/
        org-switcher.tsx
        organization-admin-panel.tsx
      org-context.tsx
      organizations.access.ts
      organizations.mutations.ts
      organizations.queries.ts
      organizations.schemas.ts
      organizations.types.ts
    security/
      components/
        security-dashboard.tsx
      security.mutations.ts
      security.queries.ts
      security.schemas.ts
  lib/
    security/
      utils/
        password-validator.ts
      config.ts
      detection.ts
      events.ts
      index.ts
      lockout.ts
      password-config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/features/organizations/__tests__/organizations.access.test.ts">
import { beforeEach, describe, expect, it, vi } from "vitest";
import type { OrganizationRole } from "~/lib/auth/guards/org-guard";

type OrgRow = {
  id: string;
  name: string;
  slug: string;
  type: string;
  status: string;
  parentOrgId: string | null;
  createdAt: Date;
  updatedAt: Date;
};

const schema = vi.hoisted(() => ({
  organizations: {
    id: "organizations.id",
    name: "organizations.name",
    slug: "organizations.slug",
    type: "organizations.type",
    status: "organizations.status",
    parentOrgId: "organizations.parentOrgId",
    createdAt: "organizations.createdAt",
    updatedAt: "organizations.updatedAt",
  },
  organizationMembers: {
    organizationId: "organizationMembers.organizationId",
    role: "organizationMembers.role",
    userId: "organizationMembers.userId",
    status: "organizationMembers.status",
  },
  delegatedAccess: {
    organizationId: "delegatedAccess.organizationId",
    scope: "delegatedAccess.scope",
    delegateUserId: "delegatedAccess.delegateUserId",
    revokedAt: "delegatedAccess.revokedAt",
    expiresAt: "delegatedAccess.expiresAt",
  },
}));

const getDbMock = vi.hoisted(() => vi.fn());
const isGlobalAdminMock = vi.hoisted(() => vi.fn());

vi.mock("~/db/schema", () => schema);
vi.mock("~/db/server-helpers", () => ({
  getDb: getDbMock,
}));
vi.mock("~/features/roles/permission.service", () => ({
  PermissionService: {
    isGlobalAdmin: (...args: unknown[]) => isGlobalAdminMock(...args),
  },
}));

const { organizations, organizationMembers, delegatedAccess } = schema;

const { listAccessibleOrganizationsForUser, resolveOrganizationAccess } = await import(
  "../organizations.access"
);

const createOrg = (overrides: Partial<OrgRow> = {}): OrgRow => ({
  id: "org",
  name: "Organization",
  slug: "organization",
  type: "club",
  status: "active",
  parentOrgId: null,
  createdAt: new Date("2025-01-01T00:00:00Z"),
  updatedAt: new Date("2025-01-01T00:00:00Z"),
  ...overrides,
});

let tableData: Map<unknown, unknown[]>;
let selectMock: ReturnType<typeof vi.fn>;

const createQuery = (table: unknown) => {
  const data = tableData.get(table) ?? [];
  const basePromise = Promise.resolve(data);
  return Object.assign(basePromise, {
    where: vi.fn(async () => data),
  });
};

const setTableData = (params: {
  orgs?: OrgRow[];
  members?: Array<{ organizationId: string; role: OrganizationRole }>;
  delegated?: Array<{ organizationId: string; scope: string }>;
}) => {
  tableData = new Map();
  tableData.set(organizations, params.orgs ?? []);
  tableData.set(organizationMembers, params.members ?? []);
  tableData.set(delegatedAccess, params.delegated ?? []);
};

describe("organizations.access", () => {
  beforeEach(() => {
    tableData = new Map();
    selectMock = vi.fn((() => ({
      from: (table: unknown) => createQuery(table),
    })) as () => { from: (table: unknown) => ReturnType<typeof createQuery> });
    getDbMock.mockReset();
    getDbMock.mockResolvedValue({ select: selectMock });
    isGlobalAdminMock.mockReset();
  });

  describe("listAccessibleOrganizationsForUser", () => {
    it("returns all orgs for global admins with admin role", async () => {
      isGlobalAdminMock.mockResolvedValue(true);

      const orgs = [createOrg({ id: "org-1" }), createOrg({ id: "org-2" })];
      setTableData({ orgs });

      const result = await listAccessibleOrganizationsForUser("user-1");

      expect(result.map((org) => org.id)).toEqual(["org-1", "org-2"]);
      expect(result.map((org) => org.role)).toEqual(["admin", "admin"]);
    });

    it("inherits membership role across descendants", async () => {
      isGlobalAdminMock.mockResolvedValue(false);

      const orgRoot = createOrg({ id: "org-root" });
      const orgChild = createOrg({ id: "org-child", parentOrgId: "org-root" });
      const orgLeaf = createOrg({ id: "org-leaf", parentOrgId: "org-child" });
      const orgOther = createOrg({ id: "org-other" });

      setTableData({
        orgs: [orgRoot, orgChild, orgLeaf, orgOther],
        members: [{ organizationId: "org-root", role: "owner" }],
      });

      const result = await listAccessibleOrganizationsForUser("user-1");
      const ids = result.map((org) => org.id).sort();

      expect(ids).toEqual(["org-child", "org-leaf", "org-root"]);
      result.forEach((org) => {
        expect(org.role).toBe("owner");
      });
    });

    it("derives reporter access from delegated scopes", async () => {
      isGlobalAdminMock.mockResolvedValue(false);

      const orgRoot = createOrg({ id: "org-root" });
      const orgChild = createOrg({ id: "org-child", parentOrgId: "org-root" });

      setTableData({
        orgs: [orgRoot, orgChild],
        delegated: [{ organizationId: "org-root", scope: "reporting" }],
      });

      const result = await listAccessibleOrganizationsForUser("user-1");
      const root = result.find((org) => org.id === "org-root");
      const child = result.find((org) => org.id === "org-child");

      expect(root?.role).toBe("reporter");
      expect(root?.delegatedScopes).toEqual(["reporting"]);
      expect(child?.role).toBe("reporter");
      expect(child?.delegatedScopes).toEqual([]);
    });
  });

  describe("resolveOrganizationAccess", () => {
    it("returns admin role for global admins", async () => {
      isGlobalAdminMock.mockResolvedValue(true);

      const orgRoot = createOrg({ id: "org-root" });
      setTableData({ orgs: [orgRoot] });

      await expect(
        resolveOrganizationAccess({ userId: "user-1", organizationId: "org-root" }),
      ).resolves.toEqual({ organizationId: "org-root", role: "admin" });
    });

    it("inherits role from parent membership", async () => {
      isGlobalAdminMock.mockResolvedValue(false);

      const orgRoot = createOrg({ id: "org-root" });
      const orgChild = createOrg({ id: "org-child", parentOrgId: "org-root" });

      setTableData({
        orgs: [orgRoot, orgChild],
        members: [{ organizationId: "org-root", role: "viewer" }],
      });

      await expect(
        resolveOrganizationAccess({ userId: "user-1", organizationId: "org-child" }),
      ).resolves.toEqual({ organizationId: "org-child", role: "viewer" });
    });

    it("returns null when no access exists", async () => {
      isGlobalAdminMock.mockResolvedValue(false);

      const orgRoot = createOrg({ id: "org-root" });
      setTableData({ orgs: [orgRoot] });

      await expect(
        resolveOrganizationAccess({ userId: "user-1", organizationId: "org-root" }),
      ).resolves.toBeNull();
    });

    it("derives delegated access from ancestor scopes", async () => {
      isGlobalAdminMock.mockResolvedValue(false);

      const orgRoot = createOrg({ id: "org-root" });
      const orgChild = createOrg({ id: "org-child", parentOrgId: "org-root" });

      setTableData({
        orgs: [orgRoot, orgChild],
        delegated: [{ organizationId: "org-root", scope: "reporting" }],
      });

      await expect(
        resolveOrganizationAccess({ userId: "user-1", organizationId: "org-child" }),
      ).resolves.toEqual({ organizationId: "org-child", role: "reporter" });
    });
  });
});
</file>

<file path="src/features/organizations/components/org-switcher.tsx">
import { useMutation } from "@tanstack/react-query";
import { toast } from "sonner";
import { Button } from "~/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";
import { setActiveOrganization } from "~/features/organizations/organizations.mutations";
import { useOrgContext } from "~/features/organizations/org-context";

interface OrgSwitcherProps {
  /** Callback when organization is successfully selected */
  onSuccess?: (organizationId: string | null) => void;
}

export function OrgSwitcher({ onSuccess }: OrgSwitcherProps = {}) {
  const {
    accessibleOrganizations,
    activeOrganizationId,
    setActiveOrganizationId,
    isLoading,
  } = useOrgContext();

  const mutation = useMutation({
    mutationFn: (organizationId: string | null) =>
      setActiveOrganization({ data: { organizationId } }),
    onSuccess: (result) => {
      if (!result?.success) {
        const message = result?.errors?.[0]?.message ?? "Failed to update organization";
        toast.error(message);
        return;
      }

      const newOrgId = result.data?.organizationId ?? null;
      setActiveOrganizationId(newOrgId);
      onSuccess?.(newOrgId);
    },
    onError: (error) => {
      toast.error(error instanceof Error ? error.message : "Failed to update organization");
    },
  });

  if (isLoading) {
    return <div className="text-muted-foreground text-sm">Loading organizations…</div>;
  }

  if (accessibleOrganizations.length === 0) {
    return (
      <div className="text-muted-foreground text-sm">
        No organizations available for your account.
      </div>
    );
  }

  return (
    <div className="space-y-3">
      <Select
        value={activeOrganizationId ?? ""}
        onValueChange={(value) => {
          const nextId = value === "__none__" ? null : value;
          mutation.mutate(nextId);
        }}
        disabled={mutation.isPending}
      >
        <SelectTrigger>
          <SelectValue placeholder="Select organization" />
        </SelectTrigger>
        <SelectContent>
          {activeOrganizationId ? (
            <SelectItem value="__none__">Clear selection</SelectItem>
          ) : null}
          {accessibleOrganizations.map((organization) => (
            <SelectItem key={organization.id} value={organization.id}>
              {organization.name}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
      {mutation.isPending ? (
        <Button variant="outline" disabled className="w-fit">
          Updating…
        </Button>
      ) : null}
    </div>
  );
}
</file>

<file path="src/features/organizations/org-context.tsx">
import { useQuery } from "@tanstack/react-query";
import { useRouteContext } from "@tanstack/react-router";
import { createContext, useContext, useEffect, useMemo, useState } from "react";
import { listAccessibleOrganizations } from "~/features/organizations/organizations.queries";
import { isFeatureEnabled } from "~/tenant/feature-gates";
import type { AccessibleOrganization } from "~/features/organizations/organizations.types";
import type { OrganizationRole } from "~/lib/auth/guards/org-guard";

type OrgContextValue = {
  activeOrganizationId: string | null;
  organizationRole: OrganizationRole | null;
  accessibleOrganizations: AccessibleOrganization[];
  setActiveOrganizationId: (organizationId: string | null) => void;
  isLoading: boolean;
};

const OrgContext = createContext<OrgContextValue | null>(null);

export function OrgContextProvider({ children }: { children: React.ReactNode }) {
  const context = useRouteContext({ strict: false }) as
    | { activeOrganizationId?: string | null }
    | undefined;
  const initialOrgId = context?.activeOrganizationId ?? null;
  const [activeOrganizationId, setActiveOrganizationId] = useState<string | null>(
    initialOrgId,
  );

  useEffect(() => {
    if (typeof window === "undefined") return;
    if (activeOrganizationId) {
      window.localStorage.setItem("active_org_id", activeOrganizationId);
    } else {
      window.localStorage.removeItem("active_org_id");
    }
  }, [activeOrganizationId]);

  const isSinPortalEnabled = isFeatureEnabled("sin_portal");
  const { data = [], isLoading } = useQuery({
    queryKey: ["organizations", "accessible"],
    queryFn: () => listAccessibleOrganizations({ data: null }),
    enabled: isSinPortalEnabled,
  });

  const activeOrganization = useMemo(
    () =>
      data.find((organization) => organization.id === activeOrganizationId) ?? null,
    [activeOrganizationId, data],
  );

  const organizationRole = activeOrganization?.role ?? null;

  return (
    <OrgContext.Provider
      value={{
        activeOrganizationId,
        organizationRole,
        accessibleOrganizations: data,
        setActiveOrganizationId,
        isLoading,
      }}
    >
      {children}
    </OrgContext.Provider>
  );
}

export const useOrgContext = () => {
  const context = useContext(OrgContext);
  if (!context) {
    throw new Error("useOrgContext must be used within OrgContextProvider");
  }
  return context;
};
</file>

<file path="src/features/organizations/organizations.access.ts">
import { and, eq, gt, isNull, or } from "drizzle-orm";
import { getDb } from "~/db/server-helpers";
import { delegatedAccess, organizationMembers, organizations } from "~/db/schema";
import type { OrganizationRole } from "~/lib/auth/guards/org-guard";
import type { AccessibleOrganization } from "./organizations.types";

const rolePriority: Record<OrganizationRole, number> = {
  owner: 5,
  admin: 4,
  reporter: 3,
  viewer: 2,
  member: 1,
};

const pickHighestRole = (roles: Array<OrganizationRole | null | undefined>) => {
  let highest: OrganizationRole | null = null;
  let max = 0;
  for (const role of roles) {
    if (!role) continue;
    const rank = rolePriority[role] ?? 0;
    if (rank > max) {
      max = rank;
      highest = role;
    }
  }
  return highest;
};

const deriveRoleFromScopes = (scopes: string[]): OrganizationRole | null => {
  if (scopes.includes("admin")) return "admin";
  if (scopes.includes("reporting")) return "reporter";
  if (scopes.includes("analytics")) return "viewer";
  return null;
};

const buildOrgMaps = (orgs: Array<{ id: string; parentOrgId: string | null }>) => {
  const parentById = new Map<string, string | null>();
  const childrenByParent = new Map<string | null, string[]>();

  orgs.forEach((org) => {
    parentById.set(org.id, org.parentOrgId ?? null);
    const parentKey = org.parentOrgId ?? null;
    const children = childrenByParent.get(parentKey) ?? [];
    children.push(org.id);
    childrenByParent.set(parentKey, children);
  });

  return { parentById, childrenByParent };
};

const collectDescendants = (
  childrenByParent: Map<string | null, string[]>,
  rootIds: Iterable<string>,
) => {
  const queue = [...rootIds];
  const result = new Set(queue);

  while (queue.length > 0) {
    const current = queue.shift();
    if (!current) continue;
    const children = childrenByParent.get(current) ?? [];
    for (const child of children) {
      if (result.has(child)) continue;
      result.add(child);
      queue.push(child);
    }
  }

  return result;
};

export const listAccessibleOrganizationsForUser = async (
  userId: string,
): Promise<AccessibleOrganization[]> => {
  const { PermissionService } = await import("~/features/roles/permission.service");
  const isAdmin = await PermissionService.isGlobalAdmin(userId);

  const db = await getDb();
  const orgRows = await db
    .select({
      id: organizations.id,
      name: organizations.name,
      slug: organizations.slug,
      type: organizations.type,
      status: organizations.status,
      parentOrgId: organizations.parentOrgId,
      createdAt: organizations.createdAt,
      updatedAt: organizations.updatedAt,
    })
    .from(organizations);

  if (isAdmin) {
    return orgRows.map((org) => ({
      ...org,
      role: "admin",
    }));
  }

  const memberships = await db
    .select({
      organizationId: organizationMembers.organizationId,
      role: organizationMembers.role,
    })
    .from(organizationMembers)
    .where(
      and(
        eq(organizationMembers.userId, userId),
        eq(organizationMembers.status, "active"),
      ),
    );

  const now = new Date();
  const delegated = await db
    .select({
      organizationId: delegatedAccess.organizationId,
      scope: delegatedAccess.scope,
    })
    .from(delegatedAccess)
    .where(
      and(
        eq(delegatedAccess.delegateUserId, userId),
        isNull(delegatedAccess.revokedAt),
        or(isNull(delegatedAccess.expiresAt), gt(delegatedAccess.expiresAt, now)),
      ),
    );

  const membershipByOrg = new Map<string, OrganizationRole>(
    memberships.map((membership) => [
      membership.organizationId,
      membership.role as OrganizationRole,
    ]),
  );

  const delegatedScopesByOrg = new Map<string, string[]>();
  delegated.forEach((entry) => {
    const scopes = delegatedScopesByOrg.get(entry.organizationId) ?? [];
    scopes.push(entry.scope);
    delegatedScopesByOrg.set(entry.organizationId, scopes);
  });

  const baseOrgIds = new Set<string>([
    ...membershipByOrg.keys(),
    ...delegatedScopesByOrg.keys(),
  ]);

  if (baseOrgIds.size === 0) {
    return [];
  }

  const { parentById, childrenByParent } = buildOrgMaps(orgRows);
  const accessibleIds = collectDescendants(childrenByParent, baseOrgIds);

  const resolveRole = (orgId: string) => {
    const roles: OrganizationRole[] = [];
    let currentId: string | null | undefined = orgId;
    while (currentId) {
      const membershipRole = membershipByOrg.get(currentId);
      if (membershipRole) roles.push(membershipRole);
      const scopes = delegatedScopesByOrg.get(currentId);
      if (scopes && scopes.length > 0) {
        const delegatedRole = deriveRoleFromScopes(scopes);
        if (delegatedRole) roles.push(delegatedRole);
      }
      currentId = parentById.get(currentId) ?? null;
    }

    return pickHighestRole(roles);
  };

  return orgRows
    .filter((org) => accessibleIds.has(org.id))
    .map((org): AccessibleOrganization => ({
      ...org,
      role: resolveRole(org.id),
      delegatedScopes: delegatedScopesByOrg.get(org.id) ?? [],
    }));
};

export const resolveOrganizationAccess = async (params: {
  userId: string;
  organizationId: string;
}) => {
  const { userId, organizationId } = params;
  const { PermissionService } = await import("~/features/roles/permission.service");
  const isAdmin = await PermissionService.isGlobalAdmin(userId);
  if (isAdmin) {
    return { organizationId, role: "admin" };
  }

  const db = await getDb();
  const orgRows = await db
    .select({
      id: organizations.id,
      parentOrgId: organizations.parentOrgId,
    })
    .from(organizations);

  const { parentById } = buildOrgMaps(orgRows);
  const membershipRows = await db
    .select({
      organizationId: organizationMembers.organizationId,
      role: organizationMembers.role,
    })
    .from(organizationMembers)
    .where(
      and(
        eq(organizationMembers.userId, userId),
        eq(organizationMembers.status, "active"),
      ),
    );

  const now = new Date();
  const delegatedRows = await db
    .select({
      organizationId: delegatedAccess.organizationId,
      scope: delegatedAccess.scope,
    })
    .from(delegatedAccess)
    .where(
      and(
        eq(delegatedAccess.delegateUserId, userId),
        isNull(delegatedAccess.revokedAt),
        or(isNull(delegatedAccess.expiresAt), gt(delegatedAccess.expiresAt, now)),
      ),
    );

  const membershipByOrg = new Map<string, OrganizationRole>(
    membershipRows.map((membership) => [
      membership.organizationId,
      membership.role as OrganizationRole,
    ]),
  );

  const delegatedScopesByOrg = new Map<string, string[]>();
  delegatedRows.forEach((entry) => {
    const scopes = delegatedScopesByOrg.get(entry.organizationId) ?? [];
    scopes.push(entry.scope);
    delegatedScopesByOrg.set(entry.organizationId, scopes);
  });

  const roles: OrganizationRole[] = [];
  let currentId: string | null | undefined = organizationId;
  while (currentId) {
    const membershipRole = membershipByOrg.get(currentId);
    if (membershipRole) roles.push(membershipRole);
    const scopes = delegatedScopesByOrg.get(currentId);
    if (scopes && scopes.length > 0) {
      const delegatedRole = deriveRoleFromScopes(scopes);
      if (delegatedRole) roles.push(delegatedRole);
    }
    currentId = parentById.get(currentId) ?? null;
  }

  const role = pickHighestRole(roles);
  if (!role) {
    return null;
  }

  return { organizationId, role };
};
</file>

<file path="src/lib/security/utils/password-validator.ts">
import { PASSWORD_CONFIG } from "../password-config";

interface PasswordValidationResult {
  isValid: boolean;
  errors: string[];
}

/**
 * Validates a password against security requirements
 * Works in both client and server environments
 */
export function validatePassword(password: string): PasswordValidationResult {
  const errors: string[] = [];
  const config = PASSWORD_CONFIG;

  // Check minimum length
  if (password.length < config.minLength) {
    errors.push(`Password must be at least ${config.minLength} characters long`);
  }

  // Check uppercase requirement
  if (config.requireUppercase && !/[A-Z]/.test(password)) {
    errors.push("Password must contain at least one uppercase letter");
  }

  // Check lowercase requirement
  if (config.requireLowercase && !/[a-z]/.test(password)) {
    errors.push("Password must contain at least one lowercase letter");
  }

  // Check numbers requirement
  if (config.requireNumbers && !/\d/.test(password)) {
    errors.push("Password must contain at least one number");
  }

  // Check special characters requirement
  if (config.requireSpecialChars && !/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
    errors.push("Password must contain at least one special character");
  }

  return {
    isValid: errors.length === 0,
    errors,
  };
}

/**
 * Generates a password strength score (0-5)
 */
export function getPasswordStrength(password: string): number {
  let strength = 0;

  // Length bonuses
  if (password.length >= 8) strength++;
  if (password.length >= 12) strength++;
  if (password.length >= 16) strength++;

  // Complexity bonuses
  if (/[a-z]/.test(password) && /[A-Z]/.test(password)) strength++;
  if (/\d/.test(password)) strength++;
  if (/[!@#$%^&*(),.?":{}|<>]/.test(password)) strength++;

  // Cap at 5
  return Math.min(strength, 5);
}

/**
 * Get a human-readable password strength label
 */
export function getPasswordStrengthLabel(strength: number): string {
  switch (strength) {
    case 0:
    case 1:
      return "Very Weak";
    case 2:
      return "Weak";
    case 3:
      return "Fair";
    case 4:
      return "Strong";
    case 5:
      return "Very Strong";
    default:
      return "Unknown";
  }
}
</file>

<file path="src/lib/security/password-config.ts">
/**
 * Password configuration constants
 * Shared between client and server - no environment dependencies
 */

export const PASSWORD_CONFIG = {
  minLength: 8,
  requireUppercase: true,
  requireLowercase: true,
  requireNumbers: true,
  requireSpecialChars: true,
} as const;

// Export type for use in other modules
export type PasswordConfig = typeof PASSWORD_CONFIG;
</file>

<file path="docs/sin-rfp/system-requirements-addendum.md">
# Strength in Numbers System Requirements

**viaSport British Columbia**
409 Granville St #1351
Vancouver, BC V6C 1T2
www.viasport.ca

---

## 1. Introduction

The System Requirements Document captures the complete set of core system-level requirements identified for the Strength in Numbers Information Management System, and serves as the reference documentation throughout the project lifecycle. The System Requirements Document outlines the functionalities necessary to support viaSport's operational requirements for end-to-end data collection, storage, analysis, reporting, and governance.

---

## 2. System Requirements

### 2.1 Data Management

| Req. ID    | Title                               | Description                                                                                                                                                                                                                  | Acceptance Criteria                                                                                                       |
| ---------- | ----------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------- |
| DM-AGG-001 | Data Collection & Submission        | The system shall enable customizable form building, support flexible data entry through variable formats (forms, file uploads), with capabilities for real-time submission tracking, editing, and historical data migration. | Users and System Admin can successfully submit, track, and edit data                                                      |
| DM-AGG-002 | Data Processing & Integration       | The system shall enable standardization of data formatting, logging of transformation processes, and integration with external platforms through API (optional), and data import/export mechanisms.                          | Incoming data is processed uniformly, logged for traceability, and exchanged with external platforms.                     |
| DM-AGG-003 | Data Governance & Access Control    | The system shall enforce role-based access to data and provide administrators with secure database access, along with data cataloging and indexing capabilities for discoverability.                                         | Users can only access data based on permission                                                                            |
| DM-AGG-004 | Data Quality & Integrity            | The system shall ensure relational integrity and continuously monitor data quality using validation rules and automated checks.                                                                                              | Submitted data meets validation rules                                                                                     |
| DM-AGG-005 | Data Storage & Retention            | The system shall support regular backups, disaster recovery mechanisms, data archiving, and secure cloud hosting aligned with retention policies.                                                                            | Data is backed up, archived as scheduled, and securely hosted in the cloud.                                               |
| DM-AGG-006 | Legacy Data Migration & Bulk Import | The system shall provide tooling and configurable mapping templates to import historical data from CSV/Excel, legacy databases, or APIs, including validation, error-handling, and rollback.                                 | Administrators can map legacy fields to system fields, preview results, and execute import; import logs stored for audit. |

### 2.2 Reporting

| Req. ID    | Title                                | Description                                                                                                                                                                                            | Acceptance Criteria                                                                                          |
| ---------- | ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------ |
| RP-AGG-001 | Data Validation & Submission Rules   | The system shall validate submissions to ensure they are complete, clean, use the correct file types, and contain valid data fields such as dates and contact information.                             | Submissions that fail validation are rejected with appropriate error messages.                               |
| RP-AGG-002 | Reporting Information Management     | The system shall manage metadata related to reporting including but not limited to contribution agreements, NCCP, contact details, fiscal periods, organization profiles, and delegated access rights. | Users can update relevant metadata and access reporting features accordingly.                                |
| RP-AGG-003 | Reporting Flow & Support             | The system shall support automated reporting reminders, allow users to track data resubmissions, and visualize submitted data through dashboards.                                                      | Users are reminded, track changes, and view data in a dashboard format.                                      |
| RP-AGG-004 | Reporting Configuration & Collection | The system shall allow system administrators to configure customizable reporting forms, define required fields, display files for users to read, edit, delete, and download.                           | System admin can configure reporting information and forms                                                   |
| RP-AGG-005 | Self-Service Analytics & Data Export | Enable authorized users to build ad-hoc charts, pivot tables, and export raw or aggregated datasets in CSV, Excel, or JSON (optional) without developer intervention.                                  | User builds a custom chart and exports underlying dataset to CSVs; export respects field-level access rules. |

### 2.3 Security

| Req. ID     | Title                           | Description                                                                                                                                                                                              | Acceptance Criteria                                                                                                         |
| ----------- | ------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------- |
| SEC-AGG-001 | Authentication & Access Control | The system shall enforce multi-factor authentication, support secure password recovery, restrict access based on user roles and affiliations, and allow organizational leaders to manage user admission. | Users log in securely; only authorized individuals gain access based on role and affiliation.                               |
| SEC-AGG-002 | Monitoring & Threat Detection   | The system shall detect and flag suspicious activities such as unusual login patterns or behavior anomalies and automatically lock accounts where appropriate.                                           | Security anomalies are flagged, logged, and result in appropriate account safeguards.                                       |
| SEC-AGG-003 | Privacy & Regulatory Compliance | The system shall comply with relevant data protection laws (e.g., PIPEDA) to ensure secure handling, storage, and access to personal information.                                                        | All sensitive data is encrypted and stored securely.                                                                        |
| SEC-AGG-004 | Audit Trail & Data Lineage      | The system shall maintain an immutable audit log of user actions, data changes, authentication events, and administrative configurations, supporting forensic review and regulatory reporting.           | Auditors can filter logs by user or record ID and export results; tamper-evident hashing verifies integrity of log entries. |

### 2.4 Training & Onboarding

| Req. ID    | Title                          | Description                                                                                                                                                           | Acceptance Criteria                                                                        |
| ---------- | ------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
| TO-AGG-001 | Template Support & Integration | The system shall provide a centralized templates tab and offer contextual template access directly from each data entry item to guide users through required formats. | Users can easily locate and access the correct template when needed.                       |
| TO-AGG-002 | Guided Learning & Walkthroughs | The system shall offer onboarding and data upload tutorials to help users navigate key processes, especially during their first-time use.                             | Users can complete tasks independently with support from walkthroughs.                     |
| TO-AGG-003 | Reference Materials & Support  | The system shall provide categorized guides and a frequently asked questions (FAQ) section to help users resolve issues and understand system functionality.          | Users can find accurate answers and instructional material without needing direct support. |

### 2.5 User Interface

| Req. ID    | Title                                         | Description                                                                                                                                                                                   | Acceptance Criteria                                                      |
| ---------- | --------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------ |
| UI-AGG-001 | User Access & Account Control                 | The system shall support secure login/logout (MFA), individual and organizational account registration, account recovery, and system administrator account management with role-based access. | Users and system admin can perform account-related tasks securely.       |
| UI-AGG-002 | Personalized Dashboard                        | The system shall provide the capability to create personalized dashboard for each user role, summarizing relevant data, actions, and reporting progress.                                      | Users can view personalized dashboards based on their roles.             |
| UI-AGG-003 | Responsive and Inclusive Design               | The system shall provide a responsive interface across devices and include accessibility features such as screen reader compatibility, color contrast tools, and etc.                         | System is functional on all devices and meets accessibility compliance.  |
| UI-AGG-004 | Communication: Task & Notification Management | The system shall enable automated and customizable notification messages and task reminders that alert users of pending actions and updates, both on the platform and via email.              | Users receive timely and relevant notifications and reminders.           |
| UI-AGG-005 | Content Navigation & Interaction              | The system shall allow users to efficiently locate and interact with information using robust categorization, search and filtering capabilities.                                              | Users can retrieve accurate results through search and filter functions. |
| UI-AGG-006 | User Support & Feedback Mechanism             | The system shall enable users to submit support inquiries and feedback and allow administrators to respond through a managed interface.                                                       | Users can submit and receive responses to inquiries within the system.   |
| UI-AGG-007 | Consistent Visual Language & Branding         | The system shall maintain a consistent design style, color scheme, and branding across all modules.                                                                                           | All UI components follow a standardized visual style.                    |
</file>

<file path="src/db/schema/organizations.schema.ts">
import { sql } from "drizzle-orm";
import {
  foreignKey,
  index,
  jsonb,
  pgEnum,
  pgTable,
  text,
  timestamp,
  uniqueIndex,
  uuid,
} from "drizzle-orm/pg-core";
import type { JsonRecord } from "~/shared/lib/json";
import { user } from "./auth.schema";

export const organizationTypeEnum = pgEnum("organization_type", [
  "governing_body",
  "pso",
  "league",
  "club",
  "affiliate",
]);

export const organizationStatusEnum = pgEnum("organization_status", [
  "pending",
  "active",
  "suspended",
  "archived",
]);

export const organizationMemberRoleEnum = pgEnum("organization_member_role", [
  "owner",
  "admin",
  "reporter",
  "viewer",
  "member",
]);

export const organizationMemberStatusEnum = pgEnum("organization_member_status", [
  "pending",
  "active",
  "suspended",
  "removed",
]);

export const delegatedAccessScopeEnum = pgEnum("delegated_access_scope", [
  "reporting",
  "analytics",
  "admin",
]);

export const organizations = pgTable(
  "organizations",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    name: text("name").notNull(),
    slug: text("slug").notNull(),
    type: organizationTypeEnum("type").notNull(),
    parentOrgId: uuid("parent_org_id"),
    status: organizationStatusEnum("status").notNull().default("active"),
    settings: jsonb("settings").$type<JsonRecord>().notNull().default({}),
    metadata: jsonb("metadata").$type<JsonRecord>().notNull().default({}),
    createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
    updatedAt: timestamp("updated_at", { withTimezone: true })
      .notNull()
      .defaultNow()
      .$onUpdate(() => new Date()),
  },
  (table) => [
    uniqueIndex("organizations_slug_unique").on(table.slug),
    index("organizations_parent_idx").on(table.parentOrgId),
    foreignKey({
      columns: [table.parentOrgId],
      foreignColumns: [table.id],
      name: "organizations_parent_fk",
    }),
  ],
);

export const organizationMembers = pgTable(
  "organization_members",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    organizationId: uuid("organization_id")
      .notNull()
      .references(() => organizations.id, { onDelete: "cascade" }),
    role: organizationMemberRoleEnum("role").notNull(),
    status: organizationMemberStatusEnum("status").notNull().default("pending"),
    invitedBy: text("invited_by").references(() => user.id),
    invitedAt: timestamp("invited_at", { withTimezone: true }),
    approvedBy: text("approved_by").references(() => user.id),
    approvedAt: timestamp("approved_at", { withTimezone: true }),
    createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
    updatedAt: timestamp("updated_at", { withTimezone: true })
      .notNull()
      .defaultNow()
      .$onUpdate(() => new Date()),
  },
  (table) => [
    uniqueIndex("organization_members_user_org_unique").on(
      table.userId,
      table.organizationId,
    ),
    index("organization_members_user_active_idx")
      .on(table.userId)
      .where(sql`${table.status} = 'active'`),
    index("organization_members_org_active_idx")
      .on(table.organizationId)
      .where(sql`${table.status} = 'active'`),
  ],
);

export const delegatedAccess = pgTable(
  "delegated_access",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    delegateUserId: text("delegate_user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    organizationId: uuid("organization_id")
      .notNull()
      .references(() => organizations.id, { onDelete: "cascade" }),
    scope: delegatedAccessScopeEnum("scope").notNull(),
    grantedBy: text("granted_by")
      .notNull()
      .references(() => user.id),
    grantedAt: timestamp("granted_at", { withTimezone: true }).notNull().defaultNow(),
    expiresAt: timestamp("expires_at", { withTimezone: true }),
    revokedAt: timestamp("revoked_at", { withTimezone: true }),
    revokedBy: text("revoked_by").references(() => user.id),
    notes: text("notes"),
  },
  (table) => [
    index("delegated_access_user_active_idx")
      .on(table.delegateUserId)
      .where(sql`${table.revokedAt} IS NULL`),
    uniqueIndex("delegated_access_unique_active")
      .on(table.delegateUserId, table.organizationId, table.scope)
      .where(sql`${table.revokedAt} IS NULL`),
  ],
);

export type Organization = typeof organizations.$inferSelect;
export type NewOrganization = typeof organizations.$inferInsert;
export type OrganizationMember = typeof organizationMembers.$inferSelect;
export type NewOrganizationMember = typeof organizationMembers.$inferInsert;
export type DelegatedAccess = typeof delegatedAccess.$inferSelect;
export type NewDelegatedAccess = typeof delegatedAccess.$inferInsert;
</file>

<file path="src/db/schema/security.schema.ts">
import {
  inet,
  integer,
  jsonb,
  pgTable,
  text,
  timestamp,
  uuid,
} from "drizzle-orm/pg-core";
import type { JsonRecord } from "~/shared/lib/json";
import { user } from "./auth.schema";

export const securityEvents = pgTable("security_events", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: text("user_id").references(() => user.id),
  eventType: text("event_type").notNull(),
  ipAddress: inet("ip_address").notNull(),
  userAgent: text("user_agent"),
  geoCountry: text("geo_country"),
  geoRegion: text("geo_region"),
  riskScore: integer("risk_score").notNull().default(0),
  riskFactors: jsonb("risk_factors").$type<string[]>().notNull().default([]),
  metadata: jsonb("metadata").$type<JsonRecord>().notNull().default({}),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
});

export const accountLocks = pgTable("account_locks", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: text("user_id")
    .notNull()
    .references(() => user.id),
  reason: text("reason").notNull(),
  lockedAt: timestamp("locked_at", { withTimezone: true }).notNull().defaultNow(),
  unlockAt: timestamp("unlock_at", { withTimezone: true }),
  unlockedBy: text("unlocked_by").references(() => user.id),
  unlockedAt: timestamp("unlocked_at", { withTimezone: true }),
  unlockReason: text("unlock_reason"),
  metadata: jsonb("metadata").$type<JsonRecord>().notNull().default({}),
});

export type SecurityEvent = typeof securityEvents.$inferSelect;
export type NewSecurityEvent = typeof securityEvents.$inferInsert;
export type AccountLock = typeof accountLocks.$inferSelect;
export type NewAccountLock = typeof accountLocks.$inferInsert;
</file>

<file path="src/features/organizations/components/organization-admin-panel.tsx">
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { useMemo, useState } from "react";
import { Button } from "~/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";
import { Input } from "~/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "~/components/ui/table";
import {
  approveOrganizationMember,
  createDelegatedAccess,
  createOrganization,
  inviteOrganizationMember,
  removeOrganizationMember,
  revokeDelegatedAccess,
  updateOrganizationMemberRole,
} from "../organizations.mutations";
import {
  listAllOrganizations,
  listDelegatedAccess,
  listOrganizationMembers,
} from "../organizations.queries";

const organizationTypes = [
  { value: "governing_body", label: "Governing body" },
  { value: "pso", label: "PSO" },
  { value: "league", label: "League" },
  { value: "club", label: "Club" },
  { value: "affiliate", label: "Affiliate" },
];

const organizationRoles = [
  { value: "owner", label: "Owner" },
  { value: "admin", label: "Admin" },
  { value: "reporter", label: "Reporter" },
  { value: "viewer", label: "Viewer" },
  { value: "member", label: "Member" },
];

const delegatedScopes = [
  { value: "reporting", label: "Reporting" },
  { value: "analytics", label: "Analytics" },
  { value: "admin", label: "Admin" },
];

const slugify = (value: string) =>
  value
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/(^-|-$)+/g, "");

export function OrganizationAdminPanel() {
  const queryClient = useQueryClient();
  const { data: organizations = [] } = useQuery({
    queryKey: ["organizations", "admin"],
    queryFn: () => listAllOrganizations({ data: { includeArchived: true } }),
  });

  const [selectedOrgId, setSelectedOrgId] = useState<string | null>(null);
  const [orgName, setOrgName] = useState("");
  const [orgSlug, setOrgSlug] = useState("");
  const [orgType, setOrgType] = useState(organizationTypes[0]?.value ?? "club");
  const [parentOrgId, setParentOrgId] = useState<string | null>(null);
  const [slugDirty, setSlugDirty] = useState(false);
  const [orgError, setOrgError] = useState<string | null>(null);

  const [inviteEmail, setInviteEmail] = useState("");
  const [inviteRole, setInviteRole] = useState("member");

  const [delegateUserId, setDelegateUserId] = useState("");
  const [delegateScope, setDelegateScope] = useState("reporting");
  const [delegateExpiresAt, setDelegateExpiresAt] = useState("");
  const [delegateNotes, setDelegateNotes] = useState("");

  const resolvedOrgId = selectedOrgId ?? organizations[0]?.id ?? null;

  const selectedOrg = useMemo(
    () => organizations.find((org) => org.id === resolvedOrgId) ?? null,
    [organizations, resolvedOrgId],
  );

  const { data: members = [] } = useQuery({
    queryKey: ["organizations", "members", resolvedOrgId],
    queryFn: () =>
      listOrganizationMembers({
        data: { organizationId: resolvedOrgId ?? "" },
      }),
    enabled: Boolean(resolvedOrgId),
  });

  const { data: delegatedAccess = [] } = useQuery({
    queryKey: ["organizations", "delegated", resolvedOrgId],
    queryFn: () =>
      listDelegatedAccess({
        data: { organizationId: resolvedOrgId ?? "" },
      }),
    enabled: Boolean(resolvedOrgId),
  });

  const createMutation = useMutation({
    mutationFn: () =>
      createOrganization({
        data: {
          name: orgName,
          slug: orgSlug,
          type: orgType as "governing_body" | "pso" | "league" | "club" | "affiliate",
          parentOrgId: parentOrgId ?? undefined,
        },
      }),
    onSuccess: (result) => {
      if (!result?.success) {
        setOrgError(result?.errors?.[0]?.message ?? "Failed to create organization");
        return;
      }
      const created = result.data;
      setOrgError(null);
      setOrgName("");
      setOrgSlug("");
      setSlugDirty(false);
      setParentOrgId(null);
      void queryClient.invalidateQueries({ queryKey: ["organizations"] });
      if (created?.id) {
        setSelectedOrgId(created.id);
      }
    },
  });

  const inviteMutation = useMutation({
    mutationFn: () =>
      inviteOrganizationMember({
        data: {
          organizationId: resolvedOrgId ?? "",
          email: inviteEmail,
          role: inviteRole as "owner" | "admin" | "reporter" | "viewer" | "member",
        },
      }),
    onSuccess: () => {
      setInviteEmail("");
      void queryClient.invalidateQueries({ queryKey: ["organizations", "members"] });
    },
  });

  const approveMutation = useMutation({
    mutationFn: (membershipId: string) =>
      approveOrganizationMember({ data: { membershipId } }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: ["organizations", "members"] });
    },
  });

  const updateRoleMutation = useMutation({
    mutationFn: (payload: { membershipId: string; role: string }) =>
      updateOrganizationMemberRole({
        data: {
          membershipId: payload.membershipId,
          role: payload.role as "owner" | "admin" | "reporter" | "viewer" | "member",
        },
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: ["organizations", "members"] });
    },
  });

  const removeMutation = useMutation({
    mutationFn: (membershipId: string) =>
      removeOrganizationMember({ data: { membershipId } }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: ["organizations", "members"] });
    },
  });

  const delegateMutation = useMutation({
    mutationFn: () =>
      createDelegatedAccess({
        data: {
          organizationId: resolvedOrgId ?? "",
          delegateUserId,
          scope: delegateScope as "reporting" | "analytics" | "admin",
          expiresAt: delegateExpiresAt
            ? new Date(delegateExpiresAt).toISOString()
            : undefined,
          notes: delegateNotes || undefined,
        },
      }),
    onSuccess: () => {
      setDelegateUserId("");
      setDelegateExpiresAt("");
      setDelegateNotes("");
      void queryClient.invalidateQueries({ queryKey: ["organizations", "delegated"] });
    },
  });

  const revokeMutation = useMutation({
    mutationFn: (accessId: string) => revokeDelegatedAccess({ data: { accessId } }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: ["organizations", "delegated"] });
    },
  });

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Create organization</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid gap-3 md:grid-cols-2">
            <Input
              placeholder="Organization name"
              value={orgName}
              onChange={(event) => {
                const nextName = event.target.value;
                setOrgName(nextName);
                if (!slugDirty) {
                  setOrgSlug(slugify(nextName));
                }
              }}
            />
            <Input
              placeholder="Slug"
              value={orgSlug}
              onChange={(event) => {
                setOrgSlug(event.target.value);
                setSlugDirty(true);
              }}
            />
            <Select value={orgType} onValueChange={setOrgType}>
              <SelectTrigger>
                <SelectValue placeholder="Organization type" />
              </SelectTrigger>
              <SelectContent>
                {organizationTypes.map((type) => (
                  <SelectItem key={type.value} value={type.value}>
                    {type.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            <Select
              value={parentOrgId ?? "__none__"}
              onValueChange={(value) =>
                setParentOrgId(value === "__none__" ? null : value)
              }
            >
              <SelectTrigger>
                <SelectValue placeholder="Parent organization (optional)" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="__none__">No parent</SelectItem>
                {organizations.map((org) => (
                  <SelectItem key={org.id} value={org.id}>
                    {org.name}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
          {orgError ? <p className="text-destructive text-sm">{orgError}</p> : null}
          <Button
            type="button"
            onClick={() => createMutation.mutate()}
            disabled={!orgName || !orgSlug || createMutation.isPending}
          >
            {createMutation.isPending ? "Creating..." : "Create"}
          </Button>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Organizations</CardTitle>
        </CardHeader>
        <CardContent className="space-y-3">
          {organizations.length === 0 ? (
            <p className="text-muted-foreground text-sm">No organizations yet.</p>
          ) : (
            <div className="grid gap-3">
              {organizations.map((org) => (
                <button
                  key={org.id}
                  type="button"
                  className={`flex items-center justify-between rounded-lg border px-3 py-2 text-left transition ${
                    resolvedOrgId === org.id
                      ? "border-blue-500 bg-blue-50"
                      : "border-gray-200 hover:bg-gray-50"
                  }`}
                  onClick={() => setSelectedOrgId(org.id)}
                >
                  <div>
                    <p className="text-sm font-semibold">{org.name}</p>
                    <p className="text-muted-foreground text-xs">
                      {org.type} • {org.status}
                    </p>
                  </div>
                  <span className="text-muted-foreground text-xs">{org.slug}</span>
                </button>
              ))}
            </div>
          )}
        </CardContent>
      </Card>

      {selectedOrg ? (
        <div className="grid gap-6 lg:grid-cols-2">
          <Card>
            <CardHeader>
              <CardTitle>Invite member</CardTitle>
            </CardHeader>
            <CardContent className="space-y-3">
              <Input
                placeholder="Member email"
                value={inviteEmail}
                onChange={(event) => setInviteEmail(event.target.value)}
              />
              <Select value={inviteRole} onValueChange={setInviteRole}>
                <SelectTrigger>
                  <SelectValue placeholder="Role" />
                </SelectTrigger>
                <SelectContent>
                  {organizationRoles.map((role) => (
                    <SelectItem key={role.value} value={role.value}>
                      {role.label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <Button
                type="button"
                onClick={() => inviteMutation.mutate()}
                disabled={!inviteEmail || inviteMutation.isPending}
              >
                {inviteMutation.isPending ? "Inviting..." : "Send invite"}
              </Button>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle>Delegated access</CardTitle>
            </CardHeader>
            <CardContent className="space-y-3">
              <Input
                placeholder="Delegate user ID"
                value={delegateUserId}
                onChange={(event) => setDelegateUserId(event.target.value)}
              />
              <Select value={delegateScope} onValueChange={setDelegateScope}>
                <SelectTrigger>
                  <SelectValue placeholder="Scope" />
                </SelectTrigger>
                <SelectContent>
                  {delegatedScopes.map((scope) => (
                    <SelectItem key={scope.value} value={scope.value}>
                      {scope.label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <Input
                type="datetime-local"
                value={delegateExpiresAt}
                onChange={(event) => setDelegateExpiresAt(event.target.value)}
              />
              <Input
                placeholder="Notes (optional)"
                value={delegateNotes}
                onChange={(event) => setDelegateNotes(event.target.value)}
              />
              <Button
                type="button"
                onClick={() => delegateMutation.mutate()}
                disabled={!delegateUserId || delegateMutation.isPending}
              >
                {delegateMutation.isPending ? "Granting..." : "Grant access"}
              </Button>
            </CardContent>
          </Card>
        </div>
      ) : null}

      {selectedOrg ? (
        <Card>
          <CardHeader>
            <CardTitle>Members for {selectedOrg.name}</CardTitle>
          </CardHeader>
          <CardContent>
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>User</TableHead>
                  <TableHead>Role</TableHead>
                  <TableHead>Status</TableHead>
                  <TableHead>Actions</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {members.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={4} className="text-center text-sm">
                      No members yet.
                    </TableCell>
                  </TableRow>
                ) : (
                  members.map((member) => (
                    <TableRow key={member.id}>
                      <TableCell>
                        <div>
                          <p className="text-sm font-medium">
                            {member.userName || member.userEmail}
                          </p>
                          <p className="text-muted-foreground text-xs">
                            {member.userEmail}
                          </p>
                        </div>
                      </TableCell>
                      <TableCell>
                        <Select
                          value={member.role}
                          onValueChange={(value) =>
                            updateRoleMutation.mutate({
                              membershipId: member.id,
                              role: value,
                            })
                          }
                        >
                          <SelectTrigger className="h-8">
                            <SelectValue />
                          </SelectTrigger>
                          <SelectContent>
                            {organizationRoles.map((role) => (
                              <SelectItem key={role.value} value={role.value}>
                                {role.label}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                      </TableCell>
                      <TableCell className="text-xs">{member.status}</TableCell>
                      <TableCell className="space-x-2">
                        {member.status === "pending" ? (
                          <Button
                            type="button"
                            size="sm"
                            onClick={() => approveMutation.mutate(member.id)}
                            disabled={approveMutation.isPending}
                          >
                            Approve
                          </Button>
                        ) : null}
                        <Button
                          type="button"
                          size="sm"
                          variant="outline"
                          onClick={() => removeMutation.mutate(member.id)}
                          disabled={removeMutation.isPending}
                        >
                          Remove
                        </Button>
                      </TableCell>
                    </TableRow>
                  ))
                )}
              </TableBody>
            </Table>
          </CardContent>
        </Card>
      ) : null}

      {selectedOrg ? (
        <Card>
          <CardHeader>
            <CardTitle>Delegated access history</CardTitle>
          </CardHeader>
          <CardContent>
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Delegate</TableHead>
                  <TableHead>Scope</TableHead>
                  <TableHead>Status</TableHead>
                  <TableHead>Actions</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {delegatedAccess.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={4} className="text-center text-sm">
                      No delegated access entries.
                    </TableCell>
                  </TableRow>
                ) : (
                  delegatedAccess.map((access) => (
                    <TableRow key={access.id}>
                      <TableCell>
                        <div>
                          <p className="text-sm font-medium">
                            {access.delegateEmail ?? access.delegateUserId}
                          </p>
                          <p className="text-muted-foreground text-xs">
                            {access.delegateUserId}
                          </p>
                        </div>
                      </TableCell>
                      <TableCell className="text-xs">{access.scope}</TableCell>
                      <TableCell className="text-xs">
                        {access.revokedAt ? "revoked" : "active"}
                      </TableCell>
                      <TableCell>
                        <Button
                          type="button"
                          size="sm"
                          variant="outline"
                          onClick={() => revokeMutation.mutate(access.id)}
                          disabled={revokeMutation.isPending || Boolean(access.revokedAt)}
                        >
                          Revoke
                        </Button>
                      </TableCell>
                    </TableRow>
                  ))
                )}
              </TableBody>
            </Table>
          </CardContent>
        </Card>
      ) : null}
    </div>
  );
}
</file>

<file path="src/features/organizations/organizations.mutations.ts">
import { createServerFn } from "@tanstack/react-start";
import { zod$ } from "~/lib/server/fn-utils";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import { getOrgHierarchy } from "~/tenant";
import type { OrganizationType } from "~/tenant/tenant.types";
import {
  approveOrganizationMemberSchema,
  createDelegatedAccessSchema,
  createOrganizationSchema,
  inviteOrganizationMemberSchema,
  removeOrganizationMemberSchema,
  revokeDelegatedAccessSchema,
  setActiveOrganizationSchema,
  updateOrganizationMemberRoleSchema,
  updateOrganizationSchema,
} from "./organizations.schemas";
import type {
  DelegatedAccessRow,
  OrganizationMemberRow,
  OrganizationOperationErrorCode,
  OrganizationOperationResult,
  OrganizationSummary,
} from "./organizations.types";

const errorResult = (code: OrganizationOperationErrorCode, message: string) => ({
  success: false,
  errors: [{ code, message }],
});

const validateOrgHierarchy = async (params: {
  type: OrganizationType;
  parentOrgId: string | null;
}) => {
  const { type, parentOrgId } = params;
  const hierarchy = getOrgHierarchy();

  if (!parentOrgId) {
    if (!hierarchy.rootTypes.includes(type)) {
      return errorResult(
        "VALIDATION_ERROR",
        `Organization type "${type}" cannot be a root organization.`,
      );
    }
    return null;
  }

  const { getDb } = await import("~/db/server-helpers");
  const { organizations } = await import("~/db/schema");
  const { eq } = await import("drizzle-orm");

  const db = await getDb();
  const [parent] = await db
    .select({ id: organizations.id, type: organizations.type })
    .from(organizations)
    .where(eq(organizations.id, parentOrgId))
    .limit(1);

  if (!parent) {
    return errorResult("NOT_FOUND", "Parent organization not found");
  }

  const allowed = hierarchy.allowedChildren[parent.type] ?? [];
  if (!allowed.includes(type)) {
    return errorResult(
      "VALIDATION_ERROR",
      `Organization type "${type}" cannot be created under "${parent.type}".`,
    );
  }

  return null;
};

const getSessionUser = async () => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const { getRequest } = await import("@tanstack/react-start/server");
  const auth = await getAuth();
  const { headers } = getRequest();
  const session = await auth.api.getSession({ headers });
  return session?.user ?? null;
};

const serializeCookie = (
  name: string,
  value: string,
  options: {
    httpOnly?: boolean;
    secure?: boolean;
    sameSite?: "lax" | "strict" | "none";
    path?: string;
    domain?: string;
    maxAge?: number;
  },
) => {
  const segments = [`${name}=${value}`];

  if (options.maxAge !== undefined) {
    segments.push(`Max-Age=${options.maxAge}`);
  }
  if (options.domain) {
    segments.push(`Domain=${options.domain}`);
  }
  if (options.path) {
    segments.push(`Path=${options.path}`);
  }
  if (options.sameSite) {
    const normalized =
      options.sameSite.charAt(0).toUpperCase() + options.sameSite.slice(1);
    segments.push(`SameSite=${normalized}`);
  }
  if (options.secure) {
    segments.push("Secure");
  }
  if (options.httpOnly) {
    segments.push("HttpOnly");
  }

  return segments.join("; ");
};

export const createOrganization = createServerFn({ method: "POST" })
  .inputValidator(zod$(createOrganizationSchema))
  .handler(
    async ({ data }): Promise<OrganizationOperationResult<OrganizationSummary>> => {
      await assertFeatureEnabled("sin_admin_orgs");
      const sessionUser = await getSessionUser();
      if (!sessionUser?.id) {
        return errorResult("UNAUTHORIZED", "User not authenticated");
      }

      try {
        const { getDb } = await import("~/db/server-helpers");
        const { organizationMembers, organizations } = await import("~/db/schema");

        const db = await getDb();
        const hierarchyError = await validateOrgHierarchy({
          type: data.type,
          parentOrgId: data.parentOrgId ?? null,
        });
        if (hierarchyError) {
          return hierarchyError;
        }
        const [organization] = await db.transaction(async (tx) => {
          const [org] = await tx
            .insert(organizations)
            .values({
              name: data.name,
              slug: data.slug,
              type: data.type,
              parentOrgId: data.parentOrgId ?? null,
              settings: data.settings ?? {},
              metadata: data.metadata ?? {},
            })
            .returning();

          if (!org) return [];

          await tx.insert(organizationMembers).values({
            userId: sessionUser.id,
            organizationId: org.id,
            role: "owner",
            status: "active",
            approvedBy: sessionUser.id,
            approvedAt: new Date(),
          });

          return [org];
        });

        if (!organization) {
          return errorResult("DATABASE_ERROR", "Failed to create organization");
        }

        const { logAdminAction } = await import("~/lib/audit");
        await logAdminAction({
          action: "ORG_CREATE",
          actorUserId: sessionUser.id,
          actorOrgId: organization.id,
          targetType: "organization",
          targetId: organization.id,
          targetOrgId: organization.id,
          changes: { name: { new: organization.name } },
          metadata: { slug: organization.slug },
        });

        return {
          success: true,
          data: {
            id: organization.id,
            name: organization.name,
            slug: organization.slug,
            type: organization.type,
            status: organization.status,
            parentOrgId: organization.parentOrgId,
            createdAt: organization.createdAt,
            updatedAt: organization.updatedAt,
          },
        };
      } catch (error) {
        console.error("Failed to create organization", error);
        return errorResult("DATABASE_ERROR", "Failed to create organization");
      }
    },
  );

export const updateOrganization = createServerFn({ method: "POST" })
  .inputValidator(zod$(updateOrganizationSchema))
  .handler(
    async ({ data }): Promise<OrganizationOperationResult<OrganizationSummary>> => {
      await assertFeatureEnabled("sin_admin_orgs");
      const sessionUser = await getSessionUser();
      if (!sessionUser?.id) {
        return errorResult("UNAUTHORIZED", "User not authenticated");
      }

      const { requireOrganizationMembership, ORG_ADMIN_ROLES } =
        await import("~/lib/auth/guards/org-guard");
      await requireOrganizationMembership(
        { userId: sessionUser.id, organizationId: data.organizationId },
        { roles: ORG_ADMIN_ROLES },
      );

      try {
        const { getDb } = await import("~/db/server-helpers");
        const { organizations } = await import("~/db/schema");
        const { eq } = await import("drizzle-orm");

        const db = await getDb();
        const [existing] = await db
          .select()
          .from(organizations)
          .where(eq(organizations.id, data.organizationId))
          .limit(1);

        if (!existing) {
          return errorResult("NOT_FOUND", "Organization not found");
        }

        const nextType = data.data.type ?? existing.type;
        const nextParentOrgId = Object.prototype.hasOwnProperty.call(
          data.data,
          "parentOrgId",
        )
          ? data.data.parentOrgId ?? null
          : existing.parentOrgId;

        const shouldValidate =
          data.data.type !== undefined ||
          Object.prototype.hasOwnProperty.call(data.data, "parentOrgId");

        if (shouldValidate) {
          const hierarchyError = await validateOrgHierarchy({
            type: nextType,
            parentOrgId: nextParentOrgId,
          });
          if (hierarchyError) {
            return hierarchyError;
          }
        }

        const [updated] = await db
          .update(organizations)
          .set({
            name: data.data.name,
            slug: data.data.slug,
            type: data.data.type,
            parentOrgId: data.data.parentOrgId ?? null,
            status: data.data.status,
            settings: data.data.settings,
            metadata: data.data.metadata,
          })
          .where(eq(organizations.id, data.organizationId))
          .returning();

        if (!updated) {
          return errorResult("NOT_FOUND", "Organization not found");
        }

        const changeEntries = Object.entries(data.data).filter(
          ([, value]) => value !== undefined,
        );
        const { createAuditDiff, logAdminAction } = await import("~/lib/audit");
        const changes =
          changeEntries.length > 0
            ? await createAuditDiff(
                Object.fromEntries(
                  changeEntries.map(([key]) => [
                    key,
                    existing[key as keyof typeof existing],
                  ]),
                ),
                Object.fromEntries(
                  changeEntries.map(([key]) => [
                    key,
                    updated[key as keyof typeof updated],
                  ]),
                ),
              )
            : null;
        await logAdminAction({
          action: "ORG_UPDATE",
          actorUserId: sessionUser.id,
          actorOrgId: updated.id,
          targetType: "organization",
          targetId: updated.id,
          targetOrgId: updated.id,
          changes,
        });

        return {
          success: true,
          data: {
            id: updated.id,
            name: updated.name,
            slug: updated.slug,
            type: updated.type,
            status: updated.status,
            parentOrgId: updated.parentOrgId,
            createdAt: updated.createdAt,
            updatedAt: updated.updatedAt,
          },
        };
      } catch (error) {
        console.error("Failed to update organization", error);
        return errorResult("DATABASE_ERROR", "Failed to update organization");
      }
    },
  );

export const inviteOrganizationMember = createServerFn({ method: "POST" })
  .inputValidator(zod$(inviteOrganizationMemberSchema))
  .handler(
    async ({ data }): Promise<OrganizationOperationResult<OrganizationMemberRow>> => {
      await assertFeatureEnabled("sin_admin_orgs");
      const sessionUser = await getSessionUser();
      if (!sessionUser?.id) {
        return errorResult("UNAUTHORIZED", "User not authenticated");
      }

      const { requireOrganizationMembership, ORG_ADMIN_ROLES } =
        await import("~/lib/auth/guards/org-guard");
      await requireOrganizationMembership(
        { userId: sessionUser.id, organizationId: data.organizationId },
        { roles: ORG_ADMIN_ROLES },
      );

      try {
        const { getDb } = await import("~/db/server-helpers");
        const { organizationMembers, user } = await import("~/db/schema");
        const { eq } = await import("drizzle-orm");

        const db = await getDb();
        const [targetUser] = await db
          .select({ id: user.id, email: user.email, name: user.name })
          .from(user)
          .where(eq(user.email, data.email.toLowerCase()))
          .limit(1);

        if (!targetUser) {
          return errorResult("NOT_FOUND", "User not found");
        }

        const [membership] = await db
          .insert(organizationMembers)
          .values({
            userId: targetUser.id,
            organizationId: data.organizationId,
            role: data.role,
            status: "pending",
            invitedBy: sessionUser.id,
            invitedAt: new Date(),
          })
          .returning();

        if (!membership) {
          return errorResult("DATABASE_ERROR", "Failed to invite member");
        }

        const { logAdminAction } = await import("~/lib/audit");
        await logAdminAction({
          action: "ORG_MEMBER_INVITE",
          actorUserId: sessionUser.id,
          actorOrgId: data.organizationId,
          targetType: "organization_member",
          targetId: membership.id,
          targetOrgId: data.organizationId,
          metadata: { invitedUserId: targetUser.id, role: data.role },
        });

        return {
          success: true,
          data: {
            id: membership.id,
            organizationId: membership.organizationId,
            userId: targetUser.id,
            userName: targetUser.name,
            userEmail: targetUser.email,
            role: membership.role,
            status: membership.status,
            invitedBy: membership.invitedBy,
            invitedAt: membership.invitedAt,
            approvedBy: membership.approvedBy,
            approvedAt: membership.approvedAt,
            createdAt: membership.createdAt,
            updatedAt: membership.updatedAt,
          },
        };
      } catch (error) {
        console.error("Failed to invite organization member", error);
        return errorResult("DATABASE_ERROR", "Failed to invite member");
      }
    },
  );

export const approveOrganizationMember = createServerFn({ method: "POST" })
  .inputValidator(zod$(approveOrganizationMemberSchema))
  .handler(
    async ({ data }): Promise<OrganizationOperationResult<OrganizationMemberRow>> => {
      await assertFeatureEnabled("sin_admin_orgs");
      const sessionUser = await getSessionUser();
      if (!sessionUser?.id) {
        return errorResult("UNAUTHORIZED", "User not authenticated");
      }

      try {
        const { getDb } = await import("~/db/server-helpers");
        const { organizationMembers, user } = await import("~/db/schema");
        const { eq } = await import("drizzle-orm");

        const db = await getDb();
        const [membership] = await db
          .select()
          .from(organizationMembers)
          .where(eq(organizationMembers.id, data.membershipId))
          .limit(1);

        if (!membership) {
          return errorResult("NOT_FOUND", "Membership not found");
        }

        const { requireOrganizationMembership, ORG_ADMIN_ROLES } =
          await import("~/lib/auth/guards/org-guard");
        await requireOrganizationMembership(
          { userId: sessionUser.id, organizationId: membership.organizationId },
          { roles: ORG_ADMIN_ROLES },
        );

        const [updated] = await db
          .update(organizationMembers)
          .set({
            status: "active",
            approvedBy: sessionUser.id,
            approvedAt: new Date(),
          })
          .where(eq(organizationMembers.id, data.membershipId))
          .returning();

        if (!updated) {
          return errorResult("DATABASE_ERROR", "Failed to approve member");
        }

        const [memberUser] = await db
          .select({ id: user.id, email: user.email, name: user.name })
          .from(user)
          .where(eq(user.id, updated.userId))
          .limit(1);

        const { logAdminAction } = await import("~/lib/audit");
        await logAdminAction({
          action: "ORG_MEMBER_APPROVE",
          actorUserId: sessionUser.id,
          actorOrgId: updated.organizationId,
          targetType: "organization_member",
          targetId: updated.id,
          targetOrgId: updated.organizationId,
          metadata: { approvedUserId: updated.userId },
        });

        return {
          success: true,
          data: {
            id: updated.id,
            organizationId: updated.organizationId,
            userId: updated.userId,
            userName: memberUser?.name ?? null,
            userEmail: memberUser?.email ?? "",
            role: updated.role,
            status: updated.status,
            invitedBy: updated.invitedBy,
            invitedAt: updated.invitedAt,
            approvedBy: updated.approvedBy,
            approvedAt: updated.approvedAt,
            createdAt: updated.createdAt,
            updatedAt: updated.updatedAt,
          },
        };
      } catch (error) {
        console.error("Failed to approve organization member", error);
        return errorResult("DATABASE_ERROR", "Failed to approve member");
      }
    },
  );

export const updateOrganizationMemberRole = createServerFn({ method: "POST" })
  .inputValidator(zod$(updateOrganizationMemberRoleSchema))
  .handler(
    async ({ data }): Promise<OrganizationOperationResult<OrganizationMemberRow>> => {
      await assertFeatureEnabled("sin_admin_orgs");
      const sessionUser = await getSessionUser();
      if (!sessionUser?.id) {
        return errorResult("UNAUTHORIZED", "User not authenticated");
      }

      try {
        const { getDb } = await import("~/db/server-helpers");
        const { organizationMembers, user } = await import("~/db/schema");
        const { eq } = await import("drizzle-orm");

        const db = await getDb();
        const [membership] = await db
          .select()
          .from(organizationMembers)
          .where(eq(organizationMembers.id, data.membershipId))
          .limit(1);

        if (!membership) {
          return errorResult("NOT_FOUND", "Membership not found");
        }

        const { requireOrganizationMembership, ORG_ADMIN_ROLES } =
          await import("~/lib/auth/guards/org-guard");
        await requireOrganizationMembership(
          { userId: sessionUser.id, organizationId: membership.organizationId },
          { roles: ORG_ADMIN_ROLES },
        );

        const [updated] = await db
          .update(organizationMembers)
          .set({ role: data.role })
          .where(eq(organizationMembers.id, data.membershipId))
          .returning();

        if (!updated) {
          return errorResult("DATABASE_ERROR", "Failed to update member");
        }

        const [memberUser] = await db
          .select({ id: user.id, email: user.email, name: user.name })
          .from(user)
          .where(eq(user.id, updated.userId))
          .limit(1);

        const { logAdminAction } = await import("~/lib/audit");
        await logAdminAction({
          action: "ORG_MEMBER_ROLE_UPDATE",
          actorUserId: sessionUser.id,
          actorOrgId: updated.organizationId,
          targetType: "organization_member",
          targetId: updated.id,
          targetOrgId: updated.organizationId,
          changes: { role: { new: updated.role } },
        });

        return {
          success: true,
          data: {
            id: updated.id,
            organizationId: updated.organizationId,
            userId: updated.userId,
            userName: memberUser?.name ?? null,
            userEmail: memberUser?.email ?? "",
            role: updated.role,
            status: updated.status,
            invitedBy: updated.invitedBy,
            invitedAt: updated.invitedAt,
            approvedBy: updated.approvedBy,
            approvedAt: updated.approvedAt,
            createdAt: updated.createdAt,
            updatedAt: updated.updatedAt,
          },
        };
      } catch (error) {
        console.error("Failed to update organization member role", error);
        return errorResult("DATABASE_ERROR", "Failed to update member");
      }
    },
  );

export const removeOrganizationMember = createServerFn({ method: "POST" })
  .inputValidator(zod$(removeOrganizationMemberSchema))
  .handler(
    async ({ data }): Promise<OrganizationOperationResult<OrganizationMemberRow>> => {
      await assertFeatureEnabled("sin_admin_orgs");
      const sessionUser = await getSessionUser();
      if (!sessionUser?.id) {
        return errorResult("UNAUTHORIZED", "User not authenticated");
      }

      try {
        const { getDb } = await import("~/db/server-helpers");
        const { organizationMembers, user } = await import("~/db/schema");
        const { eq } = await import("drizzle-orm");

        const db = await getDb();
        const [membership] = await db
          .select()
          .from(organizationMembers)
          .where(eq(organizationMembers.id, data.membershipId))
          .limit(1);

        if (!membership) {
          return errorResult("NOT_FOUND", "Membership not found");
        }

        const { requireOrganizationMembership, ORG_ADMIN_ROLES } =
          await import("~/lib/auth/guards/org-guard");
        await requireOrganizationMembership(
          { userId: sessionUser.id, organizationId: membership.organizationId },
          { roles: ORG_ADMIN_ROLES },
        );

        const [updated] = await db
          .update(organizationMembers)
          .set({ status: "removed" })
          .where(eq(organizationMembers.id, data.membershipId))
          .returning();

        if (!updated) {
          return errorResult("DATABASE_ERROR", "Failed to remove member");
        }

        const [memberUser] = await db
          .select({ id: user.id, email: user.email, name: user.name })
          .from(user)
          .where(eq(user.id, updated.userId))
          .limit(1);

        const { logAdminAction } = await import("~/lib/audit");
        await logAdminAction({
          action: "ORG_MEMBER_REMOVE",
          actorUserId: sessionUser.id,
          actorOrgId: updated.organizationId,
          targetType: "organization_member",
          targetId: updated.id,
          targetOrgId: updated.organizationId,
          metadata: { removedUserId: updated.userId },
        });

        return {
          success: true,
          data: {
            id: updated.id,
            organizationId: updated.organizationId,
            userId: updated.userId,
            userName: memberUser?.name ?? null,
            userEmail: memberUser?.email ?? "",
            role: updated.role,
            status: updated.status,
            invitedBy: updated.invitedBy,
            invitedAt: updated.invitedAt,
            approvedBy: updated.approvedBy,
            approvedAt: updated.approvedAt,
            createdAt: updated.createdAt,
            updatedAt: updated.updatedAt,
          },
        };
      } catch (error) {
        console.error("Failed to remove organization member", error);
        return errorResult("DATABASE_ERROR", "Failed to remove member");
      }
    },
  );

export const createDelegatedAccess = createServerFn({ method: "POST" })
  .inputValidator(zod$(createDelegatedAccessSchema))
  .handler(async ({ data }): Promise<OrganizationOperationResult<DelegatedAccessRow>> => {
    await assertFeatureEnabled("sin_admin_orgs");
    const sessionUser = await getSessionUser();
    if (!sessionUser?.id) {
      return errorResult("UNAUTHORIZED", "User not authenticated");
    }

    const { requireOrganizationMembership, ORG_ADMIN_ROLES } =
      await import("~/lib/auth/guards/org-guard");
    await requireOrganizationMembership(
      { userId: sessionUser.id, organizationId: data.organizationId },
      { roles: ORG_ADMIN_ROLES },
    );

    try {
      const { getDb } = await import("~/db/server-helpers");
      const { delegatedAccess, user } = await import("~/db/schema");
      const { eq } = await import("drizzle-orm");

      const db = await getDb();
      const expiresAt = data.expiresAt ? new Date(data.expiresAt) : null;

      const [access] = await db
        .insert(delegatedAccess)
        .values({
          organizationId: data.organizationId,
          delegateUserId: data.delegateUserId,
          scope: data.scope,
          grantedBy: sessionUser.id,
          expiresAt,
          notes: data.notes ?? null,
        })
        .returning();

      if (!access) {
        return errorResult("DATABASE_ERROR", "Failed to grant delegated access");
      }

      const [delegateUser] = await db
        .select({ email: user.email })
        .from(user)
        .where(eq(user.id, access.delegateUserId))
        .limit(1);

      const { logAdminAction } = await import("~/lib/audit");
      await logAdminAction({
        action: "ORG_DELEGATED_ACCESS_GRANT",
        actorUserId: sessionUser.id,
        actorOrgId: access.organizationId,
        targetType: "delegated_access",
        targetId: access.id,
        targetOrgId: access.organizationId,
        metadata: { delegateUserId: access.delegateUserId, scope: access.scope },
      });

      return {
        success: true,
        data: {
          id: access.id,
          organizationId: access.organizationId,
          delegateUserId: access.delegateUserId,
          delegateEmail: delegateUser?.email ?? null,
          scope: access.scope,
          grantedBy: access.grantedBy,
          grantedAt: access.grantedAt,
          expiresAt: access.expiresAt,
          revokedAt: access.revokedAt,
          revokedBy: access.revokedBy,
          notes: access.notes,
        },
      };
    } catch (error) {
      console.error("Failed to grant delegated access", error);
      return errorResult("DATABASE_ERROR", "Failed to grant delegated access");
    }
  });

export const revokeDelegatedAccess = createServerFn({ method: "POST" })
  .inputValidator(zod$(revokeDelegatedAccessSchema))
  .handler(async ({ data }): Promise<OrganizationOperationResult<DelegatedAccessRow>> => {
    await assertFeatureEnabled("sin_admin_orgs");
    const sessionUser = await getSessionUser();
    if (!sessionUser?.id) {
      return errorResult("UNAUTHORIZED", "User not authenticated");
    }

    try {
      const { getDb } = await import("~/db/server-helpers");
      const { delegatedAccess, user } = await import("~/db/schema");
      const { eq } = await import("drizzle-orm");

      const db = await getDb();
      const [access] = await db
        .select()
        .from(delegatedAccess)
        .where(eq(delegatedAccess.id, data.accessId))
        .limit(1);

      if (!access) {
        return errorResult("NOT_FOUND", "Delegated access not found");
      }

      const { requireOrganizationMembership, ORG_ADMIN_ROLES } =
        await import("~/lib/auth/guards/org-guard");
      await requireOrganizationMembership(
        { userId: sessionUser.id, organizationId: access.organizationId },
        { roles: ORG_ADMIN_ROLES },
      );

      const [updated] = await db
        .update(delegatedAccess)
        .set({
          revokedAt: new Date(),
          revokedBy: sessionUser.id,
          notes: data.notes ?? access.notes,
        })
        .where(eq(delegatedAccess.id, data.accessId))
        .returning();

      if (!updated) {
        return errorResult("DATABASE_ERROR", "Failed to revoke access");
      }

      const [delegateUser] = await db
        .select({ email: user.email })
        .from(user)
        .where(eq(user.id, updated.delegateUserId))
        .limit(1);

      const { logAdminAction } = await import("~/lib/audit");
      await logAdminAction({
        action: "ORG_DELEGATED_ACCESS_REVOKE",
        actorUserId: sessionUser.id,
        actorOrgId: updated.organizationId,
        targetType: "delegated_access",
        targetId: updated.id,
        targetOrgId: updated.organizationId,
        metadata: { delegateUserId: updated.delegateUserId },
      });

      return {
        success: true,
        data: {
          id: updated.id,
          organizationId: updated.organizationId,
          delegateUserId: updated.delegateUserId,
          delegateEmail: delegateUser?.email ?? null,
          scope: updated.scope,
          grantedBy: updated.grantedBy,
          grantedAt: updated.grantedAt,
          expiresAt: updated.expiresAt,
          revokedAt: updated.revokedAt,
          revokedBy: updated.revokedBy,
          notes: updated.notes,
        },
      };
    } catch (error) {
      console.error("Failed to revoke delegated access", error);
      return errorResult("DATABASE_ERROR", "Failed to revoke access");
    }
  });

export const setActiveOrganization = createServerFn({ method: "POST" })
  .inputValidator(zod$(setActiveOrganizationSchema))
  .handler(
    async ({
      data,
    }): Promise<OrganizationOperationResult<{ organizationId: string | null }>> => {
      await assertFeatureEnabled("sin_portal");
      const sessionUser = await getSessionUser();
      if (!sessionUser?.id) {
        return errorResult("UNAUTHORIZED", "User not authenticated");
      }

      if (data.organizationId) {
        const { resolveOrganizationAccess } = await import("./organizations.access");
        const access = await resolveOrganizationAccess({
          userId: sessionUser.id,
          organizationId: data.organizationId,
        });

        if (!access) {
          return errorResult("FORBIDDEN", "Organization access required");
        }
      }

      const { setResponseHeader } = await import("@tanstack/react-start/server");
      const { securityConfig } = await import("~/lib/security/config");
      const maxAge = 60 * 60 * 24 * 30;
      const cookieValue = data.organizationId
        ? encodeURIComponent(data.organizationId)
        : "";

      const cookie = serializeCookie("active_org_id", cookieValue, {
        ...securityConfig.cookies,
        maxAge: data.organizationId ? maxAge : 0,
      });

      setResponseHeader("Set-Cookie", cookie);

      return {
        success: true,
        data: {
          organizationId: data.organizationId,
        },
      };
    },
  );
</file>

<file path="src/features/organizations/organizations.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { z } from "zod";
import { zod$ } from "~/lib/server/fn-utils";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import {
  getOrganizationSchema,
  listDelegatedAccessSchema,
  listOrganizationMembersSchema,
  listOrganizationsSchema,
  searchOrganizationsSchema,
} from "./organizations.schemas";
import type {
  DelegatedAccessRow,
  AccessibleOrganization,
  OrganizationMemberRow,
  OrganizationSummary,
} from "./organizations.types";

const getSessionUserId = async () => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const { getRequest } = await import("@tanstack/react-start/server");
  const auth = await getAuth();
  const { headers } = getRequest();
  const session = await auth.api.getSession({ headers });

  return session?.user?.id ?? null;
};

const listAccessibleOrganizationsSchema = z.void().nullish();

export const getOrganization = createServerFn({ method: "GET" })
  .inputValidator(zod$(getOrganizationSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_portal");
    const { getDb } = await import("~/db/server-helpers");
    const { organizations } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    const [org] = await db
      .select()
      .from(organizations)
      .where(eq(organizations.id, data.organizationId))
      .limit(1);

    return org ?? null;
  });

export const listOrganizations = createServerFn({ method: "GET" })
  .inputValidator(zod$(listOrganizationsSchema))
  .handler(async ({ data }): Promise<OrganizationSummary[]> => {
    await assertFeatureEnabled("sin_portal");
    const userId = await getSessionUserId();
    if (!userId) return [];

    const { getDb } = await import("~/db/server-helpers");
    const { organizationMembers, organizations } = await import("~/db/schema");
    const { and, eq } = await import("drizzle-orm");

    const db = await getDb();
    const conditions = data?.includeArchived
      ? eq(organizationMembers.userId, userId)
      : and(eq(organizationMembers.userId, userId), eq(organizations.status, "active"));

    const rows = await db
      .select({
        id: organizations.id,
        name: organizations.name,
        slug: organizations.slug,
        type: organizations.type,
        status: organizations.status,
        parentOrgId: organizations.parentOrgId,
        createdAt: organizations.createdAt,
        updatedAt: organizations.updatedAt,
      })
      .from(organizationMembers)
      .innerJoin(organizations, eq(organizationMembers.organizationId, organizations.id))
      .where(conditions);

    return rows;
  });

export const listAccessibleOrganizations = createServerFn({ method: "GET" })
  .inputValidator(zod$(listAccessibleOrganizationsSchema))
  .handler(async (): Promise<AccessibleOrganization[]> => {
    await assertFeatureEnabled("sin_portal");
    const userId = await getSessionUserId();
    if (!userId) return [];

    const { listAccessibleOrganizationsForUser } = await import(
      "./organizations.access"
    );
    return listAccessibleOrganizationsForUser(userId);
  });

export const searchOrganizations = createServerFn({ method: "GET" })
  .inputValidator(zod$(searchOrganizationsSchema))
  .handler(async ({ data }): Promise<OrganizationSummary[]> => {
    await assertFeatureEnabled("sin_admin_orgs");
    const { getDb } = await import("~/db/server-helpers");
    const { organizations } = await import("~/db/schema");
    const { ilike } = await import("drizzle-orm");

    const db = await getDb();
    const rows = await db
      .select({
        id: organizations.id,
        name: organizations.name,
        slug: organizations.slug,
        type: organizations.type,
        status: organizations.status,
        parentOrgId: organizations.parentOrgId,
        createdAt: organizations.createdAt,
        updatedAt: organizations.updatedAt,
      })
      .from(organizations)
      .where(ilike(organizations.name, `%${data.query}%`))
      .limit(25);

    return rows;
  });

/**
 * Admin-only query to list all organizations (not filtered by membership).
 * Requires sin_admin_orgs feature flag.
 */
export const listAllOrganizations = createServerFn({ method: "GET" })
  .inputValidator(zod$(listOrganizationsSchema))
  .handler(async ({ data }): Promise<OrganizationSummary[]> => {
    await assertFeatureEnabled("sin_admin_orgs");

    const { getDb } = await import("~/db/server-helpers");
    const { organizations } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    const conditions = data?.includeArchived ? undefined : eq(organizations.status, "active");

    const rows = await db
      .select({
        id: organizations.id,
        name: organizations.name,
        slug: organizations.slug,
        type: organizations.type,
        status: organizations.status,
        parentOrgId: organizations.parentOrgId,
        createdAt: organizations.createdAt,
        updatedAt: organizations.updatedAt,
      })
      .from(organizations)
      .where(conditions);

    return rows;
  });

export const listOrganizationMembers = createServerFn({ method: "GET" })
  .inputValidator(zod$(listOrganizationMembersSchema))
  .handler(async ({ data }): Promise<OrganizationMemberRow[]> => {
    await assertFeatureEnabled("sin_admin_orgs");
    const userId = await getSessionUserId();
    if (!userId) return [];

    const { requireOrganizationMembership } = await import("~/lib/auth/guards/org-guard");
    await requireOrganizationMembership({
      userId,
      organizationId: data.organizationId,
    });

    const { getDb } = await import("~/db/server-helpers");
    const { organizationMembers, user } = await import("~/db/schema");
    const { and, eq } = await import("drizzle-orm");

    const db = await getDb();
    const conditions = data.includeInactive
      ? eq(organizationMembers.organizationId, data.organizationId)
      : and(
          eq(organizationMembers.organizationId, data.organizationId),
          eq(organizationMembers.status, "active"),
        );

    const rows = await db
      .select({
        id: organizationMembers.id,
        organizationId: organizationMembers.organizationId,
        userId: organizationMembers.userId,
        userName: user.name,
        userEmail: user.email,
        role: organizationMembers.role,
        status: organizationMembers.status,
        invitedBy: organizationMembers.invitedBy,
        invitedAt: organizationMembers.invitedAt,
        approvedBy: organizationMembers.approvedBy,
        approvedAt: organizationMembers.approvedAt,
        createdAt: organizationMembers.createdAt,
        updatedAt: organizationMembers.updatedAt,
      })
      .from(organizationMembers)
      .innerJoin(user, eq(organizationMembers.userId, user.id))
      .where(conditions);

    return rows;
  });

export const listDelegatedAccess = createServerFn({ method: "GET" })
  .inputValidator(zod$(listDelegatedAccessSchema))
  .handler(async ({ data }): Promise<DelegatedAccessRow[]> => {
    await assertFeatureEnabled("sin_admin_orgs");
    const userId = await getSessionUserId();
    if (!userId) return [];

    const { requireOrganizationMembership, ORG_ADMIN_ROLES } =
      await import("~/lib/auth/guards/org-guard");
    await requireOrganizationMembership(
      { userId, organizationId: data.organizationId },
      { roles: ORG_ADMIN_ROLES },
    );

    const { getDb } = await import("~/db/server-helpers");
    const { delegatedAccess, user } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    const rows = await db
      .select({
        id: delegatedAccess.id,
        organizationId: delegatedAccess.organizationId,
        delegateUserId: delegatedAccess.delegateUserId,
        delegateEmail: user.email,
        scope: delegatedAccess.scope,
        grantedBy: delegatedAccess.grantedBy,
        grantedAt: delegatedAccess.grantedAt,
        expiresAt: delegatedAccess.expiresAt,
        revokedAt: delegatedAccess.revokedAt,
        revokedBy: delegatedAccess.revokedBy,
        notes: delegatedAccess.notes,
      })
      .from(delegatedAccess)
      .innerJoin(user, eq(delegatedAccess.delegateUserId, user.id))
      .where(eq(delegatedAccess.organizationId, data.organizationId));

    return rows;
  });
</file>

<file path="src/features/organizations/organizations.schemas.ts">
import { z } from "zod";
import { jsonRecordSchema } from "~/shared/lib/json";

export const organizationTypeSchema = z.enum([
  "governing_body",
  "pso",
  "league",
  "club",
  "affiliate",
]);

export const organizationStatusSchema = z.enum([
  "pending",
  "active",
  "suspended",
  "archived",
]);

export const organizationRoleSchema = z.enum([
  "owner",
  "admin",
  "reporter",
  "viewer",
  "member",
]);

export const organizationMemberStatusSchema = z.enum([
  "pending",
  "active",
  "suspended",
  "removed",
]);

export const delegatedAccessScopeSchema = z.enum(["reporting", "analytics", "admin"]);

export const getOrganizationSchema = z.object({
  organizationId: z.uuid(),
});
export type GetOrganizationInput = z.infer<typeof getOrganizationSchema>;

export const listOrganizationsSchema = z
  .object({
    includeArchived: z.boolean().optional(),
  })
  .nullish()
  .transform((value) => value ?? { includeArchived: false });
export type ListOrganizationsInput = z.infer<typeof listOrganizationsSchema>;

export const searchOrganizationsSchema = z.object({
  query: z.string().trim().min(1),
});
export type SearchOrganizationsInput = z.infer<typeof searchOrganizationsSchema>;

export const createOrganizationSchema = z.object({
  name: z.string().min(1, "Organization name is required"),
  slug: z
    .string()
    .min(1, "Organization slug is required")
    .regex(/^[a-z0-9-]+$/, "Slug can only contain lowercase letters and hyphens"),
  type: organizationTypeSchema,
  parentOrgId: z.uuid().optional().nullable(),
  settings: jsonRecordSchema.optional(),
  metadata: jsonRecordSchema.optional(),
});
export type CreateOrganizationInput = z.infer<typeof createOrganizationSchema>;

export const updateOrganizationSchema = z.object({
  organizationId: z.uuid(),
  data: createOrganizationSchema
    .partial()
    .extend({ status: organizationStatusSchema.optional() }),
});
export type UpdateOrganizationInput = z.infer<typeof updateOrganizationSchema>;

export const inviteOrganizationMemberSchema = z.object({
  organizationId: z.uuid(),
  email: z.email("Please enter a valid email address"),
  role: organizationRoleSchema,
});
export type InviteOrganizationMemberInput = z.infer<
  typeof inviteOrganizationMemberSchema
>;

export const approveOrganizationMemberSchema = z.object({
  membershipId: z.uuid(),
});
export type ApproveOrganizationMemberInput = z.infer<
  typeof approveOrganizationMemberSchema
>;

export const updateOrganizationMemberRoleSchema = z.object({
  membershipId: z.uuid(),
  role: organizationRoleSchema,
});
export type UpdateOrganizationMemberRoleInput = z.infer<
  typeof updateOrganizationMemberRoleSchema
>;

export const removeOrganizationMemberSchema = z.object({
  membershipId: z.uuid(),
});
export type RemoveOrganizationMemberInput = z.infer<
  typeof removeOrganizationMemberSchema
>;

export const listOrganizationMembersSchema = z.object({
  organizationId: z.uuid(),
  includeInactive: z.boolean().optional(),
});
export type ListOrganizationMembersInput = z.infer<typeof listOrganizationMembersSchema>;

export const listDelegatedAccessSchema = z.object({
  organizationId: z.uuid(),
});
export type ListDelegatedAccessInput = z.infer<typeof listDelegatedAccessSchema>;

export const createDelegatedAccessSchema = z.object({
  organizationId: z.uuid(),
  delegateUserId: z.string().min(1, "Delegate user is required"),
  scope: delegatedAccessScopeSchema,
  expiresAt: z.iso.datetime().optional(),
  notes: z.string().trim().max(500).optional(),
});
export type CreateDelegatedAccessInput = z.infer<typeof createDelegatedAccessSchema>;

export const revokeDelegatedAccessSchema = z.object({
  accessId: z.uuid(),
  notes: z.string().trim().max(500).optional(),
});
export type RevokeDelegatedAccessInput = z.infer<typeof revokeDelegatedAccessSchema>;

export const setActiveOrganizationSchema = z.object({
  organizationId: z.uuid().nullable(),
});
export type SetActiveOrganizationInput = z.infer<typeof setActiveOrganizationSchema>;
</file>

<file path="src/features/organizations/organizations.types.ts">
import type { OrganizationRole } from "~/lib/auth/guards/org-guard";

export type OrganizationOperationErrorCode =
  | "VALIDATION_ERROR"
  | "UNAUTHORIZED"
  | "FORBIDDEN"
  | "NOT_FOUND"
  | "DATABASE_ERROR";

export interface OrganizationOperationError {
  code: OrganizationOperationErrorCode;
  message: string;
}

export interface OrganizationOperationResult<T> {
  success: boolean;
  data?: T;
  errors?: OrganizationOperationError[];
}

export interface OrganizationSummary {
  id: string;
  name: string;
  slug: string;
  type: string;
  status: string;
  parentOrgId: string | null;
  createdAt: Date;
  updatedAt: Date;
}

export interface OrganizationMemberRow {
  id: string;
  organizationId: string;
  userId: string;
  userName: string | null;
  userEmail: string;
  role: string;
  status: string;
  invitedBy: string | null;
  invitedAt: Date | null;
  approvedBy: string | null;
  approvedAt: Date | null;
  createdAt: Date;
  updatedAt: Date;
}

export interface DelegatedAccessRow {
  id: string;
  organizationId: string;
  delegateUserId: string;
  delegateEmail: string | null;
  scope: string;
  grantedBy: string;
  grantedAt: Date;
  expiresAt: Date | null;
  revokedAt: Date | null;
  revokedBy: string | null;
  notes: string | null;
}

export interface AccessibleOrganization extends OrganizationSummary {
  role: OrganizationRole | null;
  delegatedScopes?: string[];
}
</file>

<file path="src/features/security/components/security-dashboard.tsx">
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { useState } from "react";
import { Button } from "~/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";
import { Input } from "~/components/ui/input";
import { lockUserAccount, unlockUserAccount } from "../security.mutations";
import { listAccountLocks, listSecurityEvents } from "../security.queries";

export function SecurityDashboard() {
  const queryClient = useQueryClient();
  const [targetUserId, setTargetUserId] = useState("");
  const [lockReason, setLockReason] = useState("");
  const [unlockReason, setUnlockReason] = useState("");

  const { data: events = [] } = useQuery({
    queryKey: ["security", "events"],
    queryFn: () => listSecurityEvents({ data: {} }),
  });

  const { data: locks = [] } = useQuery({
    queryKey: ["security", "locks"],
    queryFn: () => listAccountLocks(),
  });

  const lockMutation = useMutation({
    mutationFn: (payload: { userId: string; reason: string }) =>
      lockUserAccount({ data: payload }),
    onSuccess: () => {
      setLockReason("");
      void queryClient.invalidateQueries({ queryKey: ["security"] });
    },
  });

  const unlockMutation = useMutation({
    mutationFn: (payload: { userId: string; reason?: string }) =>
      unlockUserAccount({ data: payload }),
    onSuccess: () => {
      setUnlockReason("");
      void queryClient.invalidateQueries({ queryKey: ["security"] });
    },
  });

  return (
    <div className="flex flex-col gap-6">
      <Card>
        <CardHeader>
          <CardTitle>Manual Account Controls</CardTitle>
        </CardHeader>
        <CardContent className="space-y-3 text-sm">
          <Input
            placeholder="User ID"
            value={targetUserId}
            onChange={(event) => setTargetUserId(event.target.value)}
          />
          <div className="grid gap-3 md:grid-cols-2">
            <div className="space-y-2">
              <Input
                placeholder="Lock reason"
                value={lockReason}
                onChange={(event) => setLockReason(event.target.value)}
              />
              <Button
                type="button"
                onClick={() =>
                  lockMutation.mutate({ userId: targetUserId, reason: lockReason })
                }
                disabled={!targetUserId || !lockReason || lockMutation.isPending}
              >
                {lockMutation.isPending ? "Locking..." : "Lock account"}
              </Button>
            </div>
            <div className="space-y-2">
              <Input
                placeholder="Unlock reason (optional)"
                value={unlockReason}
                onChange={(event) => setUnlockReason(event.target.value)}
              />
              <Button
                type="button"
                variant="outline"
                onClick={() =>
                  unlockMutation.mutate({
                    userId: targetUserId,
                    ...(unlockReason ? { reason: unlockReason } : {}),
                  })
                }
                disabled={!targetUserId || unlockMutation.isPending}
              >
                {unlockMutation.isPending ? "Unlocking..." : "Unlock account"}
              </Button>
            </div>
          </div>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Security Events</CardTitle>
        </CardHeader>
        <CardContent className="space-y-2 text-sm">
          {events.length === 0 ? (
            <p className="text-muted-foreground">No security events recorded.</p>
          ) : (
            events.slice(0, 8).map((event) => (
              <div key={event.id} className="flex items-center justify-between">
                <span>{event.eventType}</span>
                <span className="text-muted-foreground text-xs">
                  {new Date(event.createdAt).toLocaleString()}
                </span>
              </div>
            ))
          )}
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Account Locks</CardTitle>
        </CardHeader>
        <CardContent className="space-y-2 text-sm">
          {locks.length === 0 ? (
            <p className="text-muted-foreground">No active locks.</p>
          ) : (
            locks.slice(0, 8).map((lock) => (
              <div key={lock.id} className="flex items-center justify-between">
                <span>{lock.reason}</span>
                <span className="text-muted-foreground text-xs">
                  {new Date(lock.lockedAt).toLocaleString()}
                </span>
              </div>
            ))
          )}
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/features/security/security.mutations.ts">
import { createServerFn } from "@tanstack/react-start";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import { zod$ } from "~/lib/server/fn-utils";
import {
  lockUserSchema,
  recordSecurityEventSchema,
  unlockUserSchema,
} from "./security.schemas";

export const recordSecurityEvent = createServerFn({ method: "POST" })
  .inputValidator(zod$(recordSecurityEventSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("security_core");
    const { recordSecurityEvent: recordEvent } = await import("~/lib/security/events");
    const { applySecurityRules } = await import("~/lib/security/detection");

    let resolvedUserId = data.userId ?? null;

    if (!resolvedUserId && data.identifier) {
      const { getDb } = await import("~/db/server-helpers");
      const { user } = await import("~/db/schema");
      const { eq } = await import("drizzle-orm");

      const db = await getDb();
      const [record] = await db
        .select({ id: user.id })
        .from(user)
        .where(eq(user.email, data.identifier.toLowerCase()))
        .limit(1);

      resolvedUserId = record?.id ?? null;
    }

    const event = await recordEvent({
      userId: resolvedUserId,
      eventType: data.eventType,
      ...(data.metadata !== undefined ? { metadata: data.metadata } : {}),
    });

    if (resolvedUserId) {
      await applySecurityRules({ userId: resolvedUserId, eventType: data.eventType });
    }

    return event;
  });

export const lockUserAccount = createServerFn({ method: "POST" })
  .inputValidator(zod$(lockUserSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_security");
    const { getAuth } = await import("~/lib/auth/server-helpers");
    const { getRequest } = await import("@tanstack/react-start/server");
    const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
    const auth = await getAuth();
    const { headers } = getRequest();
    const session = await auth.api.getSession({ headers });
    const actorUserId = session?.user?.id ?? null;

    await requireAdmin(actorUserId);

    const { lockAccount } = await import("~/lib/security/lockout");
    return lockAccount({
      userId: data.userId,
      reason: data.reason,
      unlockAt: data.unlockAt ? new Date(data.unlockAt) : null,
      ...(data.metadata ? { metadata: data.metadata } : {}),
      actorUserId: actorUserId ?? null,
    });
  });

export const unlockUserAccount = createServerFn({ method: "POST" })
  .inputValidator(zod$(unlockUserSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_security");
    const { getAuth } = await import("~/lib/auth/server-helpers");
    const { getRequest } = await import("@tanstack/react-start/server");
    const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
    const auth = await getAuth();
    const { headers } = getRequest();
    const session = await auth.api.getSession({ headers });
    const actorUserId = session?.user?.id ?? null;

    await requireAdmin(actorUserId);

    const { unlockAccount } = await import("~/lib/security/lockout");
    return unlockAccount({
      userId: data.userId,
      ...(actorUserId ? { unlockedBy: actorUserId } : {}),
      ...(data.reason ? { reason: data.reason } : {}),
    });
  });
</file>

<file path="src/features/security/security.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import { z } from "zod";
import { zod$ } from "~/lib/server/fn-utils";
import { accountLockStatusSchema } from "./security.schemas";

const getSessionUserId = async () => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const { getRequest } = await import("@tanstack/react-start/server");
  const auth = await getAuth();
  const { headers } = getRequest();
  const session = await auth.api.getSession({ headers });
  return session?.user?.id ?? null;
};

const listSecurityEventsSchema = z
  .object({
    userId: z.string().optional(),
  })
  .nullish()
  .transform((value) => value ?? {});

export const listSecurityEvents = createServerFn({ method: "GET" })
  .inputValidator(zod$(listSecurityEventsSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_security");
    const sessionUserId = await getSessionUserId();
    const { unauthorized, forbidden } = await import("~/lib/server/errors");
    if (!sessionUserId) {
      throw unauthorized("User not authenticated");
    }

    const { PermissionService } = await import("~/features/roles/permission.service");
    const isGlobalAdmin = await PermissionService.isGlobalAdmin(sessionUserId);

    const { getRequest } = await import("@tanstack/react-start/server");
    const organizationId = getRequest().headers.get("x-organization-id");

    const { getDb } = await import("~/db/server-helpers");
    const { organizationMembers, securityEvents } = await import("~/db/schema");
    const { and, desc, eq, inArray } = await import("drizzle-orm");

    const db = await getDb();

    // If requesting a specific user's events:
    if (data.userId) {
      // self-access OK
      if (data.userId !== sessionUserId && !isGlobalAdmin) {
        if (!organizationId) {
          throw forbidden("Organization context required");
        }

        const { requireOrganizationMembership, ORG_ADMIN_ROLES } =
          await import("~/lib/auth/guards/org-guard");
        // requester must be org admin
        await requireOrganizationMembership(
          { userId: sessionUserId, organizationId },
          { roles: ORG_ADMIN_ROLES },
        );
        // target must be member of same org
        await requireOrganizationMembership({ userId: data.userId, organizationId });
      }

      return db
        .select()
        .from(securityEvents)
        .where(eq(securityEvents.userId, data.userId))
        .orderBy(desc(securityEvents.createdAt));
    }

    // Listing across users:
    if (isGlobalAdmin) {
      return db.select().from(securityEvents).orderBy(desc(securityEvents.createdAt));
    }

    // Org-scoped list requires org context + org admin
    if (!organizationId) {
      throw forbidden("Organization context required");
    }

    const { requireOrganizationMembership, ORG_ADMIN_ROLES } =
      await import("~/lib/auth/guards/org-guard");
    await requireOrganizationMembership(
      { userId: sessionUserId, organizationId },
      { roles: ORG_ADMIN_ROLES },
    );

    const memberRows = await db
      .select({ userId: organizationMembers.userId })
      .from(organizationMembers)
      .where(
        and(
          eq(organizationMembers.organizationId, organizationId),
          eq(organizationMembers.status, "active"),
        ),
      );
    const memberUserIds = memberRows.map((row) => row.userId);
    if (memberUserIds.length === 0) return [];

    return db
      .select()
      .from(securityEvents)
      .where(inArray(securityEvents.userId, memberUserIds))
      .orderBy(desc(securityEvents.createdAt));
  });

export const listAccountLocks = createServerFn({ method: "GET" }).handler(async () => {
  await assertFeatureEnabled("sin_admin_security");
  const sessionUserId = await getSessionUserId();
  const { unauthorized, forbidden } = await import("~/lib/server/errors");
  if (!sessionUserId) {
    throw unauthorized("User not authenticated");
  }

  const { PermissionService } = await import("~/features/roles/permission.service");
  const isGlobalAdmin = await PermissionService.isGlobalAdmin(sessionUserId);

  const { getDb } = await import("~/db/server-helpers");
  const { accountLocks, organizationMembers } = await import("~/db/schema");
  const { and, desc, eq, inArray } = await import("drizzle-orm");

  const db = await getDb();
  if (isGlobalAdmin) {
    return db.select().from(accountLocks).orderBy(desc(accountLocks.lockedAt));
  }

  const { getRequest } = await import("@tanstack/react-start/server");
  const organizationId = getRequest().headers.get("x-organization-id");
  if (!organizationId) {
    throw forbidden("Organization context required");
  }

  const { requireOrganizationMembership, ORG_ADMIN_ROLES } =
    await import("~/lib/auth/guards/org-guard");
  await requireOrganizationMembership(
    { userId: sessionUserId, organizationId },
    { roles: ORG_ADMIN_ROLES },
  );

  const memberRows = await db
    .select({ userId: organizationMembers.userId })
    .from(organizationMembers)
    .where(
      and(
        eq(organizationMembers.organizationId, organizationId),
        eq(organizationMembers.status, "active"),
      ),
    );
  const memberUserIds = memberRows.map((row) => row.userId);
  if (memberUserIds.length === 0) return [];

  return db
    .select()
    .from(accountLocks)
    .where(inArray(accountLocks.userId, memberUserIds))
    .orderBy(desc(accountLocks.lockedAt));
});

export const getAccountLockStatus = createServerFn({ method: "GET" })
  .inputValidator(zod$(accountLockStatusSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("security_core");
    const sessionUserId = await getSessionUserId();
    const { unauthorized, forbidden } = await import("~/lib/server/errors");
    if (!sessionUserId) {
      throw unauthorized("User not authenticated");
    }

    if (data.userId !== sessionUserId) {
      const { PermissionService } = await import("~/features/roles/permission.service");
      const isGlobalAdmin = await PermissionService.isGlobalAdmin(sessionUserId);

      if (!isGlobalAdmin) {
        const { getRequest } = await import("@tanstack/react-start/server");
        const organizationId = getRequest().headers.get("x-organization-id");
        if (!organizationId) {
          throw forbidden("Organization context required");
        }

        const { requireOrganizationMembership, ORG_ADMIN_ROLES } =
          await import("~/lib/auth/guards/org-guard");
        await requireOrganizationMembership(
          { userId: sessionUserId, organizationId },
          { roles: ORG_ADMIN_ROLES },
        );
        await requireOrganizationMembership({ userId: data.userId, organizationId });
      }
    }

    const { isAccountLocked } = await import("~/lib/security/lockout");
    return isAccountLocked(data.userId);
  });
</file>

<file path="src/features/security/security.schemas.ts">
import { z } from "zod";
import { jsonRecordSchema } from "~/shared/lib/json";

export const recordSecurityEventSchema = z.object({
  userId: z.string().optional(),
  identifier: z.string().optional(),
  eventType: z.string().min(1),
  metadata: jsonRecordSchema.optional(),
});
export type RecordSecurityEventInput = z.infer<typeof recordSecurityEventSchema>;

export const lockUserSchema = z.object({
  userId: z.string(),
  reason: z.string().min(1),
  unlockAt: z.iso.datetime().optional(),
  metadata: jsonRecordSchema.optional(),
});
export type LockUserInput = z.infer<typeof lockUserSchema>;

export const unlockUserSchema = z.object({
  userId: z.string(),
  reason: z.string().optional(),
});
export type UnlockUserInput = z.infer<typeof unlockUserSchema>;

export const accountLockStatusSchema = z.object({
  userId: z.string(),
});
export type AccountLockStatusInput = z.infer<typeof accountLockStatusSchema>;
</file>

<file path="src/lib/security/config.ts">
/**
 * Security configuration for the application
 * Centralizes all security-related settings
 */

import { env, getBaseUrl, isProduction } from "~/lib/env.server";
import { PASSWORD_CONFIG } from "./password-config";

// This module should only be imported in server-side code

export const securityConfig = {
  // Cookie security settings
  cookies: {
    httpOnly: true,
    sameSite: "lax" as const,
    // Force secure cookies in production or when base URL starts with https://
    // This ensures secure cookies even in preview deployments where NODE_ENV might be "test"
    secure: isProduction() || getBaseUrl().startsWith("https://"),
    path: "/",
    // Optional domain restriction for production
    // Set COOKIE_DOMAIN env var to restrict cookies to specific domain
    ...(isProduction() && env.COOKIE_DOMAIN ? { domain: env.COOKIE_DOMAIN } : {}),
  },

  // Session configuration
  session: {
    maxAge: 60 * 60 * 24 * 30, // 30 days
    updateAge: 60 * 60 * 24, // Update session if older than 1 day
    cookieCache: {
      enabled: true,
      maxAge: 60 * 5, // 5 minutes
    },
  },

  // CORS configuration
  cors: {
    credentials: true,
    origin: getBaseUrl(),
    methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allowedHeaders: ["Content-Type", "Authorization"],
  },

  // Rate limiting defaults
  rateLimit: {
    auth: {
      windowMs: 15 * 60 * 1000, // 15 minutes
      max: 5, // 5 requests per window
    },
    api: {
      windowMs: 15 * 60 * 1000, // 15 minutes
      max: 100, // 100 requests per window
    },
  },

  // Password requirements (using shared config)
  password: {
    ...PASSWORD_CONFIG,
    maxLength: 128, // Additional server-side constraint
  },

  // OAuth configuration
  oauth: {
    // Allowed email domains for OAuth sign-ups (comma-separated in env)
    // Example: OAUTH_ALLOWED_DOMAINS=company.com,partner.com
    allowedDomains: env.OAUTH_ALLOWED_DOMAINS,
  },
} as const;

// Type exports
export type SecurityConfig = typeof securityConfig;
export type CookieConfig = typeof securityConfig.cookies;
export type SessionConfig = typeof securityConfig.session;
</file>

<file path="src/lib/security/detection.ts">
import { createServerOnlyFn } from "@tanstack/react-start";
import { isAccountLocked, lockAccount } from "./lockout";

export const applySecurityRules = createServerOnlyFn(
  async (params: { userId?: string | null; eventType: string }) => {
    if (!params.userId) return null;

    const existingLock = await isAccountLocked(params.userId);
    if (existingLock) return existingLock;

    const { getDb } = await import("~/db/server-helpers");
    const { securityEvents } = await import("~/db/schema");
    const { and, count, eq, gte } = await import("drizzle-orm");

    const db = await getDb();
    const now = Date.now();

    if (params.eventType === "login_fail") {
      const fifteenMinutesAgo = new Date(now - 15 * 60 * 1000);
      const [recentFails] = await db
        .select({ total: count() })
        .from(securityEvents)
        .where(
          and(
            eq(securityEvents.userId, params.userId),
            eq(securityEvents.eventType, "login_fail"),
            gte(securityEvents.createdAt, fifteenMinutesAgo),
          ),
        );

      if ((recentFails?.total ?? 0) >= 5) {
        return lockAccount({
          userId: params.userId,
          reason: "failed_logins",
          unlockAt: new Date(now + 30 * 60 * 1000),
          metadata: { threshold: "5_in_15m" },
        });
      }

      const oneHourAgo = new Date(now - 60 * 60 * 1000);
      const [hourFails] = await db
        .select({ total: count() })
        .from(securityEvents)
        .where(
          and(
            eq(securityEvents.userId, params.userId),
            eq(securityEvents.eventType, "login_fail"),
            gte(securityEvents.createdAt, oneHourAgo),
          ),
        );

      if ((hourFails?.total ?? 0) >= 10) {
        return lockAccount({
          userId: params.userId,
          reason: "failed_logins",
          unlockAt: null,
          metadata: { threshold: "10_in_1h" },
        });
      }
    }

    if (params.eventType === "mfa_fail") {
      const fiveMinutesAgo = new Date(now - 5 * 60 * 1000);
      const [mfaFails] = await db
        .select({ total: count() })
        .from(securityEvents)
        .where(
          and(
            eq(securityEvents.userId, params.userId),
            eq(securityEvents.eventType, "mfa_fail"),
            gte(securityEvents.createdAt, fiveMinutesAgo),
          ),
        );

      if ((mfaFails?.total ?? 0) >= 3) {
        return lockAccount({
          userId: params.userId,
          reason: "mfa_failures",
          unlockAt: new Date(now + 15 * 60 * 1000),
          metadata: { threshold: "3_in_5m" },
        });
      }
    }

    return null;
  },
);
</file>

<file path="src/lib/security/events.ts">
import { createServerOnlyFn } from "@tanstack/react-start";
import type { JsonRecord } from "~/shared/lib/json";

export const recordSecurityEvent = createServerOnlyFn(
  async (params: {
    userId?: string | null;
    eventType: string;
    ipAddress?: string | null;
    userAgent?: string | null;
    geoCountry?: string | null;
    geoRegion?: string | null;
    riskScore?: number;
    riskFactors?: string[];
    metadata?: JsonRecord;
  }) => {
    const { getDb } = await import("~/db/server-helpers");
    const { securityEvents } = await import("~/db/schema");
    const { getRequest } = await import("@tanstack/react-start/server");

    const request = getRequest();
    const ipAddress =
      params.ipAddress ??
      request.headers.get("x-forwarded-for") ??
      request.headers.get("x-real-ip") ??
      "0.0.0.0";
    const userAgent = params.userAgent ?? request.headers.get("user-agent");
    const geoCountry =
      params.geoCountry ??
      request.headers.get("cf-ipcountry") ??
      request.headers.get("x-vercel-ip-country") ??
      null;
    const geoRegion =
      params.geoRegion ??
      request.headers.get("x-vercel-ip-country-region") ??
      request.headers.get("x-country-region") ??
      null;

    const db = await getDb();
    const [event] = await db
      .insert(securityEvents)
      .values({
        userId: params.userId ?? null,
        eventType: params.eventType,
        ipAddress,
        userAgent,
        geoCountry,
        geoRegion,
        riskScore: params.riskScore ?? 0,
        riskFactors: params.riskFactors ?? [],
        metadata: params.metadata ?? {},
      })
      .returning();

    const { logAuthEvent, logSecurityEvent } = await import("~/lib/audit");
    const normalizedEvent = params.eventType.toUpperCase();
    await logSecurityEvent({
      action: `SECURITY.${normalizedEvent}`,
      actorUserId: params.userId ?? null,
      actorIp: ipAddress,
      actorUserAgent: userAgent ?? null,
      metadata: params.metadata ?? {},
    });

    const authEventTypes = new Set([
      "LOGIN_SUCCESS",
      "LOGIN_FAIL",
      "MFA_SUCCESS",
      "MFA_FAIL",
      "LOGOUT",
      "PASSWORD_RESET",
    ]);
    if (authEventTypes.has(normalizedEvent)) {
      await logAuthEvent({
        action: `AUTH.${normalizedEvent}`,
        actorUserId: params.userId ?? null,
        actorIp: ipAddress,
        actorUserAgent: userAgent ?? null,
        metadata: params.metadata ?? {},
      });
    }

    return event ?? null;
  },
);
</file>

<file path="src/lib/security/index.ts">
/**
 * Security module exports
 * Centralizes all security-related functionality
 */

// Server-only exports - only import these in server code
export { securityConfig } from "./config";
export type { CookieConfig, SecurityConfig, SessionConfig } from "./config";

// Shared exports - safe for both client and server
export { PASSWORD_CONFIG } from "./password-config";
export {
  getPasswordStrength,
  getPasswordStrengthLabel,
  validatePassword,
} from "./utils/password-validator";
</file>

<file path="src/lib/security/lockout.ts">
import { createServerOnlyFn } from "@tanstack/react-start";
import type { JsonRecord } from "~/shared/lib/json";

export const lockAccount = createServerOnlyFn(
  async (params: {
    userId: string;
    reason: string;
    unlockAt?: Date | null;
    metadata?: JsonRecord;
    actorUserId?: string | null;
  }) => {
    const { getDb } = await import("~/db/server-helpers");
    const { accountLocks } = await import("~/db/schema");

    const db = await getDb();
    const [lock] = await db
      .insert(accountLocks)
      .values({
        userId: params.userId,
        reason: params.reason,
        unlockAt: params.unlockAt ?? null,
        metadata: params.metadata ?? {},
      })
      .returning();

    if (lock) {
      const { logSecurityEvent } = await import("~/lib/audit");
      await logSecurityEvent({
        action: "SECURITY.LOCKOUT",
        actorUserId: params.actorUserId ?? params.userId,
        targetType: "account_lock",
        targetId: lock.id,
        metadata: { reason: params.reason },
      });

      const { PermissionService } = await import("~/features/roles/permission.service");
      const { enqueueNotification } = await import("~/lib/notifications/queue");
      const adminIds = await PermissionService.getGlobalAdminUserIds();

      await Promise.all(
        adminIds
          .filter((adminId) => adminId !== params.userId)
          .map((adminId) =>
            enqueueNotification({
              userId: adminId,
              type: "security_lockout",
              category: "security",
              title: "Account locked",
              body: `A user account was locked due to ${params.reason}.`,
              link: "/dashboard/admin/sin",
              metadata: {
                lockedUserId: params.userId,
                reason: params.reason,
              },
            }),
          ),
      );
    }

    return lock ?? null;
  },
);

export const unlockAccount = createServerOnlyFn(
  async (params: { userId: string; unlockedBy?: string; reason?: string }) => {
    const { getDb } = await import("~/db/server-helpers");
    const { accountLocks } = await import("~/db/schema");
    const { and, eq, isNull } = await import("drizzle-orm");

    const db = await getDb();
    const [lock] = await db
      .update(accountLocks)
      .set({
        unlockedAt: new Date(),
        unlockedBy: params.unlockedBy ?? null,
        unlockReason: params.reason ?? null,
      })
      .where(and(eq(accountLocks.userId, params.userId), isNull(accountLocks.unlockedAt)))
      .returning();

    if (lock) {
      const { logSecurityEvent } = await import("~/lib/audit");
      await logSecurityEvent({
        action: "SECURITY.UNLOCK",
        actorUserId: params.unlockedBy ?? params.userId,
        targetType: "account_lock",
        targetId: lock.id,
        metadata: { reason: params.reason },
      });
    }

    return lock ?? null;
  },
);

export const isAccountLocked = createServerOnlyFn(async (userId: string) => {
  const { getDb } = await import("~/db/server-helpers");
  const { accountLocks } = await import("~/db/schema");
  const { and, eq, isNull, or, gt } = await import("drizzle-orm");

  const db = await getDb();
  const now = new Date();

  const [lock] = await db
    .select()
    .from(accountLocks)
    .where(
      and(
        eq(accountLocks.userId, userId),
        isNull(accountLocks.unlockedAt),
        or(isNull(accountLocks.unlockAt), gt(accountLocks.unlockAt, now)),
      ),
    )
    .limit(1);

  return lock ?? null;
});
</file>

<file path="docs/sin-rfp/tickets/SIN-IMPLEMENTATION-BACKLOG-V2.md">
# viaSport SIN Implementation Backlog v2

> Comprehensive implementation plan for the Strength in Numbers (SIN) system.
> Incorporates architecture review feedback, compliance requirements, and practical delivery sequencing.

---

## Executive Summary

### Current State

- **Codebase maturity:** Solid TypeScript/React foundation with TanStack Start, Drizzle ORM, Better Auth
- **SIN readiness:** ~35-40% of requirements have partial implementation
- **Critical gaps:** Organization tenancy, audit logging, MFA, notifications, dynamic forms, bulk import, analytics

### Key Insight

> **SIN is governance + compliance + workflows, not UI.**
> Building features before tenancy + audit + security posture = rework everything later.

### Critical Path (Non-Negotiable Sequence)

```
Lock Architecture → Organization Tenancy → Audit Logging → Notifications → Security Hardening → Forms → Reporting → Analytics
```

### Timeline Estimate

| Phase                        | Duration        | Outcome                         |
| ---------------------------- | --------------- | ------------------------------- |
| Phase 0: Architecture & Docs | 1-2 weeks       | RFP-defensible documentation    |
| Phase 1: Foundation          | 4-6 weeks       | Tenancy + Audit + Notifications |
| Phase 2: Security            | 3-4 weeks       | MFA + Lockouts + Privacy        |
| Phase 3: Core SIN            | 6-8 weeks       | Forms + Import + Reporting      |
| Phase 4: Analytics           | 3-4 weeks       | Exports + Saved Reports         |
| **Total to SIN-Ready**       | **17-24 weeks** | Phases 0-4                      |

---

## Implementation Progress Tracker

> **Last Updated:** 2025-12-24
> **Overall Progress:** ~85% (Core logic + admin UI done; infra/migration gaps remain)

### Phase 0: Pre-Development Documentation

| Item                               | Status      | Score    | Evidence                                         |
| ---------------------------------- | ----------- | -------- | ------------------------------------------------ |
| P0-001: Reference Architecture     | ✅ Complete | 100%     | `docs/sin-rfp/phase-0/architecture-reference.md` |
| P0-002: Data Residency Statement   | ✅ Complete | 100%     | `docs/sin-rfp/phase-0/data-residency.md`         |
| P0-003: Security Controls Overview | ✅ Complete | 100%     | `docs/sin-rfp/phase-0/security-controls.md`      |
| P0-004: Backup & DR Plan           | ✅ Complete | 100%     | `docs/sin-rfp/phase-0/backup-dr-plan.md`         |
| P0-005: Audit & Retention Policy   | ✅ Complete | 100%     | `docs/sin-rfp/phase-0/audit-retention-policy.md` |
| **Phase 0 Total**                  | ✅          | **100%** | All 5 documents complete                         |

### Phase 1: Foundation

| Item                           | Status      | Score   | Evidence                                                                                         |
| ------------------------------ | ----------- | ------- | ------------------------------------------------------------------------------------------------ |
| F-001: Organization & Tenancy  | ✅ Complete | 95%     | Schema: `organizations.schema.ts` + guards + admin UI. **Note:** hierarchy visualization pending |
| F-002: Immutable Audit Logging | ✅ Complete | 100%    | Schema + hash chain + immutability trigger + admin UI/export                                     |
| F-003: Notification Engine     | ✅ Complete | 100%    | SQS/SES integration + scheduler + digest aggregation + admin templates                           |
| **Phase 1 Total**              | ✅          | **98%** | Core logic + admin UI complete                                                                   |

### Phase 2: Security Hardening

| Item                                       | Status      | Score   | Evidence                                                                                                                        |
| ------------------------------------------ | ----------- | ------- | ------------------------------------------------------------------------------------------------------------------------------- |
| S-001: Multi-Factor Authentication         | 🟡 Partial  | 85%     | Enrollment + QR + backup codes + login challenge + step-up. **Missing:** per-role MFA UI (auto-enforced for global admin roles) |
| S-002: Security Event Monitoring & Lockout | ✅ Complete | 95%     | Events + detection + lockout + dashboard + admin alerts                                                                         |
| S-003: Privacy Compliance (PIPEDA)         | ✅ Complete | 95%     | Policy acceptance + DSAR workflow + export + erasure + retention UI/cron                                                        |
| **Phase 2 Total**                          | 🟡          | **92%** | Security UI complete, minor admin config gap                                                                                    |

### Phase 3: Core SIN Features

| Item                                | Status      | Score   | Evidence                                                                 |
| ----------------------------------- | ----------- | ------- | ------------------------------------------------------------------------ |
| D-001: Dynamic Form Builder         | ✅ Complete | 95%     | Builder + preview + publish + renderer + submissions history             |
| D-002: Bulk Import & Data Migration | 🟡 Partial  | 80%     | Lane 1 UI + Lane 2 batch runner; **Missing:** ECS task definition wiring |
| R-001: Reporting Cycles & Workflows | ✅ Complete | 95%     | Cycles + tasks + reminders + dashboards + review workflow                |
| **Phase 3 Total**                   | 🟡          | **90%** | ECS batch worker infra remaining                                         |

### Phase 4: Analytics & Export

| Item                      | Status      | Score   | Evidence                                                 |
| ------------------------- | ----------- | ------- | -------------------------------------------------------- |
| R-002: Reporting & Export | ✅ Complete | 95%     | Report builder UI + saved reports + sharing + export ACL |
| **Phase 4 Total**         | ✅          | **95%** | Builder + exports complete                               |

### Summary by Category

| Category                 | Progress | Notes                                              |
| ------------------------ | -------- | -------------------------------------------------- |
| **Documentation**        | 100%     | All Phase 0 docs complete                          |
| **Database Schema**      | 100%     | All SIN tables defined + migrations applied        |
| **Server Functions**     | 95%      | Queries + mutations with auth guards + audit hooks |
| **Auth & Security**      | 90%      | MFA, lockout, step-up, admin enforcement complete  |
| **Notification Backend** | 95%      | SQS + SES + scheduler + digests                    |
| **Admin UI Components**  | 85%      | Core admin panels implemented                      |
| **E2E Tests**            | 30%      | Initial SIN auth/export/upload tests in place      |

### Recent Changes (2025-12-24)

Applied security patches (Issues 01-11):

- ✅ Audit log access control with org scoping
- ✅ Security events access control
- ✅ Reporting permission checks
- ✅ Field-level ACL for report exports
- ✅ Audit log immutability in retention
- ✅ S3 cleanup for DSAR erasure
- ✅ Step-up auth re-auth window
- ✅ Server-side file validation
- ✅ SQS/SES notification integration
- ✅ XLSX export generation
- ✅ MFA enrollment QR + backup code regeneration
- ✅ Notification digest aggregation + audit verification UI
- ✅ Lane 2 batch runner helper + worker entrypoint

See `docs/sin-rfp/SIN-IMPLEMENTATION-TECHNICAL-DEBT.md` for detailed patch notes.

---

## Part 1: Architecture Decisions to Lock First

> These decisions ripple everywhere. Do not write code until these are documented and approved.

### ADR-001: Data Residency

**Decision:** All production data stored and processed in Canada (AWS `ca-central-1`).

**Rationale:** PIPEDA compliance, viaSport requirement, RFP defensibility.

**Implications:**

- Migrate from Neon to AWS RDS PostgreSQL in `ca-central-1`
- Use AWS SES (not SendGrid) for transactional email
- Use S3 `ca-central-1` for document storage
- No Netlify for production (edge compute has no residency guarantees)
- All sub-processors must have Canadian data processing or explicit DPAs

---

### ADR-002: Tenancy Model

**Decision:** Organization-based tenancy (not team-based).

**Rationale:** SIN requires hierarchical org structure: viaSport → PSO → Club/Affiliate.

**Data Model:**

```
organizations (id, name, type, parent_org_id, ...)
    ↓
organization_members (user_id, org_id, role, status, ...)
    ↓
All tenant-owned entities have organization_id FK
```

**Implications:**

- Remove/deprecate `teamId`/`eventId` scoping from RBAC for SIN
- Add `organization_id` to: forms, submissions, reporting_tasks, imports, notifications
- Every query must be org-scoped by default
- Consider Postgres RLS for defense-in-depth (Phase 2 hardening)

---

### ADR-003: Audit Logging Policy

**Decision:** Immutable append-only audit log with PII-aware handling.

**What Gets Logged:**
| Action Type | Detail Level | Before/After |
|-------------|--------------|--------------|
| `AUTH.*` (login, logout, MFA) | Metadata only (no secrets) | No |
| `ADMIN.*` (role changes, config) | Full detail | Yes (full) |
| `DATA.CREATE/UPDATE/DELETE` | Field-level diffs | Yes (diff only) |
| `EXPORT.*` | Query params, row count | No |
| `SECURITY.*` (lockouts, anomalies) | Full context | No |

**PII Handling in Audit Logs:**

- Store **diffs**, not full before/after snapshots for personal data
- Store **hashes** for sensitive fields (DOB, phone, emergency contact)
- Redact secrets (passwords, tokens) completely
- Define retention: audit logs retained 7 years (or as specified by viaSport)

**Rationale:** Full before/after creates a second copy of PII, complicates DSAR/erasure.

---

### ADR-004: Email PII Policy

**Decision:** Minimal PII in transactional emails.

**Allowed in Email:**

- First name (for personalization)
- Organization name
- Action summaries ("Your Q1 report is due in 7 days")
- Links to system (with auth required to view details)

**NOT Allowed in Email:**

- Full addresses
- Phone numbers
- Date of birth
- Emergency contact details
- Submission content/data

**Rationale:** Email is a US-processor risk (even with SES). Minimize data exposure.

---

### ADR-005: Session Security

**Decision:** Tightened session policy for government data system.

| Setting               | Value                       | Rationale                             |
| --------------------- | --------------------------- | ------------------------------------- |
| Session max age       | 8 hours                     | Reduced from 30 days                  |
| Idle timeout          | 30 minutes                  | Auto-logout on inactivity             |
| Admin session max     | 4 hours                     | Higher privilege = shorter session    |
| Step-up auth required | Role changes, exports, DSAR | Re-authenticate for sensitive actions |
| Admin MFA             | Required                    | Non-negotiable for SIN                |

---

### ADR-006: Infrastructure Stack

**Decision:** AWS via SST for production, Netlify for development preview only.

| Component      | Technology                             | Region                    |
| -------------- | -------------------------------------- | ------------------------- |
| Compute        | Lambda (requests), ECS Fargate (batch) | ca-central-1              |
| Database       | RDS PostgreSQL (Multi-AZ, PITR)        | ca-central-1              |
| Object Storage | S3 (SSE-KMS, versioning)               | ca-central-1              |
| Email          | AWS SES                                | ca-central-1              |
| Queues         | SQS                                    | ca-central-1              |
| Scheduling     | EventBridge Scheduler                  | ca-central-1              |
| Secrets        | Secrets Manager                        | ca-central-1              |
| Monitoring     | CloudWatch, CloudTrail, GuardDuty      | ca-central-1              |
| CDN            | CloudFront (cache static only)         | Global edge, origin in CA |

**Residency Constraints:**

- CloudFront caches static assets only; authenticated/PII responses must use `Cache-Control: no-store`.
- CSP nonce injection must move to app-layer middleware for AWS (see `sst-migration-plan.md`).

**Known Issue:** SST Lambda Function URL permissions require `$transform` workaround. See `sst-migration-plan.md`.

---

## Part 2: Compliance & Security Posture

### Sub-Processor Inventory

| Service            | Vendor                    | Data Processed                       | Region                    | DPA Status       |
| ------------------ | ------------------------- | ------------------------------------ | ------------------------- | ---------------- |
| Database           | AWS RDS                   | All PII, submissions, audit logs     | ca-central-1              | AWS DPA ✓        |
| Email              | AWS SES                   | Names, org names, action summaries   | ca-central-1              | AWS DPA ✓        |
| Object Storage     | AWS S3                    | Documents, attachments, import files | ca-central-1              | AWS DPA ✓        |
| Auth               | Self-hosted (Better Auth) | Credentials, sessions                | ca-central-1              | N/A              |
| Monitoring         | AWS CloudWatch            | Logs (PII redacted)                  | ca-central-1              | AWS DPA ✓        |
| OAuth (if enabled) | Google                    | Email + profile claims               | Verify (likely US/global) | Google terms/DPA |
| Payments           | Square (if needed)        | Payment tokens only                  | Verify                    | Requires DPA     |

**No external sub-processors for PII beyond those listed.** If added later (analytics, support tools), update this table and obtain DPAs.

---

### Security Controls Mapped to SIN Requirements

| Requirement                          | Control                                      | Status   |
| ------------------------------------ | -------------------------------------------- | -------- |
| SEC-AGG-001: MFA                     | Better Auth 2FA plugin (TOTP + backup codes) | To Build |
| SEC-AGG-001: Role/affiliation access | Organization-scoped RBAC                     | To Build |
| SEC-AGG-001: Leader admission        | Org membership approval workflow             | To Build |
| SEC-AGG-002: Anomaly detection       | Security events + risk scoring               | To Build |
| SEC-AGG-002: Account lockout         | Threshold-based auto-lock                    | To Build |
| SEC-AGG-003: PIPEDA compliance       | Consent tracking, retention, DSAR            | To Build |
| SEC-AGG-004: Immutable audit         | Append-only table + hash chain               | To Build |
| SEC-AGG-004: Export                  | Audit log filtering + CSV export             | To Build |

---

### Backup & Disaster Recovery

| Metric                         | Target    | Mechanism                           |
| ------------------------------ | --------- | ----------------------------------- |
| RPO (Recovery Point Objective) | 1 hour    | RDS automated backups + PITR        |
| RTO (Recovery Time Objective)  | 4 hours   | Multi-AZ failover + restore runbook |
| Backup retention               | 35 days   | RDS automated + manual snapshots    |
| Audit log retention            | 7 years   | S3 Glacier archive with Object Lock |
| DR testing                     | Quarterly | Documented restore procedure        |

---

## Part 3: Implementation Phases

### Phase 0: Pre-Development Documentation (1-2 weeks)

> Write these documents before writing code. They make your RFP submission defensible.

#### P0-001: Reference Architecture Document

**Deliverable:** `docs/sin-rfp/phase-0/architecture-reference.md`

Contents:

- [x] Architecture diagram (CloudFront → Lambda → RDS → S3)
- [x] Data flow diagram (user → system → storage)
- [x] Network diagram (VPC, subnets, security groups)
- [x] Component descriptions

---

#### P0-002: Data Residency Statement

**Deliverable:** `docs/sin-rfp/phase-0/data-residency.md`

Contents:

- [x] Explicit statement: "All production data stored in AWS ca-central-1"
- [x] Sub-processor list with regions
- [x] Data classification (PII, sensitive PII, operational)
- [x] Cross-border data transfer policy (none for PII)

---

#### P0-003: Security Controls Overview

**Deliverable:** `docs/sin-rfp/phase-0/security-controls.md`

Contents:

- [x] Authentication controls (MFA, session management)
- [x] Authorization controls (RBAC, org scoping)
- [x] Encryption (at rest: KMS, in transit: TLS 1.3)
- [x] Logging and monitoring
- [x] Incident response (outline)

---

#### P0-004: Backup & DR Plan

**Deliverable:** `docs/sin-rfp/phase-0/backup-dr-plan.md`

Contents:

- [x] RPO/RTO targets
- [x] Backup mechanisms and schedules
- [x] Restore procedures (step-by-step)
- [x] DR testing schedule and evidence

---

#### P0-005: Audit & Retention Policy

**Deliverable:** `docs/sin-rfp/phase-0/audit-retention-policy.md`

Contents:

- [x] What is logged (per action type)
- [x] Retention periods by data type
- [x] Archive and purge procedures
- [x] Legal hold capability

---

### Phase 1: Foundation (4-6 weeks)

> These are blocking dependencies. Everything else builds on this.

#### F-001: Organization & Tenancy Model

**Priority:** P0 (Blocker)
**Effort:** 2-3 weeks
**Blocks:** All org-scoped features

**Database Schema:**

```sql
-- Organizations (viaSport, PSOs, Clubs, Affiliates)
CREATE TABLE organizations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL,
  type TEXT NOT NULL CHECK (type IN ('governing_body', 'pso', 'club', 'affiliate')),
  parent_org_id UUID REFERENCES organizations(id),
  status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('pending', 'active', 'suspended', 'archived')),
  settings JSONB NOT NULL DEFAULT '{}',
  metadata JSONB NOT NULL DEFAULT '{}',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Organization membership with role
CREATE TABLE organization_members (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  role TEXT NOT NULL CHECK (role IN ('owner', 'admin', 'reporter', 'viewer', 'member')),
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'active', 'suspended', 'removed')),
  invited_by TEXT REFERENCES "user"(id),
  invited_at TIMESTAMPTZ,
  approved_by TEXT REFERENCES "user"(id),
  approved_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(user_id, organization_id)
);

-- Delegated access for reporting (separate from membership)
CREATE TABLE delegated_access (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  delegate_user_id TEXT NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  scope TEXT NOT NULL CHECK (scope IN ('reporting', 'analytics', 'admin')),
  granted_by TEXT NOT NULL REFERENCES "user"(id),
  granted_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  expires_at TIMESTAMPTZ,
  revoked_at TIMESTAMPTZ,
  revoked_by TEXT REFERENCES "user"(id),
  notes TEXT
);

-- Indices
CREATE INDEX idx_org_members_user ON organization_members(user_id) WHERE status = 'active';
CREATE INDEX idx_org_members_org ON organization_members(organization_id) WHERE status = 'active';
CREATE INDEX idx_org_parent ON organizations(parent_org_id);
CREATE INDEX idx_delegated_access_user ON delegated_access(delegate_user_id) WHERE revoked_at IS NULL;
CREATE UNIQUE INDEX delegated_access_active_unique
  ON delegated_access(delegate_user_id, organization_id, scope)
  WHERE revoked_at IS NULL;
```

**Implementation:**

- [x] Create `src/db/schema/organizations.schema.ts`
- [x] Create `src/features/organizations/` feature module
- [x] Implement org context middleware (resolve user's org + role per request)
- [x] Create `src/lib/auth/guards/org-guard.ts`
- [x] Add org admin UI: create org, invite members, approve/deny
- [x] Retrofit `organization_id` to existing entities (as needed for SIN)

**Acceptance Criteria:**

- [x] Organizations can be created with parent/child relationships
- [x] Users can be invited to organizations with specific roles
- [x] Organization admins can approve/deny membership requests
- [x] Delegated access can be granted and revoked with audit trail
- [x] All data queries are org-scoped by default (SIN modules scoped)
- [x] Users cannot access data outside their organization(s) (org guard enforced)

---

#### F-002: Immutable Audit Logging

**Priority:** P0 (Blocker)
**Effort:** 2 weeks
**Blocks:** Compliance, DSAR, security monitoring

**Database Schema:**

```sql
-- Append-only audit log with hash chain
CREATE TABLE audit_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  occurred_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Actor information
  actor_user_id TEXT REFERENCES "user"(id),
  actor_org_id UUID REFERENCES organizations(id),
  actor_ip INET,
  actor_user_agent TEXT,

  -- Action classification
  action TEXT NOT NULL, -- 'AUTH.LOGIN', 'DATA.CREATE', 'ADMIN.ROLE_ASSIGN', etc.
  action_category TEXT NOT NULL, -- 'AUTH', 'ADMIN', 'DATA', 'EXPORT', 'SECURITY'

  -- Target information
  target_type TEXT, -- 'user', 'organization', 'submission', etc.
  target_id TEXT,
  target_org_id UUID REFERENCES organizations(id),

  -- Change tracking (with PII awareness)
  changes JSONB, -- Field-level diffs, NOT full snapshots
  metadata JSONB NOT NULL DEFAULT '{}',

  -- Correlation and integrity
  request_id TEXT NOT NULL, -- Generate for background jobs (job_id/trace_id)
  prev_hash TEXT, -- Hash of previous entry (tamper evidence)
  entry_hash TEXT NOT NULL, -- Hash of this entry

  -- Indexing support
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Enforce append-only via trigger
CREATE OR REPLACE FUNCTION prevent_audit_modification()
RETURNS TRIGGER AS $$
BEGIN
  RAISE EXCEPTION 'Audit logs are immutable - modifications not allowed';
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER audit_logs_immutable
BEFORE UPDATE OR DELETE ON audit_logs
FOR EACH ROW EXECUTE FUNCTION prevent_audit_modification();

-- Indices for common query patterns
CREATE INDEX idx_audit_logs_actor ON audit_logs(actor_user_id, occurred_at DESC);
CREATE INDEX idx_audit_logs_target ON audit_logs(target_type, target_id, occurred_at DESC);
CREATE INDEX idx_audit_logs_action ON audit_logs(action_category, occurred_at DESC);
CREATE INDEX idx_audit_logs_org ON audit_logs(target_org_id, occurred_at DESC);
CREATE INDEX idx_audit_logs_request ON audit_logs(request_id);
```

**Audit Library Design:**

```typescript
// src/lib/audit/index.ts
interface AuditEntry {
  action: string;
  targetType?: string;
  targetId?: string;
  targetOrgId?: string;
  changes?: Record<string, { old?: unknown; new?: unknown }>;
  metadata?: Record<string, unknown>;
}

// Central logging functions
audit.logAuthEvent(type: 'LOGIN' | 'LOGOUT' | 'MFA_ENROLL' | ..., context)
audit.logAdminAction(type: 'ROLE_ASSIGN' | 'ORG_CREATE' | ..., target, changes)
audit.logDataChange(type: 'CREATE' | 'UPDATE' | 'DELETE', entity, changes)
audit.logExport(type: 'CSV' | 'EXCEL' | ..., query, rowCount)
audit.logSecurityEvent(type: 'LOCKOUT' | 'ANOMALY' | ..., context)
```

**PII Redaction Rules:**

```typescript
// Fields to hash (not store plaintext)
const HASH_FIELDS = ["dateOfBirth", "phone", "emergencyContact.phone"];

// Fields to redact completely
const REDACT_FIELDS = ["password", "secret", "token", "mfaSecret"];

// For DATA changes, store diffs only
function createAuditDiff(before: object, after: object): object {
  // Returns { fieldName: { old: redacted/hashed, new: redacted/hashed } }
}
```

**Implementation:**

- [x] Create `src/db/schema/audit.schema.ts`
- [x] Create `src/lib/audit/` module
- [x] Implement hash chain verification utility
- [x] Add request ID middleware (correlation)
- [x] Wire into auth flows (login, logout, MFA)
- [x] Wire into admin actions (role changes, org management)
- [x] Create admin UI for log viewing, filtering, export

**Acceptance Criteria:**

- [x] All auth events are logged (login, logout, failed attempts, MFA)
- [x] All admin actions are logged with actor and target
- [x] Data changes log field-level diffs (not full snapshots)
- [x] PII fields are hashed/redacted per policy
- [x] Logs cannot be modified or deleted (DB trigger enforced)
- [x] Hash chain can be verified for integrity
- [x] Admin can filter by user, org, action, date range
- [x] Logs can be exported to CSV

---

#### F-003: Notification Engine

**Priority:** P0 (Blocker)
**Effort:** 2 weeks
**Blocks:** Reporting reminders, security alerts, support tickets

**Architecture:**

```
User Action → Notification Request → SQS Queue → Worker → Email (SES) + In-App DB
                                                      ↓
                                              User Preferences Check
```

**Database Schema:**

```sql
-- In-app notifications
CREATE TABLE notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
  organization_id UUID REFERENCES organizations(id),

  type TEXT NOT NULL, -- 'reporting_reminder', 'security_alert', 'ticket_update', etc.
  category TEXT NOT NULL, -- 'reporting', 'security', 'support', 'system'

  title TEXT NOT NULL,
  body TEXT NOT NULL,
  link TEXT, -- Deep link to relevant page

  read_at TIMESTAMPTZ,
  dismissed_at TIMESTAMPTZ,

  metadata JSONB NOT NULL DEFAULT '{}',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- User notification preferences
CREATE TABLE notification_preferences (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
  category TEXT NOT NULL, -- 'reporting', 'security', 'support', 'system'

  channel_email BOOLEAN NOT NULL DEFAULT true,
  channel_in_app BOOLEAN NOT NULL DEFAULT true,

  -- Email frequency (for non-urgent)
  email_frequency TEXT NOT NULL DEFAULT 'immediate'
    CHECK (email_frequency IN ('immediate', 'daily_digest', 'weekly_digest', 'never')),

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(user_id, category)
);

-- Admin-managed notification templates
CREATE TABLE notification_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  key TEXT UNIQUE NOT NULL, -- 'reporting_reminder_7day', 'security_lockout', etc.

  category TEXT NOT NULL,
  subject TEXT NOT NULL,
  body_template TEXT NOT NULL, -- Supports {{variable}} substitution

  is_system BOOLEAN NOT NULL DEFAULT false, -- System templates can't be deleted

  created_by TEXT REFERENCES "user"(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Scheduled notifications (for reminders)
CREATE TABLE scheduled_notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  template_key TEXT NOT NULL REFERENCES notification_templates(key),

  -- Target (user, org, or broadcast)
  user_id TEXT REFERENCES "user"(id),
  organization_id UUID REFERENCES organizations(id),
  role_filter TEXT, -- Optional: only users with this role

  scheduled_for TIMESTAMPTZ NOT NULL,

  -- Execution tracking
  sent_at TIMESTAMPTZ,
  failed_at TIMESTAMPTZ,
  error_message TEXT,
  retry_count INTEGER NOT NULL DEFAULT 0,

  variables JSONB NOT NULL DEFAULT '{}',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indices
CREATE INDEX idx_notifications_user ON notifications(user_id, read_at NULLS FIRST, created_at DESC);
CREATE INDEX idx_notifications_org ON notifications(organization_id, created_at DESC);
CREATE INDEX idx_scheduled_pending ON scheduled_notifications(scheduled_for)
  WHERE sent_at IS NULL AND failed_at IS NULL;
```

**Implementation:**

- [x] Create `src/db/schema/notifications.schema.ts`
- [x] Create `src/features/notifications/` module
- [x] Create `src/lib/notifications/queue.ts` (SQS integration)
- [x] Create `src/lib/notifications/send.ts` (dispatch logic)
- [x] Create `src/lib/notifications/scheduler.ts` (EventBridge integration)
- [x] Add notification bell component to header
- [x] Add notification preferences UI
- [x] Add admin template management UI

**Acceptance Criteria:**

- [x] Users see notification bell with unread count
- [x] Notification panel shows recent items, mark as read
- [x] Users can configure preferences per category
- [x] Email notifications respect user preferences
- [x] Scheduled notifications fire at configured times
- [x] Failed notifications retry with backoff
- [x] All notifications are audit logged

---

### Phase 2: Security Hardening (3-4 weeks)

#### S-001: Multi-Factor Authentication

**Priority:** P1
**Effort:** 1.5 weeks
**Requirement:** SEC-AGG-001

**Approach:** Use [Better Auth 2FA Plugin](https://www.better-auth.com/docs/plugins/2fa)

**Features to Implement:**

- [x] TOTP enrollment with QR code
- [x] Backup codes (10 single-use codes)
- [x] MFA challenge on login
- [x] MFA required for admin roles (enforced)
- [x] Step-up auth for sensitive actions
- [x] MFA recovery workflow

**Note:** Better Auth 2FA currently supports credential accounts only. For admin roles,
require a password-linked account or restrict admin roles to credential users.

**Database Additions:**

```sql
-- Better Auth 2FA plugin manages its own tables, but we track:
ALTER TABLE "user" ADD COLUMN mfa_required BOOLEAN NOT NULL DEFAULT false;
ALTER TABLE "user" ADD COLUMN mfa_enrolled_at TIMESTAMPTZ;

-- Track MFA events in audit log (no additional table needed)
```

**Implementation:**

- [x] Install and configure Better Auth 2FA plugin
- [x] Create `src/features/auth/mfa/` components
- [x] MFA enrollment wizard (TOTP QR + backup codes)
- [x] MFA challenge screen
- [x] Step-up auth middleware for sensitive routes
- [x] Admin UI to require MFA for roles (warning + badges added in role dashboard)

**Acceptance Criteria:**

- [x] Users can enroll in TOTP MFA
- [x] Backup codes are generated and displayed once
- [x] Login requires MFA code when enrolled
- [x] Admin roles must have MFA (enforced on role assignment)
- [x] Sensitive actions (exports, role changes) require re-auth
- [x] All MFA events are audit logged

---

#### S-002: Security Event Monitoring & Lockout

**Priority:** P1
**Effort:** 1.5 weeks
**Requirement:** SEC-AGG-002

**Database Schema:**

```sql
-- Security events (separate from audit for performance)
CREATE TABLE security_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT REFERENCES "user"(id),

  event_type TEXT NOT NULL, -- 'login_success', 'login_fail', 'mfa_fail', 'password_reset', etc.

  ip_address INET NOT NULL,
  user_agent TEXT,
  geo_country TEXT,
  geo_region TEXT,

  risk_score INTEGER NOT NULL DEFAULT 0, -- 0-100
  risk_factors JSONB NOT NULL DEFAULT '[]', -- ['new_device', 'new_location', 'unusual_time']

  metadata JSONB NOT NULL DEFAULT '{}',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Account locks
CREATE TABLE account_locks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT NOT NULL REFERENCES "user"(id),

  reason TEXT NOT NULL, -- 'failed_logins', 'suspicious_activity', 'admin_action'

  locked_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  unlock_at TIMESTAMPTZ, -- NULL = permanent until manual unlock

  unlocked_by TEXT REFERENCES "user"(id),
  unlocked_at TIMESTAMPTZ,
  unlock_reason TEXT,

  metadata JSONB NOT NULL DEFAULT '{}'
);

-- Indices
CREATE INDEX idx_security_events_user ON security_events(user_id, created_at DESC);
CREATE INDEX idx_security_events_ip ON security_events(ip_address, created_at DESC);
CREATE INDEX idx_account_locks_user ON account_locks(user_id) WHERE unlocked_at IS NULL;
```

**Detection Rules (Configurable):**
| Trigger | Action |
|---------|--------|
| 5 failed logins in 15 minutes | Lock for 30 minutes |
| 10 failed logins in 1 hour | Lock until admin unlock |
| Login from new country | Flag for review, notify user |
| 3 failed MFA in 5 minutes | Lock for 15 minutes |
| Password reset from new device | Require additional verification |

**Implementation:**

- [x] Create `src/db/schema/security.schema.ts`
- [x] Create `src/lib/security/events.ts` (capture and store)
- [x] Create `src/lib/security/detection.ts` (rules engine)
- [x] Create `src/lib/security/lockout.ts` (lock/unlock logic)
- [x] Integrate with auth flows
- [x] Create admin security dashboard
- [x] Add alert notifications to admins

**Acceptance Criteria:**

- [x] All auth events captured with IP/UA/geo
- [x] Failed login threshold triggers auto-lock
- [x] Locked accounts cannot authenticate
- [x] Admins receive notifications for lockouts
- [x] Admins can manually lock/unlock with reason
- [x] Security dashboard shows recent events and anomalies
- [x] All security events are audit logged

---

#### S-003: Privacy Compliance (PIPEDA)

**Priority:** P1
**Effort:** 1.5 weeks
**Requirement:** SEC-AGG-003

**Database Schema:**

```sql
-- Privacy policy versions
CREATE TABLE policy_documents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  type TEXT NOT NULL CHECK (type IN ('privacy_policy', 'terms_of_service', 'data_agreement')),
  version TEXT NOT NULL,

  content_url TEXT, -- S3 URL to PDF
  content_hash TEXT NOT NULL, -- SHA-256 of content

  effective_date DATE NOT NULL,
  published_at TIMESTAMPTZ,
  published_by TEXT REFERENCES "user"(id),

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(type, version)
);

-- User policy acceptances (immutable record)
CREATE TABLE user_policy_acceptances (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT NOT NULL REFERENCES "user"(id),
  policy_id UUID NOT NULL REFERENCES policy_documents(id),

  accepted_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ip_address INET,
  user_agent TEXT,

  UNIQUE(user_id, policy_id)
);

-- Data Subject Access Requests (DSAR)
CREATE TABLE privacy_requests (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT NOT NULL REFERENCES "user"(id),

  type TEXT NOT NULL CHECK (type IN ('access', 'export', 'erasure', 'correction')),
  status TEXT NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'processing', 'completed', 'rejected')),

  requested_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Processing
  processed_by TEXT REFERENCES "user"(id),
  processed_at TIMESTAMPTZ,

  -- Result
  result_url TEXT, -- S3 URL for exports
  result_notes TEXT,
  rejection_reason TEXT,

  -- Audit
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Data retention policies
CREATE TABLE retention_policies (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  data_type TEXT NOT NULL, -- 'submissions', 'audit_logs', 'sessions', etc.

  retention_days INTEGER NOT NULL,
  archive_after_days INTEGER,
  purge_after_days INTEGER,

  legal_hold BOOLEAN NOT NULL DEFAULT false,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  UNIQUE(data_type)
);
```

**Implementation:**

- [x] Create `src/db/schema/privacy.schema.ts`
- [x] Create `src/features/privacy/` module
- [x] Policy acceptance flow (block access until accepted)
- [x] DSAR request submission UI
- [x] Admin DSAR processing workflow
- [x] Data export generation (user's PII)
- [x] Data erasure/anonymization logic
- [x] Retention policy configuration UI
- [x] Scheduled retention enforcement job

**Acceptance Criteria:**

- [x] Users must accept current policy to proceed
- [x] Policy acceptance recorded with timestamp/IP
- [x] Users can submit DSAR (export, erasure)
- [x] Admins can process DSAR with audit trail
- [x] Data exports include all user PII
- [x] Erasure anonymizes data while preserving audit logs
- [x] Retention policies can be configured per data type

---

### Phase 3: Core SIN Features (6-8 weeks)

#### D-001: Dynamic Form Builder

**Priority:** P1
**Effort:** 3-4 weeks
**Requirements:** DM-AGG-001, RP-AGG-004

**Database Schema:**

```sql
-- Form definitions
CREATE TABLE forms (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID REFERENCES organizations(id), -- NULL = system-wide

  name TEXT NOT NULL,
  slug TEXT NOT NULL,
  description TEXT,

  status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'published', 'archived')),

  created_by TEXT NOT NULL REFERENCES "user"(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  UNIQUE(organization_id, slug)
);

-- Form versions (immutable once published)
CREATE TABLE form_versions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  form_id UUID NOT NULL REFERENCES forms(id) ON DELETE CASCADE,

  version_number INTEGER NOT NULL,

  -- Form definition (see FormDefinition type below)
  definition JSONB NOT NULL,

  published_at TIMESTAMPTZ,
  published_by TEXT REFERENCES "user"(id),

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  UNIQUE(form_id, version_number)
);

-- Form submissions
CREATE TABLE form_submissions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  form_id UUID NOT NULL REFERENCES forms(id),
  form_version_id UUID NOT NULL REFERENCES form_versions(id),
  organization_id UUID NOT NULL REFERENCES organizations(id),

  submitter_id TEXT REFERENCES "user"(id),

  status TEXT NOT NULL DEFAULT 'draft'
    CHECK (status IN ('draft', 'submitted', 'under_review', 'changes_requested', 'approved', 'rejected')),

  payload JSONB NOT NULL,

  -- Validation tracking
  completeness_score INTEGER, -- 0-100
  missing_fields JSONB DEFAULT '[]',
  validation_errors JSONB DEFAULT '[]',

  -- Workflow tracking
  submitted_at TIMESTAMPTZ,
  reviewed_by TEXT REFERENCES "user"(id),
  reviewed_at TIMESTAMPTZ,
  review_notes TEXT,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Submission version history
CREATE TABLE form_submission_versions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  submission_id UUID NOT NULL REFERENCES form_submissions(id) ON DELETE CASCADE,

  version_number INTEGER NOT NULL,
  payload_snapshot JSONB NOT NULL,

  changed_by TEXT REFERENCES "user"(id),
  change_reason TEXT,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  UNIQUE(submission_id, version_number)
);

-- File attachments
CREATE TABLE submission_files (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  submission_id UUID NOT NULL REFERENCES form_submissions(id) ON DELETE CASCADE,

  field_key TEXT NOT NULL,
  file_name TEXT NOT NULL,
  mime_type TEXT NOT NULL,
  size_bytes INTEGER NOT NULL,
  checksum TEXT NOT NULL, -- SHA-256

  storage_key TEXT NOT NULL, -- S3 key

  uploaded_by TEXT REFERENCES "user"(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Form Definition TypeScript Schema:**

```typescript
interface FormDefinition {
  fields: FormField[];
  layout?: {
    sections: { title: string; fieldKeys: string[] }[];
  };
  settings: {
    allowDraft: boolean;
    requireApproval: boolean;
    notifyOnSubmit: string[]; // role names or user IDs
  };
}

interface FormField {
  key: string;
  type:
    | "text"
    | "number"
    | "email"
    | "phone"
    | "date"
    | "select"
    | "multiselect"
    | "checkbox"
    | "file"
    | "textarea"
    | "rich_text";
  label: string;
  description?: string;
  placeholder?: string;
  required: boolean;
  validation?: ValidationRule[];
  options?: { value: string; label: string }[]; // for select/multiselect
  conditional?: {
    field: string;
    operator: "equals" | "not_equals" | "contains" | "greater_than";
    value: unknown;
  };
  fileConfig?: {
    allowedTypes: string[]; // MIME types
    maxSizeBytes: number;
    maxFiles: number;
  };
}

interface ValidationRule {
  type: "min_length" | "max_length" | "pattern" | "min" | "max" | "custom";
  value: string | number;
  message: string;
}
```

**Implementation:**

- [x] Create `src/db/schema/forms.schema.ts`
- [x] Create `src/features/forms/` module
- [x] Form builder UI (drag-and-drop field palette)
- [x] Field configuration panel
- [x] Form preview mode
- [x] Form publishing workflow (creates immutable version)
- [x] Form renderer (generates form from definition)
- [x] Server-side validation from definition
- [x] Sanitize `rich_text` content server-side (allowlist + XSS-safe rendering)
- [x] Submission workflow (draft → submit → review)
- [x] File upload with S3 pre-signed URLs
- [x] Submission history viewer

**Acceptance Criteria:**

- [x] Admins can create forms with all field types
- [x] Validation rules are enforced server-side
- [x] Published forms are immutable (edits create new version)
- [x] Submissions track which form version was used
- [x] Files can be attached and downloaded
- [x] Submission history shows all changes
- [x] Forms support conditional field visibility

---

#### D-002: Bulk Import & Data Migration

**Priority:** P1
**Effort:** 2-3 weeks
**Requirement:** DM-AGG-006

**Two-Lane Architecture:**

**Lane 1: Interactive Import (<10K rows)**

- UI wizard for admin uploads
- In-memory validation with preview
- Row-level error display
- Direct database insert with rollback support (tag rows with `import_job_id` or use staging)

**Lane 2: Batch Import (>10K rows, up to 20M+)**

- S3 upload for source file
- Worker-based processing (ECS Fargate)
- Chunked validation in SQL
- Resumable checkpoints
- Error report to S3 (not row-per-row in DB)

**Database Schema:**

```sql
-- Import jobs (both lanes)
CREATE TABLE import_jobs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id),

  -- Source
  type TEXT NOT NULL CHECK (type IN ('csv', 'excel')),
  lane TEXT NOT NULL CHECK (lane IN ('interactive', 'batch')),
  source_file_key TEXT NOT NULL, -- S3 key
  source_file_hash TEXT NOT NULL,
  source_row_count INTEGER,

  -- Target
  target_form_id UUID REFERENCES forms(id),
  mapping_template_id UUID REFERENCES import_mapping_templates(id),

  -- Status
  status TEXT NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'validating', 'validated', 'importing',
                      'completed', 'failed', 'cancelled', 'rolled_back')),

  -- Progress (for batch)
  progress_checkpoint INTEGER DEFAULT 0,

  -- Stats
  stats JSONB NOT NULL DEFAULT '{}',
  -- { rows_total, rows_processed, rows_succeeded, rows_failed, validation_errors }

  -- Error handling
  error_report_key TEXT, -- S3 key to detailed error CSV
  error_summary JSONB DEFAULT '{}',

  -- Rollback support (for batch)
  can_rollback BOOLEAN NOT NULL DEFAULT true,
  rollback_before TIMESTAMPTZ, -- Deadline for rollback

  -- Audit
  created_by TEXT NOT NULL REFERENCES "user"(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  started_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ
);

-- Mapping templates (reusable)
CREATE TABLE import_mapping_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID REFERENCES organizations(id),

  name TEXT NOT NULL,
  description TEXT,

  target_form_id UUID REFERENCES forms(id),

  -- Mapping rules
  mappings JSONB NOT NULL,
  -- { sourceColumn: { targetField, transform?, defaultValue? } }

  created_by TEXT NOT NULL REFERENCES "user"(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Row-level errors (Lane 1 only, capped)
CREATE TABLE import_job_errors (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  job_id UUID NOT NULL REFERENCES import_jobs(id) ON DELETE CASCADE,

  row_number INTEGER NOT NULL,
  field_key TEXT,
  error_type TEXT NOT NULL,
  error_message TEXT NOT NULL,
  raw_value TEXT,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Cap row-level errors to prevent table explosion
-- For batch imports, write full errors to S3 instead
```

**Lane 2 Batch Processing Design:**

```
1. Upload CSV to S3 → Create import_jobs row
2. EventBridge triggers ECS task
3. Worker:
   - Stream-parse CSV (don't load all in memory)
   - Validate in chunks (1000 rows)
   - Write valid rows to staging table
   - Write errors to S3 (errors.csv)
   - Update checkpoint after each chunk
4. On success:
   - Promote from staging to production in chunks (short transactions)
   - Mark job completed
5. On failure:
   - Log checkpoint for resume
   - Mark job failed with error summary
6. Rollback:
   - DELETE WHERE import_job_id = X
   - Only available before rollback_before deadline
```

**Implementation:**

- [x] Create `src/db/schema/imports.schema.ts`
- [x] Create `src/features/imports/` module
- [x] Lane 1: Import wizard UI
- [x] Lane 1: Field mapping UI with auto-suggestions
- [x] Lane 1: Validation preview
- [x] Lane 2: S3 upload flow
- [x] Lane 2: Worker container (ECS task definition) (drafted in `docs/sin-rfp/phase-0/import-batch-worker.md`)
- [x] Lane 2: Chunked processing with checkpoints
- [x] Lane 1 rollback strategy (tag inserts with `import_job_id` or stage then promote)
- [x] Mapping template CRUD
- [x] Import history and status dashboard
- [x] Rollback capability

**Acceptance Criteria:**

- [x] Admin can upload CSV/Excel and preview columns
- [x] Auto-suggest mappings by column name similarity
- [x] Preview shows first N rows with validation results
- [x] Validation errors shown per row (Lane 1) or in report (Lane 2)
- [x] Import can be executed after validation
- [x] Batch imports are resumable after failure
- [x] Lane 1 rollback supported via `import_job_id` tagging or staging discard
- [x] Rollback available within configured window
- [x] Mapping templates can be saved and reused
- [x] All imports are audit logged

---

#### R-001: Reporting Cycles & Workflows

**Priority:** P1
**Effort:** 2 weeks
**Requirement:** RP-AGG-003

**Database Schema:**

```sql
-- Reporting cycles (e.g., "FY2025 Q1", "Annual Report 2025")
CREATE TABLE reporting_cycles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  name TEXT NOT NULL,
  description TEXT,

  start_date DATE NOT NULL,
  end_date DATE NOT NULL,

  status TEXT NOT NULL DEFAULT 'upcoming'
    CHECK (status IN ('upcoming', 'active', 'closed', 'archived')),

  created_by TEXT REFERENCES "user"(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Reporting tasks (what's due, when)
CREATE TABLE reporting_tasks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  cycle_id UUID NOT NULL REFERENCES reporting_cycles(id) ON DELETE CASCADE,

  form_id UUID NOT NULL REFERENCES forms(id),

  -- Target (specific org or all orgs of a type)
  organization_id UUID REFERENCES organizations(id), -- NULL = all applicable orgs
  organization_type TEXT, -- 'pso', 'club', etc.

  title TEXT NOT NULL,
  description TEXT,
  due_date DATE NOT NULL,

  -- Reminder configuration
  reminder_config JSONB NOT NULL DEFAULT '{}',
  -- { days_before: [14, 7, 3, 1], overdue_frequency: 'daily' }

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Reporting submissions (per org per task)
CREATE TABLE reporting_submissions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  task_id UUID NOT NULL REFERENCES reporting_tasks(id),
  organization_id UUID NOT NULL REFERENCES organizations(id),

  form_submission_id UUID REFERENCES form_submissions(id),

  status TEXT NOT NULL DEFAULT 'not_started'
    CHECK (status IN ('not_started', 'in_progress', 'submitted',
                      'under_review', 'changes_requested', 'approved', 'overdue')),

  submitted_at TIMESTAMPTZ,
  submitted_by TEXT REFERENCES "user"(id),

  reviewed_at TIMESTAMPTZ,
  reviewed_by TEXT REFERENCES "user"(id),
  review_notes TEXT,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  UNIQUE(task_id, organization_id)
);

-- Submission history (for resubmissions)
CREATE TABLE reporting_submission_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  reporting_submission_id UUID NOT NULL REFERENCES reporting_submissions(id) ON DELETE CASCADE,

  action TEXT NOT NULL, -- 'submitted', 'changes_requested', 'resubmitted', 'approved'
  actor_id TEXT REFERENCES "user"(id),
  notes TEXT,

  form_submission_version_id UUID REFERENCES form_submission_versions(id),

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Implementation:**

- [x] Create `src/db/schema/reporting.schema.ts`
- [x] Create `src/features/reporting/` module
- [x] Reporting cycle CRUD (admin)
- [x] Task assignment UI
- [x] Reminder scheduler (EventBridge → SQS → notification)
- [x] Organization reporting dashboard ("What's due")
- [x] Admin reporting dashboard ("Who's behind")
- [x] Review workflow (approve/request changes)
- [x] Resubmission tracking with history

**Acceptance Criteria:**

- [x] Admins can create reporting cycles and tasks
- [x] Tasks can target specific orgs or org types
- [x] Organizations see their assigned tasks with due dates
- [x] Automated reminders sent at configured intervals
- [x] Status tracked through full workflow
- [x] Resubmissions maintain history with diffs
- [x] Dashboard shows progress across all orgs
- [x] Overdue tasks highlighted and tracked

---

### Phase 4: Analytics & Export (3-4 weeks)

#### R-002: Reporting & Export

**Priority:** P2
**Effort:** 3-4 weeks
**Requirement:** RP-AGG-005

**Layered Approach:**

| Layer   | Scope                                | Effort                            |
| ------- | ------------------------------------ | --------------------------------- |
| Layer 1 | Curated exports with field-level ACL | 2 weeks                           |
| Layer 2 | Saved reports with filters           | 1-2 weeks                         |
| Layer 3 | Self-service chart builder           | 3-4 weeks (defer unless required) |

**Database Schema:**

```sql
-- Saved reports
CREATE TABLE saved_reports (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID REFERENCES organizations(id),

  name TEXT NOT NULL,
  description TEXT,

  -- Report definition
  data_source TEXT NOT NULL, -- 'submissions', 'memberships', 'organizations'
  filters JSONB NOT NULL DEFAULT '{}',
  columns JSONB NOT NULL DEFAULT '[]', -- Which fields to include
  sort JSONB DEFAULT '{}',

  -- Access control
  owner_id TEXT NOT NULL REFERENCES "user"(id),
  shared_with JSONB DEFAULT '[]', -- user IDs or roles
  is_org_wide BOOLEAN NOT NULL DEFAULT false,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Export history (for audit)
CREATE TABLE export_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  user_id TEXT NOT NULL REFERENCES "user"(id),
  organization_id UUID REFERENCES organizations(id),

  report_id UUID REFERENCES saved_reports(id),

  export_type TEXT NOT NULL, -- 'csv', 'excel', 'pdf'
  data_source TEXT NOT NULL,
  filters_used JSONB NOT NULL,
  row_count INTEGER NOT NULL,

  file_key TEXT, -- S3 key (temporary)

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Field-Level Access Control:**

```typescript
interface FieldAccessPolicy {
  field: string;
  requiredRoles: string[]; // Empty = visible to all
  redactForRoles?: string[]; // Show as "***"
}

// Applied at export time, not query time
function applyFieldAccess(data: any[], userRoles: string[], policy: FieldAccessPolicy[]) {
  // Redact or remove fields based on policy
}
```

**Implementation:**

- [x] Create `src/db/schema/reports.schema.ts`
- [x] Create `src/features/reports/` module
- [x] Curated export endpoints (CSV, Excel)
- [x] Field-level access control middleware
- [x] Export audit logging
- [x] Saved report CRUD
- [x] Report builder UI (filters, columns)
- [x] Report sharing

**Acceptance Criteria:**

- [x] Authorized users can export datasets
- [x] Exports respect field-level access rules
- [x] Every export is audit logged
- [x] Reports can be saved with filters
- [x] Saved reports can be shared within org

---

## Part 4: Deferred Features (Phase 5+)

> These are not required for SIN MVP. Build only if explicitly requested.

| Feature                      | Reason to Defer              |
| ---------------------------- | ---------------------------- |
| Website builder              | Not a SIN requirement        |
| Mobile native app            | PWA sufficient               |
| Live scoring                 | Not a data warehouse feature |
| Competition management       | Not a SIN requirement        |
| LMS / training modules       | Can use external tool        |
| Full chart builder (Layer 3) | Layer 1-2 likely sufficient  |
| Multi-currency               | CAD only for viaSport        |
| Ticket sales                 | Not a SIN requirement        |

---

## Part 5: Migration Strategy (20M+ Rows)

### Pre-Migration Checklist

- [x] Legacy data inventory (tables, row counts, relationships) (synthetic placeholders in `docs/sin-rfp/phase-0/migration-strategy.md`)
- [x] Data quality assessment (nulls, duplicates, invalid formats) (synthetic placeholders in `docs/sin-rfp/phase-0/migration-strategy.md`)
- [x] Field mapping document (legacy → SIN) (synthesized in `docs/sin-rfp/phase-0/migration-strategy.md`)
- [x] Transformation rules (date formats, phone normalization, enum mappings) (synthesized in `docs/sin-rfp/phase-0/migration-strategy.md`)
- [x] Rollback plan (keep legacy system read-only during transition) (documented in `docs/sin-rfp/phase-0/migration-strategy.md`)

### Migration Phases

| Phase | Scope                  | Approach                             |
| ----- | ---------------------- | ------------------------------------ |
| 1     | Schema creation        | Run in empty environment             |
| 2     | Organization hierarchy | Manual or scripted setup             |
| 3     | User migration         | Batch import with email notification |
| 4     | Historical submissions | Lane 2 batch import                  |
| 5     | Document migration     | S3 bulk copy with metadata sync      |
| 6     | Validation             | Reconciliation reports               |
| 7     | Cutover                | DNS switch, legacy read-only         |

### Batch Import Configuration for 20M Rows

```yaml
# ECS Task Definition
resources:
  cpu: 2048
  memory: 4096

# Processing settings
chunk_size: 5000
checkpoint_interval: 10000
max_retries: 3
connection_pool: unpooled # Direct connection, not pooled

# Error handling
max_errors_before_abort: 10000
error_report_format: csv
error_report_destination: s3://bucket/imports/{job_id}/errors.csv
```

---

## Part 6: RFP Submission Checklist

### Documentation Deliverables

- [x] Reference architecture document (with diagram)
- [x] Data residency statement
- [x] Security controls overview
- [x] Backup & DR plan with RPO/RTO
- [x] Audit & retention policy
- [x] Sub-processor inventory
- [x] Data classification guide
- [x] Migration strategy document
- [x] Phased delivery plan

### Technical Demonstration

- [x] Organization hierarchy with multi-level access (hierarchy visualization pending)
- [x] Audit log with filtering and export
- [x] MFA enrollment and challenge
- [x] Dynamic form creation and submission
- [x] Bulk import with validation and rollback
- [x] Reporting cycle with reminders
- [x] DSAR workflow (export, erasure)

### Compliance Evidence

- [x] AWS Canada region configuration
- [x] Encryption at rest (KMS)
- [x] Encryption in transit (TLS 1.3)
- [x] Immutable audit logs (trigger-enforced)
- [x] Session security controls
- [x] PII redaction in logs
- [ ] Backup restore test results (template only; needs execution)

---

## Appendix A: Existing Code to Leverage

| Existing Code                                    | Use For                            |
| ------------------------------------------------ | ---------------------------------- |
| `src/db/schema/roles.schema.ts`                  | Extend for org-scoped roles        |
| `src/components/form-fields/*`                   | Form builder field types           |
| `src/lib/email/sendgrid.ts`                      | Migrate to SES, keep patterns      |
| `src/components/ui/data-table.tsx`               | Admin dashboards                   |
| `src/lib/pacer/*`                                | Rate limiting foundation           |
| `src/features/membership/membership.finalize.ts` | Pattern for atomic multi-table ops |
| `src/lib/auth/*`                                 | Extend with MFA and org context    |

---

## Appendix B: Technology Stack Updates

| Current            | SIN Production                    |
| ------------------ | --------------------------------- |
| Neon PostgreSQL    | AWS RDS PostgreSQL (ca-central-1) |
| Netlify            | AWS via SST (production)          |
| SendGrid           | AWS SES (ca-central-1)            |
| Local file storage | S3 with SSE-KMS                   |
| No queue           | SQS for notifications             |
| No scheduler       | EventBridge Scheduler             |
| Console logging    | CloudWatch Logs (PII redacted)    |

---

## Appendix C: Better Auth 2FA Configuration

```typescript
// src/lib/auth/index.ts
import { betterAuth } from "better-auth";
import { twoFactor } from "better-auth/plugins/2fa";

export const auth = betterAuth({
  // ... existing config
  plugins: [
    twoFactor({
      issuer: "viaSport SIN",
      // TOTP settings
      totpOptions: {
        digits: 6,
        period: 30,
      },
      // Backup codes
      backupCodes: {
        enabled: true,
        count: 10,
        length: 8,
      },
    }),
  ],
});
```

---

## Document History

| Version | Date       | Changes                                                      |
| ------- | ---------- | ------------------------------------------------------------ |
| v1.0    | 2024-12    | Initial backlog                                              |
| v2.0    | 2024-12    | Complete rewrite incorporating architecture review feedback  |
| v2.1    | 2025-12-24 | Added Implementation Progress Tracker with codebase analysis |
</file>

</files>
