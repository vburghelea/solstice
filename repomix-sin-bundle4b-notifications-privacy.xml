This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/features/notifications/**/*.ts, src/features/notifications/**/*.tsx, src/db/schema/notifications.schema.ts, src/lib/notifications/**/*.ts, src/lib/email/**/*.ts, src/features/privacy/**/*.ts, src/features/privacy/**/*.tsx, src/db/schema/privacy.schema.ts, src/features/audit/**/*.ts, src/features/audit/**/*.tsx, src/db/schema/audit.schema.ts, src/lib/audit/**/*.ts, docs/sin-rfp/tickets/SIN-IMPLEMENTATION-BACKLOG-V2.md, docs/sin-rfp/phase-0/audit-retention-policy.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<user_provided_header>
# Review Task: Notifications, Privacy & Audit Systems

## Focus
Review **notifications, privacy/DSAR, and audit logging** for correctness and PIPEDA compliance.

## Key Questions
1. Is audit logging immutable with proper hash chain verification?
2. Are PII fields properly hashed/redacted in audit logs?
3. Is the DSAR workflow (access, export, erasure) complete?
4. Are notifications properly queued and delivered?
5. Is the retention policy enforcement working correctly?

## Reference Documents
- `SIN-IMPLEMENTATION-BACKLOG-V2.md`: Contains requirements for F-002 (Audit), F-003 (Notifications), S-003 (Privacy)
- `audit-retention-policy.md`: Contains retention and archival rules

## Areas to Review
- Audit log immutability (trigger, hash chain)
- PII handling in audit entries
- DSAR request processing workflow
- Notification queue and delivery
- Retention policy enforcement and S3 cleanup

## Output Format
For each issue found:
1. **System**: Audit/Privacy/Notifications
2. **Severity**: High/Medium/Low
3. **Location**: file:line
4. **Issue**: What's wrong
5. **Compliance Impact**: PIPEDA/audit requirement affected
6. **Fix**: Suggested remediation
</user_provided_header>

<directory_structure>
docs/
  sin-rfp/
    phase-0/
      audit-retention-policy.md
    tickets/
      SIN-IMPLEMENTATION-BACKLOG-V2.md
src/
  db/
    schema/
      audit.schema.ts
      notifications.schema.ts
      privacy.schema.ts
  features/
    audit/
      components/
        audit-log-table.tsx
      audit.queries.ts
      audit.schemas.ts
    notifications/
      components/
        notification-bell.tsx
        notification-preferences-card.tsx
        notification-template-panel.tsx
      notifications.mutations.ts
      notifications.queries.ts
      notifications.schemas.ts
      notifications.types.ts
    privacy/
      components/
        onboarding-policy-step.tsx
        privacy-acceptance-card.tsx
        privacy-admin-panel.tsx
        privacy-dashboard.tsx
        retention-policy-panel.tsx
      privacy.mutations.ts
      privacy.queries.ts
      privacy.schemas.ts
  lib/
    audit/
      index.ts
    email/
      sendgrid.ts
    notifications/
      digest.ts
      queue.ts
      scheduler.ts
      send.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/features/privacy/components/onboarding-policy-step.tsx">
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { Button } from "~/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";
import { Checkbox } from "~/components/ui/checkbox";
import { Label } from "~/components/ui/label";
import { useState } from "react";
import { acceptPolicy } from "../privacy.mutations";
import { getLatestPolicyDocument, listUserPolicyAcceptances } from "../privacy.queries";

interface OnboardingPolicyStepProps {
  onComplete: () => void;
}

export function OnboardingPolicyStep({ onComplete }: OnboardingPolicyStepProps) {
  const queryClient = useQueryClient();
  const [acknowledged, setAcknowledged] = useState(false);

  const { data: policy, isLoading: policyLoading } = useQuery({
    queryKey: ["privacy", "policy", "latest"],
    queryFn: () => getLatestPolicyDocument({ data: "privacy_policy" }),
  });

  const { data: acceptances = [], isLoading: acceptancesLoading } = useQuery({
    queryKey: ["privacy", "policy", "acceptances"],
    queryFn: () => listUserPolicyAcceptances(),
  });

  const hasAccepted = policy
    ? acceptances.some((acceptance) => acceptance.policyId === policy.id)
    : false;

  const acceptMutation = useMutation({
    mutationFn: (policyId: string) => acceptPolicy({ data: { policyId } }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: ["privacy", "policy"] });
      void queryClient.invalidateQueries({
        queryKey: ["privacy", "policy", "acceptances"],
      });
      onComplete();
    },
  });

  const handleAccept = () => {
    if (!policy?.id) return;
    acceptMutation.mutate(policy.id);
  };

  const isLoading = policyLoading || acceptancesLoading;
  const canProceed = policy?.id && acknowledged && !acceptMutation.isPending;

  // If already accepted, auto-proceed
  if (hasAccepted && !isLoading) {
    onComplete();
    return null;
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>Privacy Policy</CardTitle>
        <CardDescription>
          Please review and accept our privacy policy to continue
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-6">
        {isLoading ? (
          <div className="flex items-center justify-center py-8">
            <div className="text-muted-foreground">Loading policy...</div>
          </div>
        ) : policy ? (
          <>
            <div className="bg-muted/50 rounded-lg border p-4">
              <div className="mb-3 flex items-center justify-between">
                <span className="font-medium">Privacy Policy</span>
                <span className="text-muted-foreground text-sm">
                  Version {policy.version}
                </span>
              </div>
              <p className="text-muted-foreground mb-3 text-sm">
                Effective: {new Date(policy.effectiveDate).toLocaleDateString()}
              </p>
              {policy.contentUrl ? (
                <a
                  href={policy.contentUrl}
                  target="_blank"
                  rel="noreferrer"
                  className="text-primary text-sm underline"
                >
                  View full policy document
                </a>
              ) : (
                <p className="text-muted-foreground text-sm">
                  This policy outlines how we collect, use, and protect your personal
                  information. By accepting, you agree to our data handling practices.
                </p>
              )}
            </div>

            <div className="flex items-start space-x-3">
              <Checkbox
                id="acknowledge"
                checked={acknowledged}
                onCheckedChange={(checked) => setAcknowledged(checked === true)}
              />
              <Label
                htmlFor="acknowledge"
                className="text-sm leading-relaxed cursor-pointer"
              >
                I have read and agree to the Privacy Policy. I understand how my data
                will be collected, used, and protected.
              </Label>
            </div>

            {acceptMutation.isError && (
              <p className="text-sm text-destructive">
                Failed to accept policy. Please try again.
              </p>
            )}

            <Button
              onClick={handleAccept}
              disabled={!canProceed}
              className="w-full"
            >
              {acceptMutation.isPending ? "Accepting..." : "Accept and Continue"}
            </Button>
          </>
        ) : (
          <div className="py-8 text-center">
            <p className="text-muted-foreground">
              No privacy policy is currently published. You may continue without
              accepting.
            </p>
            <Button onClick={onComplete} className="mt-4">
              Continue
            </Button>
          </div>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="docs/sin-rfp/phase-0/audit-retention-policy.md">
# SIN Audit and Retention Policy

## Document Control

| Item     | Value                       |
| -------- | --------------------------- |
| Document | Audit and Retention Policy  |
| Audience | viaSport BC Evaluation Team |
| Version  | 1.0                         |
| Scope    | Production SIN platform     |

## 1.0 Purpose

This policy defines what is logged in the SIN platform, how audit data is
protected, and how long records are retained. It supports SEC-AGG-004 and
PIPEDA-aligned accountability requirements.

## 2.0 Audit Log Scope

| Action Type | Examples                 | Data Captured          | PII Handling    |
| ----------- | ------------------------ | ---------------------- | --------------- |
| AUTH.\*     | login, logout, MFA       | metadata only          | no secrets      |
| ADMIN.\*    | role changes, org config | before/after diff      | redacted/hashes |
| DATA.\*     | create/update/delete     | field-level diff       | redacted/hashes |
| EXPORT.\*   | report exports           | parameters + row count | no PII payload  |
| SECURITY.\* | lockouts, anomalies      | context metadata       | no secrets      |

Audit logs are append-only and protected with tamper-evident hashing.
Audit entries are scoped to `organization_id` and filtered by org access rules
to prevent cross-tenant visibility.

## 3.0 PII Redaction and Hashing Rules

- Sensitive fields are hashed (DOB, phone, emergency contact)
- Secrets and tokens are fully redacted
- Only diffs are stored for data changes, not full snapshots

## 4.0 Retention Schedule

| Data Type        | Retention | Storage       | Notes             |
| ---------------- | --------- | ------------- | ----------------- |
| Audit logs       | 7 years   | RDS + Glacier | Immutable archive |
| Security events  | 2 years   | RDS           | Configurable      |
| Export history   | 7 years   | RDS           | Links to audit    |
| Application logs | 1 year    | CloudWatch    | PII minimized     |
| Backups          | 35 days   | RDS snapshots | PITR enabled      |

Retention periods can be adjusted with viaSport approval.

## 5.0 Archive and Purge Procedures

- Audit logs older than active retention window are archived to S3 Glacier
  with Object Lock enabled.
- Purges are executed only after retention expires and are recorded in the
  audit log.

## 6.0 Legal Hold

- Legal holds can be applied at the record, user, or organization level.
- Held records are exempt from purge until the hold is released.

## 7.0 Access Control and Export

- Audit access is limited to authorized viaSport administrators.
- Audit exports are logged and require step-up authentication.

## 8.0 References

- `docs/sin-rfp/phase-0/security-controls.md`
- `docs/sin-rfp/SIN-REQUIREMENTS.md`
</file>

<file path="src/db/schema/audit.schema.ts">
import { index, inet, jsonb, pgTable, text, timestamp, uuid } from "drizzle-orm/pg-core";
import type { JsonRecord, JsonValue } from "~/shared/lib/json";
import { user } from "./auth.schema";
import { organizations } from "./organizations.schema";

export const auditLogs = pgTable(
  "audit_logs",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    occurredAt: timestamp("occurred_at", { withTimezone: true }).notNull().defaultNow(),

    actorUserId: text("actor_user_id").references(() => user.id),
    actorOrgId: uuid("actor_org_id").references(() => organizations.id),
    actorIp: inet("actor_ip"),
    actorUserAgent: text("actor_user_agent"),

    action: text("action").notNull(),
    actionCategory: text("action_category").notNull(),

    targetType: text("target_type"),
    targetId: text("target_id"),
    targetOrgId: uuid("target_org_id").references(() => organizations.id),

    changes:
      jsonb("changes").$type<Record<string, { old?: JsonValue; new?: JsonValue }>>(),
    metadata: jsonb("metadata").$type<JsonRecord>().notNull().default({}),

    requestId: text("request_id").notNull(),
    prevHash: text("prev_hash"),
    entryHash: text("entry_hash").notNull(),

    createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  },
  (table) => [
    index("audit_logs_actor_idx").on(table.actorUserId, table.occurredAt),
    index("audit_logs_target_idx").on(table.targetType, table.targetId, table.occurredAt),
    index("audit_logs_action_idx").on(table.actionCategory, table.occurredAt),
    index("audit_logs_org_idx").on(table.targetOrgId, table.occurredAt),
    index("audit_logs_request_idx").on(table.requestId),
  ],
);

export type AuditLog = typeof auditLogs.$inferSelect;
export type NewAuditLog = typeof auditLogs.$inferInsert;
</file>

<file path="src/db/schema/notifications.schema.ts">
import { sql } from "drizzle-orm";
import {
  boolean,
  index,
  integer,
  jsonb,
  pgTable,
  text,
  timestamp,
  uniqueIndex,
  uuid,
} from "drizzle-orm/pg-core";
import type { JsonRecord } from "~/shared/lib/json";
import { user } from "./auth.schema";
import { organizations } from "./organizations.schema";

export const notifications = pgTable(
  "notifications",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    organizationId: uuid("organization_id").references(() => organizations.id),
    type: text("type").notNull(),
    category: text("category").notNull(),
    title: text("title").notNull(),
    body: text("body").notNull(),
    link: text("link"),
    readAt: timestamp("read_at", { withTimezone: true }),
    dismissedAt: timestamp("dismissed_at", { withTimezone: true }),
    metadata: jsonb("metadata").$type<JsonRecord>().notNull().default({}),
    createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  },
  (table) => [
    index("notifications_user_idx").on(table.userId, table.readAt, table.createdAt),
    index("notifications_org_idx").on(table.organizationId, table.createdAt),
  ],
);

export const notificationPreferences = pgTable(
  "notification_preferences",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    category: text("category").notNull(),
    channelEmail: boolean("channel_email").notNull().default(true),
    channelInApp: boolean("channel_in_app").notNull().default(true),
    emailFrequency: text("email_frequency").notNull().default("immediate"),
    createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
    updatedAt: timestamp("updated_at", { withTimezone: true })
      .notNull()
      .defaultNow()
      .$onUpdate(() => new Date()),
  },
  (table) => [
    uniqueIndex("notification_preferences_unique").on(table.userId, table.category),
  ],
);

export const notificationTemplates = pgTable(
  "notification_templates",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    key: text("key").notNull(),
    category: text("category").notNull(),
    subject: text("subject").notNull(),
    bodyTemplate: text("body_template").notNull(),
    isSystem: boolean("is_system").notNull().default(false),
    createdBy: text("created_by").references(() => user.id),
    createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
    updatedAt: timestamp("updated_at", { withTimezone: true })
      .notNull()
      .defaultNow()
      .$onUpdate(() => new Date()),
  },
  (table) => [uniqueIndex("notification_templates_key_unique").on(table.key)],
);

export const scheduledNotifications = pgTable(
  "scheduled_notifications",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    templateKey: text("template_key")
      .notNull()
      .references(() => notificationTemplates.key),
    userId: text("user_id").references(() => user.id),
    organizationId: uuid("organization_id").references(() => organizations.id),
    roleFilter: text("role_filter"),
    scheduledFor: timestamp("scheduled_for", { withTimezone: true }).notNull(),
    sentAt: timestamp("sent_at", { withTimezone: true }),
    failedAt: timestamp("failed_at", { withTimezone: true }),
    errorMessage: text("error_message"),
    retryCount: integer("retry_count").notNull().default(0),
    variables: jsonb("variables").$type<JsonRecord>().notNull().default({}),
    createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  },
  (table) => [
    index("scheduled_notifications_pending_idx")
      .on(table.scheduledFor)
      .where(sql`${table.sentAt} IS NULL AND ${table.failedAt} IS NULL`),
  ],
);

export type Notification = typeof notifications.$inferSelect;
export type NewNotification = typeof notifications.$inferInsert;
export type NotificationPreference = typeof notificationPreferences.$inferSelect;
export type NewNotificationPreference = typeof notificationPreferences.$inferInsert;
export type NotificationTemplate = typeof notificationTemplates.$inferSelect;
export type NewNotificationTemplate = typeof notificationTemplates.$inferInsert;
export type ScheduledNotification = typeof scheduledNotifications.$inferSelect;
export type NewScheduledNotification = typeof scheduledNotifications.$inferInsert;
</file>

<file path="src/db/schema/privacy.schema.ts">
import {
  boolean,
  date,
  integer,
  pgEnum,
  pgTable,
  text,
  timestamp,
  uniqueIndex,
  uuid,
} from "drizzle-orm/pg-core";
import { user } from "./auth.schema";

export const policyTypeEnum = pgEnum("policy_type", [
  "privacy_policy",
  "terms_of_service",
  "data_agreement",
]);

export const privacyRequestTypeEnum = pgEnum("privacy_request_type", [
  "access",
  "export",
  "erasure",
  "correction",
]);

export const privacyRequestStatusEnum = pgEnum("privacy_request_status", [
  "pending",
  "processing",
  "completed",
  "rejected",
]);

export const policyDocuments = pgTable(
  "policy_documents",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    type: policyTypeEnum("type").notNull(),
    version: text("version").notNull(),
    contentUrl: text("content_url"),
    contentHash: text("content_hash").notNull(),
    effectiveDate: date("effective_date").notNull(),
    publishedAt: timestamp("published_at", { withTimezone: true }),
    publishedBy: text("published_by").references(() => user.id),
    createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  },
  (table) => [uniqueIndex("policy_documents_unique").on(table.type, table.version)],
);

export const userPolicyAcceptances = pgTable(
  "user_policy_acceptances",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    userId: text("user_id")
      .notNull()
      .references(() => user.id),
    policyId: uuid("policy_id")
      .notNull()
      .references(() => policyDocuments.id),
    acceptedAt: timestamp("accepted_at", { withTimezone: true }).notNull().defaultNow(),
    ipAddress: text("ip_address"),
    userAgent: text("user_agent"),
  },
  (table) => [
    uniqueIndex("user_policy_acceptances_unique").on(table.userId, table.policyId),
  ],
);

export const privacyRequests = pgTable("privacy_requests", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: text("user_id")
    .notNull()
    .references(() => user.id),
  type: privacyRequestTypeEnum("type").notNull(),
  status: privacyRequestStatusEnum("status").notNull().default("pending"),
  requestedAt: timestamp("requested_at", { withTimezone: true }).notNull().defaultNow(),
  processedBy: text("processed_by").references(() => user.id),
  processedAt: timestamp("processed_at", { withTimezone: true }),
  resultUrl: text("result_url"),
  resultNotes: text("result_notes"),
  rejectionReason: text("rejection_reason"),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true })
    .notNull()
    .defaultNow()
    .$onUpdate(() => new Date()),
});

export const retentionPolicies = pgTable(
  "retention_policies",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    dataType: text("data_type").notNull(),
    retentionDays: integer("retention_days").notNull(),
    archiveAfterDays: integer("archive_after_days"),
    purgeAfterDays: integer("purge_after_days"),
    legalHold: boolean("legal_hold").notNull().default(false),
    createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
    updatedAt: timestamp("updated_at", { withTimezone: true })
      .notNull()
      .defaultNow()
      .$onUpdate(() => new Date()),
  },
  (table) => [uniqueIndex("retention_policies_unique").on(table.dataType)],
);

export type PolicyDocument = typeof policyDocuments.$inferSelect;
export type NewPolicyDocument = typeof policyDocuments.$inferInsert;
export type UserPolicyAcceptance = typeof userPolicyAcceptances.$inferSelect;
export type NewUserPolicyAcceptance = typeof userPolicyAcceptances.$inferInsert;
export type PrivacyRequest = typeof privacyRequests.$inferSelect;
export type NewPrivacyRequest = typeof privacyRequests.$inferInsert;
export type RetentionPolicy = typeof retentionPolicies.$inferSelect;
export type NewRetentionPolicy = typeof retentionPolicies.$inferInsert;
</file>

<file path="src/features/audit/components/audit-log-table.tsx">
import { useMutation, useQuery } from "@tanstack/react-query";
import { useMemo, useState } from "react";
import { Button } from "~/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";
import { Input } from "~/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "~/components/ui/table";
import type { AuditLog } from "~/db/schema";
import { exportAuditLogs, listAuditLogs, verifyAuditHashChain } from "../audit.queries";

export function AuditLogTable() {
  const [actorUserId, setActorUserId] = useState("");
  const [targetOrgId, setTargetOrgId] = useState("");
  const [actionCategory, setActionCategory] = useState("all");
  const [fromDate, setFromDate] = useState("");
  const [toDate, setToDate] = useState("");
  const [verifyResult, setVerifyResult] = useState<{
    valid: boolean;
    invalidIds: string[];
  } | null>(null);

  const queryData = useMemo(() => {
    return {
      limit: 50,
      actorUserId: actorUserId || undefined,
      targetOrgId: targetOrgId || undefined,
      actionCategory: actionCategory === "all" ? undefined : actionCategory,
      from: fromDate || undefined,
      to: toDate || undefined,
    };
  }, [actionCategory, actorUserId, fromDate, targetOrgId, toDate]);

  const { data = [] } = useQuery<AuditLog[]>({
    queryKey: ["audit", "logs", queryData],
    queryFn: () => listAuditLogs({ data: queryData }),
  });

  const exportMutation = useMutation({
    mutationFn: async () => exportAuditLogs({ data: queryData }),
    onSuccess: (csv) => {
      const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = "audit-log-export.csv";
      link.click();
      URL.revokeObjectURL(url);
    },
  });

  const verifyMutation = useMutation({
    mutationFn: () => verifyAuditHashChain(),
    onSuccess: (result) => {
      setVerifyResult(result);
    },
  });

  return (
    <Card>
      <CardHeader>
        <CardTitle>Audit Log</CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="grid gap-3 lg:grid-cols-3">
          <Input
            placeholder="Actor user ID"
            value={actorUserId}
            onChange={(event) => setActorUserId(event.target.value)}
          />
          <Input
            placeholder="Target organization ID"
            value={targetOrgId}
            onChange={(event) => setTargetOrgId(event.target.value)}
          />
          <Select value={actionCategory} onValueChange={setActionCategory}>
            <SelectTrigger className="h-9">
              <SelectValue placeholder="Action category" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All categories</SelectItem>
              <SelectItem value="AUTH">AUTH</SelectItem>
              <SelectItem value="ADMIN">ADMIN</SelectItem>
              <SelectItem value="DATA">DATA</SelectItem>
              <SelectItem value="EXPORT">EXPORT</SelectItem>
              <SelectItem value="SECURITY">SECURITY</SelectItem>
            </SelectContent>
          </Select>
        </div>
        <div className="flex flex-wrap items-center gap-3">
          <Input
            type="date"
            value={fromDate}
            onChange={(event) => setFromDate(event.target.value)}
          />
          <Input
            type="date"
            value={toDate}
            onChange={(event) => setToDate(event.target.value)}
          />
          <Button
            type="button"
            variant="outline"
            onClick={() => exportMutation.mutate()}
            disabled={exportMutation.isPending}
          >
            {exportMutation.isPending ? "Exporting..." : "Export CSV"}
          </Button>
          <Button
            type="button"
            variant="outline"
            onClick={() => verifyMutation.mutate()}
            disabled={verifyMutation.isPending}
          >
            {verifyMutation.isPending ? "Verifying..." : "Verify hash chain"}
          </Button>
        </div>
        {verifyResult ? (
          <div className="rounded-md border border-gray-200 p-3 text-xs">
            {verifyResult.valid ? (
              <p className="text-emerald-600">Hash chain verified successfully.</p>
            ) : (
              <p className="text-destructive">
                Hash chain invalid for {verifyResult.invalidIds.length} entries.
              </p>
            )}
          </div>
        ) : null}
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Time</TableHead>
              <TableHead>Category</TableHead>
              <TableHead>Action</TableHead>
              <TableHead>Actor</TableHead>
              <TableHead>Target</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {data.length === 0 ? (
              <TableRow>
                <TableCell colSpan={5} className="text-muted-foreground text-center">
                  No audit entries yet.
                </TableCell>
              </TableRow>
            ) : (
              data.map((row) => (
                <TableRow key={row.id}>
                  <TableCell>{new Date(row.occurredAt).toLocaleString()}</TableCell>
                  <TableCell>{row.actionCategory}</TableCell>
                  <TableCell>{row.action}</TableCell>
                  <TableCell>{row.actorUserId ?? "-"}</TableCell>
                  <TableCell>{row.targetType ?? "-"}</TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/audit/audit.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import type { AuditLog } from "~/db/schema";
import { zod$ } from "~/lib/server/fn-utils";
import { listAuditLogsSchema } from "./audit.schemas";

const getSessionUserId = async () => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const { getRequest } = await import("@tanstack/react-start/server");
  const auth = await getAuth();
  const { headers } = getRequest();
  const session = await auth.api.getSession({ headers });
  return session?.user?.id ?? null;
};

export const listAuditLogs = createServerFn({ method: "GET" })
  .inputValidator(zod$(listAuditLogsSchema))
  .handler(async ({ data }): Promise<AuditLog[]> => {
    await assertFeatureEnabled("sin_admin_audit");
    const userId = await getSessionUserId();
    const { unauthorized, forbidden } = await import("~/lib/server/errors");
    if (!userId) {
      throw unauthorized("User not authenticated");
    }

    const { PermissionService } = await import("~/features/roles/permission.service");
    const isGlobalAdmin = await PermissionService.isGlobalAdmin(userId);

    const { getDb } = await import("~/db/server-helpers");
    const { auditLogs, organizationMembers } = await import("~/db/schema");
    const { and, desc, eq, gte, inArray, lte } = await import("drizzle-orm");
    const { ORG_ADMIN_ROLES } = await import("~/lib/auth/guards/org-guard");

    const db = await getDb();
    const conditions = [];

    // Access control + tenancy scoping (DM-AGG-003, SEC-AGG-004)
    if (!isGlobalAdmin) {
      // Org admins can only access audit logs for orgs they admin
      const adminMemberships = await db
        .select({ organizationId: organizationMembers.organizationId })
        .from(organizationMembers)
        .where(
          and(
            eq(organizationMembers.userId, userId),
            eq(organizationMembers.status, "active"),
            inArray(organizationMembers.role, ORG_ADMIN_ROLES),
          ),
        );

      const allowedOrgIds = adminMemberships.map((row) => row.organizationId);
      if (allowedOrgIds.length === 0) {
        throw forbidden("Admin access required");
      }

      if (data.targetOrgId) {
        if (!allowedOrgIds.includes(data.targetOrgId)) {
          throw forbidden("Insufficient organization role");
        }
        conditions.push(eq(auditLogs.targetOrgId, data.targetOrgId));
      } else {
        conditions.push(inArray(auditLogs.targetOrgId, allowedOrgIds));
      }
    } else if (data.targetOrgId) {
      // Global admins may optionally scope to an org
      conditions.push(eq(auditLogs.targetOrgId, data.targetOrgId));
    }

    if (data.actorUserId) {
      conditions.push(eq(auditLogs.actorUserId, data.actorUserId));
    }

    if (data.actionCategory) {
      conditions.push(eq(auditLogs.actionCategory, data.actionCategory));
    }

    if (data.from) {
      conditions.push(gte(auditLogs.occurredAt, new Date(data.from)));
    }

    if (data.to) {
      conditions.push(lte(auditLogs.occurredAt, new Date(data.to)));
    }

    const rows = await db
      .select()
      .from(auditLogs)
      .where(conditions.length ? and(...conditions) : undefined)
      .orderBy(desc(auditLogs.occurredAt))
      .limit(data.limit ?? 100);

    return rows as AuditLog[];
  });

export const exportAuditLogs = createServerFn({ method: "GET" })
  .inputValidator(zod$(listAuditLogsSchema))
  .handler(async ({ data }): Promise<string> => {
    await assertFeatureEnabled("sin_admin_audit");
    const logs = await listAuditLogs({ data });
    const { toCsv } = await import("~/shared/lib/csv");
    return toCsv(logs as Array<Record<string, unknown>>);
  });

export const verifyAuditHashChain = createServerFn({ method: "GET" }).handler(
  async () => {
    await assertFeatureEnabled("sin_admin_audit");
    const userId = await getSessionUserId();
    const { unauthorized, forbidden } = await import("~/lib/server/errors");
    if (!userId) {
      throw unauthorized("User not authenticated");
    }

    const { PermissionService } = await import("~/features/roles/permission.service");
    const isGlobalAdmin = await PermissionService.isGlobalAdmin(userId);
    if (!isGlobalAdmin) {
      throw forbidden("Global admin access required");
    }

    const { verifyAuditHashChain: verify } = await import("~/lib/audit");
    return verify();
  },
);
</file>

<file path="src/features/audit/audit.schemas.ts">
import { z } from "zod";

export const auditCategorySchema = z.enum([
  "AUTH",
  "ADMIN",
  "DATA",
  "EXPORT",
  "SECURITY",
]);

export const listAuditLogsSchema = z
  .object({
    actorUserId: z.string().optional(),
    targetOrgId: z.uuid().optional(),
    actionCategory: auditCategorySchema.optional(),
    from: z.iso.datetime().optional(),
    to: z.iso.datetime().optional(),
    limit: z.number().int().min(1).max(500).optional(),
  })
  .nullish()
  .transform((value) => value ?? { limit: 100 });
export type ListAuditLogsInput = z.infer<typeof listAuditLogsSchema>;
</file>

<file path="src/features/notifications/components/notification-bell.tsx">
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { Bell } from "lucide-react";
import { Badge } from "~/components/ui/badge";
import { Button } from "~/components/ui/button";
import { Popover, PopoverContent, PopoverTrigger } from "~/components/ui/popover";
import { markNotificationRead } from "../notifications.mutations";
import { getUnreadNotificationCount, listNotifications } from "../notifications.queries";

export function NotificationBell() {
  const queryClient = useQueryClient();
  const { data: unreadCount = 0 } = useQuery({
    queryKey: ["notifications", "unread-count"],
    queryFn: () => getUnreadNotificationCount(),
  });

  const { data: notifications = [] } = useQuery({
    queryKey: ["notifications", "list"],
    queryFn: () => listNotifications({ data: { unreadOnly: false, limit: 10 } }),
  });

  const markReadMutation = useMutation({
    mutationFn: (notificationId: string) =>
      markNotificationRead({ data: { notificationId } }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: ["notifications"] });
    },
  });

  return (
    <Popover>
      <PopoverTrigger asChild>
        <Button variant="ghost" size="icon" className="relative">
          <Bell className="h-5 w-5" />
          {unreadCount > 0 && (
            <Badge
              variant="destructive"
              className="absolute -top-1 -right-1 h-5 min-w-[20px] rounded-full px-1 text-[10px]"
            >
              {unreadCount > 9 ? "9+" : unreadCount}
            </Badge>
          )}
        </Button>
      </PopoverTrigger>
      <PopoverContent align="end" className="w-80">
        <div className="flex items-center justify-between border-b border-gray-200 pb-2">
          <h3 className="text-sm font-semibold">Notifications</h3>
          <span className="text-muted-foreground text-xs">{unreadCount} unread</span>
        </div>
        <div className="mt-3 flex flex-col gap-2">
          {notifications.length === 0 ? (
            <p className="text-muted-foreground text-sm">No notifications yet.</p>
          ) : (
            notifications.map((notification) => (
              <Button
                key={notification.id}
                type="button"
                variant="outline"
                className="h-auto w-full items-start justify-between gap-2 px-3 py-2 text-left whitespace-normal"
                onClick={() => {
                  if (!notification.readAt) {
                    markReadMutation.mutate(notification.id);
                  }
                }}
              >
                <div className="flex w-full items-center justify-between gap-2">
                  <span className="font-semibold">{notification.title}</span>
                  {!notification.readAt && (
                    <span className="h-2 w-2 rounded-full bg-blue-500" />
                  )}
                </div>
                <p className="text-muted-foreground mt-1 text-xs">{notification.body}</p>
              </Button>
            ))
          )}
        </div>
      </PopoverContent>
    </Popover>
  );
}
</file>

<file path="src/features/notifications/components/notification-preferences-card.tsx">
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";
import { Checkbox } from "~/components/ui/checkbox";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";
import { updateNotificationPreferences } from "../notifications.mutations";
import { getNotificationPreferences } from "../notifications.queries";

const categories = [
  { value: "reporting", label: "Reporting" },
  { value: "security", label: "Security" },
  { value: "support", label: "Support" },
  { value: "system", label: "System" },
];

const frequencies = [
  { value: "immediate", label: "Immediate" },
  { value: "daily_digest", label: "Daily digest" },
  { value: "weekly_digest", label: "Weekly digest" },
  { value: "never", label: "Never" },
];

export function NotificationPreferencesCard() {
  const queryClient = useQueryClient();
  const { data = [] } = useQuery({
    queryKey: ["notifications", "preferences"],
    queryFn: () => getNotificationPreferences(),
  });

  const updateMutation = useMutation({
    mutationFn: updateNotificationPreferences,
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: ["notifications", "preferences"] });
    },
  });

  return (
    <Card>
      <CardHeader>
        <CardTitle>Notification Preferences</CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        {categories.map((category) => {
          const preference = data.find((item) => item.category === category.value);
          return (
            <div
              key={category.value}
              className="flex flex-col gap-3 border-b border-gray-200 pb-4 last:border-none last:pb-0"
            >
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm font-semibold">{category.label}</p>
                  <p className="text-muted-foreground text-xs">
                    Control how you receive {category.label.toLowerCase()} updates.
                  </p>
                </div>
              </div>
              <div className="flex flex-wrap items-center gap-4">
                <label className="flex items-center gap-2 text-sm">
                  <Checkbox
                    checked={preference?.channelInApp ?? true}
                    onCheckedChange={(checked) =>
                      updateMutation.mutate({
                        data: {
                          category: category.value,
                          channelInApp: Boolean(checked),
                        },
                      })
                    }
                  />
                  In-app
                </label>
                <label className="flex items-center gap-2 text-sm">
                  <Checkbox
                    checked={preference?.channelEmail ?? true}
                    onCheckedChange={(checked) =>
                      updateMutation.mutate({
                        data: {
                          category: category.value,
                          channelEmail: Boolean(checked),
                        },
                      })
                    }
                  />
                  Email
                </label>
                <Select
                  value={preference?.emailFrequency ?? "immediate"}
                  onValueChange={(value) =>
                    updateMutation.mutate({
                      data: {
                        category: category.value,
                        emailFrequency: value as
                          | "immediate"
                          | "daily_digest"
                          | "weekly_digest"
                          | "never",
                      },
                    })
                  }
                >
                  <SelectTrigger className="h-8 w-40 text-xs">
                    <SelectValue placeholder="Frequency" />
                  </SelectTrigger>
                  <SelectContent>
                    {frequencies.map((frequency) => (
                      <SelectItem key={frequency.value} value={frequency.value}>
                        {frequency.label}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
            </div>
          );
        })}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/notifications/components/notification-template-panel.tsx">
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { useMemo, useState } from "react";
import { Button } from "~/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";
import { Checkbox } from "~/components/ui/checkbox";
import { Input } from "~/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";
import { Textarea } from "~/components/ui/textarea";
import {
  createNotificationTemplate,
  deleteNotificationTemplate,
  updateNotificationTemplate,
} from "../notifications.mutations";
import { listNotificationTemplates } from "../notifications.queries";

const categories = [
  { value: "reporting", label: "Reporting" },
  { value: "security", label: "Security" },
  { value: "support", label: "Support" },
  { value: "system", label: "System" },
];

type TemplateDraft = {
  key: string;
  category: string;
  subject: string;
  bodyTemplate: string;
  isSystem: boolean;
};

const defaultDraft: TemplateDraft = {
  key: "",
  category: "system",
  subject: "",
  bodyTemplate: "",
  isSystem: false,
};

export function NotificationTemplatePanel() {
  const queryClient = useQueryClient();
  const [drafts, setDrafts] = useState<Record<string, TemplateDraft>>({});
  const [newTemplate, setNewTemplate] = useState<TemplateDraft>(defaultDraft);

  const { data: templates = [] } = useQuery({
    queryKey: ["notifications", "templates"],
    queryFn: () => listNotificationTemplates(),
  });

  const createMutation = useMutation({
    mutationFn: () =>
      createNotificationTemplate({
        data: {
          key: newTemplate.key,
          category: newTemplate.category as TemplateDraft["category"],
          subject: newTemplate.subject,
          bodyTemplate: newTemplate.bodyTemplate,
          isSystem: newTemplate.isSystem,
        },
      }),
    onSuccess: () => {
      setNewTemplate(defaultDraft);
      void queryClient.invalidateQueries({ queryKey: ["notifications", "templates"] });
    },
  });

  const updateMutation = useMutation({
    mutationFn: (payload: { templateId: string; data: TemplateDraft }) =>
      updateNotificationTemplate({
        data: {
          templateId: payload.templateId,
          data: {
            key: payload.data.key,
            category: payload.data.category as TemplateDraft["category"],
            subject: payload.data.subject,
            bodyTemplate: payload.data.bodyTemplate,
            isSystem: payload.data.isSystem,
          },
        },
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: ["notifications", "templates"] });
    },
  });

  const deleteMutation = useMutation({
    mutationFn: (templateId: string) =>
      deleteNotificationTemplate({ data: { templateId } }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: ["notifications", "templates"] });
    },
  });

  const draftFor = (id: string): TemplateDraft =>
    drafts[id] ?? {
      key: "",
      category: "system",
      subject: "",
      bodyTemplate: "",
      isSystem: false,
    };

  const setDraft = (id: string, next: Partial<TemplateDraft>) => {
    setDrafts((prev) => ({
      ...prev,
      [id]: { ...draftFor(id), ...next },
    }));
  };

  const readyToCreate = useMemo(() => {
    return (
      newTemplate.key.trim().length > 0 &&
      newTemplate.subject.trim().length > 0 &&
      newTemplate.bodyTemplate.trim().length > 0
    );
  }, [newTemplate]);

  return (
    <Card>
      <CardHeader>
        <CardTitle>Notification Templates</CardTitle>
      </CardHeader>
      <CardContent className="space-y-6">
        <div className="space-y-3 rounded-md border border-gray-200 p-4">
          <p className="text-sm font-semibold">Create template</p>
          <div className="grid gap-3 md:grid-cols-2">
            <Input
              placeholder="Template key (e.g. reporting_reminder)"
              value={newTemplate.key}
              onChange={(event) =>
                setNewTemplate((prev) => ({ ...prev, key: event.target.value }))
              }
            />
            <Select
              value={newTemplate.category}
              onValueChange={(value) =>
                setNewTemplate((prev) => ({ ...prev, category: value }))
              }
            >
              <SelectTrigger>
                <SelectValue placeholder="Category" />
              </SelectTrigger>
              <SelectContent>
                {categories.map((category) => (
                  <SelectItem key={category.value} value={category.value}>
                    {category.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
          <Input
            placeholder="Subject"
            value={newTemplate.subject}
            onChange={(event) =>
              setNewTemplate((prev) => ({ ...prev, subject: event.target.value }))
            }
          />
          <Textarea
            rows={3}
            placeholder="Body template (supports {{variables}})"
            value={newTemplate.bodyTemplate}
            onChange={(event) =>
              setNewTemplate((prev) => ({ ...prev, bodyTemplate: event.target.value }))
            }
          />
          <label className="flex items-center gap-2 text-sm">
            <Checkbox
              checked={newTemplate.isSystem}
              onCheckedChange={(checked) =>
                setNewTemplate((prev) => ({ ...prev, isSystem: Boolean(checked) }))
              }
            />
            System template (locked)
          </label>
          <Button
            type="button"
            onClick={() => createMutation.mutate()}
            disabled={!readyToCreate || createMutation.isPending}
          >
            {createMutation.isPending ? "Creating..." : "Create template"}
          </Button>
        </div>

        {templates.length === 0 ? (
          <p className="text-muted-foreground text-sm">No templates yet.</p>
        ) : (
          <div className="space-y-4">
            {templates.map((template) => {
              const draft = draftFor(template.id);
              const isEditing = Boolean(drafts[template.id]);
              return (
                <div
                  key={template.id}
                  className="space-y-3 rounded-md border border-gray-200 p-4"
                >
                  <div className="flex flex-wrap items-center justify-between gap-2">
                    <div>
                      <p className="text-sm font-semibold">{template.key}</p>
                      <p className="text-muted-foreground text-xs">
                        {template.category} Â· {template.isSystem ? "system" : "custom"}
                      </p>
                    </div>
                    <div className="flex items-center gap-2">
                      <Button
                        type="button"
                        variant="outline"
                        size="sm"
                        onClick={() =>
                          setDrafts((prev) => ({
                            ...prev,
                            [template.id]: {
                              key: template.key,
                              category: template.category,
                              subject: template.subject,
                              bodyTemplate: template.bodyTemplate,
                              isSystem: template.isSystem,
                            },
                          }))
                        }
                      >
                        Edit
                      </Button>
                      <Button
                        type="button"
                        variant="outline"
                        size="sm"
                        disabled={template.isSystem || deleteMutation.isPending}
                        onClick={() => deleteMutation.mutate(template.id)}
                      >
                        Delete
                      </Button>
                    </div>
                  </div>

                  {isEditing ? (
                    <div className="space-y-3">
                      <div className="grid gap-3 md:grid-cols-2">
                        <Input
                          placeholder="Template key"
                          value={draft.key}
                          onChange={(event) =>
                            setDraft(template.id, { key: event.target.value })
                          }
                        />
                        <Select
                          value={draft.category}
                          onValueChange={(value) =>
                            setDraft(template.id, { category: value })
                          }
                        >
                          <SelectTrigger>
                            <SelectValue placeholder="Category" />
                          </SelectTrigger>
                          <SelectContent>
                            {categories.map((category) => (
                              <SelectItem key={category.value} value={category.value}>
                                {category.label}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                      </div>
                      <Input
                        placeholder="Subject"
                        value={draft.subject}
                        onChange={(event) =>
                          setDraft(template.id, { subject: event.target.value })
                        }
                      />
                      <Textarea
                        rows={3}
                        placeholder="Body template"
                        value={draft.bodyTemplate}
                        onChange={(event) =>
                          setDraft(template.id, { bodyTemplate: event.target.value })
                        }
                      />
                      <div className="flex flex-wrap items-center gap-3">
                        <label className="flex items-center gap-2 text-sm">
                          <Checkbox
                            checked={draft.isSystem}
                            onCheckedChange={(checked) =>
                              setDraft(template.id, { isSystem: Boolean(checked) })
                            }
                          />
                          System template
                        </label>
                        <Button
                          type="button"
                          size="sm"
                          onClick={() =>
                            updateMutation.mutate({
                              templateId: template.id,
                              data: draft,
                            })
                          }
                          disabled={updateMutation.isPending}
                        >
                          {updateMutation.isPending ? "Saving..." : "Save changes"}
                        </Button>
                        <Button
                          type="button"
                          size="sm"
                          variant="ghost"
                          onClick={() =>
                            setDrafts((prev) => {
                              const next = { ...prev };
                              delete next[template.id];
                              return next;
                            })
                          }
                        >
                          Cancel
                        </Button>
                      </div>
                    </div>
                  ) : (
                    <div className="text-muted-foreground text-xs">
                      <p>Subject: {template.subject}</p>
                      <p>Body: {template.bodyTemplate}</p>
                    </div>
                  )}
                </div>
              );
            })}
          </div>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/notifications/notifications.mutations.ts">
import { createServerFn } from "@tanstack/react-start";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import { zod$ } from "~/lib/server/fn-utils";
import {
  createNotificationSchema,
  createNotificationTemplateSchema,
  deleteNotificationTemplateSchema,
  dismissNotificationSchema,
  markNotificationReadSchema,
  scheduleNotificationSchema,
  updateNotificationPreferencesSchema,
  updateNotificationTemplateSchema,
} from "./notifications.schemas";
import type { NotificationPreferenceRow, NotificationRow } from "./notifications.types";

const getSessionUserId = async () => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const { getRequest } = await import("@tanstack/react-start/server");
  const auth = await getAuth();
  const { headers } = getRequest();
  const session = await auth.api.getSession({ headers });
  return session?.user?.id ?? null;
};

export const markNotificationRead = createServerFn({ method: "POST" })
  .inputValidator(zod$(markNotificationReadSchema))
  .handler(async ({ data }): Promise<NotificationRow | null> => {
    await assertFeatureEnabled("notifications_core");
    const userId = await getSessionUserId();
    if (!userId) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { notifications } = await import("~/db/schema");
    const { and, eq } = await import("drizzle-orm");

    const db = await getDb();
    const [updated] = await db
      .update(notifications)
      .set({ readAt: new Date() })
      .where(
        and(eq(notifications.id, data.notificationId), eq(notifications.userId, userId)),
      )
      .returning();

    return updated ?? null;
  });

export const dismissNotification = createServerFn({ method: "POST" })
  .inputValidator(zod$(dismissNotificationSchema))
  .handler(async ({ data }): Promise<NotificationRow | null> => {
    await assertFeatureEnabled("notifications_core");
    const userId = await getSessionUserId();
    if (!userId) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { notifications } = await import("~/db/schema");
    const { and, eq } = await import("drizzle-orm");

    const db = await getDb();
    const [updated] = await db
      .update(notifications)
      .set({ dismissedAt: new Date() })
      .where(
        and(eq(notifications.id, data.notificationId), eq(notifications.userId, userId)),
      )
      .returning();

    return updated ?? null;
  });

export const updateNotificationPreferences = createServerFn({ method: "POST" })
  .inputValidator(zod$(updateNotificationPreferencesSchema))
  .handler(async ({ data }): Promise<NotificationPreferenceRow | null> => {
    await assertFeatureEnabled("notifications_core");
    const userId = await getSessionUserId();
    if (!userId) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { notificationPreferences } = await import("~/db/schema");
    const { and, eq } = await import("drizzle-orm");

    const db = await getDb();
    const [existing] = await db
      .select()
      .from(notificationPreferences)
      .where(
        and(
          eq(notificationPreferences.userId, userId),
          eq(notificationPreferences.category, data.category),
        ),
      )
      .limit(1);

    if (existing) {
      const [updated] = await db
        .update(notificationPreferences)
        .set({
          channelEmail: data.channelEmail ?? existing.channelEmail,
          channelInApp: data.channelInApp ?? existing.channelInApp,
          emailFrequency: data.emailFrequency ?? existing.emailFrequency,
        })
        .where(eq(notificationPreferences.id, existing.id))
        .returning();

      return updated ?? null;
    }

    const [created] = await db
      .insert(notificationPreferences)
      .values({
        userId,
        category: data.category,
        channelEmail: data.channelEmail ?? true,
        channelInApp: data.channelInApp ?? true,
        emailFrequency: data.emailFrequency ?? "immediate",
      })
      .returning();

    return created ?? null;
  });

export const createNotification = createServerFn({ method: "POST" })
  .inputValidator(zod$(createNotificationSchema))
  .handler(async ({ data }): Promise<NotificationRow | null> => {
    await assertFeatureEnabled("notifications_core");
    const { getDb } = await import("~/db/server-helpers");
    const { notifications } = await import("~/db/schema");
    const db = await getDb();

    const [created] = await db
      .insert(notifications)
      .values({
        userId: data.userId,
        organizationId: data.organizationId ?? null,
        type: data.type,
        category: data.category,
        title: data.title,
        body: data.body,
        link: data.link ?? null,
        metadata: data.metadata ?? {},
      })
      .returning();

    if (created) {
      const { logDataChange } = await import("~/lib/audit");
      await logDataChange({
        action: "NOTIFICATION_CREATE",
        actorUserId: data.userId,
        actorOrgId: data.organizationId ?? null,
        targetType: "notification",
        targetId: created.id,
        targetOrgId: data.organizationId ?? null,
      });
    }

    return created ?? null;
  });

export const createNotificationTemplate = createServerFn({ method: "POST" })
  .inputValidator(zod$(createNotificationTemplateSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_notifications");
    const userId = await getSessionUserId();
    if (!userId) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { notificationTemplates } = await import("~/db/schema");
    const db = await getDb();

    const [created] = await db
      .insert(notificationTemplates)
      .values({
        key: data.key,
        category: data.category,
        subject: data.subject,
        bodyTemplate: data.bodyTemplate,
        isSystem: data.isSystem ?? false,
        createdBy: userId,
      })
      .returning();

    if (created) {
      const { logAdminAction } = await import("~/lib/audit");
      await logAdminAction({
        action: "NOTIFICATION_TEMPLATE_CREATE",
        actorUserId: userId,
        targetType: "notification_template",
        targetId: created.id,
      });
    }

    return created ?? null;
  });

export const updateNotificationTemplate = createServerFn({ method: "POST" })
  .inputValidator(zod$(updateNotificationTemplateSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_notifications");
    const userId = await getSessionUserId();
    if (!userId) return null;

    const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
    await requireAdmin(userId);

    const { getDb } = await import("~/db/server-helpers");
    const { notificationTemplates } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");
    const db = await getDb();

    const [updated] = await db
      .update(notificationTemplates)
      .set({
        key: data.data.key,
        category: data.data.category,
        subject: data.data.subject,
        bodyTemplate: data.data.bodyTemplate,
        isSystem: data.data.isSystem,
      })
      .where(eq(notificationTemplates.id, data.templateId))
      .returning();

    return updated ?? null;
  });

export const deleteNotificationTemplate = createServerFn({ method: "POST" })
  .inputValidator(zod$(deleteNotificationTemplateSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_notifications");
    const userId = await getSessionUserId();
    if (!userId) return null;

    const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
    await requireAdmin(userId);

    const { getDb } = await import("~/db/server-helpers");
    const { notificationTemplates } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");
    const db = await getDb();

    const [deleted] = await db
      .delete(notificationTemplates)
      .where(eq(notificationTemplates.id, data.templateId))
      .returning();

    return deleted ?? null;
  });

export const scheduleNotification = createServerFn({ method: "POST" })
  .inputValidator(zod$(scheduleNotificationSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_notifications");
    const userId = await getSessionUserId();
    if (!userId) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { scheduledNotifications } = await import("~/db/schema");
    const db = await getDb();

    const [created] = await db
      .insert(scheduledNotifications)
      .values({
        templateKey: data.templateKey,
        userId: data.userId ?? null,
        organizationId: data.organizationId ?? null,
        roleFilter: data.roleFilter ?? null,
        scheduledFor: new Date(data.scheduledFor),
        variables: data.variables ?? {},
      })
      .returning();

    if (created) {
      const { logDataChange } = await import("~/lib/audit");
      await logDataChange({
        action: "NOTIFICATION_SCHEDULE_CREATE",
        actorUserId: userId,
        targetType: "scheduled_notification",
        targetId: created.id,
      });
    }

    return created ?? null;
  });
</file>

<file path="src/features/notifications/notifications.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import { zod$ } from "~/lib/server/fn-utils";
import { listNotificationsSchema } from "./notifications.schemas";
import type { NotificationRow } from "./notifications.types";

const getSessionUserId = async () => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const { getRequest } = await import("@tanstack/react-start/server");
  const auth = await getAuth();
  const { headers } = getRequest();
  const session = await auth.api.getSession({ headers });
  return session?.user?.id ?? null;
};

export const listNotifications = createServerFn({ method: "GET" })
  .inputValidator(zod$(listNotificationsSchema))
  .handler(async ({ data }): Promise<NotificationRow[]> => {
    await assertFeatureEnabled("notifications_core");
    const userId = await getSessionUserId();
    if (!userId) return [];

    const { getDb } = await import("~/db/server-helpers");
    const { notifications } = await import("~/db/schema");
    const { and, desc, eq, isNull } = await import("drizzle-orm");

    const db = await getDb();
    const conditions = data.unreadOnly
      ? and(eq(notifications.userId, userId), isNull(notifications.readAt))
      : eq(notifications.userId, userId);

    const rows = await db
      .select({
        id: notifications.id,
        userId: notifications.userId,
        organizationId: notifications.organizationId,
        type: notifications.type,
        category: notifications.category,
        title: notifications.title,
        body: notifications.body,
        link: notifications.link,
        readAt: notifications.readAt,
        dismissedAt: notifications.dismissedAt,
        createdAt: notifications.createdAt,
      })
      .from(notifications)
      .where(conditions)
      .orderBy(desc(notifications.createdAt))
      .limit(data.limit ?? 25);

    return rows;
  });

export const getUnreadNotificationCount = createServerFn({ method: "GET" }).handler(
  async () => {
    await assertFeatureEnabled("notifications_core");
    const userId = await getSessionUserId();
    if (!userId) return 0;

    const { getDb } = await import("~/db/server-helpers");
    const { notifications } = await import("~/db/schema");
    const { and, count, eq, isNull } = await import("drizzle-orm");

    const db = await getDb();
    const [result] = await db
      .select({ total: count() })
      .from(notifications)
      .where(and(eq(notifications.userId, userId), isNull(notifications.readAt)));

    return result?.total ?? 0;
  },
);

export const getNotificationPreferences = createServerFn({ method: "GET" }).handler(
  async () => {
    await assertFeatureEnabled("notifications_core");
    const userId = await getSessionUserId();
    if (!userId) return [];

    const { getDb } = await import("~/db/server-helpers");
    const { notificationPreferences } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    return db
      .select()
      .from(notificationPreferences)
      .where(eq(notificationPreferences.userId, userId));
  },
);

export const listNotificationTemplates = createServerFn({ method: "GET" }).handler(
  async () => {
    await assertFeatureEnabled("sin_admin_notifications");
    const userId = await getSessionUserId();
    if (!userId) return [];

    const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
    await requireAdmin(userId);

    const { getDb } = await import("~/db/server-helpers");
    const { notificationTemplates } = await import("~/db/schema");
    const { desc } = await import("drizzle-orm");

    const db = await getDb();
    return db
      .select()
      .from(notificationTemplates)
      .orderBy(desc(notificationTemplates.createdAt));
  },
);
</file>

<file path="src/features/notifications/notifications.schemas.ts">
import { z } from "zod";
import { jsonRecordSchema } from "~/shared/lib/json";

export const notificationCategorySchema = z.enum([
  "reporting",
  "security",
  "support",
  "system",
]);

export const notificationFrequencySchema = z.enum([
  "immediate",
  "daily_digest",
  "weekly_digest",
  "never",
]);

export const listNotificationsSchema = z
  .object({
    unreadOnly: z.boolean().optional(),
    limit: z.number().int().min(1).max(100).optional(),
  })
  .nullish()
  .transform((value) => value ?? { unreadOnly: false, limit: 25 });
export type ListNotificationsInput = z.infer<typeof listNotificationsSchema>;

export const markNotificationReadSchema = z.object({
  notificationId: z.uuid(),
});
export type MarkNotificationReadInput = z.infer<typeof markNotificationReadSchema>;

export const dismissNotificationSchema = z.object({
  notificationId: z.uuid(),
});
export type DismissNotificationInput = z.infer<typeof dismissNotificationSchema>;

export const updateNotificationPreferencesSchema = z.object({
  category: notificationCategorySchema,
  channelEmail: z.boolean().optional(),
  channelInApp: z.boolean().optional(),
  emailFrequency: notificationFrequencySchema.optional(),
});
export type UpdateNotificationPreferencesInput = z.infer<
  typeof updateNotificationPreferencesSchema
>;

export const createNotificationSchema = z.object({
  userId: z.string().min(1),
  organizationId: z.uuid().optional().nullable(),
  type: z.string().min(1),
  category: notificationCategorySchema,
  title: z.string().min(1),
  body: z.string().min(1),
  link: z.string().optional().nullable(),
  metadata: jsonRecordSchema.optional(),
});
export type CreateNotificationInput = z.infer<typeof createNotificationSchema>;

export const createNotificationTemplateSchema = z.object({
  key: z.string().min(1),
  category: notificationCategorySchema,
  subject: z.string().min(1),
  bodyTemplate: z.string().min(1),
  isSystem: z.boolean().optional(),
});
export type CreateNotificationTemplateInput = z.infer<
  typeof createNotificationTemplateSchema
>;

export const updateNotificationTemplateSchema = z.object({
  templateId: z.uuid(),
  data: createNotificationTemplateSchema.partial(),
});
export type UpdateNotificationTemplateInput = z.infer<
  typeof updateNotificationTemplateSchema
>;

export const deleteNotificationTemplateSchema = z.object({
  templateId: z.uuid(),
});
export type DeleteNotificationTemplateInput = z.infer<
  typeof deleteNotificationTemplateSchema
>;

export const scheduleNotificationSchema = z.object({
  templateKey: z.string().min(1),
  userId: z.string().optional().nullable(),
  organizationId: z.uuid().optional().nullable(),
  roleFilter: z.string().optional().nullable(),
  scheduledFor: z.iso.datetime(),
  variables: jsonRecordSchema.optional(),
});
export type ScheduleNotificationInput = z.infer<typeof scheduleNotificationSchema>;
</file>

<file path="src/features/notifications/notifications.types.ts">
export interface NotificationRow {
  id: string;
  userId: string;
  organizationId: string | null;
  type: string;
  category: string;
  title: string;
  body: string;
  link: string | null;
  readAt: Date | null;
  dismissedAt: Date | null;
  createdAt: Date;
}

export interface NotificationPreferenceRow {
  id: string;
  userId: string;
  category: string;
  channelEmail: boolean;
  channelInApp: boolean;
  emailFrequency: string;
  createdAt: Date;
  updatedAt: Date;
}
</file>

<file path="src/features/privacy/components/privacy-acceptance-card.tsx">
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { Button } from "~/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";
import { acceptPolicy } from "../privacy.mutations";
import { getLatestPolicyDocument, listUserPolicyAcceptances } from "../privacy.queries";

export function PrivacyAcceptanceCard() {
  const queryClient = useQueryClient();

  const { data: policy, isLoading: policyLoading } = useQuery({
    queryKey: ["privacy", "policy", "latest"],
    queryFn: () => getLatestPolicyDocument({ data: "privacy_policy" }),
  });

  const { data: acceptances = [] } = useQuery({
    queryKey: ["privacy", "policy", "acceptances"],
    queryFn: () => listUserPolicyAcceptances(),
  });

  const hasAccepted = policy
    ? acceptances.some((acceptance) => acceptance.policyId === policy.id)
    : false;

  const acceptMutation = useMutation({
    mutationFn: (policyId: string) => acceptPolicy({ data: { policyId } }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: ["privacy", "policy"] });
      void queryClient.invalidateQueries({
        queryKey: ["privacy", "policy", "acceptances"],
      });
    },
  });

  const handleAccept = () => {
    if (!policy?.id) return;
    acceptMutation.mutate(policy.id);
  };

  // Button should be disabled if no policy ID, already accepted, or mutation pending
  const isButtonDisabled = !policy?.id || hasAccepted || acceptMutation.isPending;

  return (
    <Card>
      <CardHeader>
        <CardTitle>Privacy Policy</CardTitle>
      </CardHeader>
      <CardContent className="space-y-3 text-sm">
        {policyLoading ? (
          <p className="text-muted-foreground">Loading policy...</p>
        ) : policy ? (
          <>
            <p>
              Current version: <strong>{policy.version}</strong>
            </p>
            <p className="text-muted-foreground">
              Effective: {new Date(policy.effectiveDate).toLocaleDateString()}
            </p>
            {policy.contentUrl ? (
              <a
                href={policy.contentUrl}
                target="_blank"
                rel="noreferrer"
                className="text-blue-600 underline"
              >
                View policy document
              </a>
            ) : null}
            <Button
              type="button"
              disabled={isButtonDisabled}
              onClick={handleAccept}
            >
              {hasAccepted
                ? "Policy accepted"
                : acceptMutation.isPending
                  ? "Accepting..."
                  : "Accept policy"}
            </Button>
            {acceptMutation.isError && (
              <p className="text-sm text-destructive">
                Failed to accept policy. Please try again.
              </p>
            )}
          </>
        ) : (
          <p className="text-muted-foreground">No policy document published.</p>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/privacy/components/privacy-admin-panel.tsx">
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { useState } from "react";
import { Button } from "~/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";
import { Input } from "~/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "~/components/ui/table";
import {
  applyPrivacyErasure,
  generatePrivacyExport,
  updatePrivacyRequest,
} from "../privacy.mutations";
import { getPrivacyExportDownloadUrl, listAllPrivacyRequests } from "../privacy.queries";

const statusOptions = ["pending", "processing", "completed", "rejected"];

type UpdateState = {
  status: string;
  resultUrl: string;
  resultNotes: string;
  rejectionReason: string;
};

export function PrivacyAdminPanel() {
  const queryClient = useQueryClient();
  const [updates, setUpdates] = useState<Record<string, UpdateState>>({});

  const { data = [] } = useQuery({
    queryKey: ["privacy", "admin", "requests"],
    queryFn: () => listAllPrivacyRequests(),
  });

  const updateMutation = useMutation({
    mutationFn: (payload: {
      requestId: string;
      status: string;
      resultUrl?: string;
      resultNotes?: string;
      rejectionReason?: string;
    }) => updatePrivacyRequest({ data: payload }),
    onSuccess: () => {
      void queryClient.invalidateQueries({
        queryKey: ["privacy", "admin", "requests"],
      });
    },
  });

  const exportMutation = useMutation({
    mutationFn: (requestId: string) => generatePrivacyExport({ data: { requestId } }),
    onSuccess: () => {
      void queryClient.invalidateQueries({
        queryKey: ["privacy", "admin", "requests"],
      });
    },
  });

  const erasureMutation = useMutation({
    mutationFn: (payload: { requestId: string; reason?: string }) =>
      applyPrivacyErasure({ data: payload }),
    onSuccess: () => {
      void queryClient.invalidateQueries({
        queryKey: ["privacy", "admin", "requests"],
      });
    },
  });

  const downloadMutation = useMutation({
    mutationFn: (requestId: string) =>
      getPrivacyExportDownloadUrl({ data: { requestId } }),
    onSuccess: (url) => {
      if (url) {
        window.open(url, "_blank", "noopener,noreferrer");
      }
    },
  });

  const getUpdateState = (requestId: string, status: string): UpdateState =>
    updates[requestId] ?? {
      status,
      resultUrl: "",
      resultNotes: "",
      rejectionReason: "",
    };

  const updateState = (requestId: string, next: Partial<UpdateState>) => {
    setUpdates((prev) => ({
      ...prev,
      [requestId]: { ...getUpdateState(requestId, "pending"), ...next },
    }));
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>DSAR Processing</CardTitle>
      </CardHeader>
      <CardContent>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>User</TableHead>
              <TableHead>Type</TableHead>
              <TableHead>Status</TableHead>
              <TableHead>Notes</TableHead>
              <TableHead>Actions</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {data.length === 0 ? (
              <TableRow>
                <TableCell colSpan={5} className="text-center text-sm">
                  No privacy requests.
                </TableCell>
              </TableRow>
            ) : (
              data.map((request) => {
                const state = getUpdateState(request.id, request.status);
                return (
                  <TableRow key={request.id}>
                    <TableCell className="text-xs">{request.userId}</TableCell>
                    <TableCell className="text-xs">{request.type}</TableCell>
                    <TableCell className="text-xs">
                      <Select
                        value={state.status}
                        onValueChange={(value) =>
                          updateState(request.id, { status: value })
                        }
                      >
                        <SelectTrigger className="h-8">
                          <SelectValue />
                        </SelectTrigger>
                        <SelectContent>
                          {statusOptions.map((status) => (
                            <SelectItem key={status} value={status}>
                              {status}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                    </TableCell>
                    <TableCell className="space-y-2">
                      <Input
                        placeholder="Result URL"
                        value={state.resultUrl}
                        onChange={(event) =>
                          updateState(request.id, { resultUrl: event.target.value })
                        }
                      />
                      <Input
                        placeholder="Result notes"
                        value={state.resultNotes}
                        onChange={(event) =>
                          updateState(request.id, { resultNotes: event.target.value })
                        }
                      />
                      <Input
                        placeholder="Rejection reason"
                        value={state.rejectionReason}
                        onChange={(event) =>
                          updateState(request.id, {
                            rejectionReason: event.target.value,
                          })
                        }
                      />
                    </TableCell>
                    <TableCell>
                      <div className="flex flex-col gap-2">
                        <Button
                          type="button"
                          size="sm"
                          onClick={() => {
                            updateMutation.mutate({
                              requestId: request.id,
                              status: state.status,
                              ...(state.resultUrl ? { resultUrl: state.resultUrl } : {}),
                              ...(state.resultNotes
                                ? { resultNotes: state.resultNotes }
                                : {}),
                              ...(state.rejectionReason
                                ? { rejectionReason: state.rejectionReason }
                                : {}),
                            });
                          }}
                          disabled={updateMutation.isPending}
                        >
                          {updateMutation.isPending ? "Updating..." : "Update"}
                        </Button>
                        {request.type === "export" || request.type === "access" ? (
                          <Button
                            type="button"
                            size="sm"
                            variant="outline"
                            onClick={() => exportMutation.mutate(request.id)}
                            disabled={exportMutation.isPending}
                          >
                            {exportMutation.isPending
                              ? "Generating..."
                              : "Generate export"}
                          </Button>
                        ) : null}
                        {request.type === "erasure" ? (
                          <Button
                            type="button"
                            size="sm"
                            variant="outline"
                            onClick={() =>
                              erasureMutation.mutate({
                                requestId: request.id,
                                ...(state.resultNotes
                                  ? { reason: state.resultNotes }
                                  : {}),
                              })
                            }
                            disabled={erasureMutation.isPending}
                          >
                            {erasureMutation.isPending ? "Erasing..." : "Apply erasure"}
                          </Button>
                        ) : null}
                        {request.resultUrl ? (
                          <Button
                            type="button"
                            size="sm"
                            variant="ghost"
                            onClick={() => downloadMutation.mutate(request.id)}
                            disabled={downloadMutation.isPending}
                          >
                            {downloadMutation.isPending
                              ? "Preparing..."
                              : "Download export"}
                          </Button>
                        ) : null}
                      </div>
                    </TableCell>
                  </TableRow>
                );
              })
            )}
          </TableBody>
        </Table>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/privacy/components/privacy-dashboard.tsx">
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { useState } from "react";
import { Button } from "~/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";
import { createPrivacyRequest } from "../privacy.mutations";
import { listPrivacyRequests } from "../privacy.queries";

export function PrivacyDashboard() {
  const queryClient = useQueryClient();
  const [requestType, setRequestType] = useState("access");

  const { data = [] } = useQuery({
    queryKey: ["privacy", "requests"],
    queryFn: () => listPrivacyRequests(),
  });

  const requestMutation = useMutation({
    mutationFn: () => createPrivacyRequest({ data: { type: requestType } }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: ["privacy", "requests"] });
    },
  });

  return (
    <Card>
      <CardHeader>
        <CardTitle>Privacy Requests</CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="flex flex-wrap items-end gap-3">
          <div className="min-w-[220px]">
            <label className="text-sm font-medium">New request</label>
            <Select value={requestType} onValueChange={setRequestType}>
              <SelectTrigger className="mt-2">
                <SelectValue placeholder="Request type" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="access">Access</SelectItem>
                <SelectItem value="export">Export</SelectItem>
                <SelectItem value="erasure">Erasure</SelectItem>
                <SelectItem value="correction">Correction</SelectItem>
              </SelectContent>
            </Select>
          </div>
          <Button
            type="button"
            onClick={() => requestMutation.mutate()}
            disabled={requestMutation.isPending}
          >
            {requestMutation.isPending ? "Submitting..." : "Submit request"}
          </Button>
        </div>
        {data.length === 0 ? (
          <p className="text-muted-foreground text-sm">No privacy requests yet.</p>
        ) : (
          data.map((request) => (
            <div
              key={request.id}
              className="flex items-center justify-between rounded-md border border-gray-200 px-3 py-2"
            >
              <div>
                <p className="text-sm font-semibold">{request.type}</p>
                <p className="text-muted-foreground text-xs">{request.status}</p>
              </div>
              <span className="text-muted-foreground text-xs">
                {new Date(request.createdAt).toLocaleDateString()}
              </span>
            </div>
          ))
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/privacy/components/retention-policy-panel.tsx">
import { useQuery, useQueryClient } from "@tanstack/react-query";
import { useMemo } from "react";
import { toast } from "sonner";
import { Button } from "~/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";
import { Checkbox } from "~/components/ui/checkbox";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "~/components/ui/table";
import { useAppForm } from "~/lib/hooks/useAppForm";
import { upsertRetentionPolicy } from "../privacy.mutations";
import { listRetentionPolicies } from "../privacy.queries";

type RetentionFormValues = {
  dataType: string;
  retentionDays: string;
  archiveAfterDays: string;
  purgeAfterDays: string;
  legalHold: boolean;
};

function normalizeNumberInput(value: string) {
  const trimmed = value.trim();
  if (!trimmed) return undefined;
  const parsed = Number(trimmed);
  return Number.isNaN(parsed) ? undefined : parsed;
}

function RetentionPolicyCreate() {
  const queryClient = useQueryClient();
  const form = useAppForm({
    defaultValues: {
      dataType: "",
      retentionDays: "365",
      archiveAfterDays: "",
      purgeAfterDays: "",
      legalHold: false,
    },
    onSubmit: async ({ value }) => {
      const retentionDays = normalizeNumberInput(value.retentionDays);
      if (!retentionDays || retentionDays <= 0) {
        toast.error("Retention days must be a positive number.");
        return;
      }

      const result = await upsertRetentionPolicy({
        data: {
          dataType: value.dataType.trim(),
          retentionDays,
          archiveAfterDays: normalizeNumberInput(value.archiveAfterDays),
          purgeAfterDays: normalizeNumberInput(value.purgeAfterDays),
          legalHold: value.legalHold,
        },
      });

      if (!result) {
        toast.error("Failed to save retention policy.");
        return;
      }

      toast.success("Retention policy saved.");
      form.reset();
      await queryClient.invalidateQueries({ queryKey: ["privacy", "retention"] });
    },
  });

  return (
    <form
      onSubmit={(event) => {
        event.preventDefault();
        event.stopPropagation();
        void form.handleSubmit();
      }}
      className="space-y-3"
    >
      <p className="text-sm font-semibold">Create retention policy</p>
      <div className="grid gap-3 md:grid-cols-2">
        <form.Field name="dataType">
          {(field) => (
            <Input
              value={(field.state.value as string) ?? ""}
              onChange={(event) => field.handleChange(event.target.value)}
              onBlur={field.handleBlur}
              placeholder="Data type (e.g., audit_logs)"
            />
          )}
        </form.Field>
        <form.Field name="retentionDays">
          {(field) => (
            <Input
              type="number"
              min={1}
              value={(field.state.value as string) ?? ""}
              onChange={(event) => field.handleChange(event.target.value)}
              onBlur={field.handleBlur}
              placeholder="Retention days"
            />
          )}
        </form.Field>
      </div>
      <div className="grid gap-3 md:grid-cols-2">
        <form.Field name="archiveAfterDays">
          {(field) => (
            <Input
              type="number"
              min={0}
              value={(field.state.value as string) ?? ""}
              onChange={(event) => field.handleChange(event.target.value)}
              onBlur={field.handleBlur}
              placeholder="Archive after (days)"
            />
          )}
        </form.Field>
        <form.Field name="purgeAfterDays">
          {(field) => (
            <Input
              type="number"
              min={0}
              value={(field.state.value as string) ?? ""}
              onChange={(event) => field.handleChange(event.target.value)}
              onBlur={field.handleBlur}
              placeholder="Purge after (days)"
            />
          )}
        </form.Field>
      </div>
      <form.Field name="legalHold">
        {(field) => (
          <label className="flex items-center gap-2 text-sm">
            <Checkbox
              checked={Boolean(field.state.value)}
              onCheckedChange={(checked) => field.handleChange(Boolean(checked))}
            />
            Legal hold (skip purge)
          </label>
        )}
      </form.Field>
      <Button type="submit">Save policy</Button>
    </form>
  );
}

function RetentionPolicyRow({
  policy,
}: {
  policy: {
    id: string;
    dataType: string;
    retentionDays: number;
    archiveAfterDays: number | null;
    purgeAfterDays: number | null;
    legalHold: boolean;
  };
}) {
  const queryClient = useQueryClient();
  const form = useAppForm<RetentionFormValues>({
    defaultValues: {
      dataType: policy.dataType,
      retentionDays: String(policy.retentionDays),
      archiveAfterDays: policy.archiveAfterDays ? String(policy.archiveAfterDays) : "",
      purgeAfterDays: policy.purgeAfterDays ? String(policy.purgeAfterDays) : "",
      legalHold: policy.legalHold,
    },
    onSubmit: async ({ value }) => {
      const retentionDays = normalizeNumberInput(value.retentionDays);
      if (!retentionDays || retentionDays <= 0) {
        toast.error("Retention days must be a positive number.");
        return;
      }

      const result = await upsertRetentionPolicy({
        data: {
          dataType: policy.dataType,
          retentionDays,
          archiveAfterDays: normalizeNumberInput(value.archiveAfterDays),
          purgeAfterDays: normalizeNumberInput(value.purgeAfterDays),
          legalHold: value.legalHold,
        },
      });

      if (!result) {
        toast.error("Failed to update retention policy.");
        return;
      }

      toast.success("Retention policy updated.");
      await queryClient.invalidateQueries({ queryKey: ["privacy", "retention"] });
    },
  });

  return (
    <TableRow>
      <TableCell className="text-xs font-semibold">{policy.dataType}</TableCell>
      <TableCell>
        <form.Field name="retentionDays">
          {(field) => (
            <Input
              type="number"
              min={1}
              className="h-8"
              value={(field.state.value as string) ?? ""}
              onChange={(event) => field.handleChange(event.target.value)}
              onBlur={field.handleBlur}
            />
          )}
        </form.Field>
      </TableCell>
      <TableCell>
        <form.Field name="archiveAfterDays">
          {(field) => (
            <Input
              type="number"
              min={0}
              className="h-8"
              value={(field.state.value as string) ?? ""}
              onChange={(event) => field.handleChange(event.target.value)}
              onBlur={field.handleBlur}
            />
          )}
        </form.Field>
      </TableCell>
      <TableCell>
        <form.Field name="purgeAfterDays">
          {(field) => (
            <Input
              type="number"
              min={0}
              className="h-8"
              value={(field.state.value as string) ?? ""}
              onChange={(event) => field.handleChange(event.target.value)}
              onBlur={field.handleBlur}
            />
          )}
        </form.Field>
      </TableCell>
      <TableCell>
        <form.Field name="legalHold">
          {(field) => (
            <Checkbox
              checked={Boolean(field.state.value)}
              onCheckedChange={(checked) => field.handleChange(Boolean(checked))}
            />
          )}
        </form.Field>
      </TableCell>
      <TableCell className="text-right">
        <Button type="button" size="sm" onClick={() => void form.handleSubmit()}>
          Update
        </Button>
      </TableCell>
    </TableRow>
  );
}

export function RetentionPolicyPanel() {
  const { data: policies = [] } = useQuery({
    queryKey: ["privacy", "retention"],
    queryFn: () => listRetentionPolicies(),
  });

  const rows = useMemo(() => policies, [policies]);

  return (
    <Card>
      <CardHeader>
        <CardTitle>Retention Policies</CardTitle>
      </CardHeader>
      <CardContent className="space-y-6">
        <RetentionPolicyCreate />
        {rows.length === 0 ? (
          <p className="text-muted-foreground text-sm">No retention policies yet.</p>
        ) : (
          <div>
            <Label className="text-sm font-semibold">Existing policies</Label>
            <Table className="mt-2">
              <TableHeader>
                <TableRow>
                  <TableHead>Data type</TableHead>
                  <TableHead>Retention (days)</TableHead>
                  <TableHead>Archive after</TableHead>
                  <TableHead>Purge after</TableHead>
                  <TableHead>Legal hold</TableHead>
                  <TableHead className="text-right">Action</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {rows.map((policy) => (
                  <RetentionPolicyRow key={policy.id} policy={policy} />
                ))}
              </TableBody>
            </Table>
          </div>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/privacy/privacy.mutations.ts">
import { createServerFn } from "@tanstack/react-start";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import { zod$ } from "~/lib/server/fn-utils";
import {
  acceptPolicySchema,
  applyPrivacyErasureSchema,
  createPolicyDocumentSchema,
  createPrivacyRequestSchema,
  generatePrivacyExportSchema,
  updatePrivacyRequestSchema,
  upsertRetentionPolicySchema,
} from "./privacy.schemas";

const getSessionUser = async () => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const { getRequest } = await import("@tanstack/react-start/server");
  const auth = await getAuth();
  const { headers } = getRequest();
  const session = await auth.api.getSession({ headers });
  return session?.user ?? null;
};

export const createPolicyDocument = createServerFn({ method: "POST" })
  .inputValidator(zod$(createPolicyDocumentSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_privacy");
    const sessionUser = await getSessionUser();
    if (!sessionUser?.id) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { policyDocuments } = await import("~/db/schema");

    const db = await getDb();
    const [created] = await db
      .insert(policyDocuments)
      .values({
        type: data.type,
        version: data.version,
        contentUrl: data.contentUrl ?? null,
        contentHash: data.contentHash,
        effectiveDate: data.effectiveDate,
        publishedAt: new Date(),
        publishedBy: sessionUser.id,
      })
      .returning();

    if (created) {
      const { logAdminAction } = await import("~/lib/audit");
      await logAdminAction({
        action: "POLICY_CREATE",
        actorUserId: sessionUser.id,
        targetType: "policy_document",
        targetId: created.id,
      });
    }

    return created ?? null;
  });

export const acceptPolicy = createServerFn({ method: "POST" })
  .inputValidator(zod$(acceptPolicySchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("security_core");
    const sessionUser = await getSessionUser();
    if (!sessionUser?.id) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { userPolicyAcceptances } = await import("~/db/schema");
    const { getRequest } = await import("@tanstack/react-start/server");

    const request = getRequest();
    const ipAddress =
      request.headers.get("x-forwarded-for") ?? request.headers.get("x-real-ip");
    const userAgent = request.headers.get("user-agent");

    const db = await getDb();
    const [accepted] = await db
      .insert(userPolicyAcceptances)
      .values({
        userId: sessionUser.id,
        policyId: data.policyId,
        ipAddress: ipAddress ?? null,
        userAgent: userAgent ?? null,
      })
      .returning();

    if (accepted) {
      const { logDataChange } = await import("~/lib/audit");
      await logDataChange({
        action: "POLICY_ACCEPT",
        actorUserId: sessionUser.id,
        targetType: "policy_acceptance",
        targetId: accepted.id,
      });
    }

    return accepted ?? null;
  });

export const createPrivacyRequest = createServerFn({ method: "POST" })
  .inputValidator(zod$(createPrivacyRequestSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("security_core");
    const sessionUser = await getSessionUser();
    if (!sessionUser?.id) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { privacyRequests } = await import("~/db/schema");
    const db = await getDb();

    const [created] = await db
      .insert(privacyRequests)
      .values({
        userId: sessionUser.id,
        type: data.type,
        status: "pending",
      })
      .returning();

    if (created) {
      const { logDataChange } = await import("~/lib/audit");
      await logDataChange({
        action: "PRIVACY_REQUEST_CREATE",
        actorUserId: sessionUser.id,
        targetType: "privacy_request",
        targetId: created.id,
      });
    }

    return created ?? null;
  });

export const updatePrivacyRequest = createServerFn({ method: "POST" })
  .inputValidator(zod$(updatePrivacyRequestSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_privacy");
    const sessionUser = await getSessionUser();
    if (!sessionUser?.id) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { privacyRequests } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");
    const db = await getDb();

    const [updated] = await db
      .update(privacyRequests)
      .set({
        status: data.status,
        processedBy: sessionUser.id,
        processedAt: new Date(),
        resultUrl: data.resultUrl ?? null,
        resultNotes: data.resultNotes ?? null,
        rejectionReason: data.rejectionReason ?? null,
      })
      .where(eq(privacyRequests.id, data.requestId))
      .returning();

    if (updated) {
      const { logAdminAction } = await import("~/lib/audit");
      await logAdminAction({
        action: "PRIVACY_REQUEST_UPDATE",
        actorUserId: sessionUser.id,
        targetType: "privacy_request",
        targetId: updated.id,
      });
    }

    return updated ?? null;
  });

export const upsertRetentionPolicy = createServerFn({ method: "POST" })
  .inputValidator(zod$(upsertRetentionPolicySchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_privacy");
    const sessionUser = await getSessionUser();
    if (!sessionUser?.id) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { retentionPolicies } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    const [existing] = await db
      .select()
      .from(retentionPolicies)
      .where(eq(retentionPolicies.dataType, data.dataType))
      .limit(1);

    if (existing) {
      const [updated] = await db
        .update(retentionPolicies)
        .set({
          retentionDays: data.retentionDays,
          archiveAfterDays: data.archiveAfterDays ?? null,
          purgeAfterDays: data.purgeAfterDays ?? null,
          legalHold: data.legalHold ?? existing.legalHold,
        })
        .where(eq(retentionPolicies.id, existing.id))
        .returning();

      return updated ?? null;
    }

    const [created] = await db
      .insert(retentionPolicies)
      .values({
        dataType: data.dataType,
        retentionDays: data.retentionDays,
        archiveAfterDays: data.archiveAfterDays ?? null,
        purgeAfterDays: data.purgeAfterDays ?? null,
        legalHold: data.legalHold ?? false,
      })
      .returning();

    return created ?? null;
  });

export const generatePrivacyExport = createServerFn({ method: "POST" })
  .inputValidator(zod$(generatePrivacyExportSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_privacy");
    const sessionUser = await getSessionUser();
    if (!sessionUser?.id) return null;

    const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
    await requireAdmin(sessionUser.id);

    const { getDb } = await import("~/db/server-helpers");
    const {
      account,
      auditLogs,
      delegatedAccess,
      formSubmissionVersions,
      formSubmissions,
      notificationPreferences,
      notifications,
      organizationMembers,
      organizations,
      privacyRequests,
      reportingSubmissionHistory,
      reportingSubmissions,
      securityEvents,
      session,
      submissionFiles,
      twoFactor,
      user,
      userPolicyAcceptances,
      userRoles,
      verification,
      roles,
    } = await import("~/db/schema");
    const { and, eq, inArray, or } = await import("drizzle-orm");

    const db = await getDb();
    const [request] = await db
      .select()
      .from(privacyRequests)
      .where(eq(privacyRequests.id, data.requestId))
      .limit(1);

    if (!request) return null;

    await db
      .update(privacyRequests)
      .set({
        status: "processing",
        processedBy: sessionUser.id,
        processedAt: new Date(),
      })
      .where(eq(privacyRequests.id, data.requestId));

    const [userRecord] = await db
      .select()
      .from(user)
      .where(eq(user.id, request.userId))
      .limit(1);

    if (!userRecord) return null;

    const orgMemberships = await db
      .select()
      .from(organizationMembers)
      .where(eq(organizationMembers.userId, request.userId));
    const orgIds = orgMemberships.map((membership) => membership.organizationId);
    const orgRecords = orgIds.length
      ? await db.select().from(organizations).where(inArray(organizations.id, orgIds))
      : [];

    const delegated = await db
      .select()
      .from(delegatedAccess)
      .where(eq(delegatedAccess.delegateUserId, request.userId));

    const roleAssignments = await db
      .select({
        id: userRoles.id,
        roleId: userRoles.roleId,
        roleName: roles.name,
        teamId: userRoles.teamId,
        eventId: userRoles.eventId,
        assignedBy: userRoles.assignedBy,
        assignedAt: userRoles.assignedAt,
        expiresAt: userRoles.expiresAt,
        notes: userRoles.notes,
      })
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(eq(userRoles.userId, request.userId));

    const submissions = await db
      .select()
      .from(formSubmissions)
      .where(eq(formSubmissions.submitterId, request.userId));
    const submissionIds = submissions.map((submission) => submission.id);
    const submissionVersions = submissionIds.length
      ? await db
          .select()
          .from(formSubmissionVersions)
          .where(inArray(formSubmissionVersions.submissionId, submissionIds))
      : [];
    const submissionFileRows = submissionIds.length
      ? await db
          .select()
          .from(submissionFiles)
          .where(inArray(submissionFiles.submissionId, submissionIds))
      : [];

    const reporting = await db
      .select()
      .from(reportingSubmissions)
      .where(eq(reportingSubmissions.submittedBy, request.userId));
    const reportingIds = reporting.map((item) => item.id);
    const reportingHistory = reportingIds.length
      ? await db
          .select()
          .from(reportingSubmissionHistory)
          .where(inArray(reportingSubmissionHistory.reportingSubmissionId, reportingIds))
      : [];

    const privacyRequestsByUser = await db
      .select()
      .from(privacyRequests)
      .where(eq(privacyRequests.userId, request.userId));
    const policyAcceptances = await db
      .select()
      .from(userPolicyAcceptances)
      .where(eq(userPolicyAcceptances.userId, request.userId));
    const userNotifications = await db
      .select()
      .from(notifications)
      .where(eq(notifications.userId, request.userId));
    const userPreferences = await db
      .select()
      .from(notificationPreferences)
      .where(eq(notificationPreferences.userId, request.userId));
    const security = await db
      .select()
      .from(securityEvents)
      .where(eq(securityEvents.userId, request.userId));

    const audit = await db
      .select()
      .from(auditLogs)
      .where(
        or(
          eq(auditLogs.actorUserId, request.userId),
          and(eq(auditLogs.targetType, "user"), eq(auditLogs.targetId, request.userId)),
        ),
      );

    const accounts = await db
      .select()
      .from(account)
      .where(eq(account.userId, request.userId));
    const sessions = await db
      .select()
      .from(session)
      .where(eq(session.userId, request.userId));
    const twoFactorRows = await db
      .select()
      .from(twoFactor)
      .where(eq(twoFactor.userId, request.userId));
    const verifications = await db
      .select()
      .from(verification)
      .where(eq(verification.identifier, userRecord.email));

    const exportPayload = {
      generatedAt: new Date().toISOString(),
      requestId: request.id,
      user: userRecord,
      organizations: orgRecords,
      organizationMemberships: orgMemberships,
      delegatedAccess: delegated,
      roleAssignments,
      accounts,
      sessions,
      twoFactor: twoFactorRows,
      verifications,
      policyAcceptances,
      privacyRequests: privacyRequestsByUser,
      notifications: userNotifications,
      notificationPreferences: userPreferences,
      securityEvents: security,
      auditLogs: audit,
      formSubmissions: submissions,
      formSubmissionVersions: submissionVersions,
      submissionFiles: submissionFileRows,
      reportingSubmissions: reporting,
      reportingSubmissionHistory: reportingHistory,
    };

    const { PutObjectCommand } = await import("@aws-sdk/client-s3");
    const { getArtifactsBucketName, getS3Client } =
      await import("~/lib/storage/artifacts");

    const bucket = await getArtifactsBucketName();
    const storageKey = `privacy/exports/${request.userId}/${request.id}.json`;
    const client = await getS3Client();

    await client.send(
      new PutObjectCommand({
        Bucket: bucket,
        Key: storageKey,
        Body: JSON.stringify(exportPayload, null, 2),
        ContentType: "application/json",
      }),
    );

    const resultUrl = `s3://${bucket}/${storageKey}`;

    const [updated] = await db
      .update(privacyRequests)
      .set({
        status: "completed",
        processedBy: sessionUser.id,
        processedAt: new Date(),
        resultUrl,
        resultNotes: "Export generated and stored in SIN artifacts bucket.",
      })
      .where(eq(privacyRequests.id, data.requestId))
      .returning();

    if (updated) {
      const { logAdminAction } = await import("~/lib/audit");
      await logAdminAction({
        action: "PRIVACY_EXPORT_GENERATE",
        actorUserId: sessionUser.id,
        targetType: "privacy_request",
        targetId: updated.id,
        metadata: { storageKey },
      });
    }

    return updated ?? null;
  });

export const applyPrivacyErasure = createServerFn({ method: "POST" })
  .inputValidator(zod$(applyPrivacyErasureSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_privacy");
    const sessionUser = await getSessionUser();
    if (!sessionUser?.id) return null;

    const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
    await requireAdmin(sessionUser.id);

    const { getDb } = await import("~/db/server-helpers");
    const {
      account,
      accountLocks,
      delegatedAccess,
      formSubmissionVersions,
      formSubmissions,
      notifications,
      organizationMembers,
      privacyRequests,
      reportingSubmissionHistory,
      reportingSubmissions,
      securityEvents,
      session,
      submissionFiles,
      twoFactor,
      user,
      userPolicyAcceptances,
      userRoles,
      verification,
    } = await import("~/db/schema");
    const { eq, inArray, or } = await import("drizzle-orm");

    const db = await getDb();
    const [request] = await db
      .select()
      .from(privacyRequests)
      .where(eq(privacyRequests.id, data.requestId))
      .limit(1);

    if (!request) return null;

    // Mark request as processing early (so UI/admin can see it in-flight)
    await db
      .update(privacyRequests)
      .set({
        status: "processing",
        processedBy: sessionUser.id,
        processedAt: new Date(),
        resultNotes:
          "Processing erasure request (deleting stored artifacts and anonymizing user record).",
      })
      .where(eq(privacyRequests.id, data.requestId));

    const [userRecord] = await db
      .select({ email: user.email })
      .from(user)
      .where(eq(user.id, request.userId))
      .limit(1);

    const anonymizedEmail = `deleted+${request.userId}@example.invalid`;

    // ISSUE 06 FIX: Find submission files tied to this user and delete S3 objects first.
    const userSubmissions = await db
      .select({ id: formSubmissions.id })
      .from(formSubmissions)
      .where(eq(formSubmissions.submitterId, request.userId));
    const submissionIds = userSubmissions.map((row) => row.id);

    const fileConditions = [eq(submissionFiles.uploadedBy, request.userId)];
    if (submissionIds.length) {
      fileConditions.push(inArray(submissionFiles.submissionId, submissionIds));
    }

    const fileWhere =
      fileConditions.length === 1 ? fileConditions[0] : or(...fileConditions);

    const filesToErase = fileWhere
      ? await db.select().from(submissionFiles).where(fileWhere)
      : [];

    let erasedFilesAttempted = 0;
    let erasedFilesDeleted = 0;
    if (filesToErase.length) {
      const { deleteFormSubmissionFiles } =
        await import("~/lib/privacy/submission-files");
      const result = await deleteFormSubmissionFiles({ items: filesToErase });
      erasedFilesAttempted = result.attempted;
      erasedFilesDeleted = result.deleted;
    }

    await db.transaction(async (tx) => {
      await tx
        .update(user)
        .set({
          name: "Deleted User",
          email: anonymizedEmail,
          image: null,
          profileComplete: false,
          dateOfBirth: null,
          emergencyContact: null,
          gender: null,
          pronouns: null,
          phone: null,
          privacySettings: null,
          mfaRequired: false,
          mfaEnrolledAt: null,
          twoFactorEnabled: false,
        })
        .where(eq(user.id, request.userId));

      await tx.delete(account).where(eq(account.userId, request.userId));
      await tx.delete(session).where(eq(session.userId, request.userId));
      await tx.delete(twoFactor).where(eq(twoFactor.userId, request.userId));
      await tx.delete(userRoles).where(eq(userRoles.userId, request.userId));
      await tx
        .delete(userPolicyAcceptances)
        .where(eq(userPolicyAcceptances.userId, request.userId));
      await tx.delete(notifications).where(eq(notifications.userId, request.userId));
      await tx.delete(accountLocks).where(eq(accountLocks.userId, request.userId));
      await tx
        .update(securityEvents)
        .set({ userId: null })
        .where(eq(securityEvents.userId, request.userId));

      if (userRecord?.email) {
        await tx
          .delete(verification)
          .where(eq(verification.identifier, userRecord.email));
      }

      await tx
        .update(organizationMembers)
        .set({ status: "removed" })
        .where(eq(organizationMembers.userId, request.userId));

      await tx
        .update(delegatedAccess)
        .set({
          revokedAt: new Date(),
          revokedBy: sessionUser.id,
          notes: data.reason ?? "DSAR erasure request",
        })
        .where(eq(delegatedAccess.delegateUserId, request.userId));

      await tx
        .update(formSubmissions)
        .set({ submitterId: null })
        .where(eq(formSubmissions.submitterId, request.userId));
      await tx
        .update(formSubmissionVersions)
        .set({ changedBy: null })
        .where(eq(formSubmissionVersions.changedBy, request.userId));

      // Files are deleted from S3, so remove their DB rows to avoid dangling pointers / metadata retention
      if (filesToErase.length) {
        await tx.delete(submissionFiles).where(
          inArray(
            submissionFiles.id,
            filesToErase.map((row) => row.id),
          ),
        );
      }

      await tx
        .update(reportingSubmissions)
        .set({ submittedBy: null })
        .where(eq(reportingSubmissions.submittedBy, request.userId));
      await tx
        .update(reportingSubmissionHistory)
        .set({ actorId: null })
        .where(eq(reportingSubmissionHistory.actorId, request.userId));

      await tx
        .update(privacyRequests)
        .set({
          status: "completed",
          processedBy: sessionUser.id,
          processedAt: new Date(),
          resultNotes:
            (data.reason ?? "User data anonymized per DSAR request.") +
            ` Removed ${erasedFilesDeleted}/${erasedFilesAttempted} file artifact(s) from object storage.`,
        })
        .where(eq(privacyRequests.id, data.requestId));
    });

    const { logAdminAction } = await import("~/lib/audit");
    await logAdminAction({
      action: "PRIVACY_ERASURE_APPLY",
      actorUserId: sessionUser.id,
      targetType: "privacy_request",
      targetId: request.id,
      metadata: {
        userId: request.userId,
        reason: data.reason ?? null,
        erasedFilesAttempted,
        erasedFilesDeleted,
      },
    });

    return { success: true };
  });
</file>

<file path="src/features/privacy/privacy.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { assertFeatureEnabled } from "~/tenant/feature-gates";
import { zod$ } from "~/lib/server/fn-utils";
import { getPrivacyExportUrlSchema, policyTypeSchema } from "./privacy.schemas";

const getSessionUserId = async () => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const { getRequest } = await import("@tanstack/react-start/server");
  const auth = await getAuth();
  const { headers } = getRequest();
  const session = await auth.api.getSession({ headers });
  return session?.user?.id ?? null;
};

export const listPolicyDocuments = createServerFn({ method: "GET" }).handler(async () => {
  await assertFeatureEnabled("security_core");
  const { getDb } = await import("~/db/server-helpers");
  const { policyDocuments } = await import("~/db/schema");
  const { desc } = await import("drizzle-orm");

  const db = await getDb();
  return db.select().from(policyDocuments).orderBy(desc(policyDocuments.createdAt));
});

export const getLatestPolicyDocument = createServerFn({ method: "GET" })
  .inputValidator(zod$(policyTypeSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("security_core");
    const { getDb } = await import("~/db/server-helpers");
    const { policyDocuments } = await import("~/db/schema");
    const { desc, eq } = await import("drizzle-orm");

    const db = await getDb();
    const [policy] = await db
      .select()
      .from(policyDocuments)
      .where(eq(policyDocuments.type, data))
      .orderBy(desc(policyDocuments.effectiveDate))
      .limit(1);

    return policy ?? null;
  });

export const listUserPolicyAcceptances = createServerFn({ method: "GET" }).handler(
  async () => {
    await assertFeatureEnabled("security_core");
    const userId = await getSessionUserId();
    if (!userId) return [];

    const { getDb } = await import("~/db/server-helpers");
    const { userPolicyAcceptances } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    return db
      .select()
      .from(userPolicyAcceptances)
      .where(eq(userPolicyAcceptances.userId, userId));
  },
);

export const listPrivacyRequests = createServerFn({ method: "GET" }).handler(async () => {
  await assertFeatureEnabled("security_core");
  const userId = await getSessionUserId();
  if (!userId) return [];

  const { getDb } = await import("~/db/server-helpers");
  const { privacyRequests } = await import("~/db/schema");
  const { desc, eq } = await import("drizzle-orm");

  const db = await getDb();
  return db
    .select()
    .from(privacyRequests)
    .where(eq(privacyRequests.userId, userId))
    .orderBy(desc(privacyRequests.createdAt));
});

export const listAllPrivacyRequests = createServerFn({ method: "GET" }).handler(
  async () => {
    await assertFeatureEnabled("sin_admin_privacy");
    const userId = await getSessionUserId();
    if (!userId) return [];

    const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
    await requireAdmin(userId);

    const { getDb } = await import("~/db/server-helpers");
    const { privacyRequests } = await import("~/db/schema");
    const { desc } = await import("drizzle-orm");

    const db = await getDb();
    return db.select().from(privacyRequests).orderBy(desc(privacyRequests.createdAt));
  },
);

export const listRetentionPolicies = createServerFn({ method: "GET" }).handler(
  async () => {
    await assertFeatureEnabled("sin_admin_privacy");
    const userId = await getSessionUserId();
    if (!userId) return [];

    const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
    await requireAdmin(userId);

    const { getDb } = await import("~/db/server-helpers");
    const { retentionPolicies } = await import("~/db/schema");
    const { asc } = await import("drizzle-orm");

    const db = await getDb();
    return db.select().from(retentionPolicies).orderBy(asc(retentionPolicies.dataType));
  },
);

export const getPrivacyExportDownloadUrl = createServerFn({ method: "GET" })
  .inputValidator(zod$(getPrivacyExportUrlSchema))
  .handler(async ({ data }) => {
    await assertFeatureEnabled("sin_admin_privacy");
    const userId = await getSessionUserId();
    if (!userId) return null;

    const { getDb } = await import("~/db/server-helpers");
    const { privacyRequests } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");

    const db = await getDb();
    const [request] = await db
      .select()
      .from(privacyRequests)
      .where(eq(privacyRequests.id, data.requestId))
      .limit(1);

    if (!request?.resultUrl) return null;

    if (request.userId !== userId) {
      const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
      await requireAdmin(userId);
    }

    const { GetObjectCommand } = await import("@aws-sdk/client-s3");
    const { getSignedUrl } = await import("@aws-sdk/s3-request-presigner");
    const { getArtifactsBucketName, getS3Client } =
      await import("~/lib/storage/artifacts");

    const bucket = request.resultUrl.startsWith("s3://")
      ? request.resultUrl.replace("s3://", "").split("/")[0]
      : await getArtifactsBucketName();
    const key = request.resultUrl.startsWith("s3://")
      ? request.resultUrl.replace(`s3://${bucket}/`, "")
      : request.resultUrl;

    const client = await getS3Client();
    const command = new GetObjectCommand({ Bucket: bucket, Key: key });
    const url = await getSignedUrl(client, command, { expiresIn: 900 });
    return url;
  });
</file>

<file path="src/features/privacy/privacy.schemas.ts">
import { z } from "zod";

export const policyTypeSchema = z.enum([
  "privacy_policy",
  "terms_of_service",
  "data_agreement",
]);

export const privacyRequestTypeSchema = z.enum([
  "access",
  "export",
  "erasure",
  "correction",
]);

export const privacyRequestStatusSchema = z.enum([
  "pending",
  "processing",
  "completed",
  "rejected",
]);

export const createPolicyDocumentSchema = z.object({
  type: policyTypeSchema,
  version: z.string().min(1),
  contentUrl: z.string().optional(),
  contentHash: z.string().min(1),
  effectiveDate: z.string().min(1),
});
export type CreatePolicyDocumentInput = z.infer<typeof createPolicyDocumentSchema>;

export const acceptPolicySchema = z.object({
  policyId: z.uuid(),
});
export type AcceptPolicyInput = z.infer<typeof acceptPolicySchema>;

export const createPrivacyRequestSchema = z.object({
  type: privacyRequestTypeSchema,
});
export type CreatePrivacyRequestInput = z.infer<typeof createPrivacyRequestSchema>;

export const updatePrivacyRequestSchema = z.object({
  requestId: z.uuid(),
  status: privacyRequestStatusSchema,
  resultUrl: z.string().optional(),
  resultNotes: z.string().optional(),
  rejectionReason: z.string().optional(),
});
export type UpdatePrivacyRequestInput = z.infer<typeof updatePrivacyRequestSchema>;

export const upsertRetentionPolicySchema = z.object({
  dataType: z.string().min(1),
  retentionDays: z.number().int().min(1),
  archiveAfterDays: z.number().int().min(0).optional(),
  purgeAfterDays: z.number().int().min(0).optional(),
  legalHold: z.boolean().optional(),
});
export type UpsertRetentionPolicyInput = z.infer<typeof upsertRetentionPolicySchema>;

export const generatePrivacyExportSchema = z.object({
  requestId: z.uuid(),
});
export type GeneratePrivacyExportInput = z.infer<typeof generatePrivacyExportSchema>;

export const applyPrivacyErasureSchema = z.object({
  requestId: z.uuid(),
  reason: z.string().trim().max(500).optional(),
});
export type ApplyPrivacyErasureInput = z.infer<typeof applyPrivacyErasureSchema>;

export const getPrivacyExportUrlSchema = z.object({
  requestId: z.uuid(),
});
export type GetPrivacyExportUrlInput = z.infer<typeof getPrivacyExportUrlSchema>;
</file>

<file path="src/lib/audit/index.ts">
import { createServerOnlyFn } from "@tanstack/react-start";
import { asc, desc } from "drizzle-orm";
import { getRequestContext } from "~/lib/server/request-context";
import { resolveRequestId } from "~/lib/server/request-id";
import type { JsonRecord, JsonValue } from "~/shared/lib/json";

export type AuditActionCategory = "AUTH" | "ADMIN" | "DATA" | "EXPORT" | "SECURITY";

export interface AuditEntryInput {
  action: string;
  actionCategory?: AuditActionCategory;
  actorUserId?: string | null;
  actorOrgId?: string | null;
  actorIp?: string | null;
  actorUserAgent?: string | null;
  targetType?: string | null;
  targetId?: string | null;
  targetOrgId?: string | null;
  changes?: Record<string, { old?: JsonValue; new?: JsonValue }> | null;
  metadata?: JsonRecord;
  requestId?: string;
}

const HASH_FIELDS = ["dateOfBirth", "phone", "emergencyContact.phone"];
const REDACT_FIELDS = ["password", "secret", "token", "mfaSecret"];

const shouldRedact = (field: string) =>
  REDACT_FIELDS.some(
    (redacted) => field === redacted || field.startsWith(`${redacted}.`),
  );

const shouldHash = (field: string) =>
  HASH_FIELDS.some((hashed) => field === hashed || field.startsWith(`${hashed}.`));

const stableStringify = (value: unknown): string => {
  if (value === null || value === undefined) {
    return JSON.stringify(value);
  }

  if (Array.isArray(value)) {
    return `[${value.map((item) => stableStringify(item)).join(",")}]`;
  }

  if (typeof value === "object") {
    const entries = Object.entries(value as Record<string, unknown>)
      .sort(([a], [b]) => a.localeCompare(b))
      .map(([key, val]) => `"${key}":${stableStringify(val)}`);
    return `{${entries.join(",")}}`;
  }

  return JSON.stringify(value);
};

const hashValue = async (value: unknown): Promise<string> => {
  const { createHash } = await import("crypto");
  return createHash("sha256").update(stableStringify(value)).digest("hex");
};

const toJsonValue = (value: unknown): JsonValue => {
  if (value === undefined) return null;
  if (typeof value === "bigint") return value.toString();
  if (typeof value === "symbol") return value.toString();
  if (typeof value === "function") return null;

  try {
    return JSON.parse(JSON.stringify(value)) as JsonValue;
  } catch {
    return String(value);
  }
};

const sanitizeValue = async (field: string, value: unknown): Promise<JsonValue> => {
  if (shouldRedact(field)) {
    return "[REDACTED]";
  }

  if (shouldHash(field)) {
    return await hashValue(value);
  }

  return toJsonValue(value);
};

const sanitizeChanges = async (
  changes?: Record<string, { old?: unknown; new?: unknown }> | null,
) => {
  if (!changes) return null;

  const entries = await Promise.all(
    Object.entries(changes).map(async ([field, change]) => {
      return [
        field,
        {
          old: await sanitizeValue(field, change.old),
          new: await sanitizeValue(field, change.new),
        },
      ] as const;
    }),
  );

  return Object.fromEntries(entries) as Record<
    string,
    { old?: JsonValue; new?: JsonValue }
  >;
};

export const createAuditDiff = async (
  before: Record<string, unknown> | null,
  after: Record<string, unknown> | null,
) => {
  const changes: Record<string, { old?: JsonValue; new?: JsonValue }> = {};
  const beforeData = before ?? {};
  const afterData = after ?? {};
  const keys = new Set([...Object.keys(beforeData), ...Object.keys(afterData)]);

  for (const key of keys) {
    const oldValue = beforeData[key];
    const newValue = afterData[key];
    const isSame =
      oldValue === newValue || stableStringify(oldValue) === stableStringify(newValue);

    if (!isSame) {
      changes[key] = { old: toJsonValue(oldValue), new: toJsonValue(newValue) };
    }
  }

  return sanitizeChanges(changes);
};

const inferCategory = (action: string): AuditActionCategory => {
  const [prefix] = action.split(".");
  if (!prefix) return "DATA";
  const normalized = prefix.toUpperCase() as AuditActionCategory;
  return ["AUTH", "ADMIN", "DATA", "EXPORT", "SECURITY"].includes(normalized)
    ? normalized
    : "DATA";
};

const resolveRequestContext = () => {
  const context = getRequestContext();
  const headers = context?.headers;
  const actorIp = headers?.get("x-forwarded-for") ?? headers?.get("x-real-ip") ?? null;
  const actorUserAgent = headers?.get("user-agent") ?? null;

  return {
    headers,
    requestId: context?.requestId ?? null,
    actorIp,
    actorUserAgent,
  };
};

export const logAuditEntry = createServerOnlyFn(async (input: AuditEntryInput) => {
  const { getDb } = await import("~/db/server-helpers");
  const { auditLogs } = await import("~/db/schema");

  const db = await getDb();
  const requestContext = resolveRequestContext();
  const requestId =
    input.requestId ??
    requestContext.requestId ??
    resolveRequestId(requestContext.headers);
  const actorIp = input.actorIp ?? requestContext.actorIp ?? null;
  const actorUserAgent = input.actorUserAgent ?? requestContext.actorUserAgent ?? null;

  const [previous] = await db
    .select({ entryHash: auditLogs.entryHash })
    .from(auditLogs)
    .orderBy(desc(auditLogs.occurredAt))
    .limit(1);

  const prevHash = previous?.entryHash ?? null;
  const sanitizedChanges = await sanitizeChanges(input.changes ?? null);

  const payload = {
    action: input.action,
    actionCategory: input.actionCategory ?? inferCategory(input.action),
    actorUserId: input.actorUserId ?? null,
    actorOrgId: input.actorOrgId ?? null,
    actorIp,
    actorUserAgent,
    targetType: input.targetType ?? null,
    targetId: input.targetId ?? null,
    targetOrgId: input.targetOrgId ?? null,
    changes: sanitizedChanges,
    metadata: input.metadata ?? {},
    requestId,
    prevHash,
  };

  const entryHash = await hashValue(payload);

  await db.insert(auditLogs).values({
    occurredAt: new Date(),
    actorUserId: payload.actorUserId,
    actorOrgId: payload.actorOrgId,
    actorIp: payload.actorIp ?? undefined,
    actorUserAgent: payload.actorUserAgent ?? undefined,
    action: payload.action,
    actionCategory: payload.actionCategory,
    targetType: payload.targetType,
    targetId: payload.targetId,
    targetOrgId: payload.targetOrgId ?? null,
    changes: payload.changes ?? undefined,
    metadata: payload.metadata,
    requestId,
    prevHash: payload.prevHash ?? undefined,
    entryHash,
  });
});

export const logAuthEvent = async (params: Omit<AuditEntryInput, "actionCategory">) =>
  logAuditEntry({
    ...params,
    actionCategory: "AUTH",
  });

export const logAdminAction = async (params: Omit<AuditEntryInput, "actionCategory">) =>
  logAuditEntry({
    ...params,
    actionCategory: "ADMIN",
  });

export const logDataChange = async (params: Omit<AuditEntryInput, "actionCategory">) =>
  logAuditEntry({
    ...params,
    actionCategory: "DATA",
  });

export const logExportEvent = async (params: Omit<AuditEntryInput, "actionCategory">) =>
  logAuditEntry({
    ...params,
    actionCategory: "EXPORT",
  });

export const logSecurityEvent = async (params: Omit<AuditEntryInput, "actionCategory">) =>
  logAuditEntry({
    ...params,
    actionCategory: "SECURITY",
  });

export const verifyAuditHashChain = createServerOnlyFn(async () => {
  const { getDb } = await import("~/db/server-helpers");
  const { auditLogs } = await import("~/db/schema");

  const db = await getDb();
  const rows = await db
    .select({
      id: auditLogs.id,
      entryHash: auditLogs.entryHash,
      prevHash: auditLogs.prevHash,
      action: auditLogs.action,
      actionCategory: auditLogs.actionCategory,
      actorUserId: auditLogs.actorUserId,
      actorOrgId: auditLogs.actorOrgId,
      actorIp: auditLogs.actorIp,
      actorUserAgent: auditLogs.actorUserAgent,
      targetType: auditLogs.targetType,
      targetId: auditLogs.targetId,
      targetOrgId: auditLogs.targetOrgId,
      changes: auditLogs.changes,
      metadata: auditLogs.metadata,
      requestId: auditLogs.requestId,
      occurredAt: auditLogs.occurredAt,
    })
    .from(auditLogs)
    .orderBy(asc(auditLogs.occurredAt));

  const invalidIds: string[] = [];
  let previousHash: string | null = null;

  for (const row of rows) {
    const payload = {
      action: row.action,
      actionCategory: row.actionCategory as AuditActionCategory,
      actorUserId: row.actorUserId,
      actorOrgId: row.actorOrgId,
      actorIp: row.actorIp,
      actorUserAgent: row.actorUserAgent,
      targetType: row.targetType,
      targetId: row.targetId,
      targetOrgId: row.targetOrgId,
      changes: row.changes ?? null,
      metadata: row.metadata ?? {},
      requestId: row.requestId,
      prevHash: previousHash,
    };

    const expectedHash = await hashValue(payload);
    if (row.prevHash !== previousHash || row.entryHash !== expectedHash) {
      invalidIds.push(row.id);
    }

    previousHash = row.entryHash;
  }

  return { valid: invalidIds.length === 0, invalidIds };
});
</file>

<file path="src/lib/notifications/digest.ts">
import { createServerOnlyFn } from "@tanstack/react-start";
import type { JsonRecord } from "~/shared/lib/json";

const DIGEST_WINDOWS_MS: Record<string, number> = {
  daily_digest: 24 * 60 * 60 * 1000,
  weekly_digest: 7 * 24 * 60 * 60 * 1000,
};

const buildDigestBody = (
  items: Array<{
    title: string;
    link: string | null;
    createdAt: Date;
  }>,
) => {
  const lines = ["Recent notifications:", ""];

  items.forEach((item) => {
    const timestamp = item.createdAt.toLocaleString();
    const linkLine = item.link ? ` (${item.link})` : "";
    lines.push(`- ${timestamp}: ${item.title}${linkLine}`);
  });

  return lines.join("\n");
};

export const processNotificationDigests = createServerOnlyFn(async () => {
  const { getDb } = await import("~/db/server-helpers");
  const { notificationPreferences, notifications } = await import("~/db/schema");
  const { and, desc, eq, gte, inArray, sql } = await import("drizzle-orm");
  const { sendDigestEmail } = await import("~/lib/notifications/send");
  const { logDataChange } = await import("~/lib/audit");

  const db = await getDb();
  const now = new Date();

  const preferences = await db
    .select()
    .from(notificationPreferences)
    .where(
      and(
        eq(notificationPreferences.channelEmail, true),
        inArray(notificationPreferences.emailFrequency, [
          "daily_digest",
          "weekly_digest",
        ]),
      ),
    );

  let sent = 0;
  let skipped = 0;

  for (const preference of preferences) {
    const windowMs = DIGEST_WINDOWS_MS[preference.emailFrequency ?? ""] ?? null;
    if (!windowMs) continue;

    const windowStart = new Date(now.getTime() - windowMs);

    const digestSentAtExpr = sql<string>`(${notifications.metadata} ->> 'digestSentAt')`;
    const rows = await db
      .select({
        id: notifications.id,
        title: notifications.title,
        link: notifications.link,
        createdAt: notifications.createdAt,
        metadata: notifications.metadata,
      })
      .from(notifications)
      .where(
        and(
          eq(notifications.userId, preference.userId),
          eq(notifications.category, preference.category),
          gte(notifications.createdAt, windowStart),
          sql`${digestSentAtExpr} IS NULL`,
        ),
      )
      .orderBy(desc(notifications.createdAt))
      .limit(50);

    if (rows.length === 0) {
      skipped += 1;
      continue;
    }

    const subject = `You have ${rows.length} ${preference.category} updates`;
    const body = buildDigestBody(rows);

    const result = await sendDigestEmail({
      userId: preference.userId,
      subject,
      bodyText: body,
    });

    if (!result.sent) {
      skipped += 1;
      continue;
    }

    const digestTimestamp = now.toISOString();
    for (const row of rows) {
      const metadata = (row.metadata as JsonRecord | null) ?? {};
      await db
        .update(notifications)
        .set({ metadata: { ...metadata, digestSentAt: digestTimestamp } })
        .where(eq(notifications.id, row.id));
    }

    await logDataChange({
      action: "NOTIFICATION_DIGEST_SENT",
      actorUserId: preference.userId,
      targetType: "notification_digest",
      targetId: preference.userId,
      metadata: {
        category: preference.category,
        count: rows.length,
        window: preference.emailFrequency,
      },
    });

    sent += 1;
  }

  return { sent, skipped };
});
</file>

<file path="src/lib/notifications/queue.ts">
import { createServerOnlyFn } from "@tanstack/react-start";
import { sendNotification, type NotificationDispatch } from "./send";

type EnqueueResult =
  | { mode: "direct"; inApp: boolean; email: boolean; notificationId: string }
  | { mode: "sqs"; queued: true; messageId: string | null; notificationId: string };

export const enqueueNotification = createServerOnlyFn(
  async (payload: NotificationDispatch): Promise<EnqueueResult> => {
    const { randomUUID } = await import("crypto");

    const notificationId = payload.notificationId ?? randomUUID();
    const enriched: NotificationDispatch = {
      ...payload,
      notificationId,
      metadata: {
        ...(payload.metadata ?? {}),
        notificationId,
      },
    };

    const queueUrl = process.env["SIN_NOTIFICATIONS_QUEUE_URL"];
    if (!queueUrl) {
      // Dev fallback: direct send when queue URL not configured
      const result = await sendNotification(enriched);
      return { mode: "direct", ...result, notificationId };
    }

    const region = process.env["AWS_REGION"] ?? "ca-central-1";
    const { SQSClient, SendMessageCommand } = await import("@aws-sdk/client-sqs");

    const client = new SQSClient({ region });
    const body = JSON.stringify(enriched);

    const isFifo = queueUrl.endsWith(".fifo");

    const command = new SendMessageCommand({
      QueueUrl: queueUrl,
      MessageBody: body,
      ...(isFifo
        ? {
            MessageGroupId: enriched.userId,
            MessageDeduplicationId: notificationId,
          }
        : {}),
    });

    const resp = await client.send(command);
    return {
      mode: "sqs",
      queued: true,
      messageId: resp.MessageId ?? null,
      notificationId,
    };
  },
);
</file>

<file path="src/lib/notifications/scheduler.ts">
import { createServerOnlyFn } from "@tanstack/react-start";
import type { JsonRecord } from "~/shared/lib/json";
import { enqueueNotification } from "./queue";

const applyTemplate = (template: string, variables: JsonRecord) =>
  template.replace(/{{\s*([^}]+)\s*}}/g, (_match, key) => {
    const value = variables[key.trim()];
    return value === undefined || value === null ? "" : String(value);
  });

export const scheduleNotification = createServerOnlyFn(
  async (params: {
    templateKey: string;
    userId?: string | null;
    organizationId?: string | null;
    roleFilter?: string | null;
    scheduledFor: Date;
    variables?: JsonRecord;
  }) => {
    const { getDb } = await import("~/db/server-helpers");
    const { scheduledNotifications } = await import("~/db/schema");
    const db = await getDb();

    const [created] = await db
      .insert(scheduledNotifications)
      .values({
        templateKey: params.templateKey,
        userId: params.userId ?? null,
        organizationId: params.organizationId ?? null,
        roleFilter: params.roleFilter ?? null,
        scheduledFor: params.scheduledFor,
        variables: params.variables ?? {},
      })
      .returning();

    return created ?? null;
  },
);

export const processScheduledNotifications = createServerOnlyFn(async () => {
  const { getDb } = await import("~/db/server-helpers");
  const { notificationTemplates, scheduledNotifications } = await import("~/db/schema");
  const { and, eq, isNull, lte } = await import("drizzle-orm");

  const db = await getDb();
  const now = new Date();

  const pending = await db
    .select()
    .from(scheduledNotifications)
    .where(
      and(
        isNull(scheduledNotifications.sentAt),
        isNull(scheduledNotifications.failedAt),
        lte(scheduledNotifications.scheduledFor, now),
      ),
    )
    .limit(100);

  for (const job of pending) {
    try {
      const [template] = await db
        .select()
        .from(notificationTemplates)
        .where(eq(notificationTemplates.key, job.templateKey))
        .limit(1);

      if (!template) {
        throw new Error("Template not found");
      }

      if (!job.userId) {
        throw new Error("Scheduled notifications without userId are not supported yet.");
      }

      const variables = job.variables ?? {};
      await enqueueNotification({
        // Use job.id as stable notificationId for idempotency across retries
        notificationId: job.id,
        userId: job.userId,
        organizationId: job.organizationId ?? null,
        type: job.templateKey,
        category: template.category,
        title: applyTemplate(template.subject, variables),
        body: applyTemplate(template.bodyTemplate, variables),
        metadata: {
          scheduledNotificationId: job.id,
          templateKey: job.templateKey,
        },
      });

      await db
        .update(scheduledNotifications)
        .set({ sentAt: new Date() })
        .where(eq(scheduledNotifications.id, job.id));
    } catch (error) {
      console.error("Failed to process scheduled notification", error);
      const nextRetry = job.retryCount + 1;
      const maxRetries = 3;
      const errorMessage = error instanceof Error ? error.message : "Unknown error";

      if (nextRetry <= maxRetries) {
        const backoffMinutes = Math.min(60, 5 * 2 ** job.retryCount);
        await db
          .update(scheduledNotifications)
          .set({
            scheduledFor: new Date(Date.now() + backoffMinutes * 60 * 1000),
            errorMessage,
            retryCount: nextRetry,
          })
          .where(eq(scheduledNotifications.id, job.id));
      } else {
        await db
          .update(scheduledNotifications)
          .set({
            failedAt: new Date(),
            errorMessage,
            retryCount: nextRetry,
          })
          .where(eq(scheduledNotifications.id, job.id));
      }
    }
  }

  return { processed: pending.length };
});
</file>

<file path="src/lib/notifications/send.ts">
import { createServerOnlyFn } from "@tanstack/react-start";
import type { JsonRecord } from "~/shared/lib/json";

export type NotificationDispatch = {
  // stable id for idempotency across retries
  notificationId?: string;

  userId: string;
  organizationId?: string | null;
  type: string;
  category: string;
  title: string;
  body: string;
  link?: string | null;
  metadata?: JsonRecord;
};

const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

const isRetryableSesError = (error: unknown) => {
  const err = error as Record<string, unknown>;
  const errName = err?.["name"];
  const errCode = err?.["Code"];
  const code = (errName ?? errCode ?? null) as string | null;
  const metadata = err?.["$metadata"] as { httpStatusCode?: number } | undefined;
  const status = metadata?.httpStatusCode ?? null;

  return (
    code === "ThrottlingException" ||
    code === "ServiceUnavailableException" ||
    code === "TooManyRequestsException" ||
    (typeof status === "number" && status >= 500)
  );
};

const buildEmailText = (payload: NotificationDispatch) => {
  const lines = [payload.body];
  if (payload.link) {
    lines.push("", `Open: ${payload.link}`);
  }
  return lines.join("\n");
};

const sendEmailWithRetry = async (params: {
  to: string;
  subject: string;
  bodyText: string;
}) => {
  const from = process.env["SIN_NOTIFICATIONS_FROM_EMAIL"];
  if (!from) {
    throw new Error("SIN_NOTIFICATIONS_FROM_EMAIL is not configured.");
  }

  const replyTo = process.env["SIN_NOTIFICATIONS_REPLY_TO_EMAIL"] ?? null;
  const region = process.env["AWS_REGION"] ?? "ca-central-1";
  const { SESClient, SendEmailCommand } = await import("@aws-sdk/client-ses");

  const client = new SESClient({ region });

  const maxAttempts = 3;
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await client.send(
        new SendEmailCommand({
          Source: from,
          Destination: { ToAddresses: [params.to] },
          ReplyToAddresses: replyTo ? [replyTo] : undefined,
          Message: {
            Subject: { Data: params.subject },
            Body: { Text: { Data: params.bodyText } },
          },
        }),
      );
    } catch (error) {
      if (attempt === maxAttempts || !isRetryableSesError(error)) {
        throw error;
      }
      const backoffMs = Math.min(10_000, 250 * 2 ** (attempt - 1));
      await sleep(backoffMs);
    }
  }

  throw new Error("SES send failed after retries.");
};

export const sendDigestEmail = createServerOnlyFn(
  async (params: { userId: string; subject: string; bodyText: string }) => {
    const { getDb } = await import("~/db/server-helpers");
    const { user } = await import("~/db/schema");
    const { eq } = await import("drizzle-orm");
    const db = await getDb();

    const [recipient] = await db
      .select({ email: user.email })
      .from(user)
      .where(eq(user.id, params.userId))
      .limit(1);

    const to = recipient?.email ?? null;
    const isAnonymized = !!to && to.toLowerCase().endsWith("@example.invalid");

    if (!to || isAnonymized) {
      return { sent: false, skipped: true };
    }

    const response = await sendEmailWithRetry({
      to,
      subject: params.subject,
      bodyText: params.bodyText,
    });

    return { sent: true, messageId: response?.MessageId ?? null };
  },
);

export const sendNotification = createServerOnlyFn(
  async (payload: NotificationDispatch) => {
    const { randomUUID } = await import("crypto");
    const notificationId = payload.notificationId ?? randomUUID();

    const { getDb } = await import("~/db/server-helpers");
    const { notificationPreferences, notifications, user } = await import("~/db/schema");
    const { and, eq } = await import("drizzle-orm");

    const db = await getDb();

    const [preference] = await db
      .select()
      .from(notificationPreferences)
      .where(
        and(
          eq(notificationPreferences.userId, payload.userId),
          eq(notificationPreferences.category, payload.category),
        ),
      )
      .limit(1);

    const allowInApp = preference?.channelInApp ?? true;
    const emailFrequency = preference?.emailFrequency ?? "immediate";
    const emailEnabled = (preference?.channelEmail ?? true) && emailFrequency !== "never";
    const sendImmediateEmail = emailEnabled && emailFrequency === "immediate";

    let existingMetadata: JsonRecord | null = null;

    // In-app insert is idempotent when notificationId is stable
    if (allowInApp) {
      await db
        .insert(notifications)
        .values({
          id: notificationId,
          userId: payload.userId,
          organizationId: payload.organizationId ?? null,
          type: payload.type,
          category: payload.category,
          title: payload.title,
          body: payload.body,
          link: payload.link ?? null,
          metadata: payload.metadata ?? {},
        })
        .onConflictDoNothing();

      const [existing] = await db
        .select({ metadata: notifications.metadata })
        .from(notifications)
        .where(eq(notifications.id, notificationId))
        .limit(1);

      existingMetadata = (existing?.metadata as JsonRecord) ?? null;
    }

    // Email idempotency: if we recorded emailSentAt, do not re-send on retries
    const alreadyEmailSent =
      !!existingMetadata && typeof existingMetadata["emailSentAt"] === "string";

    let emailSent = false;
    let emailMessageId: string | null = null;

    if (sendImmediateEmail) {
      const [recipient] = await db
        .select({ email: user.email })
        .from(user)
        .where(eq(user.id, payload.userId))
        .limit(1);

      const to = recipient?.email ?? null;
      const isAnonymized = !!to && to.toLowerCase().endsWith("@example.invalid");

      if (to && !isAnonymized && !alreadyEmailSent) {
        try {
          const resp = await sendEmailWithRetry({
            to,
            subject: payload.title,
            bodyText: buildEmailText(payload),
          });

          emailSent = true;
          emailMessageId = resp?.MessageId ?? null;

          if (allowInApp) {
            const nextMetadata: JsonRecord = {
              ...(existingMetadata ?? {}),
              ...(payload.metadata ?? {}),
              emailSentAt: new Date().toISOString(),
              ...(emailMessageId ? { emailMessageId } : {}),
            };

            await db
              .update(notifications)
              .set({ metadata: nextMetadata })
              .where(eq(notifications.id, notificationId));
          }
        } catch (error) {
          console.error("[Notifications] Email send failed", {
            userId: payload.userId,
            notificationId,
            error: error instanceof Error ? error.message : "Unknown error",
          });
          // Don't rethrow - in-app notification was created, email failure is logged
        }
      } else if (alreadyEmailSent) {
        emailSent = true;
      }
    }

    const { logDataChange } = await import("~/lib/audit");
    await logDataChange({
      action: "NOTIFICATION_DISPATCH",
      actorUserId: payload.userId,
      actorOrgId: payload.organizationId ?? null,
      targetType: "notification",
      targetId: allowInApp ? notificationId : null,
      targetOrgId: payload.organizationId ?? null,
      metadata: {
        notificationId,
        category: payload.category,
        type: payload.type,
        channels: { inApp: allowInApp, email: emailEnabled },
        delivered: { email: emailSent },
        emailFrequency,
      },
    });

    return { inApp: allowInApp, email: emailSent };
  },
);
</file>

<file path="docs/sin-rfp/tickets/SIN-IMPLEMENTATION-BACKLOG-V2.md">
# viaSport SIN Implementation Backlog v2

> Comprehensive implementation plan for the Strength in Numbers (SIN) system.
> Incorporates architecture review feedback, compliance requirements, and practical delivery sequencing.

---

## Executive Summary

### Current State

- **Codebase maturity:** Solid TypeScript/React foundation with TanStack Start, Drizzle ORM, Better Auth
- **SIN readiness:** ~35-40% of requirements have partial implementation
- **Critical gaps:** Organization tenancy, audit logging, MFA, notifications, dynamic forms, bulk import, analytics

### Key Insight

> **SIN is governance + compliance + workflows, not UI.**
> Building features before tenancy + audit + security posture = rework everything later.

### Critical Path (Non-Negotiable Sequence)

```
Lock Architecture â Organization Tenancy â Audit Logging â Notifications â Security Hardening â Forms â Reporting â Analytics
```

### Timeline Estimate

| Phase                        | Duration        | Outcome                         |
| ---------------------------- | --------------- | ------------------------------- |
| Phase 0: Architecture & Docs | 1-2 weeks       | RFP-defensible documentation    |
| Phase 1: Foundation          | 4-6 weeks       | Tenancy + Audit + Notifications |
| Phase 2: Security            | 3-4 weeks       | MFA + Lockouts + Privacy        |
| Phase 3: Core SIN            | 6-8 weeks       | Forms + Import + Reporting      |
| Phase 4: Analytics           | 3-4 weeks       | Exports + Saved Reports         |
| **Total to SIN-Ready**       | **17-24 weeks** | Phases 0-4                      |

---

## Implementation Progress Tracker

> **Last Updated:** 2025-12-24
> **Overall Progress:** ~85% (Core logic + admin UI done; infra/migration gaps remain)

### Phase 0: Pre-Development Documentation

| Item                               | Status      | Score    | Evidence                                         |
| ---------------------------------- | ----------- | -------- | ------------------------------------------------ |
| P0-001: Reference Architecture     | â Complete | 100%     | `docs/sin-rfp/phase-0/architecture-reference.md` |
| P0-002: Data Residency Statement   | â Complete | 100%     | `docs/sin-rfp/phase-0/data-residency.md`         |
| P0-003: Security Controls Overview | â Complete | 100%     | `docs/sin-rfp/phase-0/security-controls.md`      |
| P0-004: Backup & DR Plan           | â Complete | 100%     | `docs/sin-rfp/phase-0/backup-dr-plan.md`         |
| P0-005: Audit & Retention Policy   | â Complete | 100%     | `docs/sin-rfp/phase-0/audit-retention-policy.md` |
| **Phase 0 Total**                  | â          | **100%** | All 5 documents complete                         |

### Phase 1: Foundation

| Item                           | Status      | Score   | Evidence                                                                                         |
| ------------------------------ | ----------- | ------- | ------------------------------------------------------------------------------------------------ |
| F-001: Organization & Tenancy  | â Complete | 95%     | Schema: `organizations.schema.ts` + guards + admin UI. **Note:** hierarchy visualization pending |
| F-002: Immutable Audit Logging | â Complete | 100%    | Schema + hash chain + immutability trigger + admin UI/export                                     |
| F-003: Notification Engine     | â Complete | 100%    | SQS/SES integration + scheduler + digest aggregation + admin templates                           |
| **Phase 1 Total**              | â          | **98%** | Core logic + admin UI complete                                                                   |

### Phase 2: Security Hardening

| Item                                       | Status      | Score   | Evidence                                                                                                                        |
| ------------------------------------------ | ----------- | ------- | ------------------------------------------------------------------------------------------------------------------------------- |
| S-001: Multi-Factor Authentication         | ð¡ Partial  | 85%     | Enrollment + QR + backup codes + login challenge + step-up. **Missing:** per-role MFA UI (auto-enforced for global admin roles) |
| S-002: Security Event Monitoring & Lockout | â Complete | 95%     | Events + detection + lockout + dashboard + admin alerts                                                                         |
| S-003: Privacy Compliance (PIPEDA)         | â Complete | 95%     | Policy acceptance + DSAR workflow + export + erasure + retention UI/cron                                                        |
| **Phase 2 Total**                          | ð¡          | **92%** | Security UI complete, minor admin config gap                                                                                    |

### Phase 3: Core SIN Features

| Item                                | Status      | Score   | Evidence                                                                 |
| ----------------------------------- | ----------- | ------- | ------------------------------------------------------------------------ |
| D-001: Dynamic Form Builder         | â Complete | 95%     | Builder + preview + publish + renderer + submissions history             |
| D-002: Bulk Import & Data Migration | ð¡ Partial  | 80%     | Lane 1 UI + Lane 2 batch runner; **Missing:** ECS task definition wiring |
| R-001: Reporting Cycles & Workflows | â Complete | 95%     | Cycles + tasks + reminders + dashboards + review workflow                |
| **Phase 3 Total**                   | ð¡          | **90%** | ECS batch worker infra remaining                                         |

### Phase 4: Analytics & Export

| Item                      | Status      | Score   | Evidence                                                 |
| ------------------------- | ----------- | ------- | -------------------------------------------------------- |
| R-002: Reporting & Export | â Complete | 95%     | Report builder UI + saved reports + sharing + export ACL |
| **Phase 4 Total**         | â          | **95%** | Builder + exports complete                               |

### Summary by Category

| Category                 | Progress | Notes                                              |
| ------------------------ | -------- | -------------------------------------------------- |
| **Documentation**        | 100%     | All Phase 0 docs complete                          |
| **Database Schema**      | 100%     | All SIN tables defined + migrations applied        |
| **Server Functions**     | 95%      | Queries + mutations with auth guards + audit hooks |
| **Auth & Security**      | 90%      | MFA, lockout, step-up, admin enforcement complete  |
| **Notification Backend** | 95%      | SQS + SES + scheduler + digests                    |
| **Admin UI Components**  | 85%      | Core admin panels implemented                      |
| **E2E Tests**            | 30%      | Initial SIN auth/export/upload tests in place      |

### Recent Changes (2025-12-24)

Applied security patches (Issues 01-11):

- â Audit log access control with org scoping
- â Security events access control
- â Reporting permission checks
- â Field-level ACL for report exports
- â Audit log immutability in retention
- â S3 cleanup for DSAR erasure
- â Step-up auth re-auth window
- â Server-side file validation
- â SQS/SES notification integration
- â XLSX export generation
- â MFA enrollment QR + backup code regeneration
- â Notification digest aggregation + audit verification UI
- â Lane 2 batch runner helper + worker entrypoint

See `docs/sin-rfp/SIN-IMPLEMENTATION-TECHNICAL-DEBT.md` for detailed patch notes.

---

## Part 1: Architecture Decisions to Lock First

> These decisions ripple everywhere. Do not write code until these are documented and approved.

### ADR-001: Data Residency

**Decision:** All production data stored and processed in Canada (AWS `ca-central-1`).

**Rationale:** PIPEDA compliance, viaSport requirement, RFP defensibility.

**Implications:**

- Migrate from Neon to AWS RDS PostgreSQL in `ca-central-1`
- Use AWS SES (not SendGrid) for transactional email
- Use S3 `ca-central-1` for document storage
- No Netlify for production (edge compute has no residency guarantees)
- All sub-processors must have Canadian data processing or explicit DPAs

---

### ADR-002: Tenancy Model

**Decision:** Organization-based tenancy (not team-based).

**Rationale:** SIN requires hierarchical org structure: viaSport â PSO â Club/Affiliate.

**Data Model:**

```
organizations (id, name, type, parent_org_id, ...)
    â
organization_members (user_id, org_id, role, status, ...)
    â
All tenant-owned entities have organization_id FK
```

**Implications:**

- Remove/deprecate `teamId`/`eventId` scoping from RBAC for SIN
- Add `organization_id` to: forms, submissions, reporting_tasks, imports, notifications
- Every query must be org-scoped by default
- Consider Postgres RLS for defense-in-depth (Phase 2 hardening)

---

### ADR-003: Audit Logging Policy

**Decision:** Immutable append-only audit log with PII-aware handling.

**What Gets Logged:**
| Action Type | Detail Level | Before/After |
|-------------|--------------|--------------|
| `AUTH.*` (login, logout, MFA) | Metadata only (no secrets) | No |
| `ADMIN.*` (role changes, config) | Full detail | Yes (full) |
| `DATA.CREATE/UPDATE/DELETE` | Field-level diffs | Yes (diff only) |
| `EXPORT.*` | Query params, row count | No |
| `SECURITY.*` (lockouts, anomalies) | Full context | No |

**PII Handling in Audit Logs:**

- Store **diffs**, not full before/after snapshots for personal data
- Store **hashes** for sensitive fields (DOB, phone, emergency contact)
- Redact secrets (passwords, tokens) completely
- Define retention: audit logs retained 7 years (or as specified by viaSport)

**Rationale:** Full before/after creates a second copy of PII, complicates DSAR/erasure.

---

### ADR-004: Email PII Policy

**Decision:** Minimal PII in transactional emails.

**Allowed in Email:**

- First name (for personalization)
- Organization name
- Action summaries ("Your Q1 report is due in 7 days")
- Links to system (with auth required to view details)

**NOT Allowed in Email:**

- Full addresses
- Phone numbers
- Date of birth
- Emergency contact details
- Submission content/data

**Rationale:** Email is a US-processor risk (even with SES). Minimize data exposure.

---

### ADR-005: Session Security

**Decision:** Tightened session policy for government data system.

| Setting               | Value                       | Rationale                             |
| --------------------- | --------------------------- | ------------------------------------- |
| Session max age       | 8 hours                     | Reduced from 30 days                  |
| Idle timeout          | 30 minutes                  | Auto-logout on inactivity             |
| Admin session max     | 4 hours                     | Higher privilege = shorter session    |
| Step-up auth required | Role changes, exports, DSAR | Re-authenticate for sensitive actions |
| Admin MFA             | Required                    | Non-negotiable for SIN                |

---

### ADR-006: Infrastructure Stack

**Decision:** AWS via SST for production, Netlify for development preview only.

| Component      | Technology                             | Region                    |
| -------------- | -------------------------------------- | ------------------------- |
| Compute        | Lambda (requests), ECS Fargate (batch) | ca-central-1              |
| Database       | RDS PostgreSQL (Multi-AZ, PITR)        | ca-central-1              |
| Object Storage | S3 (SSE-KMS, versioning)               | ca-central-1              |
| Email          | AWS SES                                | ca-central-1              |
| Queues         | SQS                                    | ca-central-1              |
| Scheduling     | EventBridge Scheduler                  | ca-central-1              |
| Secrets        | Secrets Manager                        | ca-central-1              |
| Monitoring     | CloudWatch, CloudTrail, GuardDuty      | ca-central-1              |
| CDN            | CloudFront (cache static only)         | Global edge, origin in CA |

**Residency Constraints:**

- CloudFront caches static assets only; authenticated/PII responses must use `Cache-Control: no-store`.
- CSP nonce injection must move to app-layer middleware for AWS (see `sst-migration-plan.md`).

**Known Issue:** SST Lambda Function URL permissions require `$transform` workaround. See `sst-migration-plan.md`.

---

## Part 2: Compliance & Security Posture

### Sub-Processor Inventory

| Service            | Vendor                    | Data Processed                       | Region                    | DPA Status       |
| ------------------ | ------------------------- | ------------------------------------ | ------------------------- | ---------------- |
| Database           | AWS RDS                   | All PII, submissions, audit logs     | ca-central-1              | AWS DPA â        |
| Email              | AWS SES                   | Names, org names, action summaries   | ca-central-1              | AWS DPA â        |
| Object Storage     | AWS S3                    | Documents, attachments, import files | ca-central-1              | AWS DPA â        |
| Auth               | Self-hosted (Better Auth) | Credentials, sessions                | ca-central-1              | N/A              |
| Monitoring         | AWS CloudWatch            | Logs (PII redacted)                  | ca-central-1              | AWS DPA â        |
| OAuth (if enabled) | Google                    | Email + profile claims               | Verify (likely US/global) | Google terms/DPA |
| Payments           | Square (if needed)        | Payment tokens only                  | Verify                    | Requires DPA     |

**No external sub-processors for PII beyond those listed.** If added later (analytics, support tools), update this table and obtain DPAs.

---

### Security Controls Mapped to SIN Requirements

| Requirement                          | Control                                      | Status   |
| ------------------------------------ | -------------------------------------------- | -------- |
| SEC-AGG-001: MFA                     | Better Auth 2FA plugin (TOTP + backup codes) | To Build |
| SEC-AGG-001: Role/affiliation access | Organization-scoped RBAC                     | To Build |
| SEC-AGG-001: Leader admission        | Org membership approval workflow             | To Build |
| SEC-AGG-002: Anomaly detection       | Security events + risk scoring               | To Build |
| SEC-AGG-002: Account lockout         | Threshold-based auto-lock                    | To Build |
| SEC-AGG-003: PIPEDA compliance       | Consent tracking, retention, DSAR            | To Build |
| SEC-AGG-004: Immutable audit         | Append-only table + hash chain               | To Build |
| SEC-AGG-004: Export                  | Audit log filtering + CSV export             | To Build |

---

### Backup & Disaster Recovery

| Metric                         | Target    | Mechanism                           |
| ------------------------------ | --------- | ----------------------------------- |
| RPO (Recovery Point Objective) | 1 hour    | RDS automated backups + PITR        |
| RTO (Recovery Time Objective)  | 4 hours   | Multi-AZ failover + restore runbook |
| Backup retention               | 35 days   | RDS automated + manual snapshots    |
| Audit log retention            | 7 years   | S3 Glacier archive with Object Lock |
| DR testing                     | Quarterly | Documented restore procedure        |

---

## Part 3: Implementation Phases

### Phase 0: Pre-Development Documentation (1-2 weeks)

> Write these documents before writing code. They make your RFP submission defensible.

#### P0-001: Reference Architecture Document

**Deliverable:** `docs/sin-rfp/phase-0/architecture-reference.md`

Contents:

- [x] Architecture diagram (CloudFront â Lambda â RDS â S3)
- [x] Data flow diagram (user â system â storage)
- [x] Network diagram (VPC, subnets, security groups)
- [x] Component descriptions

---

#### P0-002: Data Residency Statement

**Deliverable:** `docs/sin-rfp/phase-0/data-residency.md`

Contents:

- [x] Explicit statement: "All production data stored in AWS ca-central-1"
- [x] Sub-processor list with regions
- [x] Data classification (PII, sensitive PII, operational)
- [x] Cross-border data transfer policy (none for PII)

---

#### P0-003: Security Controls Overview

**Deliverable:** `docs/sin-rfp/phase-0/security-controls.md`

Contents:

- [x] Authentication controls (MFA, session management)
- [x] Authorization controls (RBAC, org scoping)
- [x] Encryption (at rest: KMS, in transit: TLS 1.3)
- [x] Logging and monitoring
- [x] Incident response (outline)

---

#### P0-004: Backup & DR Plan

**Deliverable:** `docs/sin-rfp/phase-0/backup-dr-plan.md`

Contents:

- [x] RPO/RTO targets
- [x] Backup mechanisms and schedules
- [x] Restore procedures (step-by-step)
- [x] DR testing schedule and evidence

---

#### P0-005: Audit & Retention Policy

**Deliverable:** `docs/sin-rfp/phase-0/audit-retention-policy.md`

Contents:

- [x] What is logged (per action type)
- [x] Retention periods by data type
- [x] Archive and purge procedures
- [x] Legal hold capability

---

### Phase 1: Foundation (4-6 weeks)

> These are blocking dependencies. Everything else builds on this.

#### F-001: Organization & Tenancy Model

**Priority:** P0 (Blocker)
**Effort:** 2-3 weeks
**Blocks:** All org-scoped features

**Database Schema:**

```sql
-- Organizations (viaSport, PSOs, Clubs, Affiliates)
CREATE TABLE organizations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL,
  type TEXT NOT NULL CHECK (type IN ('governing_body', 'pso', 'club', 'affiliate')),
  parent_org_id UUID REFERENCES organizations(id),
  status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('pending', 'active', 'suspended', 'archived')),
  settings JSONB NOT NULL DEFAULT '{}',
  metadata JSONB NOT NULL DEFAULT '{}',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Organization membership with role
CREATE TABLE organization_members (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  role TEXT NOT NULL CHECK (role IN ('owner', 'admin', 'reporter', 'viewer', 'member')),
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'active', 'suspended', 'removed')),
  invited_by TEXT REFERENCES "user"(id),
  invited_at TIMESTAMPTZ,
  approved_by TEXT REFERENCES "user"(id),
  approved_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(user_id, organization_id)
);

-- Delegated access for reporting (separate from membership)
CREATE TABLE delegated_access (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  delegate_user_id TEXT NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  scope TEXT NOT NULL CHECK (scope IN ('reporting', 'analytics', 'admin')),
  granted_by TEXT NOT NULL REFERENCES "user"(id),
  granted_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  expires_at TIMESTAMPTZ,
  revoked_at TIMESTAMPTZ,
  revoked_by TEXT REFERENCES "user"(id),
  notes TEXT
);

-- Indices
CREATE INDEX idx_org_members_user ON organization_members(user_id) WHERE status = 'active';
CREATE INDEX idx_org_members_org ON organization_members(organization_id) WHERE status = 'active';
CREATE INDEX idx_org_parent ON organizations(parent_org_id);
CREATE INDEX idx_delegated_access_user ON delegated_access(delegate_user_id) WHERE revoked_at IS NULL;
CREATE UNIQUE INDEX delegated_access_active_unique
  ON delegated_access(delegate_user_id, organization_id, scope)
  WHERE revoked_at IS NULL;
```

**Implementation:**

- [x] Create `src/db/schema/organizations.schema.ts`
- [x] Create `src/features/organizations/` feature module
- [x] Implement org context middleware (resolve user's org + role per request)
- [x] Create `src/lib/auth/guards/org-guard.ts`
- [x] Add org admin UI: create org, invite members, approve/deny
- [x] Retrofit `organization_id` to existing entities (as needed for SIN)

**Acceptance Criteria:**

- [x] Organizations can be created with parent/child relationships
- [x] Users can be invited to organizations with specific roles
- [x] Organization admins can approve/deny membership requests
- [x] Delegated access can be granted and revoked with audit trail
- [x] All data queries are org-scoped by default (SIN modules scoped)
- [x] Users cannot access data outside their organization(s) (org guard enforced)

---

#### F-002: Immutable Audit Logging

**Priority:** P0 (Blocker)
**Effort:** 2 weeks
**Blocks:** Compliance, DSAR, security monitoring

**Database Schema:**

```sql
-- Append-only audit log with hash chain
CREATE TABLE audit_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  occurred_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Actor information
  actor_user_id TEXT REFERENCES "user"(id),
  actor_org_id UUID REFERENCES organizations(id),
  actor_ip INET,
  actor_user_agent TEXT,

  -- Action classification
  action TEXT NOT NULL, -- 'AUTH.LOGIN', 'DATA.CREATE', 'ADMIN.ROLE_ASSIGN', etc.
  action_category TEXT NOT NULL, -- 'AUTH', 'ADMIN', 'DATA', 'EXPORT', 'SECURITY'

  -- Target information
  target_type TEXT, -- 'user', 'organization', 'submission', etc.
  target_id TEXT,
  target_org_id UUID REFERENCES organizations(id),

  -- Change tracking (with PII awareness)
  changes JSONB, -- Field-level diffs, NOT full snapshots
  metadata JSONB NOT NULL DEFAULT '{}',

  -- Correlation and integrity
  request_id TEXT NOT NULL, -- Generate for background jobs (job_id/trace_id)
  prev_hash TEXT, -- Hash of previous entry (tamper evidence)
  entry_hash TEXT NOT NULL, -- Hash of this entry

  -- Indexing support
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Enforce append-only via trigger
CREATE OR REPLACE FUNCTION prevent_audit_modification()
RETURNS TRIGGER AS $$
BEGIN
  RAISE EXCEPTION 'Audit logs are immutable - modifications not allowed';
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER audit_logs_immutable
BEFORE UPDATE OR DELETE ON audit_logs
FOR EACH ROW EXECUTE FUNCTION prevent_audit_modification();

-- Indices for common query patterns
CREATE INDEX idx_audit_logs_actor ON audit_logs(actor_user_id, occurred_at DESC);
CREATE INDEX idx_audit_logs_target ON audit_logs(target_type, target_id, occurred_at DESC);
CREATE INDEX idx_audit_logs_action ON audit_logs(action_category, occurred_at DESC);
CREATE INDEX idx_audit_logs_org ON audit_logs(target_org_id, occurred_at DESC);
CREATE INDEX idx_audit_logs_request ON audit_logs(request_id);
```

**Audit Library Design:**

```typescript
// src/lib/audit/index.ts
interface AuditEntry {
  action: string;
  targetType?: string;
  targetId?: string;
  targetOrgId?: string;
  changes?: Record<string, { old?: unknown; new?: unknown }>;
  metadata?: Record<string, unknown>;
}

// Central logging functions
audit.logAuthEvent(type: 'LOGIN' | 'LOGOUT' | 'MFA_ENROLL' | ..., context)
audit.logAdminAction(type: 'ROLE_ASSIGN' | 'ORG_CREATE' | ..., target, changes)
audit.logDataChange(type: 'CREATE' | 'UPDATE' | 'DELETE', entity, changes)
audit.logExport(type: 'CSV' | 'EXCEL' | ..., query, rowCount)
audit.logSecurityEvent(type: 'LOCKOUT' | 'ANOMALY' | ..., context)
```

**PII Redaction Rules:**

```typescript
// Fields to hash (not store plaintext)
const HASH_FIELDS = ["dateOfBirth", "phone", "emergencyContact.phone"];

// Fields to redact completely
const REDACT_FIELDS = ["password", "secret", "token", "mfaSecret"];

// For DATA changes, store diffs only
function createAuditDiff(before: object, after: object): object {
  // Returns { fieldName: { old: redacted/hashed, new: redacted/hashed } }
}
```

**Implementation:**

- [x] Create `src/db/schema/audit.schema.ts`
- [x] Create `src/lib/audit/` module
- [x] Implement hash chain verification utility
- [x] Add request ID middleware (correlation)
- [x] Wire into auth flows (login, logout, MFA)
- [x] Wire into admin actions (role changes, org management)
- [x] Create admin UI for log viewing, filtering, export

**Acceptance Criteria:**

- [x] All auth events are logged (login, logout, failed attempts, MFA)
- [x] All admin actions are logged with actor and target
- [x] Data changes log field-level diffs (not full snapshots)
- [x] PII fields are hashed/redacted per policy
- [x] Logs cannot be modified or deleted (DB trigger enforced)
- [x] Hash chain can be verified for integrity
- [x] Admin can filter by user, org, action, date range
- [x] Logs can be exported to CSV

---

#### F-003: Notification Engine

**Priority:** P0 (Blocker)
**Effort:** 2 weeks
**Blocks:** Reporting reminders, security alerts, support tickets

**Architecture:**

```
User Action â Notification Request â SQS Queue â Worker â Email (SES) + In-App DB
                                                      â
                                              User Preferences Check
```

**Database Schema:**

```sql
-- In-app notifications
CREATE TABLE notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
  organization_id UUID REFERENCES organizations(id),

  type TEXT NOT NULL, -- 'reporting_reminder', 'security_alert', 'ticket_update', etc.
  category TEXT NOT NULL, -- 'reporting', 'security', 'support', 'system'

  title TEXT NOT NULL,
  body TEXT NOT NULL,
  link TEXT, -- Deep link to relevant page

  read_at TIMESTAMPTZ,
  dismissed_at TIMESTAMPTZ,

  metadata JSONB NOT NULL DEFAULT '{}',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- User notification preferences
CREATE TABLE notification_preferences (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
  category TEXT NOT NULL, -- 'reporting', 'security', 'support', 'system'

  channel_email BOOLEAN NOT NULL DEFAULT true,
  channel_in_app BOOLEAN NOT NULL DEFAULT true,

  -- Email frequency (for non-urgent)
  email_frequency TEXT NOT NULL DEFAULT 'immediate'
    CHECK (email_frequency IN ('immediate', 'daily_digest', 'weekly_digest', 'never')),

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(user_id, category)
);

-- Admin-managed notification templates
CREATE TABLE notification_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  key TEXT UNIQUE NOT NULL, -- 'reporting_reminder_7day', 'security_lockout', etc.

  category TEXT NOT NULL,
  subject TEXT NOT NULL,
  body_template TEXT NOT NULL, -- Supports {{variable}} substitution

  is_system BOOLEAN NOT NULL DEFAULT false, -- System templates can't be deleted

  created_by TEXT REFERENCES "user"(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Scheduled notifications (for reminders)
CREATE TABLE scheduled_notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  template_key TEXT NOT NULL REFERENCES notification_templates(key),

  -- Target (user, org, or broadcast)
  user_id TEXT REFERENCES "user"(id),
  organization_id UUID REFERENCES organizations(id),
  role_filter TEXT, -- Optional: only users with this role

  scheduled_for TIMESTAMPTZ NOT NULL,

  -- Execution tracking
  sent_at TIMESTAMPTZ,
  failed_at TIMESTAMPTZ,
  error_message TEXT,
  retry_count INTEGER NOT NULL DEFAULT 0,

  variables JSONB NOT NULL DEFAULT '{}',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indices
CREATE INDEX idx_notifications_user ON notifications(user_id, read_at NULLS FIRST, created_at DESC);
CREATE INDEX idx_notifications_org ON notifications(organization_id, created_at DESC);
CREATE INDEX idx_scheduled_pending ON scheduled_notifications(scheduled_for)
  WHERE sent_at IS NULL AND failed_at IS NULL;
```

**Implementation:**

- [x] Create `src/db/schema/notifications.schema.ts`
- [x] Create `src/features/notifications/` module
- [x] Create `src/lib/notifications/queue.ts` (SQS integration)
- [x] Create `src/lib/notifications/send.ts` (dispatch logic)
- [x] Create `src/lib/notifications/scheduler.ts` (EventBridge integration)
- [x] Add notification bell component to header
- [x] Add notification preferences UI
- [x] Add admin template management UI

**Acceptance Criteria:**

- [x] Users see notification bell with unread count
- [x] Notification panel shows recent items, mark as read
- [x] Users can configure preferences per category
- [x] Email notifications respect user preferences
- [x] Scheduled notifications fire at configured times
- [x] Failed notifications retry with backoff
- [x] All notifications are audit logged

---

### Phase 2: Security Hardening (3-4 weeks)

#### S-001: Multi-Factor Authentication

**Priority:** P1
**Effort:** 1.5 weeks
**Requirement:** SEC-AGG-001

**Approach:** Use [Better Auth 2FA Plugin](https://www.better-auth.com/docs/plugins/2fa)

**Features to Implement:**

- [x] TOTP enrollment with QR code
- [x] Backup codes (10 single-use codes)
- [x] MFA challenge on login
- [x] MFA required for admin roles (enforced)
- [x] Step-up auth for sensitive actions
- [x] MFA recovery workflow

**Note:** Better Auth 2FA currently supports credential accounts only. For admin roles,
require a password-linked account or restrict admin roles to credential users.

**Database Additions:**

```sql
-- Better Auth 2FA plugin manages its own tables, but we track:
ALTER TABLE "user" ADD COLUMN mfa_required BOOLEAN NOT NULL DEFAULT false;
ALTER TABLE "user" ADD COLUMN mfa_enrolled_at TIMESTAMPTZ;

-- Track MFA events in audit log (no additional table needed)
```

**Implementation:**

- [x] Install and configure Better Auth 2FA plugin
- [x] Create `src/features/auth/mfa/` components
- [x] MFA enrollment wizard (TOTP QR + backup codes)
- [x] MFA challenge screen
- [x] Step-up auth middleware for sensitive routes
- [x] Admin UI to require MFA for roles (warning + badges added in role dashboard)

**Acceptance Criteria:**

- [x] Users can enroll in TOTP MFA
- [x] Backup codes are generated and displayed once
- [x] Login requires MFA code when enrolled
- [x] Admin roles must have MFA (enforced on role assignment)
- [x] Sensitive actions (exports, role changes) require re-auth
- [x] All MFA events are audit logged

---

#### S-002: Security Event Monitoring & Lockout

**Priority:** P1
**Effort:** 1.5 weeks
**Requirement:** SEC-AGG-002

**Database Schema:**

```sql
-- Security events (separate from audit for performance)
CREATE TABLE security_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT REFERENCES "user"(id),

  event_type TEXT NOT NULL, -- 'login_success', 'login_fail', 'mfa_fail', 'password_reset', etc.

  ip_address INET NOT NULL,
  user_agent TEXT,
  geo_country TEXT,
  geo_region TEXT,

  risk_score INTEGER NOT NULL DEFAULT 0, -- 0-100
  risk_factors JSONB NOT NULL DEFAULT '[]', -- ['new_device', 'new_location', 'unusual_time']

  metadata JSONB NOT NULL DEFAULT '{}',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Account locks
CREATE TABLE account_locks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT NOT NULL REFERENCES "user"(id),

  reason TEXT NOT NULL, -- 'failed_logins', 'suspicious_activity', 'admin_action'

  locked_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  unlock_at TIMESTAMPTZ, -- NULL = permanent until manual unlock

  unlocked_by TEXT REFERENCES "user"(id),
  unlocked_at TIMESTAMPTZ,
  unlock_reason TEXT,

  metadata JSONB NOT NULL DEFAULT '{}'
);

-- Indices
CREATE INDEX idx_security_events_user ON security_events(user_id, created_at DESC);
CREATE INDEX idx_security_events_ip ON security_events(ip_address, created_at DESC);
CREATE INDEX idx_account_locks_user ON account_locks(user_id) WHERE unlocked_at IS NULL;
```

**Detection Rules (Configurable):**
| Trigger | Action |
|---------|--------|
| 5 failed logins in 15 minutes | Lock for 30 minutes |
| 10 failed logins in 1 hour | Lock until admin unlock |
| Login from new country | Flag for review, notify user |
| 3 failed MFA in 5 minutes | Lock for 15 minutes |
| Password reset from new device | Require additional verification |

**Implementation:**

- [x] Create `src/db/schema/security.schema.ts`
- [x] Create `src/lib/security/events.ts` (capture and store)
- [x] Create `src/lib/security/detection.ts` (rules engine)
- [x] Create `src/lib/security/lockout.ts` (lock/unlock logic)
- [x] Integrate with auth flows
- [x] Create admin security dashboard
- [x] Add alert notifications to admins

**Acceptance Criteria:**

- [x] All auth events captured with IP/UA/geo
- [x] Failed login threshold triggers auto-lock
- [x] Locked accounts cannot authenticate
- [x] Admins receive notifications for lockouts
- [x] Admins can manually lock/unlock with reason
- [x] Security dashboard shows recent events and anomalies
- [x] All security events are audit logged

---

#### S-003: Privacy Compliance (PIPEDA)

**Priority:** P1
**Effort:** 1.5 weeks
**Requirement:** SEC-AGG-003

**Database Schema:**

```sql
-- Privacy policy versions
CREATE TABLE policy_documents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  type TEXT NOT NULL CHECK (type IN ('privacy_policy', 'terms_of_service', 'data_agreement')),
  version TEXT NOT NULL,

  content_url TEXT, -- S3 URL to PDF
  content_hash TEXT NOT NULL, -- SHA-256 of content

  effective_date DATE NOT NULL,
  published_at TIMESTAMPTZ,
  published_by TEXT REFERENCES "user"(id),

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(type, version)
);

-- User policy acceptances (immutable record)
CREATE TABLE user_policy_acceptances (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT NOT NULL REFERENCES "user"(id),
  policy_id UUID NOT NULL REFERENCES policy_documents(id),

  accepted_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ip_address INET,
  user_agent TEXT,

  UNIQUE(user_id, policy_id)
);

-- Data Subject Access Requests (DSAR)
CREATE TABLE privacy_requests (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT NOT NULL REFERENCES "user"(id),

  type TEXT NOT NULL CHECK (type IN ('access', 'export', 'erasure', 'correction')),
  status TEXT NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'processing', 'completed', 'rejected')),

  requested_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Processing
  processed_by TEXT REFERENCES "user"(id),
  processed_at TIMESTAMPTZ,

  -- Result
  result_url TEXT, -- S3 URL for exports
  result_notes TEXT,
  rejection_reason TEXT,

  -- Audit
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Data retention policies
CREATE TABLE retention_policies (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  data_type TEXT NOT NULL, -- 'submissions', 'audit_logs', 'sessions', etc.

  retention_days INTEGER NOT NULL,
  archive_after_days INTEGER,
  purge_after_days INTEGER,

  legal_hold BOOLEAN NOT NULL DEFAULT false,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  UNIQUE(data_type)
);
```

**Implementation:**

- [x] Create `src/db/schema/privacy.schema.ts`
- [x] Create `src/features/privacy/` module
- [x] Policy acceptance flow (block access until accepted)
- [x] DSAR request submission UI
- [x] Admin DSAR processing workflow
- [x] Data export generation (user's PII)
- [x] Data erasure/anonymization logic
- [x] Retention policy configuration UI
- [x] Scheduled retention enforcement job

**Acceptance Criteria:**

- [x] Users must accept current policy to proceed
- [x] Policy acceptance recorded with timestamp/IP
- [x] Users can submit DSAR (export, erasure)
- [x] Admins can process DSAR with audit trail
- [x] Data exports include all user PII
- [x] Erasure anonymizes data while preserving audit logs
- [x] Retention policies can be configured per data type

---

### Phase 3: Core SIN Features (6-8 weeks)

#### D-001: Dynamic Form Builder

**Priority:** P1
**Effort:** 3-4 weeks
**Requirements:** DM-AGG-001, RP-AGG-004

**Database Schema:**

```sql
-- Form definitions
CREATE TABLE forms (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID REFERENCES organizations(id), -- NULL = system-wide

  name TEXT NOT NULL,
  slug TEXT NOT NULL,
  description TEXT,

  status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'published', 'archived')),

  created_by TEXT NOT NULL REFERENCES "user"(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  UNIQUE(organization_id, slug)
);

-- Form versions (immutable once published)
CREATE TABLE form_versions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  form_id UUID NOT NULL REFERENCES forms(id) ON DELETE CASCADE,

  version_number INTEGER NOT NULL,

  -- Form definition (see FormDefinition type below)
  definition JSONB NOT NULL,

  published_at TIMESTAMPTZ,
  published_by TEXT REFERENCES "user"(id),

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  UNIQUE(form_id, version_number)
);

-- Form submissions
CREATE TABLE form_submissions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  form_id UUID NOT NULL REFERENCES forms(id),
  form_version_id UUID NOT NULL REFERENCES form_versions(id),
  organization_id UUID NOT NULL REFERENCES organizations(id),

  submitter_id TEXT REFERENCES "user"(id),

  status TEXT NOT NULL DEFAULT 'draft'
    CHECK (status IN ('draft', 'submitted', 'under_review', 'changes_requested', 'approved', 'rejected')),

  payload JSONB NOT NULL,

  -- Validation tracking
  completeness_score INTEGER, -- 0-100
  missing_fields JSONB DEFAULT '[]',
  validation_errors JSONB DEFAULT '[]',

  -- Workflow tracking
  submitted_at TIMESTAMPTZ,
  reviewed_by TEXT REFERENCES "user"(id),
  reviewed_at TIMESTAMPTZ,
  review_notes TEXT,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Submission version history
CREATE TABLE form_submission_versions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  submission_id UUID NOT NULL REFERENCES form_submissions(id) ON DELETE CASCADE,

  version_number INTEGER NOT NULL,
  payload_snapshot JSONB NOT NULL,

  changed_by TEXT REFERENCES "user"(id),
  change_reason TEXT,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  UNIQUE(submission_id, version_number)
);

-- File attachments
CREATE TABLE submission_files (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  submission_id UUID NOT NULL REFERENCES form_submissions(id) ON DELETE CASCADE,

  field_key TEXT NOT NULL,
  file_name TEXT NOT NULL,
  mime_type TEXT NOT NULL,
  size_bytes INTEGER NOT NULL,
  checksum TEXT NOT NULL, -- SHA-256

  storage_key TEXT NOT NULL, -- S3 key

  uploaded_by TEXT REFERENCES "user"(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Form Definition TypeScript Schema:**

```typescript
interface FormDefinition {
  fields: FormField[];
  layout?: {
    sections: { title: string; fieldKeys: string[] }[];
  };
  settings: {
    allowDraft: boolean;
    requireApproval: boolean;
    notifyOnSubmit: string[]; // role names or user IDs
  };
}

interface FormField {
  key: string;
  type:
    | "text"
    | "number"
    | "email"
    | "phone"
    | "date"
    | "select"
    | "multiselect"
    | "checkbox"
    | "file"
    | "textarea"
    | "rich_text";
  label: string;
  description?: string;
  placeholder?: string;
  required: boolean;
  validation?: ValidationRule[];
  options?: { value: string; label: string }[]; // for select/multiselect
  conditional?: {
    field: string;
    operator: "equals" | "not_equals" | "contains" | "greater_than";
    value: unknown;
  };
  fileConfig?: {
    allowedTypes: string[]; // MIME types
    maxSizeBytes: number;
    maxFiles: number;
  };
}

interface ValidationRule {
  type: "min_length" | "max_length" | "pattern" | "min" | "max" | "custom";
  value: string | number;
  message: string;
}
```

**Implementation:**

- [x] Create `src/db/schema/forms.schema.ts`
- [x] Create `src/features/forms/` module
- [x] Form builder UI (drag-and-drop field palette)
- [x] Field configuration panel
- [x] Form preview mode
- [x] Form publishing workflow (creates immutable version)
- [x] Form renderer (generates form from definition)
- [x] Server-side validation from definition
- [x] Sanitize `rich_text` content server-side (allowlist + XSS-safe rendering)
- [x] Submission workflow (draft â submit â review)
- [x] File upload with S3 pre-signed URLs
- [x] Submission history viewer

**Acceptance Criteria:**

- [x] Admins can create forms with all field types
- [x] Validation rules are enforced server-side
- [x] Published forms are immutable (edits create new version)
- [x] Submissions track which form version was used
- [x] Files can be attached and downloaded
- [x] Submission history shows all changes
- [x] Forms support conditional field visibility

---

#### D-002: Bulk Import & Data Migration

**Priority:** P1
**Effort:** 2-3 weeks
**Requirement:** DM-AGG-006

**Two-Lane Architecture:**

**Lane 1: Interactive Import (<10K rows)**

- UI wizard for admin uploads
- In-memory validation with preview
- Row-level error display
- Direct database insert with rollback support (tag rows with `import_job_id` or use staging)

**Lane 2: Batch Import (>10K rows, up to 20M+)**

- S3 upload for source file
- Worker-based processing (ECS Fargate)
- Chunked validation in SQL
- Resumable checkpoints
- Error report to S3 (not row-per-row in DB)

**Database Schema:**

```sql
-- Import jobs (both lanes)
CREATE TABLE import_jobs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id),

  -- Source
  type TEXT NOT NULL CHECK (type IN ('csv', 'excel')),
  lane TEXT NOT NULL CHECK (lane IN ('interactive', 'batch')),
  source_file_key TEXT NOT NULL, -- S3 key
  source_file_hash TEXT NOT NULL,
  source_row_count INTEGER,

  -- Target
  target_form_id UUID REFERENCES forms(id),
  mapping_template_id UUID REFERENCES import_mapping_templates(id),

  -- Status
  status TEXT NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'validating', 'validated', 'importing',
                      'completed', 'failed', 'cancelled', 'rolled_back')),

  -- Progress (for batch)
  progress_checkpoint INTEGER DEFAULT 0,

  -- Stats
  stats JSONB NOT NULL DEFAULT '{}',
  -- { rows_total, rows_processed, rows_succeeded, rows_failed, validation_errors }

  -- Error handling
  error_report_key TEXT, -- S3 key to detailed error CSV
  error_summary JSONB DEFAULT '{}',

  -- Rollback support (for batch)
  can_rollback BOOLEAN NOT NULL DEFAULT true,
  rollback_before TIMESTAMPTZ, -- Deadline for rollback

  -- Audit
  created_by TEXT NOT NULL REFERENCES "user"(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  started_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ
);

-- Mapping templates (reusable)
CREATE TABLE import_mapping_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID REFERENCES organizations(id),

  name TEXT NOT NULL,
  description TEXT,

  target_form_id UUID REFERENCES forms(id),

  -- Mapping rules
  mappings JSONB NOT NULL,
  -- { sourceColumn: { targetField, transform?, defaultValue? } }

  created_by TEXT NOT NULL REFERENCES "user"(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Row-level errors (Lane 1 only, capped)
CREATE TABLE import_job_errors (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  job_id UUID NOT NULL REFERENCES import_jobs(id) ON DELETE CASCADE,

  row_number INTEGER NOT NULL,
  field_key TEXT,
  error_type TEXT NOT NULL,
  error_message TEXT NOT NULL,
  raw_value TEXT,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Cap row-level errors to prevent table explosion
-- For batch imports, write full errors to S3 instead
```

**Lane 2 Batch Processing Design:**

```
1. Upload CSV to S3 â Create import_jobs row
2. EventBridge triggers ECS task
3. Worker:
   - Stream-parse CSV (don't load all in memory)
   - Validate in chunks (1000 rows)
   - Write valid rows to staging table
   - Write errors to S3 (errors.csv)
   - Update checkpoint after each chunk
4. On success:
   - Promote from staging to production in chunks (short transactions)
   - Mark job completed
5. On failure:
   - Log checkpoint for resume
   - Mark job failed with error summary
6. Rollback:
   - DELETE WHERE import_job_id = X
   - Only available before rollback_before deadline
```

**Implementation:**

- [x] Create `src/db/schema/imports.schema.ts`
- [x] Create `src/features/imports/` module
- [x] Lane 1: Import wizard UI
- [x] Lane 1: Field mapping UI with auto-suggestions
- [x] Lane 1: Validation preview
- [x] Lane 2: S3 upload flow
- [x] Lane 2: Worker container (ECS task definition) (drafted in `docs/sin-rfp/phase-0/import-batch-worker.md`)
- [x] Lane 2: Chunked processing with checkpoints
- [x] Lane 1 rollback strategy (tag inserts with `import_job_id` or stage then promote)
- [x] Mapping template CRUD
- [x] Import history and status dashboard
- [x] Rollback capability

**Acceptance Criteria:**

- [x] Admin can upload CSV/Excel and preview columns
- [x] Auto-suggest mappings by column name similarity
- [x] Preview shows first N rows with validation results
- [x] Validation errors shown per row (Lane 1) or in report (Lane 2)
- [x] Import can be executed after validation
- [x] Batch imports are resumable after failure
- [x] Lane 1 rollback supported via `import_job_id` tagging or staging discard
- [x] Rollback available within configured window
- [x] Mapping templates can be saved and reused
- [x] All imports are audit logged

---

#### R-001: Reporting Cycles & Workflows

**Priority:** P1
**Effort:** 2 weeks
**Requirement:** RP-AGG-003

**Database Schema:**

```sql
-- Reporting cycles (e.g., "FY2025 Q1", "Annual Report 2025")
CREATE TABLE reporting_cycles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  name TEXT NOT NULL,
  description TEXT,

  start_date DATE NOT NULL,
  end_date DATE NOT NULL,

  status TEXT NOT NULL DEFAULT 'upcoming'
    CHECK (status IN ('upcoming', 'active', 'closed', 'archived')),

  created_by TEXT REFERENCES "user"(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Reporting tasks (what's due, when)
CREATE TABLE reporting_tasks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  cycle_id UUID NOT NULL REFERENCES reporting_cycles(id) ON DELETE CASCADE,

  form_id UUID NOT NULL REFERENCES forms(id),

  -- Target (specific org or all orgs of a type)
  organization_id UUID REFERENCES organizations(id), -- NULL = all applicable orgs
  organization_type TEXT, -- 'pso', 'club', etc.

  title TEXT NOT NULL,
  description TEXT,
  due_date DATE NOT NULL,

  -- Reminder configuration
  reminder_config JSONB NOT NULL DEFAULT '{}',
  -- { days_before: [14, 7, 3, 1], overdue_frequency: 'daily' }

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Reporting submissions (per org per task)
CREATE TABLE reporting_submissions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  task_id UUID NOT NULL REFERENCES reporting_tasks(id),
  organization_id UUID NOT NULL REFERENCES organizations(id),

  form_submission_id UUID REFERENCES form_submissions(id),

  status TEXT NOT NULL DEFAULT 'not_started'
    CHECK (status IN ('not_started', 'in_progress', 'submitted',
                      'under_review', 'changes_requested', 'approved', 'overdue')),

  submitted_at TIMESTAMPTZ,
  submitted_by TEXT REFERENCES "user"(id),

  reviewed_at TIMESTAMPTZ,
  reviewed_by TEXT REFERENCES "user"(id),
  review_notes TEXT,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  UNIQUE(task_id, organization_id)
);

-- Submission history (for resubmissions)
CREATE TABLE reporting_submission_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  reporting_submission_id UUID NOT NULL REFERENCES reporting_submissions(id) ON DELETE CASCADE,

  action TEXT NOT NULL, -- 'submitted', 'changes_requested', 'resubmitted', 'approved'
  actor_id TEXT REFERENCES "user"(id),
  notes TEXT,

  form_submission_version_id UUID REFERENCES form_submission_versions(id),

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Implementation:**

- [x] Create `src/db/schema/reporting.schema.ts`
- [x] Create `src/features/reporting/` module
- [x] Reporting cycle CRUD (admin)
- [x] Task assignment UI
- [x] Reminder scheduler (EventBridge â SQS â notification)
- [x] Organization reporting dashboard ("What's due")
- [x] Admin reporting dashboard ("Who's behind")
- [x] Review workflow (approve/request changes)
- [x] Resubmission tracking with history

**Acceptance Criteria:**

- [x] Admins can create reporting cycles and tasks
- [x] Tasks can target specific orgs or org types
- [x] Organizations see their assigned tasks with due dates
- [x] Automated reminders sent at configured intervals
- [x] Status tracked through full workflow
- [x] Resubmissions maintain history with diffs
- [x] Dashboard shows progress across all orgs
- [x] Overdue tasks highlighted and tracked

---

### Phase 4: Analytics & Export (3-4 weeks)

#### R-002: Reporting & Export

**Priority:** P2
**Effort:** 3-4 weeks
**Requirement:** RP-AGG-005

**Layered Approach:**

| Layer   | Scope                                | Effort                            |
| ------- | ------------------------------------ | --------------------------------- |
| Layer 1 | Curated exports with field-level ACL | 2 weeks                           |
| Layer 2 | Saved reports with filters           | 1-2 weeks                         |
| Layer 3 | Self-service chart builder           | 3-4 weeks (defer unless required) |

**Database Schema:**

```sql
-- Saved reports
CREATE TABLE saved_reports (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID REFERENCES organizations(id),

  name TEXT NOT NULL,
  description TEXT,

  -- Report definition
  data_source TEXT NOT NULL, -- 'submissions', 'memberships', 'organizations'
  filters JSONB NOT NULL DEFAULT '{}',
  columns JSONB NOT NULL DEFAULT '[]', -- Which fields to include
  sort JSONB DEFAULT '{}',

  -- Access control
  owner_id TEXT NOT NULL REFERENCES "user"(id),
  shared_with JSONB DEFAULT '[]', -- user IDs or roles
  is_org_wide BOOLEAN NOT NULL DEFAULT false,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Export history (for audit)
CREATE TABLE export_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  user_id TEXT NOT NULL REFERENCES "user"(id),
  organization_id UUID REFERENCES organizations(id),

  report_id UUID REFERENCES saved_reports(id),

  export_type TEXT NOT NULL, -- 'csv', 'excel', 'pdf'
  data_source TEXT NOT NULL,
  filters_used JSONB NOT NULL,
  row_count INTEGER NOT NULL,

  file_key TEXT, -- S3 key (temporary)

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Field-Level Access Control:**

```typescript
interface FieldAccessPolicy {
  field: string;
  requiredRoles: string[]; // Empty = visible to all
  redactForRoles?: string[]; // Show as "***"
}

// Applied at export time, not query time
function applyFieldAccess(data: any[], userRoles: string[], policy: FieldAccessPolicy[]) {
  // Redact or remove fields based on policy
}
```

**Implementation:**

- [x] Create `src/db/schema/reports.schema.ts`
- [x] Create `src/features/reports/` module
- [x] Curated export endpoints (CSV, Excel)
- [x] Field-level access control middleware
- [x] Export audit logging
- [x] Saved report CRUD
- [x] Report builder UI (filters, columns)
- [x] Report sharing

**Acceptance Criteria:**

- [x] Authorized users can export datasets
- [x] Exports respect field-level access rules
- [x] Every export is audit logged
- [x] Reports can be saved with filters
- [x] Saved reports can be shared within org

---

## Part 4: Deferred Features (Phase 5+)

> These are not required for SIN MVP. Build only if explicitly requested.

| Feature                      | Reason to Defer              |
| ---------------------------- | ---------------------------- |
| Website builder              | Not a SIN requirement        |
| Mobile native app            | PWA sufficient               |
| Live scoring                 | Not a data warehouse feature |
| Competition management       | Not a SIN requirement        |
| LMS / training modules       | Can use external tool        |
| Full chart builder (Layer 3) | Layer 1-2 likely sufficient  |
| Multi-currency               | CAD only for viaSport        |
| Ticket sales                 | Not a SIN requirement        |

---

## Part 5: Migration Strategy (20M+ Rows)

### Pre-Migration Checklist

- [x] Legacy data inventory (tables, row counts, relationships) (synthetic placeholders in `docs/sin-rfp/phase-0/migration-strategy.md`)
- [x] Data quality assessment (nulls, duplicates, invalid formats) (synthetic placeholders in `docs/sin-rfp/phase-0/migration-strategy.md`)
- [x] Field mapping document (legacy â SIN) (synthesized in `docs/sin-rfp/phase-0/migration-strategy.md`)
- [x] Transformation rules (date formats, phone normalization, enum mappings) (synthesized in `docs/sin-rfp/phase-0/migration-strategy.md`)
- [x] Rollback plan (keep legacy system read-only during transition) (documented in `docs/sin-rfp/phase-0/migration-strategy.md`)

### Migration Phases

| Phase | Scope                  | Approach                             |
| ----- | ---------------------- | ------------------------------------ |
| 1     | Schema creation        | Run in empty environment             |
| 2     | Organization hierarchy | Manual or scripted setup             |
| 3     | User migration         | Batch import with email notification |
| 4     | Historical submissions | Lane 2 batch import                  |
| 5     | Document migration     | S3 bulk copy with metadata sync      |
| 6     | Validation             | Reconciliation reports               |
| 7     | Cutover                | DNS switch, legacy read-only         |

### Batch Import Configuration for 20M Rows

```yaml
# ECS Task Definition
resources:
  cpu: 2048
  memory: 4096

# Processing settings
chunk_size: 5000
checkpoint_interval: 10000
max_retries: 3
connection_pool: unpooled # Direct connection, not pooled

# Error handling
max_errors_before_abort: 10000
error_report_format: csv
error_report_destination: s3://bucket/imports/{job_id}/errors.csv
```

---

## Part 6: RFP Submission Checklist

### Documentation Deliverables

- [x] Reference architecture document (with diagram)
- [x] Data residency statement
- [x] Security controls overview
- [x] Backup & DR plan with RPO/RTO
- [x] Audit & retention policy
- [x] Sub-processor inventory
- [x] Data classification guide
- [x] Migration strategy document
- [x] Phased delivery plan

### Technical Demonstration

- [x] Organization hierarchy with multi-level access (hierarchy visualization pending)
- [x] Audit log with filtering and export
- [x] MFA enrollment and challenge
- [x] Dynamic form creation and submission
- [x] Bulk import with validation and rollback
- [x] Reporting cycle with reminders
- [x] DSAR workflow (export, erasure)

### Compliance Evidence

- [x] AWS Canada region configuration
- [x] Encryption at rest (KMS)
- [x] Encryption in transit (TLS 1.3)
- [x] Immutable audit logs (trigger-enforced)
- [x] Session security controls
- [x] PII redaction in logs
- [ ] Backup restore test results (template only; needs execution)

---

## Appendix A: Existing Code to Leverage

| Existing Code                                    | Use For                            |
| ------------------------------------------------ | ---------------------------------- |
| `src/db/schema/roles.schema.ts`                  | Extend for org-scoped roles        |
| `src/components/form-fields/*`                   | Form builder field types           |
| `src/lib/email/sendgrid.ts`                      | Migrate to SES, keep patterns      |
| `src/components/ui/data-table.tsx`               | Admin dashboards                   |
| `src/lib/pacer/*`                                | Rate limiting foundation           |
| `src/features/membership/membership.finalize.ts` | Pattern for atomic multi-table ops |
| `src/lib/auth/*`                                 | Extend with MFA and org context    |

---

## Appendix B: Technology Stack Updates

| Current            | SIN Production                    |
| ------------------ | --------------------------------- |
| Neon PostgreSQL    | AWS RDS PostgreSQL (ca-central-1) |
| Netlify            | AWS via SST (production)          |
| SendGrid           | AWS SES (ca-central-1)            |
| Local file storage | S3 with SSE-KMS                   |
| No queue           | SQS for notifications             |
| No scheduler       | EventBridge Scheduler             |
| Console logging    | CloudWatch Logs (PII redacted)    |

---

## Appendix C: Better Auth 2FA Configuration

```typescript
// src/lib/auth/index.ts
import { betterAuth } from "better-auth";
import { twoFactor } from "better-auth/plugins/2fa";

export const auth = betterAuth({
  // ... existing config
  plugins: [
    twoFactor({
      issuer: "viaSport SIN",
      // TOTP settings
      totpOptions: {
        digits: 6,
        period: 30,
      },
      // Backup codes
      backupCodes: {
        enabled: true,
        count: 10,
        length: 8,
      },
    }),
  ],
});
```

---

## Document History

| Version | Date       | Changes                                                      |
| ------- | ---------- | ------------------------------------------------------------ |
| v1.0    | 2024-12    | Initial backlog                                              |
| v2.0    | 2024-12    | Complete rewrite incorporating architecture review feedback  |
| v2.1    | 2025-12-24 | Added Implementation Progress Tracker with codebase analysis |
</file>

<file path="src/lib/email/sendgrid.ts">
/**
 * SendGrid email service wrapper
 * Provides type-safe methods for sending transactional emails
 */

import { z } from "zod";
import { getBrand } from "~/tenant";

// Email configuration schemas
export const EmailRecipientSchema = z.object({
  email: z.email(),
  name: z.string().optional(),
});

export const EmailDataSchema = z.object({
  to: z.union([EmailRecipientSchema, z.array(EmailRecipientSchema)]),
  from: EmailRecipientSchema,
  subject: z.string(),
  text: z.string().optional(),
  html: z.string().optional(),
  templateId: z.string().optional(),
  dynamicTemplateData: z.record(z.string(), z.unknown()).optional(),
  replyTo: EmailRecipientSchema.optional(),
  attachments: z
    .array(
      z.object({
        content: z.string(),
        filename: z.string(),
        type: z.string().optional(),
        disposition: z.string().optional(),
      }),
    )
    .optional(),
});

export type EmailRecipient = z.infer<typeof EmailRecipientSchema>;
export type EmailData = z.infer<typeof EmailDataSchema>;

// Response types
export interface SendEmailResult {
  success: boolean;
  messageId?: string;
  error?: string;
}

// Email template IDs (to be populated with actual SendGrid template IDs)
export const EMAIL_TEMPLATES = {
  MEMBERSHIP_PURCHASE_RECEIPT: "membership_purchase_receipt",
  WELCOME: "welcome",
  PASSWORD_RESET: "password_reset",
  TEAM_INVITATION: "team_invitation",
  EVENT_REGISTRATION_CONFIRMATION: "event_registration_confirmation",
} as const;

export type EmailTemplateId = (typeof EMAIL_TEMPLATES)[keyof typeof EMAIL_TEMPLATES];

// Mock email service for development
class MockEmailService {
  async send(data: EmailData): Promise<SendEmailResult> {
    console.log("ð§ Mock Email Service - Sending email:", {
      to: data.to,
      subject: data.subject,
      templateId: data.templateId,
      dynamicTemplateData: data.dynamicTemplateData,
    });

    // Simulate network delay
    await new Promise((resolve) => setTimeout(resolve, 1000));

    // Simulate success
    return {
      success: true,
      messageId: `mock-${Date.now()}`,
    };
  }

  setApiKey(_key: string): void {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const key = _key;
    console.log("ð§ Mock Email Service - API key set");
  }
}

// Real SendGrid service
class SendGridEmailService {
  private client: unknown;
  private initialized = false;

  async initialize(): Promise<void> {
    if (this.initialized) return;

    try {
      const sgMail = await import("@sendgrid/mail");
      this.client = sgMail.default;

      const apiKey = process.env["SENDGRID_API_KEY"];
      if (!apiKey) {
        throw new Error("SENDGRID_API_KEY environment variable is not set");
      }

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (this.client as any).setApiKey(apiKey);
      this.initialized = true;
    } catch (error) {
      console.error("Failed to initialize SendGrid:", error);
      throw error;
    }
  }

  async send(data: EmailData): Promise<SendEmailResult> {
    try {
      await this.initialize();

      // Validate email data
      const validatedData = EmailDataSchema.parse(data);

      // Convert to SendGrid format
      const msg = {
        to: validatedData.to,
        from: validatedData.from,
        subject: validatedData.subject,
        text: validatedData.text,
        html: validatedData.html,
        templateId: validatedData.templateId,
        dynamicTemplateData: validatedData.dynamicTemplateData,
        replyTo: validatedData.replyTo,
        attachments: validatedData.attachments,
      };

      // Send email
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const [response] = await (this.client as any).send(msg);

      return {
        success: true,
        messageId: response.headers["x-message-id"],
      };
    } catch (error) {
      console.error("SendGrid error:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to send email",
      };
    }
  }
}

// Factory function to get the appropriate email service
type EmailService = MockEmailService | SendGridEmailService;

let cachedEmailService: EmailService | null = null;

const resolveEmailService = async (): Promise<EmailService> => {
  if (cachedEmailService) {
    return cachedEmailService;
  }

  const useSendGrid =
    process.env["SENDGRID_API_KEY"] && process.env["NODE_ENV"] !== "test";

  cachedEmailService = useSendGrid ? new SendGridEmailService() : new MockEmailService();
  return cachedEmailService;
};

export const getEmailService = async (): Promise<EmailService> => resolveEmailService();

const getBrandEmailConfig = () => {
  const brand = getBrand();
  const fromEmail =
    process.env["SENDGRID_FROM_EMAIL"] ||
    brand.supportEmail ||
    "noreply@solstice.app";
  const fromName = process.env["SENDGRID_FROM_NAME"] || brand.name;
  const supportEmail = brand.supportEmail || fromEmail;
  const supportName = brand.supportName || brand.name;

  return { brand, fromEmail, fromName, supportEmail, supportName };
};

// Convenience function for sending membership purchase receipts
export const sendMembershipPurchaseReceipt = async (params: {
  to: EmailRecipient;
  membershipType: string;
  amount: number;
  paymentId: string;
  expiresAt: Date;
}) => {
  const service = await getEmailService();
  const { brand, fromEmail, fromName, supportEmail, supportName } =
    getBrandEmailConfig();

  return service.send({
    to: params.to,
    from: {
      email: fromEmail,
      name: fromName,
    },
    subject: `Membership Purchase Confirmation - ${brand.name}`,
    templateId: EMAIL_TEMPLATES.MEMBERSHIP_PURCHASE_RECEIPT,
    dynamicTemplateData: {
      memberName: params.to.name || "Member",
      membershipType: params.membershipType,
      amount: `$${(params.amount / 100).toFixed(2)}`,
      paymentId: params.paymentId,
      expiresAt: params.expiresAt.toLocaleDateString("en-CA"),
      year: new Date().getFullYear(),
    },
    // Fallback plain text version
    text: `Thank you for purchasing a ${params.membershipType} membership!

Amount paid: $${(params.amount / 100).toFixed(2)}
Payment ID: ${params.paymentId}
Expires: ${params.expiresAt.toLocaleDateString("en-CA")}

You can view your membership status at any time by logging into your dashboard.

If you have any questions, please contact us at ${supportEmail}.

Best regards,
${supportName}`,
    // HTML version (used if no template ID is configured)
    html: `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Membership Purchase Confirmation</title>
</head>
<body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
  <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
    <h1 style="color: ${brand.themeColor ?? "#0ea5e9"};">Membership Purchase Confirmation</h1>
    
    <p>Hello ${params.to.name || "Member"},</p>
    
    <p>Thank you for purchasing a <strong>${params.membershipType}</strong> membership!</p>
    
    <div style="background-color: #f3f4f6; padding: 20px; border-radius: 8px; margin: 20px 0;">
      <h2 style="margin-top: 0;">Purchase Details</h2>
      <p><strong>Amount paid:</strong> $${(params.amount / 100).toFixed(2)}</p>
      <p><strong>Payment ID:</strong> ${params.paymentId}</p>
      <p><strong>Expires:</strong> ${params.expiresAt.toLocaleDateString("en-CA")}</p>
    </div>
    
    <p>You can view your membership status at any time by logging into your dashboard.</p>
    
    <p>If you have any questions, please contact us at <a href="mailto:${supportEmail}">${supportEmail}</a>.</p>
    
    <hr style="margin: 30px 0; border: none; border-top: 1px solid #e5e7eb;">
    
    <p style="color: #6b7280; font-size: 14px;">
      Best regards,<br>
      ${supportName}
    </p>
  </div>
</body>
</html>
    `,
  });
};

export const sendTeamInvitationEmail = async (params: {
  to: EmailRecipient;
  teamName: string;
  teamSlug: string;
  role: string;
  invitedByName?: string;
  invitedByEmail?: string;
}) => {
  const service = await getEmailService();
  const { brand, fromEmail, fromName } = getBrandEmailConfig();

  const siteUrl =
    process.env["SITE_URL"] ||
    process.env["URL"] ||
    process.env["VITE_BASE_URL"] ||
    "http://localhost:5173";
  const normalizedSiteUrl = siteUrl.endsWith("/") ? siteUrl.slice(0, -1) : siteUrl;
  const dashboardUrl = `${normalizedSiteUrl}/dashboard/teams`;
  const invitationUrl = `${dashboardUrl}/${params.teamSlug}`;

  const inviterDisplay =
    params.invitedByName ||
    params.invitedByEmail ||
    `a ${brand.name} team representative`;

  const textBody = `You've been invited to join ${params.teamName} as a ${params.role}.

Accept or decline your invitation here: ${dashboardUrl}

If the link above doesn't work, copy and paste this URL into your browser: ${invitationUrl}

Invitation sent by ${inviterDisplay}.`;

  return service.send({
    to: params.to,
    from: {
      email: fromEmail,
      name: fromName,
    },
    subject: `${params.teamName} team invitation`,
    templateId: EMAIL_TEMPLATES.TEAM_INVITATION,
    dynamicTemplateData: {
      teamName: params.teamName,
      role: params.role,
      inviterName: inviterDisplay,
      dashboardUrl,
      invitationUrl,
    },
    text: textBody,
  });
};

// Convenience function for sending welcome emails
export const sendWelcomeEmail = async (params: {
  to: EmailRecipient;
  profileUrl: string;
}) => {
  const service = await getEmailService();
  const { brand, fromEmail, fromName, supportEmail, supportName } =
    getBrandEmailConfig();

  return service.send({
    to: params.to,
    from: {
      email: fromEmail,
      name: fromName,
    },
    subject: `Welcome to ${brand.name}!`,
    templateId: EMAIL_TEMPLATES.WELCOME,
    dynamicTemplateData: {
      memberName: params.to.name || "New Member",
      profileUrl: params.profileUrl,
      year: new Date().getFullYear(),
    },
    text: `Welcome to ${brand.name}!

We're thrilled to have you join our community.

To get started, please complete your profile: ${params.profileUrl}

If you have any questions, feel free to reach out to us at ${supportEmail}.

Best regards,
${supportName}`,
  });
};
</file>

</files>
