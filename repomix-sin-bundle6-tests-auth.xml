This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: e2e/tests/authenticated/sin-*.ts, e2e/tests/authenticated/sin-*.spec.ts, src/features/auth/**/*.ts, src/features/auth/**/*.tsx, src/lib/auth/**/*.ts, src/routes/api/auth/**/*.ts, scripts/seed-global-admins.ts, scripts/seed-sin-data.ts, docs/sin-rfp/tickets/SIN-IMPLEMENTATION-BACKLOG-V2.md, docs/sin-rfp/phase-0/security-controls.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<user_provided_header>
# Review Task: Authentication, MFA & E2E Tests

## Focus
Review **authentication system, MFA implementation, and E2E test coverage** for security and completeness.

## Key Questions
1. Is MFA properly enforced for admin roles?
2. Is step-up authentication working for sensitive actions?
3. Are auth guards properly protecting routes?
4. Do E2E tests cover critical SIN flows?
5. Are seed scripts creating proper test data?

## Reference Documents
- `SIN-IMPLEMENTATION-BACKLOG-V2.md`: Contains S-001 (MFA) requirements
- `security-controls.md`: Contains session and auth requirements

## Areas to Review
- MFA enrollment and challenge flow
- Step-up auth for exports, role changes, DSAR
- Auth guards (requireAdmin, requireSession, etc.)
- E2E test coverage for SIN admin and portal
- Seed scripts for test data

## Output Format
For each issue found:
1. **Category**: Auth/MFA/Tests/Seeds
2. **Severity**: High/Medium/Low
3. **Location**: file:line
4. **Issue**: What's wrong or missing
5. **Security Impact**: What could be exploited
6. **Fix**: Suggested remediation

Also provide:
- **Test Coverage Gaps**: Critical flows without E2E tests
- **Auth Hardening Recommendations**: Additional security measures
</user_provided_header>

<directory_structure>
docs/
  sin-rfp/
    phase-0/
      security-controls.md
    tickets/
      SIN-IMPLEMENTATION-BACKLOG-V2.md
e2e/
  tests/
    authenticated/
      sin-admin-access.auth.spec.ts
      sin-portal-access.auth.spec.ts
scripts/
  seed-global-admins.ts
  seed-sin-data.ts
src/
  features/
    auth/
      __tests__/
        login-with-router.test.tsx
        login.test.tsx
        signup-with-router.test.tsx
      components/
        login.tsx
        signup.tsx
      hooks/
        useAuth.ts
        useAuthForm.ts
      mfa/
        mfa-enrollment.tsx
        mfa-recovery.tsx
        mfa.mutations.ts
      auth.queries.ts
      auth.schemas.ts
      index.ts
      step-up.tsx
  lib/
    auth/
      guards/
        org-context.ts
        org-guard.ts
        route-guards.ts
        step-up.ts
      middleware/
        __tests__/
          auth-guard.test.ts
        auth-guard.ts
        role-guard.ts
      utils/
        admin-check.ts
      index.ts
      server-helpers.ts
      types.ts
  routes/
    api/
      auth/
        $action/
          $provider.ts
        $.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="e2e/tests/authenticated/sin-portal-access.auth.spec.ts">
import { expect, test } from "@playwright/test";
import { clearAuthState, gotoWithAuth } from "../../utils/auth";

const tenantKey =
  process.env["TENANT_KEY"] ?? process.env["VITE_TENANT_KEY"] ?? "qc";
const isViaSport = tenantKey === "viasport";

test.describe("SIN portal access", () => {
  test("QC tenant blocks SIN portal routes", async ({ page }) => {
    test.skip(isViaSport, "QC-only assertion");

    await clearAuthState(page);
    await gotoWithAuth(page, "/dashboard/sin", {
      email: process.env["E2E_TEST_EMAIL"]!,
      password: process.env["E2E_TEST_PASSWORD"]!,
    });

    await expect(page).toHaveURL(/\/dashboard\/forbidden/);
    await expect(page.getByRole("heading", { name: "Access restricted" })).toBeVisible();
  });

  test("viaSport redirects /dashboard to SIN", async ({ page }) => {
    test.skip(!isViaSport, "viaSport-only assertion");

    await clearAuthState(page);
    await gotoWithAuth(page, "/dashboard", {
      email: process.env["E2E_TEST_EMAIL"]!,
      password: process.env["E2E_TEST_PASSWORD"]!,
    });

    await expect(page).toHaveURL(/\/dashboard\/select-org/);
    const redirectTarget = new URL(page.url()).searchParams.get("redirect") ?? "";
    expect(decodeURIComponent(redirectTarget)).toContain("/dashboard/sin");
  });
});
</file>

<file path="scripts/seed-sin-data.ts">
#!/usr/bin/env tsx
/**
 * Seed script for viaSport SIN (Strength in Numbers) test data
 *
 * This script creates a realistic data environment for the SIN platform,
 * which is fundamentally different from the QC (Quadball Canada) platform.
 *
 * SIN is a data reporting and management platform for BC amateur sports organizations.
 *
 * Run with: npx tsx scripts/seed-sin-data.ts
 *
 * Test users created (all with password: testpassword123):
 * - admin@example.com - Platform admin (Solstice Admin)
 * - viasport-staff@example.com - viaSport staff (viaSport Admin)
 * - pso-admin@example.com - PSO administrator
 * - club-reporter@example.com - Club data reporter
 * - member@example.com - Regular member
 */

import { hashPassword } from "better-auth/crypto";
import dotenv from "dotenv";
import { and, eq, like, or } from "drizzle-orm";
import { drizzle } from "drizzle-orm/postgres-js";
import postgres from "postgres";
import {
  account,
  delegatedAccess,
  forms,
  formSubmissions,
  formVersions,
  notificationTemplates,
  organizationMembers,
  organizations,
  policyDocuments,
  reportingCycles,
  reportingSubmissions,
  reportingTasks,
  retentionPolicies,
  roles,
  session,
  user,
  userRoles,
} from "../src/db/schema";

// Load environment variables (don't override SST-provided vars)
// When running via SST shell, DATABASE_URL is already set correctly
if (!process.env["DATABASE_URL"]) {
  dotenv.config({ path: ".env" });
  dotenv.config({ path: ".env.e2e" });
}

// Static IDs for predictable test data
const IDS = {
  // Users
  platformAdminId: "sin-user-platform-admin-001",
  viasportStaffId: "sin-user-viasport-staff-001",
  psoAdminId: "sin-user-pso-admin-001",
  clubReporterId: "sin-user-club-reporter-001",
  memberId: "sin-user-member-001",

  // Organizations
  viasportBcId: "00000000-0000-0000-0001-000000000001",
  bcHockeyId: "00000000-0000-0000-0001-000000000002",
  bcSoccerId: "00000000-0000-0000-0001-000000000003",
  bcAthleticsId: "00000000-0000-0000-0001-000000000004",
  vanMinorHockeyId: "00000000-0000-0000-0001-000000000005",
  victoriaHockeyId: "00000000-0000-0000-0001-000000000006",
  whitecapsAcademyId: "00000000-0000-0000-0001-000000000007",
  bcSoccerDevLeagueId: "00000000-0000-0000-0001-000000000008",
  vanThunderbirdsId: "00000000-0000-0000-0001-000000000009",
  northShoreClubId: "00000000-0000-0000-0001-000000000010",

  // Forms
  annualStatsFormId: "00000000-0000-0000-0002-000000000001",
  quarterlyFinFormId: "00000000-0000-0000-0002-000000000002",
  demographicsFormId: "00000000-0000-0000-0002-000000000003",
  coachingFormId: "00000000-0000-0000-0002-000000000004",

  // Form Versions
  annualStatsFormV1Id: "00000000-0000-0000-0003-000000000001",
  quarterlyFinFormV1Id: "00000000-0000-0000-0003-000000000002",
  demographicsFormV1Id: "00000000-0000-0000-0003-000000000003",
  coachingFormV1Id: "00000000-0000-0000-0003-000000000004",

  // Reporting Cycles
  fy2425CycleId: "00000000-0000-0000-0004-000000000001",
  q42024CycleId: "00000000-0000-0000-0004-000000000002",
  q12025CycleId: "00000000-0000-0000-0004-000000000003",

  // Reporting Tasks
  annualTask1Id: "00000000-0000-0000-0005-000000000001",
  annualTask2Id: "00000000-0000-0000-0005-000000000002",
  annualTask3Id: "00000000-0000-0000-0005-000000000003",
  quarterlyTask1Id: "00000000-0000-0000-0005-000000000004",

  // Policy Documents
  privacyPolicyId: "00000000-0000-0000-0006-000000000001",
  tosId: "00000000-0000-0000-0006-000000000002",
} as const;

async function seed() {
  console.log("üå± Seeding viaSport SIN test data...");
  console.log("   This creates a realistic org hierarchy and reporting environment.\n");

  const connectionString =
    process.env["E2E_DATABASE_URL"] || process.env["DATABASE_URL"] || "";

  if (!connectionString) {
    throw new Error("No database URL found. Set DATABASE_URL or E2E_DATABASE_URL");
  }

  const sql = postgres(connectionString, { max: 1 });
  const db = drizzle(sql);

  try {
    // ========================================
    // PHASE 1: Clean up existing SIN test data
    // ========================================
    console.log("Phase 1: Cleaning up existing SIN test data...");

    // Delete in correct order for FK constraints
    await db.delete(reportingSubmissions);
    await db.delete(reportingTasks);
    await db.delete(reportingCycles);
    await db.delete(formSubmissions);
    await db.delete(formVersions);
    await db.delete(forms);
    await db.delete(delegatedAccess);
    await db.delete(organizationMembers);
    await db.delete(organizations);
    await db.delete(retentionPolicies);
    await db.delete(policyDocuments);
    await db.delete(notificationTemplates);
    await db.delete(userRoles);
    await db.delete(session).where(like(session.userId, "sin-user-%"));
    await db.delete(account).where(like(account.userId, "sin-user-%"));
    await db.delete(user).where(
      or(
        like(user.id, "sin-user-%"),
        like(user.email, "%-staff@example.com"),
        like(user.email, "pso-%@example.com"),
        like(user.email, "club-%@example.com"),
      )
    );
    await db.delete(roles);

    console.log("   ‚úì Cleaned existing data\n");

    // ========================================
    // PHASE 2: Create roles
    // ========================================
    console.log("Phase 2: Creating roles...");

    await db.insert(roles).values([
      {
        id: "solstice-admin",
        name: "Solstice Admin",
        description: "Platform administrator with full system access",
        permissions: {
          "system:*": true,
          "roles:manage": true,
        },
      },
      {
        id: "viasport-admin",
        name: "viaSport Admin",
        description: "viaSport administrator with organization-wide access",
        permissions: {
          "viasport:*": true,
          "orgs:manage": true,
          "reports:view": true,
          "forms:manage": true,
        },
      },
      {
        id: "org-admin",
        name: "Organization Admin",
        description: "Administrator for a specific organization",
        permissions: {
          "org:manage": true,
          "org:members:manage": true,
          "org:reports:submit": true,
        },
      },
      {
        id: "org-reporter",
        name: "Organization Reporter",
        description: "Can submit reports for an organization",
        permissions: {
          "org:reports:submit": true,
          "org:reports:view": true,
        },
      },
    ]);
    console.log("   ‚úì Created 4 roles\n");

    // ========================================
    // PHASE 3: Create test users
    // ========================================
    console.log("Phase 3: Creating test users...");

    const hashedPassword = await hashPassword("testpassword123");

    const testUsers = [
      {
        id: IDS.platformAdminId,
        email: "admin@example.com",
        name: "Platform Admin",
        roleId: "solstice-admin",
      },
      {
        id: IDS.viasportStaffId,
        email: "viasport-staff@example.com",
        name: "viaSport Staff Member",
        roleId: "viasport-admin",
      },
      {
        id: IDS.psoAdminId,
        email: "pso-admin@example.com",
        name: "PSO Administrator",
        roleId: null, // Assigned via org membership
      },
      {
        id: IDS.clubReporterId,
        email: "club-reporter@example.com",
        name: "Club Data Reporter",
        roleId: null, // Assigned via org membership
      },
      {
        id: IDS.memberId,
        email: "member@example.com",
        name: "Regular Member",
        roleId: null,
      },
    ];

    for (const userData of testUsers) {
      await db.insert(user).values({
        id: userData.id,
        email: userData.email,
        name: userData.name,
        emailVerified: true,
        profileComplete: true,
        profileVersion: 1,
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      await db.insert(account).values({
        id: `${userData.id}-account`,
        userId: userData.id,
        providerId: "credential",
        accountId: userData.email,
        password: hashedPassword,
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      await db.insert(session).values({
        id: `${userData.id}-session`,
        userId: userData.id,
        token: `sin-test-token-${userData.id}`,
        expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      if (userData.roleId) {
        await db.insert(userRoles).values({
          id: `${userData.id}-role`,
          userId: userData.id,
          roleId: userData.roleId,
          assignedBy: IDS.platformAdminId,
          notes: "Seeded via seed-sin-data.ts",
        });
      }

      console.log(`   ‚úì Created user: ${userData.email}`);
    }
    console.log("");

    // ========================================
    // PHASE 4: Create organization hierarchy
    // ========================================
    console.log("Phase 4: Creating organization hierarchy...");

    // Root: viaSport BC (governing body)
    await db.insert(organizations).values({
      id: IDS.viasportBcId,
      name: "viaSport BC",
      slug: "viasport-bc",
      type: "governing_body",
      status: "active",
      settings: { fiscalYearEnd: "03-31" },
      metadata: { established: 2010 },
    });
    console.log("   ‚úì viaSport BC (governing_body)");

    // PSOs under viaSport
    const psos = [
      { id: IDS.bcHockeyId, name: "BC Hockey", slug: "bc-hockey" },
      { id: IDS.bcSoccerId, name: "BC Soccer", slug: "bc-soccer" },
      { id: IDS.bcAthleticsId, name: "BC Athletics", slug: "bc-athletics" },
    ];

    for (const pso of psos) {
      await db.insert(organizations).values({
        ...pso,
        type: "pso",
        parentOrgId: IDS.viasportBcId,
        status: "active",
        settings: {},
        metadata: {},
      });
      console.log(`   ‚úì ${pso.name} (pso)`);
    }

    // Leagues under PSOs
    const leagues = [
      { id: IDS.vanMinorHockeyId, name: "Vancouver Minor Hockey", slug: "van-minor-hockey", parentId: IDS.bcHockeyId },
      { id: IDS.bcSoccerDevLeagueId, name: "BC Soccer Development League", slug: "bc-soccer-dev", parentId: IDS.bcSoccerId },
    ];

    for (const league of leagues) {
      await db.insert(organizations).values({
        id: league.id,
        name: league.name,
        slug: league.slug,
        type: "league",
        parentOrgId: league.parentId,
        status: "active",
        settings: {},
        metadata: {},
      });
      console.log(`   ‚úì ${league.name} (league)`);
    }

    // Clubs
    const clubs = [
      { id: IDS.northShoreClubId, name: "North Shore Winter Club", slug: "north-shore-winter", parentId: IDS.vanMinorHockeyId },
      { id: IDS.victoriaHockeyId, name: "Victoria Hockey Association", slug: "victoria-hockey", parentId: IDS.bcHockeyId },
      { id: IDS.whitecapsAcademyId, name: "Vancouver Whitecaps Academy", slug: "whitecaps-academy", parentId: IDS.bcSoccerId },
      { id: IDS.vanThunderbirdsId, name: "Vancouver Thunderbirds", slug: "van-thunderbirds", parentId: IDS.bcAthleticsId },
    ];

    for (const club of clubs) {
      await db.insert(organizations).values({
        id: club.id,
        name: club.name,
        slug: club.slug,
        type: "club",
        parentOrgId: club.parentId,
        status: "active",
        settings: {},
        metadata: {},
      });
      console.log(`   ‚úì ${club.name} (club)`);
    }
    console.log("");

    // ========================================
    // PHASE 5: Assign organization memberships
    // ========================================
    console.log("Phase 5: Assigning organization memberships...");

    const memberships = [
      // viaSport staff is owner of viaSport BC
      { userId: IDS.viasportStaffId, orgId: IDS.viasportBcId, role: "owner" as const },
      // PSO admin is admin of BC Hockey
      { userId: IDS.psoAdminId, orgId: IDS.bcHockeyId, role: "admin" as const },
      // Club reporter is reporter for North Shore Winter Club
      { userId: IDS.clubReporterId, orgId: IDS.northShoreClubId, role: "reporter" as const },
      // Member is viewer at Vancouver Minor Hockey
      { userId: IDS.memberId, orgId: IDS.vanMinorHockeyId, role: "viewer" as const },
    ];

    for (const mem of memberships) {
      await db.insert(organizationMembers).values({
        userId: mem.userId,
        organizationId: mem.orgId,
        role: mem.role,
        status: "active",
        approvedBy: IDS.viasportStaffId,
        approvedAt: new Date(),
      });
    }
    console.log(`   ‚úì Created ${memberships.length} organization memberships\n`);

    // ========================================
    // PHASE 6: Create forms
    // ========================================
    console.log("Phase 6: Creating forms...");

    const formsData = [
      {
        id: IDS.annualStatsFormId,
        versionId: IDS.annualStatsFormV1Id,
        name: "Annual Statistics Report",
        slug: "annual-stats",
        description: "Annual participant and activity statistics for PSOs",
        status: "published" as const,
        definition: {
          fields: [
            { key: "total_participants", type: "number", label: "Total Registered Participants", required: true },
            { key: "male_participants", type: "number", label: "Male Participants", required: true },
            { key: "female_participants", type: "number", label: "Female Participants", required: true },
            { key: "other_participants", type: "number", label: "Other/Non-binary Participants", required: false },
            { key: "youth_under_18", type: "number", label: "Youth (Under 18)", required: true },
            { key: "adults_18_plus", type: "number", label: "Adults (18+)", required: true },
            { key: "coaches_certified", type: "number", label: "Certified Coaches", required: true },
            { key: "events_held", type: "number", label: "Events/Competitions Held", required: true },
            { key: "notes", type: "textarea", label: "Additional Notes", required: false },
          ],
          settings: { allowDraft: true, requireApproval: true },
        },
      },
      {
        id: IDS.quarterlyFinFormId,
        versionId: IDS.quarterlyFinFormV1Id,
        name: "Quarterly Financial Summary",
        slug: "quarterly-financial",
        description: "Quarterly financial reporting for grant compliance",
        status: "published" as const,
        definition: {
          fields: [
            { key: "revenue_grants", type: "currency", label: "Revenue - Grants", required: true },
            { key: "revenue_fees", type: "currency", label: "Revenue - Membership Fees", required: true },
            { key: "revenue_events", type: "currency", label: "Revenue - Events", required: true },
            { key: "revenue_other", type: "currency", label: "Revenue - Other", required: false },
            { key: "expenses_programs", type: "currency", label: "Expenses - Programs", required: true },
            { key: "expenses_admin", type: "currency", label: "Expenses - Administration", required: true },
            { key: "expenses_facilities", type: "currency", label: "Expenses - Facilities", required: true },
            { key: "supporting_docs", type: "file", label: "Supporting Documents", required: false },
          ],
          settings: { allowDraft: true, requireApproval: true },
        },
      },
      {
        id: IDS.demographicsFormId,
        versionId: IDS.demographicsFormV1Id,
        name: "Participant Demographics Survey",
        slug: "demographics",
        description: "Optional demographic data collection",
        status: "draft" as const,
        definition: {
          fields: [
            { key: "indigenous_participants", type: "number", label: "Indigenous Participants", required: false },
            { key: "newcomer_participants", type: "number", label: "Newcomer Participants", required: false },
            { key: "disability_participants", type: "number", label: "Participants with Disabilities", required: false },
            { key: "low_income_participants", type: "number", label: "Low-Income Participants", required: false },
          ],
          settings: { allowDraft: true, requireApproval: false },
        },
      },
      {
        id: IDS.coachingFormId,
        versionId: IDS.coachingFormV1Id,
        name: "Coaching Certification Tracker",
        slug: "coaching-certs",
        description: "Track NCCP and other coaching certifications",
        status: "published" as const,
        definition: {
          fields: [
            { key: "nccp_community", type: "number", label: "NCCP Community Sport", required: true },
            { key: "nccp_competition", type: "number", label: "NCCP Competition", required: true },
            { key: "nccp_instruction", type: "number", label: "NCCP Instruction", required: true },
            { key: "other_certs", type: "number", label: "Other Certifications", required: false },
            { key: "first_aid", type: "number", label: "First Aid Certified", required: true },
          ],
          settings: { allowDraft: true, requireApproval: true },
        },
      },
    ];

    for (const form of formsData) {
      await db.insert(forms).values({
        id: form.id,
        name: form.name,
        slug: form.slug,
        description: form.description,
        status: form.status,
        createdBy: IDS.viasportStaffId,
      });

      await db.insert(formVersions).values({
        id: form.versionId,
        formId: form.id,
        versionNumber: 1,
        definition: form.definition,
        publishedAt: form.status === "published" ? new Date() : null,
        publishedBy: form.status === "published" ? IDS.viasportStaffId : null,
      });

      console.log(`   ‚úì ${form.name} (${form.status})`);
    }
    console.log("");

    // ========================================
    // PHASE 7: Create reporting cycles
    // ========================================
    console.log("Phase 7: Creating reporting cycles...");

    const now = new Date();
    const currentYear = now.getFullYear();

    await db.insert(reportingCycles).values([
      {
        id: IDS.fy2425CycleId,
        name: `FY ${currentYear}-${(currentYear + 1).toString().slice(-2)} Annual Reporting`,
        description: "Annual statistics and financial reporting cycle",
        startDate: `${currentYear}-04-01`,
        endDate: `${currentYear + 1}-03-31`,
        status: "active",
        createdBy: IDS.viasportStaffId,
      },
      {
        id: IDS.q42024CycleId,
        name: `Q4 ${currentYear - 1} Quarterly`,
        description: "Fourth quarter reporting",
        startDate: `${currentYear - 1}-10-01`,
        endDate: `${currentYear - 1}-12-31`,
        status: "closed",
        createdBy: IDS.viasportStaffId,
      },
      {
        id: IDS.q12025CycleId,
        name: `Q1 ${currentYear} Quarterly`,
        description: "First quarter reporting",
        startDate: `${currentYear}-01-01`,
        endDate: `${currentYear}-03-31`,
        status: "upcoming",
        createdBy: IDS.viasportStaffId,
      },
    ]);
    console.log("   ‚úì Created 3 reporting cycles\n");

    // ========================================
    // PHASE 8: Create reporting tasks
    // ========================================
    console.log("Phase 8: Creating reporting tasks...");

    const dueDateAnnual = new Date(currentYear + 1, 3, 30); // April 30 next year
    const dueDateQuarterly = new Date(currentYear, 4, 15); // May 15 this year

    await db.insert(reportingTasks).values([
      {
        id: IDS.annualTask1Id,
        cycleId: IDS.fy2425CycleId,
        formId: IDS.annualStatsFormId,
        organizationType: "pso",
        title: "Annual Statistics Report - PSOs",
        description: "All PSOs must submit annual participant statistics",
        dueDate: dueDateAnnual.toISOString().slice(0, 10),
        reminderConfig: { daysBeforeDue: [30, 14, 7, 1] },
      },
      {
        id: IDS.annualTask2Id,
        cycleId: IDS.fy2425CycleId,
        formId: IDS.coachingFormId,
        organizationType: "pso",
        title: "Coaching Certification Report - PSOs",
        description: "Annual coaching certification data",
        dueDate: dueDateAnnual.toISOString().slice(0, 10),
        reminderConfig: { daysBeforeDue: [30, 14, 7] },
      },
      {
        id: IDS.annualTask3Id,
        cycleId: IDS.fy2425CycleId,
        formId: IDS.quarterlyFinFormId,
        organizationId: IDS.bcHockeyId,
        title: "Annual Financial Summary - BC Hockey",
        description: "Year-end financial summary for BC Hockey",
        dueDate: dueDateAnnual.toISOString().slice(0, 10),
        reminderConfig: { daysBeforeDue: [30, 14, 7, 1] },
      },
      {
        id: IDS.quarterlyTask1Id,
        cycleId: IDS.q12025CycleId,
        formId: IDS.quarterlyFinFormId,
        organizationType: "pso",
        title: "Q1 Financial Report - All PSOs",
        description: "Quarterly financial summary",
        dueDate: dueDateQuarterly.toISOString().slice(0, 10),
        reminderConfig: { daysBeforeDue: [14, 7, 1] },
      },
    ]);
    console.log("   ‚úì Created 4 reporting tasks\n");

    // ========================================
    // PHASE 9: Create sample submissions
    // ========================================
    console.log("Phase 9: Creating sample form submissions...");

    // Create a submission for BC Hockey
    const bcHockeySubmissionId = "00000000-0000-0000-0007-000000000001";
    await db.insert(formSubmissions).values({
      id: bcHockeySubmissionId,
      formId: IDS.annualStatsFormId,
      formVersionId: IDS.annualStatsFormV1Id,
      organizationId: IDS.bcHockeyId,
      submitterId: IDS.psoAdminId,
      status: "submitted",
      payload: {
        total_participants: 45000,
        male_participants: 28000,
        female_participants: 16500,
        other_participants: 500,
        youth_under_18: 32000,
        adults_18_plus: 13000,
        coaches_certified: 3200,
        events_held: 850,
        notes: "Growth of 8% in female participation this year.",
      },
      completenessScore: 100,
      submittedAt: new Date(),
    });

    await db.insert(reportingSubmissions).values({
      taskId: IDS.annualTask1Id,
      organizationId: IDS.bcHockeyId,
      formSubmissionId: bcHockeySubmissionId,
      status: "submitted",
      submittedAt: new Date(),
      submittedBy: IDS.psoAdminId,
    });
    console.log("   ‚úì BC Hockey annual stats (submitted)\n");

    // ========================================
    // PHASE 10: Create notification templates
    // ========================================
    console.log("Phase 10: Creating notification templates...");

    await db.insert(notificationTemplates).values([
      {
        key: "reporting_reminder",
        category: "reporting",
        subject: "Reminder: {{task_name}} due in {{days_remaining}} days",
        bodyTemplate: "Your organization has a pending report: {{task_name}}. Please submit by {{due_date}}.",
        isSystem: true,
      },
      {
        key: "submission_approved",
        category: "reporting",
        subject: "Report Approved: {{task_name}}",
        bodyTemplate: "Your submission for {{task_name}} has been approved. Thank you for your timely reporting.",
        isSystem: true,
      },
      {
        key: "changes_requested",
        category: "reporting",
        subject: "Changes Requested: {{task_name}}",
        bodyTemplate: "Your submission for {{task_name}} requires changes. Reviewer notes: {{review_notes}}",
        isSystem: true,
      },
      {
        key: "welcome_org_member",
        category: "account",
        subject: "Welcome to {{org_name}}",
        bodyTemplate: "You have been added as a {{role}} for {{org_name}}. Log in to access your dashboard.",
        isSystem: true,
      },
    ]);
    console.log("   ‚úì Created 4 notification templates\n");

    // ========================================
    // PHASE 11: Create policy documents
    // ========================================
    console.log("Phase 11: Creating policy documents...");

    await db.insert(policyDocuments).values([
      {
        id: IDS.privacyPolicyId,
        type: "privacy_policy",
        version: "1.0",
        contentHash: "sha256:abc123placeholder",
        effectiveDate: "2024-01-01",
        publishedAt: new Date("2024-01-01"),
        publishedBy: IDS.viasportStaffId,
      },
      {
        id: IDS.tosId,
        type: "terms_of_service",
        version: "1.0",
        contentHash: "sha256:def456placeholder",
        effectiveDate: "2024-01-01",
        publishedAt: new Date("2024-01-01"),
        publishedBy: IDS.viasportStaffId,
      },
    ]);
    console.log("   ‚úì Created privacy policy and terms of service\n");

    // ========================================
    // PHASE 12: Create retention policies
    // ========================================
    console.log("Phase 12: Creating retention policies...");

    await db.insert(retentionPolicies).values([
      { dataType: "audit_logs", retentionDays: 2555, archiveAfterDays: 365 }, // 7 years
      { dataType: "form_submissions", retentionDays: 1825, archiveAfterDays: 730 }, // 5 years
      { dataType: "user_sessions", retentionDays: 90 },
      { dataType: "notifications", retentionDays: 365 },
    ]);
    console.log("   ‚úì Created 4 retention policies\n");

    // ========================================
    // COMPLETE
    // ========================================
    console.log("=" .repeat(50));
    console.log("‚úÖ viaSport SIN test data seeded successfully!\n");
    console.log("Test Users (password: testpassword123):");
    console.log("  ‚Ä¢ admin@example.com - Platform Admin");
    console.log("  ‚Ä¢ viasport-staff@example.com - viaSport Staff");
    console.log("  ‚Ä¢ pso-admin@example.com - PSO Administrator");
    console.log("  ‚Ä¢ club-reporter@example.com - Club Reporter");
    console.log("  ‚Ä¢ member@example.com - Regular Member\n");
    console.log("Organizations created: 10 (1 governing body, 3 PSOs, 2 leagues, 4 clubs)");
    console.log("Forms created: 4 (3 published, 1 draft)");
    console.log("Reporting cycles: 3 (1 active, 1 closed, 1 upcoming)");
    console.log("=" .repeat(50));

  } catch (error) {
    console.error("‚ùå Error seeding SIN data:", error);
    throw error;
  } finally {
    await sql.end({ timeout: 3 });
    process.exit(0);
  }
}

seed().catch((error) => {
  console.error("Failed to seed:", error);
  process.exit(1);
});
</file>

<file path="src/features/auth/hooks/useAuth.ts">
import { useRouteContext } from "@tanstack/react-router";
import type { User } from "better-auth";

/**
 * Hook to access authentication state from route context
 *
 * @example
 * const { user, isAuthenticated } = useAuth();
 *
 * if (isAuthenticated) {
 *   // User is logged in
 * }
 */
export function useAuth() {
  const context = useRouteContext({ from: "__root__" });
  const user = context.user as User | null;

  return {
    user,
    isAuthenticated: !!user,
  };
}

/**
 * Hook that requires authentication and returns the user
 * Should only be used in components that are already protected by route guards
 *
 * @example
 * const user = useAuthenticatedUser(); // Will never be null
 */
export function useAuthenticatedUser(): User {
  const { user } = useAuth();

  if (!user) {
    throw new Error(
      "useAuthenticatedUser must be used within an authenticated route. " +
        "Make sure the route has proper auth guards in place.",
    );
  }

  return user;
}
</file>

<file path="src/lib/auth/guards/route-guards.ts">
import { redirect } from "@tanstack/react-router";
import type { User } from "better-auth";
import { requireCompleteProfile } from "~/features/profile/profile-guard";
import type { User as ExtendedUser } from "~/lib/auth/types";

/**
 * Route guard that requires authentication
 * Redirects to login page if user is not authenticated
 *
 * @example
 * export const Route = createFileRoute("/protected")({
 *   beforeLoad: async ({ context, location }) => {
 *     requireAuth({ user: context.user, location });
 *   },
 * });
 */
export function requireAuth({
  user,
  location,
  redirectTo = "/auth/login",
}: {
  user: User | null;
  location: { pathname: string };
  redirectTo?: string;
}) {
  if (!user) {
    throw redirect({
      to: redirectTo,
      search: {
        redirect: location.pathname,
      },
    });
  }
}

/**
 * Route guard that redirects authenticated users
 * Useful for login/signup pages
 *
 * @example
 * export const Route = createFileRoute("/auth/login")({
 *   beforeLoad: async ({ context }) => {
 *     redirectIfAuthenticated({ user: context.user });
 *   },
 * });
 */
export function redirectIfAuthenticated({
  user,
  redirectTo = "/dashboard",
}: {
  user: User | null;
  redirectTo?: string;
}) {
  if (user) {
    throw redirect({
      to: redirectTo,
    });
  }
}

/**
 * Composite guard that checks both auth and profile completion
 * Note: This expects the ExtendedUser type from route context which includes profile fields
 *
 * @example
 * export const Route = createFileRoute("/app/feature")({
 *   beforeLoad: async ({ context, location }) => {
 *     requireAuthAndProfile({ user: context.user, location });
 *   },
 * });
 */
export function requireAuthAndProfile({
  user,
  location,
}: {
  user: ExtendedUser | null;
  location: { pathname: string };
}) {
  // First check auth (will throw if user is null)
  requireAuth({ user, location });

  // Then check profile completion
  // The type assertion is safe because requireAuth would have thrown if user was null
  requireCompleteProfile(user as ExtendedUser);
}
</file>

<file path="docs/sin-rfp/phase-0/security-controls.md">
# SIN Security Controls Overview

## Document Control

| Item     | Value                       |
| -------- | --------------------------- |
| Document | Security Controls Overview  |
| Audience | viaSport BC Evaluation Team |
| Version  | 1.0                         |
| Scope    | Production SIN platform     |

## 1.0 Overview

The SIN platform will implement layered security controls covering identity,
authorization, data protection, monitoring, and incident response. Controls are
aligned to SEC-AGG-001 through SEC-AGG-004 and are designed for PIPEDA and
SOC 2/ISO 27001-aligned practices.

## 2.0 Identity and Access Management

Authentication:

- Email/password authentication with strong password policy
- Optional OAuth (Google) with consent-based enablement
- MFA (TOTP + backup codes) required for admins and optional for all users
- Secure account recovery with verified email and step-up controls

Session management:

- Max session age: 8 hours (admin: 4 hours)
- Idle timeout: 30 minutes
- Step-up authentication for sensitive actions (exports, role changes, DSAR)

## 3.0 Authorization and Tenancy

- Organization-based tenancy with scoped roles and delegated access
- Least-privilege enforcement at API and data layers
- Default deny posture for cross-organization access
- Field-level access policies for sensitive data
- Server-side feature gating to block tenant-ineligible endpoints even if URLs
  are guessed (UI, route, and server function enforcement).

## 4.0 Data Protection

- TLS 1.2+ in transit, TLS 1.3 where supported
- KMS-backed encryption at rest for RDS and S3
- Secrets stored in AWS Secrets Manager
- PII redaction and hashing for audit trails

## 5.0 Logging and Monitoring

- Append-only audit log with tamper-evident hashing
- Security event logging for authentication and admin actions
- Centralized logs and metrics in CloudWatch
- AWS CloudTrail for platform-level auditability

## 6.0 Threat Detection and Response

- Rate limiting and anomaly detection rules
- Account lockout thresholds for repeated failures
- GuardDuty alerts for suspicious infrastructure events
- Admin alerting for security incidents and lockouts

## 7.0 Secure SDLC and Operational Controls

- Infrastructure-as-code with SST for traceable deployments
- Dependency and vulnerability monitoring
- Segregated environments with controlled promotion
- Access restricted via IAM least-privilege roles

## 8.0 Incident Response (Outline)

1. Detection and triage (monitoring alerts, audit review)
2. Containment (account lock, access revocation)
3. Eradication (patch, credential rotation)
4. Recovery (restore services, validate integrity)
5. Communication (notify viaSport per policy)
6. Post-incident review and corrective actions

## 9.0 Requirements Mapping

| SIN Requirement | Control Alignment                   | Evidence/Deliverable           |
| --------------- | ----------------------------------- | ------------------------------ |
| SEC-AGG-001     | MFA, session policy, org-based RBAC | MFA workflows, RBAC guardrails |
| SEC-AGG-002     | Security events, lockouts, alerts   | Security event log + rules     |
| SEC-AGG-003     | Encryption, consent, retention      | KMS, TLS, privacy workflows    |
| SEC-AGG-004     | Immutable audit log, export         | Audit log UI + CSV export      |

## 10.0 References

- `docs/sin-rfp/SIN-REQUIREMENTS.md`
- `docs/sin-rfp/hosting-compliance.md`
- `docs/sin-rfp/phase-0/audit-retention-policy.md`
</file>

<file path="e2e/tests/authenticated/sin-admin-access.auth.spec.ts">
import { expect, test } from "@playwright/test";
import { clearAuthState, gotoWithAuth } from "../../utils/auth";

const tenantKey =
  process.env["TENANT_KEY"] ?? process.env["VITE_TENANT_KEY"] ?? "qc";
const isViaSport = tenantKey === "viasport";

test.describe("SIN admin access", () => {
  test("admin access respects tenant gating", async ({ page }) => {
    await clearAuthState(page);
    await gotoWithAuth(page, "/dashboard/admin/sin", {
      email: process.env["E2E_TEST_ADMIN_EMAIL"]!,
      password: process.env["E2E_TEST_ADMIN_PASSWORD"]!,
    });

    if (!isViaSport) {
      await expect(page).toHaveURL(/\/dashboard\/forbidden/);
      await expect(
        page.getByRole("heading", { name: "Access restricted" }),
      ).toBeVisible();
      return;
    }

    await expect(page.getByRole("heading", { name: "SIN Admin" })).toBeVisible();
    await expect(page.getByRole("link", { name: "Manage orgs" })).toBeVisible();
    await expect(page.getByRole("link", { name: "Open security" })).toBeVisible();
  });

  test("non-admin users are redirected to forbidden", async ({ page }) => {
    await clearAuthState(page);
    await gotoWithAuth(page, "/dashboard/admin/sin", {
      email: process.env["E2E_TEST_EMAIL"]!,
      password: process.env["E2E_TEST_PASSWORD"]!,
    });

    await expect(page).toHaveURL(/\/dashboard\/forbidden/);
    await expect(page.getByRole("heading", { name: "Access restricted" })).toBeVisible();
  });
});
</file>

<file path="scripts/seed-global-admins.ts">
#!/usr/bin/env tsx

import "dotenv/config";

import type { InferInsertModel } from "drizzle-orm";
import { and, eq, inArray, isNull } from "drizzle-orm";
import { drizzle } from "drizzle-orm/postgres-js";
import process from "node:process";
import postgres from "postgres";
import * as schema from "../src/db/schema";
import { roles, user, userRoles } from "../src/db/schema";
import { getTenantConfig } from "../src/tenant";

type UserRow = typeof user.$inferSelect;

const tenantConfig = getTenantConfig();
const tenantKey = tenantConfig.key;
const platformRoleName =
  tenantConfig.admin.globalRoleNames.find((name) => name === "Solstice Admin") ??
  "Solstice Admin";
const tenantRoleName =
  tenantConfig.admin.globalRoleNames.find((name) => name !== platformRoleName) ??
  (tenantKey === "viasport" ? "viaSport Admin" : "Quadball Canada Admin");

const PLATFORM_ADMIN_ROLE: InferInsertModel<typeof roles> = {
  id: "solstice-admin",
  name: platformRoleName,
  description: "Platform administrator with full system access",
  permissions: {
    "system:*": true,
    "roles:manage": true,
    "memberships:manage": true,
    "events:manage": true,
    "teams:manage": true,
    "reports:view": true,
  },
};

const TENANT_ADMIN_ROLE: InferInsertModel<typeof roles> =
  tenantKey === "viasport"
    ? {
        id: "viasport-admin",
        name: tenantRoleName,
        description: "viaSport administrator with organization-wide access",
        permissions: {
          "viasport:*": true,
          "reports:view": true,
        },
      }
    : {
        id: "quadball-canada-admin",
        name: tenantRoleName,
        description: "Quadball Canada administrator with organization-wide access",
        permissions: {
          "quadball_canada:*": true,
          "teams:manage": true,
          "events:manage": true,
          "members:manage": true,
          "memberships:manage": true,
          "reports:view": true,
        },
      };

const SCOPED_ADMIN_ROLES: Array<InferInsertModel<typeof roles>> = [
  {
    id: "team-admin",
    name: "Team Admin",
    description: "Administrator for a specific team",
    permissions: {
      "team:manage": true,
      "team:members:manage": true,
      "team:events:manage": true,
    },
  },
  {
    id: "event-admin",
    name: "Event Admin",
    description: "Administrator for a specific event",
    permissions: {
      "event:manage": true,
      "event:registrations:manage": true,
      "event:communications:manage": true,
    },
  },
];

const DEFAULT_ROLES: Array<InferInsertModel<typeof roles>> = [
  PLATFORM_ADMIN_ROLE,
  TENANT_ADMIN_ROLE,
  ...SCOPED_ADMIN_ROLES,
];

const roleNameToId = new Map(DEFAULT_ROLES.map((role) => [role.name, role.id]));

function parseCommaList(value: string | undefined): string[] {
  if (!value) return [];
  return value
    .split(",")
    .map((item) => item.trim())
    .filter((item) => item.length > 0);
}

function getArgValues(flag: string): string[] {
  const equalsArg = process.argv.find((arg) => arg.startsWith(`--${flag}=`));
  if (equalsArg) {
    const [, rawValue] = equalsArg.split("=");
    return parseCommaList(rawValue);
  }

  const flagIndex = process.argv.indexOf(`--${flag}`);
  if (flagIndex !== -1) {
    const values: string[] = [];
    for (let i = flagIndex + 1; i < process.argv.length; i++) {
      const next = process.argv[i];
      if (next.startsWith("--")) break;
      values.push(next);
    }
    return values;
  }

  return [];
}

function dedupe(values: string[]): string[] {
  return [...new Set(values.map((value) => value.toLowerCase()))];
}

function getAssignmentsFromInput() {
  const solsticeEmails = getArgValues("solstice");
  const tenantEmails =
    getArgValues("tenant").length > 0
      ? getArgValues("tenant")
      : tenantKey === "viasport"
        ? getArgValues("viasport")
        : getArgValues("quadball");

  const envSolsticeEmails = parseCommaList(process.env["SOLSTICE_ADMIN_EMAILS"]);
  const envTenantEmails = parseCommaList(
    process.env[tenantKey === "viasport" ? "VIASPORT_ADMIN_EMAILS" : "QUADBALL_ADMIN_EMAILS"],
  );
  const envGlobalAdminEmails = parseCommaList(process.env["GLOBAL_ADMIN_EMAILS"]);

  const pickNonEmpty = (primary: string[], fallback: string[]) =>
    primary.length > 0 ? primary : fallback;

  const solstice = dedupe(pickNonEmpty(solsticeEmails, envSolsticeEmails));
  const tenant = dedupe(pickNonEmpty(tenantEmails, pickNonEmpty(envTenantEmails, envGlobalAdminEmails)));

  return {
    solstice,
    tenant,
  };
}

function getConnectionString(): string {
  const candidates = [
    process.env["DATABASE_URL_UNPOOLED"],
    process.env["DATABASE_UNPOOLED_URL"],
    process.env["NETLIFY_DATABASE_URL_UNPOOLED"],
    process.env["DATABASE_URL"],
    process.env["DATABASE_POOLED_URL"],
    process.env["NETLIFY_DATABASE_URL"],
  ];

  const connectionString = candidates.find(
    (value) => typeof value === "string" && value.length > 0,
  );
  if (!connectionString) {
    throw new Error(
      "No database connection string found. Set DATABASE_URL (or *_UNPOOLED) before running this script.",
    );
  }

  return connectionString;
}

async function ensureRoles(db: ReturnType<typeof drizzle>) {
  console.log("\nüõ†Ô∏è  Ensuring default roles exist...");

  await db
    .insert(roles)
    .values(DEFAULT_ROLES)
    .onConflictDoUpdate({
      target: roles.id,
      set: {
        name: roles.name,
        description: roles.description,
        permissions: roles.permissions,
        updatedAt: new Date(),
      },
    });

  const defaultRoleIds = DEFAULT_ROLES.map((role) => role.id).filter(
    (roleId): roleId is string => Boolean(roleId),
  );
  const existingRoles = await db
    .select()
    .from(roles)
    .where(inArray(roles.id, defaultRoleIds));
  existingRoles.forEach((role) => {
    console.log(`  ‚Ä¢ ${role.name} (${role.id})`);
  });

  return existingRoles;
}

async function findUsersByEmail(
  db: ReturnType<typeof drizzle>,
  emails: string[],
): Promise<UserRow[]> {
  if (!emails.length) return [];
  const normalized = emails.map((value) => value.toLowerCase());
  const rows = await db.select().from(user).where(inArray(user.email, normalized));

  const missing = normalized.filter(
    (email) => !rows.some((row) => row.email.toLowerCase() === email),
  );
  missing.forEach((email) => {
    console.warn(`‚ö†Ô∏è  No user found for email: ${email}`);
  });

  return rows;
}

async function getAssignerUserId(db: ReturnType<typeof drizzle>): Promise<string | null> {
  const assignerArg = getArgValues("assigner");
  const assignerEnv = parseCommaList(process.env["ROLE_ASSIGNER_EMAIL"]);
  const assignerCandidates = dedupe(assignerArg.length ? assignerArg : assignerEnv);

  if (!assignerCandidates.length) {
    return null;
  }

  const assignerUsers = await findUsersByEmail(db, assignerCandidates);
  if (!assignerUsers.length) {
    console.warn(
      `‚ö†Ô∏è  Could not find assigner user for provided email(s): ${assignerCandidates.join(", ")}. Falling back to self-assignment.`,
    );
    return null;
  }

  if (assignerUsers.length > 1) {
    console.warn(
      `‚ö†Ô∏è  Multiple assigner users found (${assignerUsers.map((user) => user.email).join(", ")}). Using the first entry.`,
    );
  }

  const assignerUser = assignerUsers[0];
  const assignerHasGlobalRole = await db
    .select({ id: userRoles.id })
    .from(userRoles)
    .where(
      and(
        eq(userRoles.userId, assignerUser.id),
        isNull(userRoles.teamId),
        isNull(userRoles.eventId),
      ),
    )
    .limit(1);

  if (!assignerHasGlobalRole.length) {
    console.warn(
      `‚ö†Ô∏è  Assigner ${assignerUser.email} does not currently hold a global admin role. The assignment will still proceed but the audit trail may appear odd.`,
    );
  }

  return assignerUser.id;
}

async function assignRoles(
  db: ReturnType<typeof drizzle>,
  assignments: Array<{ email: string; roleName: string }>,
  assignerUserId: string | null,
) {
  if (!assignments.length) {
    console.log("No role assignments requested. Skipping role assignment.");
    return;
  }

  const uniqueEmails = dedupe(assignments.map((assignment) => assignment.email));
  const users = await findUsersByEmail(db, uniqueEmails);
  const userByEmail = new Map(users.map((user) => [user.email.toLowerCase(), user]));

  const timestamp = new Date().toISOString();
  for (const assignment of assignments) {
    const userRecord = userByEmail.get(assignment.email.toLowerCase());
    if (!userRecord) {
      console.warn(`‚ö†Ô∏è  Skipping ${assignment.email} ‚Äì user not found.`);
      continue;
    }

    const roleId = roleNameToId.get(assignment.roleName);
    let resolvedRoleId = roleId;

    if (!resolvedRoleId) {
      const [roleRow] = await db
        .select({ id: roles.id })
        .from(roles)
        .where(eq(roles.name, assignment.roleName))
        .limit(1);

      if (!roleRow) {
        console.warn(
          `‚ö†Ô∏è  Skipping ${assignment.email} ‚Äì role ${assignment.roleName} not found.`,
        );
        continue;
      }

      resolvedRoleId = roleRow.id;
    }

    const [existingAssignment] = await db
      .select({ id: userRoles.id })
      .from(userRoles)
      .where(
        and(
          eq(userRoles.userId, userRecord.id),
          eq(userRoles.roleId, resolvedRoleId),
          isNull(userRoles.teamId),
          isNull(userRoles.eventId),
        ),
      )
      .limit(1);

    if (existingAssignment) {
      console.log(
        `‚ÑπÔ∏è  ${assignment.email} already has ${assignment.roleName}. Skipping.`,
      );
      continue;
    }

    const assignedBy = assignerUserId ?? userRecord.id;

    await db.insert(userRoles).values({
      userId: userRecord.id,
      roleId: resolvedRoleId,
      assignedBy,
      notes: `Seeded via seed-global-admins.ts on ${timestamp}`,
    });

    console.log(`‚úÖ Assigned ${assignment.roleName} to ${assignment.email}`);
  }
}

async function main() {
  console.log("üå± Running global admin role seed script...");

  const assignmentsInput = getAssignmentsFromInput();
  const assignments: Array<{ email: string; roleName: string }> = [];

  assignmentsInput.solstice.forEach((email) => {
    assignments.push({ email, roleName: platformRoleName });
  });

  assignmentsInput.tenant.forEach((email) => {
    assignments.push({ email, roleName: tenantRoleName });
  });

  const connectionString = getConnectionString();
  const sql = postgres(connectionString, { max: 1 });
  const db = drizzle(sql, { schema, casing: "snake_case" });

  try {
    const ensuredRoles = await ensureRoles(db);
    const roleNames = ensuredRoles.map((role) => role.name).join(", ");
    console.log(`‚úÖ Roles ensured: ${roleNames}`);

    if (!assignments.length) {
      console.log(
        "No admin emails provided via flags or environment. The script ensured roles exist and will now exit.",
      );
      return;
    }

    const assignerUserId = await getAssignerUserId(db);
    await assignRoles(db, assignments, assignerUserId);
  } catch (error) {
    console.error("‚ùå Failed to seed global admins:", error);
    process.exitCode = 1;
  } finally {
    await sql.end({ timeout: 3 });
  }
}

main().catch((error) => {
  console.error("Unexpected error:", error);
  process.exit(1);
});
</file>

<file path="src/features/auth/__tests__/login-with-router.test.tsx">
import userEvent from "@testing-library/user-event";
import { beforeEach, describe, expect, it, vi } from "vitest";
import { auth } from "~/lib/auth-client";
import { renderWithRouter, screen, waitFor } from "~/tests/utils";
import LoginForm from "../components/login";

// Mock auth client
vi.mock("~/lib/auth-client", () => ({
  auth: {
    signIn: {
      email: vi.fn(),
    },
    signInWithOAuth: vi.fn(),
  },
}));

vi.mock("~/features/security/security.mutations", () => ({
  recordSecurityEvent: vi.fn(),
}));

vi.mock("~/features/security/security.queries", () => ({
  getAccountLockStatus: vi.fn().mockResolvedValue(null),
}));

describe("LoginForm with TanStack Router", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("renders login form in router context", async () => {
    await renderWithRouter(<LoginForm />);

    expect(screen.getByLabelText("Email")).toBeInTheDocument();
    expect(screen.getByLabelText("Password")).toBeInTheDocument();
    expect(screen.getByRole("button", { name: "Login" })).toBeInTheDocument();
  });

  it("handles navigation with router context", async () => {
    const user = userEvent.setup();

    // Mock successful login
    vi.mocked(auth.signIn.email).mockImplementation((data, handlers) => {
      handlers?.onSuccess?.({ data: { user: {}, session: {} } } as Parameters<
        NonNullable<typeof handlers.onSuccess>
      >[0]);
      return Promise.resolve({ data: { user: {}, session: {} }, error: null });
    });

    const { router } = await renderWithRouter(<LoginForm />);

    // Fill and submit form
    await user.type(screen.getByLabelText("Email"), "test@example.com");
    await user.type(screen.getByLabelText("Password"), "password123");
    await user.click(screen.getByRole("button", { name: "Login" }));

    await waitFor(() => {
      expect(auth.signIn.email).toHaveBeenCalled();
    });

    // In a real router test, we would check navigation
    // But since LoginForm uses router hooks that we need to mock,
    // we'll verify the router exists
    expect(router).toBeDefined();
  });

  it("renders with custom user context", async () => {
    const customUser = {
      id: "custom-user",
      name: "Custom User",
      email: "custom@example.com",
      emailVerified: true,
      image: null,
      createdAt: new Date(),
      updatedAt: new Date(),
      profileComplete: true,
      dateOfBirth: new Date("1990-01-01"),
      phone: "+1234567890",
      gender: "male" as const,
      pronouns: "he/him",
      emergencyContact: JSON.stringify({
        name: "Emergency Contact",
        phone: "+0987654321",
        relationship: "spouse",
      }),
      privacySettings: JSON.stringify({
        showEmail: false,
        showPhone: false,
        showDateOfBirth: false,
      }),
      profileVersion: 1,
      profileUpdatedAt: new Date(),
      mfaRequired: false,
      mfaEnrolledAt: null,
      twoFactorEnabled: false,
    };

    await renderWithRouter(<LoginForm />, { user: customUser });

    // Component should still render
    expect(screen.getByLabelText("Email")).toBeInTheDocument();
  });

  it("has access to query client", async () => {
    const { queryClient } = await renderWithRouter(<LoginForm />);

    expect(queryClient).toBeDefined();
    expect(queryClient?.getDefaultOptions()).toBeDefined();
  });
});
</file>

<file path="src/features/auth/__tests__/signup-with-router.test.tsx">
import userEvent from "@testing-library/user-event";
import { beforeEach, describe, expect, it, vi } from "vitest";
import { auth } from "~/lib/auth-client";
import { renderWithRouter, screen, waitFor } from "~/tests/utils";
import SignupForm from "../components/signup";

// Mock auth client
vi.mock("~/lib/auth-client", () => ({
  auth: {
    signUp: {
      email: vi.fn(),
    },
    signInWithOAuth: vi.fn(),
  },
}));

describe("SignupForm with Router", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("renders signup form with all fields", async () => {
    await renderWithRouter(<SignupForm />);

    expect(screen.getByLabelText("Name")).toBeInTheDocument();
    expect(screen.getByLabelText("Email")).toBeInTheDocument();
    expect(screen.getByLabelText("Password")).toBeInTheDocument();
    expect(screen.getByLabelText("Confirm Password")).toBeInTheDocument();
    expect(screen.getByRole("button", { name: "Sign up" })).toBeInTheDocument();
  });

  it("validates password confirmation", async () => {
    const user = userEvent.setup();

    await renderWithRouter(<SignupForm />);

    // Fill form with mismatched passwords
    await user.type(screen.getByLabelText("Name"), "Test User");
    await user.type(screen.getByLabelText("Email"), "test@example.com");
    await user.type(screen.getByLabelText("Password"), "password123");
    await user.type(screen.getByLabelText("Confirm Password"), "password456");

    await user.click(screen.getByRole("button", { name: "Sign up" }));

    // Should show password mismatch error
    await waitFor(() => {
      expect(screen.getByText(/passwords do not match/i)).toBeInTheDocument();
    });

    // Auth should not be called
    expect(auth.signUp.email).not.toHaveBeenCalled();
  });

  it("handles successful signup", async () => {
    const user = userEvent.setup();

    vi.mocked(auth.signUp.email).mockImplementation((data, handlers) => {
      handlers?.onSuccess?.({ data: { user: {}, session: {} } } as Parameters<
        NonNullable<typeof handlers.onSuccess>
      >[0]);
      return Promise.resolve({ data: { user: {}, session: {} }, error: null });
    });

    const { router } = await renderWithRouter(<SignupForm />);

    // Fill form correctly
    await user.type(screen.getByLabelText("Name"), "New User");
    await user.type(screen.getByLabelText("Email"), "newuser@example.com");
    await user.type(screen.getByLabelText("Password"), "securepassword123");
    await user.type(screen.getByLabelText("Confirm Password"), "securepassword123");

    await user.click(screen.getByRole("button", { name: "Sign up" }));

    await waitFor(() => {
      expect(auth.signUp.email).toHaveBeenCalledWith(
        expect.objectContaining({
          email: "newuser@example.com",
          password: "securepassword123",
          name: "New User",
          callbackURL: "/dashboard",
        }),
      );
    });

    // Verify router exists for navigation
    expect(router).toBeDefined();
  });

  it("displays login link", async () => {
    await renderWithRouter(<SignupForm />);

    const loginLink = screen.getByRole("link", { name: "Login" });
    expect(loginLink).toHaveAttribute("href", "/auth/login");
  });

  it("handles OAuth signup", async () => {
    const user = userEvent.setup();

    vi.mocked(auth.signInWithOAuth).mockResolvedValue(
      {} as ReturnType<typeof auth.signInWithOAuth>,
    );

    await renderWithRouter(<SignupForm />);

    const googleButton = screen.getByRole("button", { name: /sign up with google/i });
    await user.click(googleButton);

    expect(auth.signInWithOAuth).toHaveBeenCalledWith(
      expect.objectContaining({
        provider: "google",
      }),
      expect.any(Object),
    );
  });
});
</file>

<file path="src/features/auth/hooks/useAuthForm.ts">
import { useQueryClient } from "@tanstack/react-query";
import { useNavigate, useRouter } from "@tanstack/react-router";
import { useState } from "react";
import { authQueryKey } from "../auth.queries";

interface UseAuthFormOptions {
  redirectUrl?: string;
}

/**
 * Custom hook for handling authentication form state and navigation
 * Reduces repetitive code in login and signup components
 *
 * @example
 * const { isLoading, errorMessage, handleAuth } = useAuthForm();
 *
 * const onSubmit = async (e) => {
 *   await handleAuth(async () => {
 *     // Your auth logic here
 *   });
 * };
 */
export function useAuthForm(options: UseAuthFormOptions = {}) {
  const { redirectUrl = "/dashboard" } = options;
  const [isLoading, setIsLoading] = useState(false);
  const [errorMessage, setErrorMessage] = useState("");
  const queryClient = useQueryClient();
  const navigate = useNavigate();
  const router = useRouter();

  const handleAuth = async (
    authFunction: () => Promise<void>,
    onError?: (error: unknown) => void,
  ) => {
    setIsLoading(true);
    setErrorMessage("");

    try {
      await authFunction();
      // Success is handled by the auth function's onSuccess callback
    } catch (error) {
      const message = error instanceof Error ? error.message : "Authentication failed";
      setErrorMessage(message);
      onError?.(error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleAuthSuccess = async () => {
    queryClient.invalidateQueries({ queryKey: authQueryKey });
    await router.invalidate();
    navigate({ to: redirectUrl });
  };

  const resetError = () => setErrorMessage("");

  return {
    isLoading,
    errorMessage,
    handleAuth,
    handleAuthSuccess,
    resetError,
    setErrorMessage,
    setIsLoading,
  };
}
</file>

<file path="src/features/auth/mfa/mfa-enrollment.tsx">
import { useState } from "react";
import QRCode from "react-qr-code";
import { Button } from "~/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";
import { Input } from "~/components/ui/input";
import { auth } from "~/lib/auth-client";
import { markMfaEnrolled } from "./mfa.mutations";

export function MfaEnrollmentCard() {
  const [password, setPassword] = useState("");
  const [totpUri, setTotpUri] = useState("");
  const [backupCodes, setBackupCodes] = useState<string[]>([]);
  const [verificationCode, setVerificationCode] = useState("");
  const [errorMessage, setErrorMessage] = useState("");
  const [verifyError, setVerifyError] = useState("");
  const [backupCodeError, setBackupCodeError] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [isVerifying, setIsVerifying] = useState(false);
  const [isRegenerating, setIsRegenerating] = useState(false);
  const [isVerified, setIsVerified] = useState(false);

  const handleEnable = async () => {
    setIsLoading(true);
    setErrorMessage("");
    try {
      const result = await auth.twoFactor.enable({ password });
      if (result?.error) {
        throw new Error(result.error.message || "Failed to enable MFA");
      }
      setTotpUri(result?.data?.totpURI ?? "");
      setBackupCodes(result?.data?.backupCodes ?? []);
    } catch (error) {
      setErrorMessage((error as Error)?.message || "Failed to enable MFA");
    } finally {
      setIsLoading(false);
    }
  };

  const handleVerify = async () => {
    setIsVerifying(true);
    setVerifyError("");
    try {
      const result = await auth.twoFactor.verifyTotp({ code: verificationCode });
      if (result?.error) {
        throw new Error(result.error.message || "Invalid verification code");
      }
      await markMfaEnrolled();
      setIsVerified(true);
    } catch (error) {
      setVerifyError((error as Error)?.message || "Failed to verify MFA");
    } finally {
      setIsVerifying(false);
    }
  };

  const handleRegenerateBackupCodes = async () => {
    if (!password) {
      setBackupCodeError("Password required to regenerate backup codes.");
      return;
    }

    setIsRegenerating(true);
    setBackupCodeError("");
    try {
      const result = await auth.twoFactor.generateBackupCodes({ password });
      if (result?.error) {
        throw new Error(result.error.message || "Failed to regenerate backup codes");
      }
      setBackupCodes(result?.data?.backupCodes ?? []);
    } catch (error) {
      setBackupCodeError(
        (error as Error)?.message || "Failed to regenerate backup codes",
      );
    } finally {
      setIsRegenerating(false);
    }
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>Multi-Factor Authentication</CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="space-y-2">
          <label className="text-sm font-medium" htmlFor="mfa-password">
            Confirm your password
          </label>
          <Input
            id="mfa-password"
            type="password"
            value={password}
            onChange={(event) => setPassword(event.target.value)}
            placeholder="Enter your password"
          />
        </div>
        <Button onClick={handleEnable} disabled={isLoading || !password}>
          {isLoading ? "Enabling..." : "Enable MFA"}
        </Button>

        {totpUri && (
          <div className="space-y-3 rounded-md border border-gray-200 p-3 text-sm">
            <div>
              <p className="font-semibold">Scan QR code</p>
              <p className="text-muted-foreground text-xs">
                Use your authenticator app to scan this code.
              </p>
            </div>
            <div className="w-fit rounded-md border bg-white p-3">
              <QRCode value={totpUri} size={160} />
            </div>
            <div>
              <p className="font-semibold">TOTP URI</p>
              <p className="text-muted-foreground text-xs break-all">{totpUri}</p>
            </div>
          </div>
        )}

        {backupCodes.length > 0 && (
          <div className="space-y-2 rounded-md border border-gray-200 p-3 text-sm">
            <p className="font-semibold">Backup codes</p>
            <p className="text-muted-foreground text-xs">
              Save these codes now. Each code can be used once.
            </p>
            <ul className="text-muted-foreground list-inside list-disc text-xs">
              {backupCodes.map((code) => (
                <li key={code}>{code}</li>
              ))}
            </ul>
            <Button
              type="button"
              variant="outline"
              size="sm"
              onClick={handleRegenerateBackupCodes}
              disabled={isRegenerating}
            >
              {isRegenerating ? "Regenerating..." : "Regenerate codes"}
            </Button>
            {backupCodeError ? (
              <p className="text-destructive text-xs">{backupCodeError}</p>
            ) : null}
          </div>
        )}

        {totpUri ? (
          <div className="space-y-3">
            <label className="text-sm font-medium" htmlFor="mfa-verify">
              Enter the code from your authenticator app
            </label>
            <Input
              id="mfa-verify"
              value={verificationCode}
              onChange={(event) => setVerificationCode(event.target.value.trim())}
              placeholder="123456"
              inputMode="numeric"
            />
            <Button
              type="button"
              onClick={handleVerify}
              disabled={!verificationCode || isVerifying}
            >
              {isVerifying ? "Verifying..." : "Verify MFA"}
            </Button>
            {isVerified ? (
              <p className="text-sm text-emerald-600">MFA verified and enabled.</p>
            ) : null}
            {verifyError ? (
              <p className="text-destructive text-sm">{verifyError}</p>
            ) : null}
          </div>
        ) : null}

        {errorMessage && <p className="text-destructive text-sm">{errorMessage}</p>}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/auth/mfa/mfa-recovery.tsx">
import { useState } from "react";
import { Button } from "~/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "~/components/ui/card";
import { Input } from "~/components/ui/input";
import { auth } from "~/lib/auth-client";

export function MfaRecoveryCard() {
  const [code, setCode] = useState("");
  const [errorMessage, setErrorMessage] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  const handleVerify = async () => {
    setIsLoading(true);
    setErrorMessage("");
    try {
      const result = await auth.twoFactor.verifyBackupCode({ code });
      if (result?.error) {
        throw new Error(result.error.message || "Invalid backup code");
      }
    } catch (error) {
      setErrorMessage((error as Error)?.message || "Invalid backup code");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>Use Backup Code</CardTitle>
      </CardHeader>
      <CardContent className="space-y-3">
        <Input
          value={code}
          onChange={(event) => setCode(event.target.value.trim())}
          placeholder="Enter backup code"
        />
        <Button onClick={handleVerify} disabled={isLoading || !code}>
          {isLoading ? "Verifying..." : "Verify backup code"}
        </Button>
        {errorMessage && <p className="text-destructive text-sm">{errorMessage}</p>}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/auth/mfa/mfa.mutations.ts">
import { createServerFn } from "@tanstack/react-start";

export const markMfaEnrolled = createServerFn({ method: "POST" }).handler(async () => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const { getRequest } = await import("@tanstack/react-start/server");
  const auth = await getAuth();
  const { headers } = getRequest();
  const session = await auth.api.getSession({ headers });

  if (!session?.user?.id) return null;

  const { getDb } = await import("~/db/server-helpers");
  const { user } = await import("~/db/schema");
  const { eq } = await import("drizzle-orm");
  const db = await getDb();

  const [updated] = await db
    .update(user)
    .set({ mfaEnrolledAt: new Date() })
    .where(eq(user.id, session.user.id))
    .returning();

  if (updated) {
    const { logAuthEvent } = await import("~/lib/audit");
    await logAuthEvent({
      action: "AUTH.MFA_ENROLL",
      actorUserId: session.user.id,
      targetType: "user",
      targetId: session.user.id,
    });
  }

  return updated ?? null;
});
</file>

<file path="src/features/auth/index.ts">
// Export auth hooks
export { useAuth, useAuthenticatedUser } from "./hooks/useAuth";

// Export components (default exports)
export { default as Login } from "./components/login";
export { default as Signup } from "./components/signup";

// Route guard utilities are available in ~/lib/auth/guards/route-guards
</file>

<file path="src/features/auth/step-up.tsx">
import {
  FormEvent,
  ReactNode,
  createContext,
  use,
  useCallback,
  useEffect,
  useMemo,
  useState,
} from "react";
import { toast } from "sonner";
import { FormSubmitButton } from "~/components/form-fields/FormSubmitButton";
import { Button } from "~/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "~/components/ui/dialog";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";
import { auth } from "~/lib/auth-client";

type StepUpContextValue = {
  requestStepUp: (reason?: string) => void;
};

const StepUpContext = createContext<StepUpContextValue | null>(null);

const STEP_UP_MESSAGES = [
  "Re-authentication required for this action",
  "MFA re-verification required for this action",
];

export const getStepUpErrorMessage = (error: unknown) => {
  if (!error) return null;
  const message =
    error instanceof Error
      ? error.message
      : typeof error === "string"
        ? error
        : typeof error === "object" && "message" in error
          ? String((error as { message?: unknown }).message ?? "")
          : "";

  if (!message) return null;
  return STEP_UP_MESSAGES.find((match) => message.includes(match)) ?? null;
};

export function StepUpProvider({ children }: { readonly children: ReactNode }) {
  const [open, setOpen] = useState(false);
  const [reason, setReason] = useState<string | null>(null);

  const requestStepUp = useCallback((message?: string) => {
    setReason(message ?? "Re-authentication required for this action");
    setOpen(true);
  }, []);

  const handleOpenChange = useCallback((nextOpen: boolean) => {
    setOpen(nextOpen);
    if (!nextOpen) {
      setReason(null);
    }
  }, []);

  const value = useMemo(() => ({ requestStepUp }), [requestStepUp]);

  return (
    <StepUpContext value={value}>
      {children}
      <StepUpDialog open={open} reason={reason} onOpenChange={handleOpenChange} />
    </StepUpContext>
  );
}

export const useStepUpPrompt = () => {
  const context = use(StepUpContext);
  if (!context) {
    throw new Error("StepUpProvider is missing from the component tree.");
  }
  return context;
};

function StepUpDialog({
  open,
  reason,
  onOpenChange,
}: {
  open: boolean;
  reason: string | null;
  onOpenChange: (open: boolean) => void;
}) {
  const [email, setEmail] = useState("");
  const [emailLocked, setEmailLocked] = useState(false);
  const [password, setPassword] = useState("");
  const [code, setCode] = useState("");
  const [step, setStep] = useState<"password" | "mfa">("password");
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [errorMessage, setErrorMessage] = useState("");

  const resetState = useCallback(() => {
    setPassword("");
    setCode("");
    setStep("password");
    setIsSubmitting(false);
    setErrorMessage("");
  }, []);

  const handleDialogOpenChange = useCallback(
    (nextOpen: boolean) => {
      if (!nextOpen) {
        resetState();
      }
      onOpenChange(nextOpen);
    },
    [onOpenChange, resetState],
  );

  useEffect(() => {
    if (!open) {
      return;
    }

    let isActive = true;

    const loadSessionEmail = async () => {
      try {
        const result = await auth.getSession();
        const sessionEmail = result?.data?.user?.email;
        if (!isActive) return;
        if (sessionEmail) {
          setEmail(sessionEmail);
          setEmailLocked(true);
        } else {
          setEmail("");
          setEmailLocked(false);
        }
      } catch {
        if (!isActive) return;
        setEmailLocked(false);
      }
    };

    void loadSessionEmail();

    return () => {
      isActive = false;
    };
  }, [open]);

  const handlePasswordSubmit = async (event: FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    setIsSubmitting(true);
    setErrorMessage("");

    if (!email.trim() || !password) {
      setErrorMessage("Email and password are required.");
      setIsSubmitting(false);
      return;
    }

    try {
      const result = await auth.signIn.email({ email: email.trim(), password });

      if (result?.error) {
        throw new Error(result.error.message || "Authentication failed");
      }

      if (
        result?.data &&
        "twoFactorRedirect" in result.data &&
        result.data.twoFactorRedirect
      ) {
        setStep("mfa");
        setIsSubmitting(false);
        return;
      }

      toast.success("Re-authenticated. Please retry the action.");
      onOpenChange(false);
    } catch (error) {
      setErrorMessage(error instanceof Error ? error.message : "Authentication failed");
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleMfaSubmit = async (event: FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    setIsSubmitting(true);
    setErrorMessage("");

    if (!code.trim()) {
      setErrorMessage("Authentication code is required.");
      setIsSubmitting(false);
      return;
    }

    try {
      const result = await auth.twoFactor.verifyTotp({ code: code.trim() });
      if (result?.error) {
        throw new Error(result.error.message || "Invalid authentication code");
      }

      toast.success("Re-authenticated. Please retry the action.");
      onOpenChange(false);
    } catch (error) {
      setErrorMessage(
        error instanceof Error ? error.message : "Authentication verification failed",
      );
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={handleDialogOpenChange}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>Confirm your identity</DialogTitle>
          <DialogDescription>
            {reason ?? "Re-authentication is required to continue this action."}
          </DialogDescription>
        </DialogHeader>

        {step === "password" ? (
          <form onSubmit={handlePasswordSubmit} className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="step-up-email">Email</Label>
              <Input
                id="step-up-email"
                type="email"
                value={email}
                disabled={emailLocked || isSubmitting}
                onChange={(event) => setEmail(event.target.value)}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="step-up-password">Password</Label>
              <Input
                id="step-up-password"
                type="password"
                value={password}
                disabled={isSubmitting}
                onChange={(event) => setPassword(event.target.value)}
              />
            </div>
            {errorMessage ? (
              <p className="text-destructive text-sm">{errorMessage}</p>
            ) : null}
            <DialogFooter className="gap-2 sm:justify-end">
              <Button type="button" variant="ghost" onClick={() => onOpenChange(false)}>
                Cancel
              </Button>
              <FormSubmitButton isSubmitting={isSubmitting} loadingText="Confirming...">
                Continue
              </FormSubmitButton>
            </DialogFooter>
          </form>
        ) : (
          <form onSubmit={handleMfaSubmit} className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="step-up-code">Authentication code</Label>
              <Input
                id="step-up-code"
                inputMode="numeric"
                autoComplete="one-time-code"
                value={code}
                disabled={isSubmitting}
                onChange={(event) => setCode(event.target.value)}
              />
            </div>
            {errorMessage ? (
              <p className="text-destructive text-sm">{errorMessage}</p>
            ) : null}
            <DialogFooter className="gap-2 sm:justify-end">
              <Button type="button" variant="ghost" onClick={() => setStep("password")}>
                Back
              </Button>
              <FormSubmitButton isSubmitting={isSubmitting} loadingText="Verifying...">
                Verify
              </FormSubmitButton>
            </DialogFooter>
          </form>
        )}
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/lib/auth/guards/org-context.ts">
import { createMiddleware } from "@tanstack/react-start";

const getSessionUserId = async (headers: Headers) => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const auth = await getAuth();
  const session = await auth.api.getSession({ headers });
  return session?.user?.id ?? null;
};

const getCookieValue = (headers: Headers, name: string) => {
  const cookieHeader = headers.get("cookie");
  if (!cookieHeader) return null;
  const cookies = cookieHeader.split(";").map((entry) => entry.trim());
  const prefix = `${name}=`;
  for (const cookie of cookies) {
    if (cookie.startsWith(prefix)) {
      return decodeURIComponent(cookie.slice(prefix.length));
    }
  }
  return null;
};

export const orgContextMiddleware = createMiddleware({ type: "function" })
  .client(async ({ next }) => {
    const activeOrganizationId =
      typeof window === "undefined"
        ? undefined
        : window.localStorage.getItem("active_org_id") ?? undefined;
    return next({
      sendContext: {
        activeOrganizationId,
      },
    });
  })
  .server(async ({ next, context }) => {
    const { getRequest } = await import("@tanstack/react-start/server");
    const request = getRequest();
    const headers = request.headers;
    const userId = await getSessionUserId(headers);

    const contextOrgId = (context as { activeOrganizationId?: string } | undefined)
      ?.activeOrganizationId;
    const headerOrgId = headers.get("x-organization-id");
    const cookieOrgId = getCookieValue(headers, "active_org_id");
    const requestedOrgId = headerOrgId ?? contextOrgId ?? cookieOrgId ?? null;

    let resolvedOrgId: string | null = null;
    let resolvedRole: string | null = null;

    if (requestedOrgId && userId) {
      const { resolveOrganizationAccess } = await import(
        "~/features/organizations/organizations.access"
      );
      const access = await resolveOrganizationAccess({
        userId,
        organizationId: requestedOrgId,
      });
      if (access) {
        resolvedOrgId = access.organizationId;
        resolvedRole = access.role;
      }
    }

    return next({
      context: {
        ...(context as Record<string, unknown> | undefined),
        userId,
        organizationId: resolvedOrgId,
        organizationRole: resolvedRole,
      },
    });
  });
</file>

<file path="src/lib/auth/guards/org-guard.ts">
import { forbidden, unauthorized } from "~/lib/server/errors";

export type OrganizationRole = "owner" | "admin" | "reporter" | "viewer" | "member";

export const ORG_ADMIN_ROLES: OrganizationRole[] = ["owner", "admin"];

type MembershipLookup = {
  userId: string;
  organizationId: string;
};

export async function getOrganizationMembership({
  userId,
  organizationId,
}: MembershipLookup) {
  const { getDb } = await import("~/db/server-helpers");
  const { organizationMembers } = await import("~/db/schema");
  const { and, eq } = await import("drizzle-orm");

  const db = await getDb();
  const [membership] = await db
    .select()
    .from(organizationMembers)
    .where(
      and(
        eq(organizationMembers.userId, userId),
        eq(organizationMembers.organizationId, organizationId),
      ),
    )
    .limit(1);

  return membership ?? null;
}

export async function requireOrganizationMembership(
  { userId, organizationId }: MembershipLookup,
  options?: { roles?: OrganizationRole[]; allowPending?: boolean },
) {
  if (!userId) {
    throw unauthorized("User not authenticated");
  }

  const membership = await getOrganizationMembership({ userId, organizationId });

  if (!membership) {
    throw forbidden("Organization membership required");
  }

  if (!options?.allowPending && membership.status !== "active") {
    throw forbidden("Organization membership is not active");
  }

  if (options?.roles && !options.roles.includes(membership.role as OrganizationRole)) {
    throw forbidden("Insufficient organization role");
  }

  return membership;
}

export async function requireOrganizationAccess(
  { userId, organizationId }: MembershipLookup,
  options?: { roles?: OrganizationRole[] },
) {
  if (!userId) {
    throw unauthorized("User not authenticated");
  }

  const { resolveOrganizationAccess } = await import(
    "~/features/organizations/organizations.access"
  );
  const access = await resolveOrganizationAccess({ userId, organizationId });

  if (!access) {
    throw forbidden("Organization access required");
  }

  if (options?.roles && !options.roles.includes(access.role as OrganizationRole)) {
    throw forbidden("Insufficient organization role");
  }

  return access;
}
</file>

<file path="src/lib/auth/guards/step-up.ts">
import { forbidden } from "~/lib/server/errors";

// Default re-auth window: 15 minutes
const REAUTH_WINDOW_MS = 15 * 60 * 1000;

/**
 * Extract session timestamps from Better Auth session.
 * Better Auth stores timestamps in various formats depending on version/config.
 * This function attempts to extract the most recent auth time.
 */
const extractSessionTimes = (session: Record<string, unknown> | null | undefined) => {
  if (!session) return { authenticatedAt: null, lastMfaVerifiedAt: null };

  const getTimestamp = (value: unknown): Date | null => {
    if (value instanceof Date) return value;
    if (typeof value === "string") {
      const parsed = Date.parse(value);
      return isNaN(parsed) ? null : new Date(parsed);
    }
    if (typeof value === "number") return new Date(value);
    return null;
  };

  // Try common session property names for auth time
  const authTimeKeys = [
    "authenticatedAt",
    "createdAt",
    "iat",
    "created_at",
    "signedInAt",
  ];
  let authenticatedAt: Date | null = null;
  for (const key of authTimeKeys) {
    const val = getTimestamp(session[key]);
    if (val) {
      authenticatedAt = val;
      break;
    }
  }

  // Try common session property names for MFA verification time
  const mfaTimeKeys = [
    "lastMfaVerifiedAt",
    "mfaVerifiedAt",
    "last_mfa_verified_at",
    "mfa_verified_at",
  ];
  let lastMfaVerifiedAt: Date | null = null;
  for (const key of mfaTimeKeys) {
    const val = getTimestamp(session[key]);
    if (val) {
      lastMfaVerifiedAt = val;
      break;
    }
  }

  return { authenticatedAt, lastMfaVerifiedAt };
};

/**
 * Checks if user has MFA enabled when required.
 * For sensitive operations, prefer requireRecentAuth() which also checks re-auth window.
 */
export const requireMfaEnabled = async (userId: string) => {
  const { getDb } = await import("~/db/server-helpers");
  const { user } = await import("~/db/schema");
  const { eq } = await import("drizzle-orm");

  const db = await getDb();
  const [record] = await db.select().from(user).where(eq(user.id, userId)).limit(1);

  if (!record) {
    throw forbidden("User not found");
  }

  if (record.mfaRequired && !record.twoFactorEnabled) {
    throw forbidden("Multi-factor authentication required");
  }
};

/**
 * Requires that user has authenticated recently (within REAUTH_WINDOW_MS).
 * For MFA-enabled users, also checks that MFA was verified recently.
 *
 * Use this for sensitive operations like:
 * - Data exports
 * - Role/permission changes
 * - DSAR processing
 * - Financial operations
 */
export const requireRecentAuth = async (
  userId: string,
  session: Record<string, unknown> | null | undefined,
  options?: { reAuthWindowMs?: number },
) => {
  const { getDb } = await import("~/db/server-helpers");
  const { user } = await import("~/db/schema");
  const { eq } = await import("drizzle-orm");

  const db = await getDb();
  const [record] = await db.select().from(user).where(eq(user.id, userId)).limit(1);

  if (!record) {
    throw forbidden("User not found");
  }

  if (record.mfaRequired && !record.twoFactorEnabled) {
    throw forbidden("Multi-factor authentication required");
  }

  const reAuthWindowMs = options?.reAuthWindowMs ?? REAUTH_WINDOW_MS;
  const now = Date.now();
  const { authenticatedAt, lastMfaVerifiedAt } = extractSessionTimes(session);

  // Check if session was created recently
  if (authenticatedAt) {
    const sessionAge = now - authenticatedAt.getTime();
    if (sessionAge > reAuthWindowMs) {
      throw forbidden("Re-authentication required for this action");
    }
  }

  // For MFA-enabled users, also require recent MFA verification
  if (record.twoFactorEnabled) {
    // If we have MFA verification time, check it's recent
    if (lastMfaVerifiedAt) {
      const mfaAge = now - lastMfaVerifiedAt.getTime();
      if (mfaAge > reAuthWindowMs) {
        throw forbidden("MFA re-verification required for this action");
      }
    } else if (!authenticatedAt) {
      // No auth time and no MFA time - require re-auth
      throw forbidden("Re-authentication required for this action");
    }
  }
};

/**
 * Helper to get current session for step-up checks.
 * Call this and pass result to requireRecentAuth().
 */
export const getCurrentSession = async () => {
  const { getAuth } = await import("~/lib/auth/server-helpers");
  const { getRequest } = await import("@tanstack/react-start/server");
  const auth = await getAuth();
  const { headers } = getRequest();
  const session = await auth.api.getSession({ headers });
  return session;
};
</file>

<file path="src/lib/auth/middleware/__tests__/auth-guard.test.ts">
import { beforeEach, describe, expect, it, vi } from "vitest";

// Mock the auth module to avoid server-side environment variable access
vi.mock("~/lib/auth", () => ({
  auth: {
    api: {
      getSession: vi.fn(),
    },
  },
}));

// Mock TanStack Start server functions
vi.mock("@tanstack/react-start/server", () => ({
  getRequest: vi.fn(() => new Request("http://localhost", { headers: new Headers() })),
  setResponseStatus: vi.fn(),
}));

describe("authMiddleware", () => {
  // Since the authMiddleware uses TanStack Start's createMiddleware which is complex to test,
  // we'll focus on testing the authentication logic separately

  it("should be defined", async () => {
    const { authMiddleware } = await import("../auth-guard");
    expect(authMiddleware).toBeDefined();
    expect(typeof authMiddleware).toBe("object");
  });

  describe("authentication logic", () => {
    // Mock functions for testing the auth logic
    const mockGetSession = vi.fn();

    beforeEach(() => {
      vi.clearAllMocks();
    });

    it("should allow access when session exists", async () => {
      const mockUser = {
        id: "test-user-id",
        email: "test@example.com",
        name: "Test User",
      };

      const mockSession = {
        user: mockUser,
        session: { id: "test-session-id" },
      };

      mockGetSession.mockResolvedValueOnce(mockSession);

      // Test the authentication logic
      const headers = new Headers({ cookie: "session=test" });
      const result = await mockGetSession({
        headers,
        query: { disableCookieCache: true },
      });

      expect(result).toEqual(mockSession);
      expect(result.user).toEqual(mockUser);
    });

    it("should deny access when no session exists", async () => {
      mockGetSession.mockResolvedValueOnce(null);

      // Test the authentication logic
      const headers = new Headers({ cookie: "session=invalid" });
      const result = await mockGetSession({
        headers,
        query: { disableCookieCache: true },
      });

      expect(result).toBeNull();

      // In the actual middleware, this would trigger:
      // - setResponseStatus(401)
      // - throw new Error('Unauthorized')
    });

    it("should pass correct parameters to getSession", async () => {
      const headers = new Headers({
        cookie: "session=test-session",
        authorization: "Bearer token",
      });

      mockGetSession.mockResolvedValueOnce({ user: {}, session: {} });

      await mockGetSession({
        headers,
        query: { disableCookieCache: true },
      });

      expect(mockGetSession).toHaveBeenCalledWith({
        headers,
        query: { disableCookieCache: true },
      });
    });

    it("should always disable cookie cache for fresh session check", async () => {
      const headers = new Headers({ cookie: "session=test" });

      mockGetSession.mockResolvedValueOnce({ user: {}, session: {} });

      await mockGetSession({
        headers,
        query: { disableCookieCache: true },
      });

      const call = mockGetSession.mock.calls[0][0];
      expect(call.query.disableCookieCache).toBe(true);
    });
  });
});
</file>

<file path="src/lib/auth/index.ts">
/**
 * Auth module - Client-safe exports
 *
 * For server-side auth configuration, import from ~/lib/auth/server-helpers
 */

// Export types that are safe for client use
export type { Session, User } from "better-auth";
export type { AuthUser, User as ExtendedUser } from "./types";
</file>

<file path="docs/sin-rfp/tickets/SIN-IMPLEMENTATION-BACKLOG-V2.md">
# viaSport SIN Implementation Backlog v2

> Comprehensive implementation plan for the Strength in Numbers (SIN) system.
> Incorporates architecture review feedback, compliance requirements, and practical delivery sequencing.

---

## Executive Summary

### Current State

- **Codebase maturity:** Solid TypeScript/React foundation with TanStack Start, Drizzle ORM, Better Auth
- **SIN readiness:** ~35-40% of requirements have partial implementation
- **Critical gaps:** Organization tenancy, audit logging, MFA, notifications, dynamic forms, bulk import, analytics

### Key Insight

> **SIN is governance + compliance + workflows, not UI.**
> Building features before tenancy + audit + security posture = rework everything later.

### Critical Path (Non-Negotiable Sequence)

```
Lock Architecture ‚Üí Organization Tenancy ‚Üí Audit Logging ‚Üí Notifications ‚Üí Security Hardening ‚Üí Forms ‚Üí Reporting ‚Üí Analytics
```

### Timeline Estimate

| Phase                        | Duration        | Outcome                         |
| ---------------------------- | --------------- | ------------------------------- |
| Phase 0: Architecture & Docs | 1-2 weeks       | RFP-defensible documentation    |
| Phase 1: Foundation          | 4-6 weeks       | Tenancy + Audit + Notifications |
| Phase 2: Security            | 3-4 weeks       | MFA + Lockouts + Privacy        |
| Phase 3: Core SIN            | 6-8 weeks       | Forms + Import + Reporting      |
| Phase 4: Analytics           | 3-4 weeks       | Exports + Saved Reports         |
| **Total to SIN-Ready**       | **17-24 weeks** | Phases 0-4                      |

---

## Implementation Progress Tracker

> **Last Updated:** 2025-12-24
> **Overall Progress:** ~85% (Core logic + admin UI done; infra/migration gaps remain)

### Phase 0: Pre-Development Documentation

| Item                               | Status      | Score    | Evidence                                         |
| ---------------------------------- | ----------- | -------- | ------------------------------------------------ |
| P0-001: Reference Architecture     | ‚úÖ Complete | 100%     | `docs/sin-rfp/phase-0/architecture-reference.md` |
| P0-002: Data Residency Statement   | ‚úÖ Complete | 100%     | `docs/sin-rfp/phase-0/data-residency.md`         |
| P0-003: Security Controls Overview | ‚úÖ Complete | 100%     | `docs/sin-rfp/phase-0/security-controls.md`      |
| P0-004: Backup & DR Plan           | ‚úÖ Complete | 100%     | `docs/sin-rfp/phase-0/backup-dr-plan.md`         |
| P0-005: Audit & Retention Policy   | ‚úÖ Complete | 100%     | `docs/sin-rfp/phase-0/audit-retention-policy.md` |
| **Phase 0 Total**                  | ‚úÖ          | **100%** | All 5 documents complete                         |

### Phase 1: Foundation

| Item                           | Status      | Score   | Evidence                                                                                         |
| ------------------------------ | ----------- | ------- | ------------------------------------------------------------------------------------------------ |
| F-001: Organization & Tenancy  | ‚úÖ Complete | 95%     | Schema: `organizations.schema.ts` + guards + admin UI. **Note:** hierarchy visualization pending |
| F-002: Immutable Audit Logging | ‚úÖ Complete | 100%    | Schema + hash chain + immutability trigger + admin UI/export                                     |
| F-003: Notification Engine     | ‚úÖ Complete | 100%    | SQS/SES integration + scheduler + digest aggregation + admin templates                           |
| **Phase 1 Total**              | ‚úÖ          | **98%** | Core logic + admin UI complete                                                                   |

### Phase 2: Security Hardening

| Item                                       | Status      | Score   | Evidence                                                                                                                        |
| ------------------------------------------ | ----------- | ------- | ------------------------------------------------------------------------------------------------------------------------------- |
| S-001: Multi-Factor Authentication         | üü° Partial  | 85%     | Enrollment + QR + backup codes + login challenge + step-up. **Missing:** per-role MFA UI (auto-enforced for global admin roles) |
| S-002: Security Event Monitoring & Lockout | ‚úÖ Complete | 95%     | Events + detection + lockout + dashboard + admin alerts                                                                         |
| S-003: Privacy Compliance (PIPEDA)         | ‚úÖ Complete | 95%     | Policy acceptance + DSAR workflow + export + erasure + retention UI/cron                                                        |
| **Phase 2 Total**                          | üü°          | **92%** | Security UI complete, minor admin config gap                                                                                    |

### Phase 3: Core SIN Features

| Item                                | Status      | Score   | Evidence                                                                 |
| ----------------------------------- | ----------- | ------- | ------------------------------------------------------------------------ |
| D-001: Dynamic Form Builder         | ‚úÖ Complete | 95%     | Builder + preview + publish + renderer + submissions history             |
| D-002: Bulk Import & Data Migration | üü° Partial  | 80%     | Lane 1 UI + Lane 2 batch runner; **Missing:** ECS task definition wiring |
| R-001: Reporting Cycles & Workflows | ‚úÖ Complete | 95%     | Cycles + tasks + reminders + dashboards + review workflow                |
| **Phase 3 Total**                   | üü°          | **90%** | ECS batch worker infra remaining                                         |

### Phase 4: Analytics & Export

| Item                      | Status      | Score   | Evidence                                                 |
| ------------------------- | ----------- | ------- | -------------------------------------------------------- |
| R-002: Reporting & Export | ‚úÖ Complete | 95%     | Report builder UI + saved reports + sharing + export ACL |
| **Phase 4 Total**         | ‚úÖ          | **95%** | Builder + exports complete                               |

### Summary by Category

| Category                 | Progress | Notes                                              |
| ------------------------ | -------- | -------------------------------------------------- |
| **Documentation**        | 100%     | All Phase 0 docs complete                          |
| **Database Schema**      | 100%     | All SIN tables defined + migrations applied        |
| **Server Functions**     | 95%      | Queries + mutations with auth guards + audit hooks |
| **Auth & Security**      | 90%      | MFA, lockout, step-up, admin enforcement complete  |
| **Notification Backend** | 95%      | SQS + SES + scheduler + digests                    |
| **Admin UI Components**  | 85%      | Core admin panels implemented                      |
| **E2E Tests**            | 30%      | Initial SIN auth/export/upload tests in place      |

### Recent Changes (2025-12-24)

Applied security patches (Issues 01-11):

- ‚úÖ Audit log access control with org scoping
- ‚úÖ Security events access control
- ‚úÖ Reporting permission checks
- ‚úÖ Field-level ACL for report exports
- ‚úÖ Audit log immutability in retention
- ‚úÖ S3 cleanup for DSAR erasure
- ‚úÖ Step-up auth re-auth window
- ‚úÖ Server-side file validation
- ‚úÖ SQS/SES notification integration
- ‚úÖ XLSX export generation
- ‚úÖ MFA enrollment QR + backup code regeneration
- ‚úÖ Notification digest aggregation + audit verification UI
- ‚úÖ Lane 2 batch runner helper + worker entrypoint

See `docs/sin-rfp/SIN-IMPLEMENTATION-TECHNICAL-DEBT.md` for detailed patch notes.

---

## Part 1: Architecture Decisions to Lock First

> These decisions ripple everywhere. Do not write code until these are documented and approved.

### ADR-001: Data Residency

**Decision:** All production data stored and processed in Canada (AWS `ca-central-1`).

**Rationale:** PIPEDA compliance, viaSport requirement, RFP defensibility.

**Implications:**

- Migrate from Neon to AWS RDS PostgreSQL in `ca-central-1`
- Use AWS SES (not SendGrid) for transactional email
- Use S3 `ca-central-1` for document storage
- No Netlify for production (edge compute has no residency guarantees)
- All sub-processors must have Canadian data processing or explicit DPAs

---

### ADR-002: Tenancy Model

**Decision:** Organization-based tenancy (not team-based).

**Rationale:** SIN requires hierarchical org structure: viaSport ‚Üí PSO ‚Üí Club/Affiliate.

**Data Model:**

```
organizations (id, name, type, parent_org_id, ...)
    ‚Üì
organization_members (user_id, org_id, role, status, ...)
    ‚Üì
All tenant-owned entities have organization_id FK
```

**Implications:**

- Remove/deprecate `teamId`/`eventId` scoping from RBAC for SIN
- Add `organization_id` to: forms, submissions, reporting_tasks, imports, notifications
- Every query must be org-scoped by default
- Consider Postgres RLS for defense-in-depth (Phase 2 hardening)

---

### ADR-003: Audit Logging Policy

**Decision:** Immutable append-only audit log with PII-aware handling.

**What Gets Logged:**
| Action Type | Detail Level | Before/After |
|-------------|--------------|--------------|
| `AUTH.*` (login, logout, MFA) | Metadata only (no secrets) | No |
| `ADMIN.*` (role changes, config) | Full detail | Yes (full) |
| `DATA.CREATE/UPDATE/DELETE` | Field-level diffs | Yes (diff only) |
| `EXPORT.*` | Query params, row count | No |
| `SECURITY.*` (lockouts, anomalies) | Full context | No |

**PII Handling in Audit Logs:**

- Store **diffs**, not full before/after snapshots for personal data
- Store **hashes** for sensitive fields (DOB, phone, emergency contact)
- Redact secrets (passwords, tokens) completely
- Define retention: audit logs retained 7 years (or as specified by viaSport)

**Rationale:** Full before/after creates a second copy of PII, complicates DSAR/erasure.

---

### ADR-004: Email PII Policy

**Decision:** Minimal PII in transactional emails.

**Allowed in Email:**

- First name (for personalization)
- Organization name
- Action summaries ("Your Q1 report is due in 7 days")
- Links to system (with auth required to view details)

**NOT Allowed in Email:**

- Full addresses
- Phone numbers
- Date of birth
- Emergency contact details
- Submission content/data

**Rationale:** Email is a US-processor risk (even with SES). Minimize data exposure.

---

### ADR-005: Session Security

**Decision:** Tightened session policy for government data system.

| Setting               | Value                       | Rationale                             |
| --------------------- | --------------------------- | ------------------------------------- |
| Session max age       | 8 hours                     | Reduced from 30 days                  |
| Idle timeout          | 30 minutes                  | Auto-logout on inactivity             |
| Admin session max     | 4 hours                     | Higher privilege = shorter session    |
| Step-up auth required | Role changes, exports, DSAR | Re-authenticate for sensitive actions |
| Admin MFA             | Required                    | Non-negotiable for SIN                |

---

### ADR-006: Infrastructure Stack

**Decision:** AWS via SST for production, Netlify for development preview only.

| Component      | Technology                             | Region                    |
| -------------- | -------------------------------------- | ------------------------- |
| Compute        | Lambda (requests), ECS Fargate (batch) | ca-central-1              |
| Database       | RDS PostgreSQL (Multi-AZ, PITR)        | ca-central-1              |
| Object Storage | S3 (SSE-KMS, versioning)               | ca-central-1              |
| Email          | AWS SES                                | ca-central-1              |
| Queues         | SQS                                    | ca-central-1              |
| Scheduling     | EventBridge Scheduler                  | ca-central-1              |
| Secrets        | Secrets Manager                        | ca-central-1              |
| Monitoring     | CloudWatch, CloudTrail, GuardDuty      | ca-central-1              |
| CDN            | CloudFront (cache static only)         | Global edge, origin in CA |

**Residency Constraints:**

- CloudFront caches static assets only; authenticated/PII responses must use `Cache-Control: no-store`.
- CSP nonce injection must move to app-layer middleware for AWS (see `sst-migration-plan.md`).

**Known Issue:** SST Lambda Function URL permissions require `$transform` workaround. See `sst-migration-plan.md`.

---

## Part 2: Compliance & Security Posture

### Sub-Processor Inventory

| Service            | Vendor                    | Data Processed                       | Region                    | DPA Status       |
| ------------------ | ------------------------- | ------------------------------------ | ------------------------- | ---------------- |
| Database           | AWS RDS                   | All PII, submissions, audit logs     | ca-central-1              | AWS DPA ‚úì        |
| Email              | AWS SES                   | Names, org names, action summaries   | ca-central-1              | AWS DPA ‚úì        |
| Object Storage     | AWS S3                    | Documents, attachments, import files | ca-central-1              | AWS DPA ‚úì        |
| Auth               | Self-hosted (Better Auth) | Credentials, sessions                | ca-central-1              | N/A              |
| Monitoring         | AWS CloudWatch            | Logs (PII redacted)                  | ca-central-1              | AWS DPA ‚úì        |
| OAuth (if enabled) | Google                    | Email + profile claims               | Verify (likely US/global) | Google terms/DPA |
| Payments           | Square (if needed)        | Payment tokens only                  | Verify                    | Requires DPA     |

**No external sub-processors for PII beyond those listed.** If added later (analytics, support tools), update this table and obtain DPAs.

---

### Security Controls Mapped to SIN Requirements

| Requirement                          | Control                                      | Status   |
| ------------------------------------ | -------------------------------------------- | -------- |
| SEC-AGG-001: MFA                     | Better Auth 2FA plugin (TOTP + backup codes) | To Build |
| SEC-AGG-001: Role/affiliation access | Organization-scoped RBAC                     | To Build |
| SEC-AGG-001: Leader admission        | Org membership approval workflow             | To Build |
| SEC-AGG-002: Anomaly detection       | Security events + risk scoring               | To Build |
| SEC-AGG-002: Account lockout         | Threshold-based auto-lock                    | To Build |
| SEC-AGG-003: PIPEDA compliance       | Consent tracking, retention, DSAR            | To Build |
| SEC-AGG-004: Immutable audit         | Append-only table + hash chain               | To Build |
| SEC-AGG-004: Export                  | Audit log filtering + CSV export             | To Build |

---

### Backup & Disaster Recovery

| Metric                         | Target    | Mechanism                           |
| ------------------------------ | --------- | ----------------------------------- |
| RPO (Recovery Point Objective) | 1 hour    | RDS automated backups + PITR        |
| RTO (Recovery Time Objective)  | 4 hours   | Multi-AZ failover + restore runbook |
| Backup retention               | 35 days   | RDS automated + manual snapshots    |
| Audit log retention            | 7 years   | S3 Glacier archive with Object Lock |
| DR testing                     | Quarterly | Documented restore procedure        |

---

## Part 3: Implementation Phases

### Phase 0: Pre-Development Documentation (1-2 weeks)

> Write these documents before writing code. They make your RFP submission defensible.

#### P0-001: Reference Architecture Document

**Deliverable:** `docs/sin-rfp/phase-0/architecture-reference.md`

Contents:

- [x] Architecture diagram (CloudFront ‚Üí Lambda ‚Üí RDS ‚Üí S3)
- [x] Data flow diagram (user ‚Üí system ‚Üí storage)
- [x] Network diagram (VPC, subnets, security groups)
- [x] Component descriptions

---

#### P0-002: Data Residency Statement

**Deliverable:** `docs/sin-rfp/phase-0/data-residency.md`

Contents:

- [x] Explicit statement: "All production data stored in AWS ca-central-1"
- [x] Sub-processor list with regions
- [x] Data classification (PII, sensitive PII, operational)
- [x] Cross-border data transfer policy (none for PII)

---

#### P0-003: Security Controls Overview

**Deliverable:** `docs/sin-rfp/phase-0/security-controls.md`

Contents:

- [x] Authentication controls (MFA, session management)
- [x] Authorization controls (RBAC, org scoping)
- [x] Encryption (at rest: KMS, in transit: TLS 1.3)
- [x] Logging and monitoring
- [x] Incident response (outline)

---

#### P0-004: Backup & DR Plan

**Deliverable:** `docs/sin-rfp/phase-0/backup-dr-plan.md`

Contents:

- [x] RPO/RTO targets
- [x] Backup mechanisms and schedules
- [x] Restore procedures (step-by-step)
- [x] DR testing schedule and evidence

---

#### P0-005: Audit & Retention Policy

**Deliverable:** `docs/sin-rfp/phase-0/audit-retention-policy.md`

Contents:

- [x] What is logged (per action type)
- [x] Retention periods by data type
- [x] Archive and purge procedures
- [x] Legal hold capability

---

### Phase 1: Foundation (4-6 weeks)

> These are blocking dependencies. Everything else builds on this.

#### F-001: Organization & Tenancy Model

**Priority:** P0 (Blocker)
**Effort:** 2-3 weeks
**Blocks:** All org-scoped features

**Database Schema:**

```sql
-- Organizations (viaSport, PSOs, Clubs, Affiliates)
CREATE TABLE organizations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL,
  type TEXT NOT NULL CHECK (type IN ('governing_body', 'pso', 'club', 'affiliate')),
  parent_org_id UUID REFERENCES organizations(id),
  status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('pending', 'active', 'suspended', 'archived')),
  settings JSONB NOT NULL DEFAULT '{}',
  metadata JSONB NOT NULL DEFAULT '{}',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Organization membership with role
CREATE TABLE organization_members (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  role TEXT NOT NULL CHECK (role IN ('owner', 'admin', 'reporter', 'viewer', 'member')),
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'active', 'suspended', 'removed')),
  invited_by TEXT REFERENCES "user"(id),
  invited_at TIMESTAMPTZ,
  approved_by TEXT REFERENCES "user"(id),
  approved_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(user_id, organization_id)
);

-- Delegated access for reporting (separate from membership)
CREATE TABLE delegated_access (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  delegate_user_id TEXT NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  scope TEXT NOT NULL CHECK (scope IN ('reporting', 'analytics', 'admin')),
  granted_by TEXT NOT NULL REFERENCES "user"(id),
  granted_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  expires_at TIMESTAMPTZ,
  revoked_at TIMESTAMPTZ,
  revoked_by TEXT REFERENCES "user"(id),
  notes TEXT
);

-- Indices
CREATE INDEX idx_org_members_user ON organization_members(user_id) WHERE status = 'active';
CREATE INDEX idx_org_members_org ON organization_members(organization_id) WHERE status = 'active';
CREATE INDEX idx_org_parent ON organizations(parent_org_id);
CREATE INDEX idx_delegated_access_user ON delegated_access(delegate_user_id) WHERE revoked_at IS NULL;
CREATE UNIQUE INDEX delegated_access_active_unique
  ON delegated_access(delegate_user_id, organization_id, scope)
  WHERE revoked_at IS NULL;
```

**Implementation:**

- [x] Create `src/db/schema/organizations.schema.ts`
- [x] Create `src/features/organizations/` feature module
- [x] Implement org context middleware (resolve user's org + role per request)
- [x] Create `src/lib/auth/guards/org-guard.ts`
- [x] Add org admin UI: create org, invite members, approve/deny
- [x] Retrofit `organization_id` to existing entities (as needed for SIN)

**Acceptance Criteria:**

- [x] Organizations can be created with parent/child relationships
- [x] Users can be invited to organizations with specific roles
- [x] Organization admins can approve/deny membership requests
- [x] Delegated access can be granted and revoked with audit trail
- [x] All data queries are org-scoped by default (SIN modules scoped)
- [x] Users cannot access data outside their organization(s) (org guard enforced)

---

#### F-002: Immutable Audit Logging

**Priority:** P0 (Blocker)
**Effort:** 2 weeks
**Blocks:** Compliance, DSAR, security monitoring

**Database Schema:**

```sql
-- Append-only audit log with hash chain
CREATE TABLE audit_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  occurred_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Actor information
  actor_user_id TEXT REFERENCES "user"(id),
  actor_org_id UUID REFERENCES organizations(id),
  actor_ip INET,
  actor_user_agent TEXT,

  -- Action classification
  action TEXT NOT NULL, -- 'AUTH.LOGIN', 'DATA.CREATE', 'ADMIN.ROLE_ASSIGN', etc.
  action_category TEXT NOT NULL, -- 'AUTH', 'ADMIN', 'DATA', 'EXPORT', 'SECURITY'

  -- Target information
  target_type TEXT, -- 'user', 'organization', 'submission', etc.
  target_id TEXT,
  target_org_id UUID REFERENCES organizations(id),

  -- Change tracking (with PII awareness)
  changes JSONB, -- Field-level diffs, NOT full snapshots
  metadata JSONB NOT NULL DEFAULT '{}',

  -- Correlation and integrity
  request_id TEXT NOT NULL, -- Generate for background jobs (job_id/trace_id)
  prev_hash TEXT, -- Hash of previous entry (tamper evidence)
  entry_hash TEXT NOT NULL, -- Hash of this entry

  -- Indexing support
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Enforce append-only via trigger
CREATE OR REPLACE FUNCTION prevent_audit_modification()
RETURNS TRIGGER AS $$
BEGIN
  RAISE EXCEPTION 'Audit logs are immutable - modifications not allowed';
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER audit_logs_immutable
BEFORE UPDATE OR DELETE ON audit_logs
FOR EACH ROW EXECUTE FUNCTION prevent_audit_modification();

-- Indices for common query patterns
CREATE INDEX idx_audit_logs_actor ON audit_logs(actor_user_id, occurred_at DESC);
CREATE INDEX idx_audit_logs_target ON audit_logs(target_type, target_id, occurred_at DESC);
CREATE INDEX idx_audit_logs_action ON audit_logs(action_category, occurred_at DESC);
CREATE INDEX idx_audit_logs_org ON audit_logs(target_org_id, occurred_at DESC);
CREATE INDEX idx_audit_logs_request ON audit_logs(request_id);
```

**Audit Library Design:**

```typescript
// src/lib/audit/index.ts
interface AuditEntry {
  action: string;
  targetType?: string;
  targetId?: string;
  targetOrgId?: string;
  changes?: Record<string, { old?: unknown; new?: unknown }>;
  metadata?: Record<string, unknown>;
}

// Central logging functions
audit.logAuthEvent(type: 'LOGIN' | 'LOGOUT' | 'MFA_ENROLL' | ..., context)
audit.logAdminAction(type: 'ROLE_ASSIGN' | 'ORG_CREATE' | ..., target, changes)
audit.logDataChange(type: 'CREATE' | 'UPDATE' | 'DELETE', entity, changes)
audit.logExport(type: 'CSV' | 'EXCEL' | ..., query, rowCount)
audit.logSecurityEvent(type: 'LOCKOUT' | 'ANOMALY' | ..., context)
```

**PII Redaction Rules:**

```typescript
// Fields to hash (not store plaintext)
const HASH_FIELDS = ["dateOfBirth", "phone", "emergencyContact.phone"];

// Fields to redact completely
const REDACT_FIELDS = ["password", "secret", "token", "mfaSecret"];

// For DATA changes, store diffs only
function createAuditDiff(before: object, after: object): object {
  // Returns { fieldName: { old: redacted/hashed, new: redacted/hashed } }
}
```

**Implementation:**

- [x] Create `src/db/schema/audit.schema.ts`
- [x] Create `src/lib/audit/` module
- [x] Implement hash chain verification utility
- [x] Add request ID middleware (correlation)
- [x] Wire into auth flows (login, logout, MFA)
- [x] Wire into admin actions (role changes, org management)
- [x] Create admin UI for log viewing, filtering, export

**Acceptance Criteria:**

- [x] All auth events are logged (login, logout, failed attempts, MFA)
- [x] All admin actions are logged with actor and target
- [x] Data changes log field-level diffs (not full snapshots)
- [x] PII fields are hashed/redacted per policy
- [x] Logs cannot be modified or deleted (DB trigger enforced)
- [x] Hash chain can be verified for integrity
- [x] Admin can filter by user, org, action, date range
- [x] Logs can be exported to CSV

---

#### F-003: Notification Engine

**Priority:** P0 (Blocker)
**Effort:** 2 weeks
**Blocks:** Reporting reminders, security alerts, support tickets

**Architecture:**

```
User Action ‚Üí Notification Request ‚Üí SQS Queue ‚Üí Worker ‚Üí Email (SES) + In-App DB
                                                      ‚Üì
                                              User Preferences Check
```

**Database Schema:**

```sql
-- In-app notifications
CREATE TABLE notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
  organization_id UUID REFERENCES organizations(id),

  type TEXT NOT NULL, -- 'reporting_reminder', 'security_alert', 'ticket_update', etc.
  category TEXT NOT NULL, -- 'reporting', 'security', 'support', 'system'

  title TEXT NOT NULL,
  body TEXT NOT NULL,
  link TEXT, -- Deep link to relevant page

  read_at TIMESTAMPTZ,
  dismissed_at TIMESTAMPTZ,

  metadata JSONB NOT NULL DEFAULT '{}',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- User notification preferences
CREATE TABLE notification_preferences (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
  category TEXT NOT NULL, -- 'reporting', 'security', 'support', 'system'

  channel_email BOOLEAN NOT NULL DEFAULT true,
  channel_in_app BOOLEAN NOT NULL DEFAULT true,

  -- Email frequency (for non-urgent)
  email_frequency TEXT NOT NULL DEFAULT 'immediate'
    CHECK (email_frequency IN ('immediate', 'daily_digest', 'weekly_digest', 'never')),

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(user_id, category)
);

-- Admin-managed notification templates
CREATE TABLE notification_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  key TEXT UNIQUE NOT NULL, -- 'reporting_reminder_7day', 'security_lockout', etc.

  category TEXT NOT NULL,
  subject TEXT NOT NULL,
  body_template TEXT NOT NULL, -- Supports {{variable}} substitution

  is_system BOOLEAN NOT NULL DEFAULT false, -- System templates can't be deleted

  created_by TEXT REFERENCES "user"(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Scheduled notifications (for reminders)
CREATE TABLE scheduled_notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  template_key TEXT NOT NULL REFERENCES notification_templates(key),

  -- Target (user, org, or broadcast)
  user_id TEXT REFERENCES "user"(id),
  organization_id UUID REFERENCES organizations(id),
  role_filter TEXT, -- Optional: only users with this role

  scheduled_for TIMESTAMPTZ NOT NULL,

  -- Execution tracking
  sent_at TIMESTAMPTZ,
  failed_at TIMESTAMPTZ,
  error_message TEXT,
  retry_count INTEGER NOT NULL DEFAULT 0,

  variables JSONB NOT NULL DEFAULT '{}',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indices
CREATE INDEX idx_notifications_user ON notifications(user_id, read_at NULLS FIRST, created_at DESC);
CREATE INDEX idx_notifications_org ON notifications(organization_id, created_at DESC);
CREATE INDEX idx_scheduled_pending ON scheduled_notifications(scheduled_for)
  WHERE sent_at IS NULL AND failed_at IS NULL;
```

**Implementation:**

- [x] Create `src/db/schema/notifications.schema.ts`
- [x] Create `src/features/notifications/` module
- [x] Create `src/lib/notifications/queue.ts` (SQS integration)
- [x] Create `src/lib/notifications/send.ts` (dispatch logic)
- [x] Create `src/lib/notifications/scheduler.ts` (EventBridge integration)
- [x] Add notification bell component to header
- [x] Add notification preferences UI
- [x] Add admin template management UI

**Acceptance Criteria:**

- [x] Users see notification bell with unread count
- [x] Notification panel shows recent items, mark as read
- [x] Users can configure preferences per category
- [x] Email notifications respect user preferences
- [x] Scheduled notifications fire at configured times
- [x] Failed notifications retry with backoff
- [x] All notifications are audit logged

---

### Phase 2: Security Hardening (3-4 weeks)

#### S-001: Multi-Factor Authentication

**Priority:** P1
**Effort:** 1.5 weeks
**Requirement:** SEC-AGG-001

**Approach:** Use [Better Auth 2FA Plugin](https://www.better-auth.com/docs/plugins/2fa)

**Features to Implement:**

- [x] TOTP enrollment with QR code
- [x] Backup codes (10 single-use codes)
- [x] MFA challenge on login
- [x] MFA required for admin roles (enforced)
- [x] Step-up auth for sensitive actions
- [x] MFA recovery workflow

**Note:** Better Auth 2FA currently supports credential accounts only. For admin roles,
require a password-linked account or restrict admin roles to credential users.

**Database Additions:**

```sql
-- Better Auth 2FA plugin manages its own tables, but we track:
ALTER TABLE "user" ADD COLUMN mfa_required BOOLEAN NOT NULL DEFAULT false;
ALTER TABLE "user" ADD COLUMN mfa_enrolled_at TIMESTAMPTZ;

-- Track MFA events in audit log (no additional table needed)
```

**Implementation:**

- [x] Install and configure Better Auth 2FA plugin
- [x] Create `src/features/auth/mfa/` components
- [x] MFA enrollment wizard (TOTP QR + backup codes)
- [x] MFA challenge screen
- [x] Step-up auth middleware for sensitive routes
- [x] Admin UI to require MFA for roles (warning + badges added in role dashboard)

**Acceptance Criteria:**

- [x] Users can enroll in TOTP MFA
- [x] Backup codes are generated and displayed once
- [x] Login requires MFA code when enrolled
- [x] Admin roles must have MFA (enforced on role assignment)
- [x] Sensitive actions (exports, role changes) require re-auth
- [x] All MFA events are audit logged

---

#### S-002: Security Event Monitoring & Lockout

**Priority:** P1
**Effort:** 1.5 weeks
**Requirement:** SEC-AGG-002

**Database Schema:**

```sql
-- Security events (separate from audit for performance)
CREATE TABLE security_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT REFERENCES "user"(id),

  event_type TEXT NOT NULL, -- 'login_success', 'login_fail', 'mfa_fail', 'password_reset', etc.

  ip_address INET NOT NULL,
  user_agent TEXT,
  geo_country TEXT,
  geo_region TEXT,

  risk_score INTEGER NOT NULL DEFAULT 0, -- 0-100
  risk_factors JSONB NOT NULL DEFAULT '[]', -- ['new_device', 'new_location', 'unusual_time']

  metadata JSONB NOT NULL DEFAULT '{}',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Account locks
CREATE TABLE account_locks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT NOT NULL REFERENCES "user"(id),

  reason TEXT NOT NULL, -- 'failed_logins', 'suspicious_activity', 'admin_action'

  locked_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  unlock_at TIMESTAMPTZ, -- NULL = permanent until manual unlock

  unlocked_by TEXT REFERENCES "user"(id),
  unlocked_at TIMESTAMPTZ,
  unlock_reason TEXT,

  metadata JSONB NOT NULL DEFAULT '{}'
);

-- Indices
CREATE INDEX idx_security_events_user ON security_events(user_id, created_at DESC);
CREATE INDEX idx_security_events_ip ON security_events(ip_address, created_at DESC);
CREATE INDEX idx_account_locks_user ON account_locks(user_id) WHERE unlocked_at IS NULL;
```

**Detection Rules (Configurable):**
| Trigger | Action |
|---------|--------|
| 5 failed logins in 15 minutes | Lock for 30 minutes |
| 10 failed logins in 1 hour | Lock until admin unlock |
| Login from new country | Flag for review, notify user |
| 3 failed MFA in 5 minutes | Lock for 15 minutes |
| Password reset from new device | Require additional verification |

**Implementation:**

- [x] Create `src/db/schema/security.schema.ts`
- [x] Create `src/lib/security/events.ts` (capture and store)
- [x] Create `src/lib/security/detection.ts` (rules engine)
- [x] Create `src/lib/security/lockout.ts` (lock/unlock logic)
- [x] Integrate with auth flows
- [x] Create admin security dashboard
- [x] Add alert notifications to admins

**Acceptance Criteria:**

- [x] All auth events captured with IP/UA/geo
- [x] Failed login threshold triggers auto-lock
- [x] Locked accounts cannot authenticate
- [x] Admins receive notifications for lockouts
- [x] Admins can manually lock/unlock with reason
- [x] Security dashboard shows recent events and anomalies
- [x] All security events are audit logged

---

#### S-003: Privacy Compliance (PIPEDA)

**Priority:** P1
**Effort:** 1.5 weeks
**Requirement:** SEC-AGG-003

**Database Schema:**

```sql
-- Privacy policy versions
CREATE TABLE policy_documents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  type TEXT NOT NULL CHECK (type IN ('privacy_policy', 'terms_of_service', 'data_agreement')),
  version TEXT NOT NULL,

  content_url TEXT, -- S3 URL to PDF
  content_hash TEXT NOT NULL, -- SHA-256 of content

  effective_date DATE NOT NULL,
  published_at TIMESTAMPTZ,
  published_by TEXT REFERENCES "user"(id),

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(type, version)
);

-- User policy acceptances (immutable record)
CREATE TABLE user_policy_acceptances (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT NOT NULL REFERENCES "user"(id),
  policy_id UUID NOT NULL REFERENCES policy_documents(id),

  accepted_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ip_address INET,
  user_agent TEXT,

  UNIQUE(user_id, policy_id)
);

-- Data Subject Access Requests (DSAR)
CREATE TABLE privacy_requests (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT NOT NULL REFERENCES "user"(id),

  type TEXT NOT NULL CHECK (type IN ('access', 'export', 'erasure', 'correction')),
  status TEXT NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'processing', 'completed', 'rejected')),

  requested_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Processing
  processed_by TEXT REFERENCES "user"(id),
  processed_at TIMESTAMPTZ,

  -- Result
  result_url TEXT, -- S3 URL for exports
  result_notes TEXT,
  rejection_reason TEXT,

  -- Audit
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Data retention policies
CREATE TABLE retention_policies (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  data_type TEXT NOT NULL, -- 'submissions', 'audit_logs', 'sessions', etc.

  retention_days INTEGER NOT NULL,
  archive_after_days INTEGER,
  purge_after_days INTEGER,

  legal_hold BOOLEAN NOT NULL DEFAULT false,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  UNIQUE(data_type)
);
```

**Implementation:**

- [x] Create `src/db/schema/privacy.schema.ts`
- [x] Create `src/features/privacy/` module
- [x] Policy acceptance flow (block access until accepted)
- [x] DSAR request submission UI
- [x] Admin DSAR processing workflow
- [x] Data export generation (user's PII)
- [x] Data erasure/anonymization logic
- [x] Retention policy configuration UI
- [x] Scheduled retention enforcement job

**Acceptance Criteria:**

- [x] Users must accept current policy to proceed
- [x] Policy acceptance recorded with timestamp/IP
- [x] Users can submit DSAR (export, erasure)
- [x] Admins can process DSAR with audit trail
- [x] Data exports include all user PII
- [x] Erasure anonymizes data while preserving audit logs
- [x] Retention policies can be configured per data type

---

### Phase 3: Core SIN Features (6-8 weeks)

#### D-001: Dynamic Form Builder

**Priority:** P1
**Effort:** 3-4 weeks
**Requirements:** DM-AGG-001, RP-AGG-004

**Database Schema:**

```sql
-- Form definitions
CREATE TABLE forms (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID REFERENCES organizations(id), -- NULL = system-wide

  name TEXT NOT NULL,
  slug TEXT NOT NULL,
  description TEXT,

  status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'published', 'archived')),

  created_by TEXT NOT NULL REFERENCES "user"(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  UNIQUE(organization_id, slug)
);

-- Form versions (immutable once published)
CREATE TABLE form_versions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  form_id UUID NOT NULL REFERENCES forms(id) ON DELETE CASCADE,

  version_number INTEGER NOT NULL,

  -- Form definition (see FormDefinition type below)
  definition JSONB NOT NULL,

  published_at TIMESTAMPTZ,
  published_by TEXT REFERENCES "user"(id),

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  UNIQUE(form_id, version_number)
);

-- Form submissions
CREATE TABLE form_submissions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  form_id UUID NOT NULL REFERENCES forms(id),
  form_version_id UUID NOT NULL REFERENCES form_versions(id),
  organization_id UUID NOT NULL REFERENCES organizations(id),

  submitter_id TEXT REFERENCES "user"(id),

  status TEXT NOT NULL DEFAULT 'draft'
    CHECK (status IN ('draft', 'submitted', 'under_review', 'changes_requested', 'approved', 'rejected')),

  payload JSONB NOT NULL,

  -- Validation tracking
  completeness_score INTEGER, -- 0-100
  missing_fields JSONB DEFAULT '[]',
  validation_errors JSONB DEFAULT '[]',

  -- Workflow tracking
  submitted_at TIMESTAMPTZ,
  reviewed_by TEXT REFERENCES "user"(id),
  reviewed_at TIMESTAMPTZ,
  review_notes TEXT,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Submission version history
CREATE TABLE form_submission_versions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  submission_id UUID NOT NULL REFERENCES form_submissions(id) ON DELETE CASCADE,

  version_number INTEGER NOT NULL,
  payload_snapshot JSONB NOT NULL,

  changed_by TEXT REFERENCES "user"(id),
  change_reason TEXT,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  UNIQUE(submission_id, version_number)
);

-- File attachments
CREATE TABLE submission_files (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  submission_id UUID NOT NULL REFERENCES form_submissions(id) ON DELETE CASCADE,

  field_key TEXT NOT NULL,
  file_name TEXT NOT NULL,
  mime_type TEXT NOT NULL,
  size_bytes INTEGER NOT NULL,
  checksum TEXT NOT NULL, -- SHA-256

  storage_key TEXT NOT NULL, -- S3 key

  uploaded_by TEXT REFERENCES "user"(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Form Definition TypeScript Schema:**

```typescript
interface FormDefinition {
  fields: FormField[];
  layout?: {
    sections: { title: string; fieldKeys: string[] }[];
  };
  settings: {
    allowDraft: boolean;
    requireApproval: boolean;
    notifyOnSubmit: string[]; // role names or user IDs
  };
}

interface FormField {
  key: string;
  type:
    | "text"
    | "number"
    | "email"
    | "phone"
    | "date"
    | "select"
    | "multiselect"
    | "checkbox"
    | "file"
    | "textarea"
    | "rich_text";
  label: string;
  description?: string;
  placeholder?: string;
  required: boolean;
  validation?: ValidationRule[];
  options?: { value: string; label: string }[]; // for select/multiselect
  conditional?: {
    field: string;
    operator: "equals" | "not_equals" | "contains" | "greater_than";
    value: unknown;
  };
  fileConfig?: {
    allowedTypes: string[]; // MIME types
    maxSizeBytes: number;
    maxFiles: number;
  };
}

interface ValidationRule {
  type: "min_length" | "max_length" | "pattern" | "min" | "max" | "custom";
  value: string | number;
  message: string;
}
```

**Implementation:**

- [x] Create `src/db/schema/forms.schema.ts`
- [x] Create `src/features/forms/` module
- [x] Form builder UI (drag-and-drop field palette)
- [x] Field configuration panel
- [x] Form preview mode
- [x] Form publishing workflow (creates immutable version)
- [x] Form renderer (generates form from definition)
- [x] Server-side validation from definition
- [x] Sanitize `rich_text` content server-side (allowlist + XSS-safe rendering)
- [x] Submission workflow (draft ‚Üí submit ‚Üí review)
- [x] File upload with S3 pre-signed URLs
- [x] Submission history viewer

**Acceptance Criteria:**

- [x] Admins can create forms with all field types
- [x] Validation rules are enforced server-side
- [x] Published forms are immutable (edits create new version)
- [x] Submissions track which form version was used
- [x] Files can be attached and downloaded
- [x] Submission history shows all changes
- [x] Forms support conditional field visibility

---

#### D-002: Bulk Import & Data Migration

**Priority:** P1
**Effort:** 2-3 weeks
**Requirement:** DM-AGG-006

**Two-Lane Architecture:**

**Lane 1: Interactive Import (<10K rows)**

- UI wizard for admin uploads
- In-memory validation with preview
- Row-level error display
- Direct database insert with rollback support (tag rows with `import_job_id` or use staging)

**Lane 2: Batch Import (>10K rows, up to 20M+)**

- S3 upload for source file
- Worker-based processing (ECS Fargate)
- Chunked validation in SQL
- Resumable checkpoints
- Error report to S3 (not row-per-row in DB)

**Database Schema:**

```sql
-- Import jobs (both lanes)
CREATE TABLE import_jobs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id),

  -- Source
  type TEXT NOT NULL CHECK (type IN ('csv', 'excel')),
  lane TEXT NOT NULL CHECK (lane IN ('interactive', 'batch')),
  source_file_key TEXT NOT NULL, -- S3 key
  source_file_hash TEXT NOT NULL,
  source_row_count INTEGER,

  -- Target
  target_form_id UUID REFERENCES forms(id),
  mapping_template_id UUID REFERENCES import_mapping_templates(id),

  -- Status
  status TEXT NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'validating', 'validated', 'importing',
                      'completed', 'failed', 'cancelled', 'rolled_back')),

  -- Progress (for batch)
  progress_checkpoint INTEGER DEFAULT 0,

  -- Stats
  stats JSONB NOT NULL DEFAULT '{}',
  -- { rows_total, rows_processed, rows_succeeded, rows_failed, validation_errors }

  -- Error handling
  error_report_key TEXT, -- S3 key to detailed error CSV
  error_summary JSONB DEFAULT '{}',

  -- Rollback support (for batch)
  can_rollback BOOLEAN NOT NULL DEFAULT true,
  rollback_before TIMESTAMPTZ, -- Deadline for rollback

  -- Audit
  created_by TEXT NOT NULL REFERENCES "user"(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  started_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ
);

-- Mapping templates (reusable)
CREATE TABLE import_mapping_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID REFERENCES organizations(id),

  name TEXT NOT NULL,
  description TEXT,

  target_form_id UUID REFERENCES forms(id),

  -- Mapping rules
  mappings JSONB NOT NULL,
  -- { sourceColumn: { targetField, transform?, defaultValue? } }

  created_by TEXT NOT NULL REFERENCES "user"(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Row-level errors (Lane 1 only, capped)
CREATE TABLE import_job_errors (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  job_id UUID NOT NULL REFERENCES import_jobs(id) ON DELETE CASCADE,

  row_number INTEGER NOT NULL,
  field_key TEXT,
  error_type TEXT NOT NULL,
  error_message TEXT NOT NULL,
  raw_value TEXT,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Cap row-level errors to prevent table explosion
-- For batch imports, write full errors to S3 instead
```

**Lane 2 Batch Processing Design:**

```
1. Upload CSV to S3 ‚Üí Create import_jobs row
2. EventBridge triggers ECS task
3. Worker:
   - Stream-parse CSV (don't load all in memory)
   - Validate in chunks (1000 rows)
   - Write valid rows to staging table
   - Write errors to S3 (errors.csv)
   - Update checkpoint after each chunk
4. On success:
   - Promote from staging to production in chunks (short transactions)
   - Mark job completed
5. On failure:
   - Log checkpoint for resume
   - Mark job failed with error summary
6. Rollback:
   - DELETE WHERE import_job_id = X
   - Only available before rollback_before deadline
```

**Implementation:**

- [x] Create `src/db/schema/imports.schema.ts`
- [x] Create `src/features/imports/` module
- [x] Lane 1: Import wizard UI
- [x] Lane 1: Field mapping UI with auto-suggestions
- [x] Lane 1: Validation preview
- [x] Lane 2: S3 upload flow
- [x] Lane 2: Worker container (ECS task definition) (drafted in `docs/sin-rfp/phase-0/import-batch-worker.md`)
- [x] Lane 2: Chunked processing with checkpoints
- [x] Lane 1 rollback strategy (tag inserts with `import_job_id` or stage then promote)
- [x] Mapping template CRUD
- [x] Import history and status dashboard
- [x] Rollback capability

**Acceptance Criteria:**

- [x] Admin can upload CSV/Excel and preview columns
- [x] Auto-suggest mappings by column name similarity
- [x] Preview shows first N rows with validation results
- [x] Validation errors shown per row (Lane 1) or in report (Lane 2)
- [x] Import can be executed after validation
- [x] Batch imports are resumable after failure
- [x] Lane 1 rollback supported via `import_job_id` tagging or staging discard
- [x] Rollback available within configured window
- [x] Mapping templates can be saved and reused
- [x] All imports are audit logged

---

#### R-001: Reporting Cycles & Workflows

**Priority:** P1
**Effort:** 2 weeks
**Requirement:** RP-AGG-003

**Database Schema:**

```sql
-- Reporting cycles (e.g., "FY2025 Q1", "Annual Report 2025")
CREATE TABLE reporting_cycles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  name TEXT NOT NULL,
  description TEXT,

  start_date DATE NOT NULL,
  end_date DATE NOT NULL,

  status TEXT NOT NULL DEFAULT 'upcoming'
    CHECK (status IN ('upcoming', 'active', 'closed', 'archived')),

  created_by TEXT REFERENCES "user"(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Reporting tasks (what's due, when)
CREATE TABLE reporting_tasks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  cycle_id UUID NOT NULL REFERENCES reporting_cycles(id) ON DELETE CASCADE,

  form_id UUID NOT NULL REFERENCES forms(id),

  -- Target (specific org or all orgs of a type)
  organization_id UUID REFERENCES organizations(id), -- NULL = all applicable orgs
  organization_type TEXT, -- 'pso', 'club', etc.

  title TEXT NOT NULL,
  description TEXT,
  due_date DATE NOT NULL,

  -- Reminder configuration
  reminder_config JSONB NOT NULL DEFAULT '{}',
  -- { days_before: [14, 7, 3, 1], overdue_frequency: 'daily' }

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Reporting submissions (per org per task)
CREATE TABLE reporting_submissions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  task_id UUID NOT NULL REFERENCES reporting_tasks(id),
  organization_id UUID NOT NULL REFERENCES organizations(id),

  form_submission_id UUID REFERENCES form_submissions(id),

  status TEXT NOT NULL DEFAULT 'not_started'
    CHECK (status IN ('not_started', 'in_progress', 'submitted',
                      'under_review', 'changes_requested', 'approved', 'overdue')),

  submitted_at TIMESTAMPTZ,
  submitted_by TEXT REFERENCES "user"(id),

  reviewed_at TIMESTAMPTZ,
  reviewed_by TEXT REFERENCES "user"(id),
  review_notes TEXT,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  UNIQUE(task_id, organization_id)
);

-- Submission history (for resubmissions)
CREATE TABLE reporting_submission_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  reporting_submission_id UUID NOT NULL REFERENCES reporting_submissions(id) ON DELETE CASCADE,

  action TEXT NOT NULL, -- 'submitted', 'changes_requested', 'resubmitted', 'approved'
  actor_id TEXT REFERENCES "user"(id),
  notes TEXT,

  form_submission_version_id UUID REFERENCES form_submission_versions(id),

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Implementation:**

- [x] Create `src/db/schema/reporting.schema.ts`
- [x] Create `src/features/reporting/` module
- [x] Reporting cycle CRUD (admin)
- [x] Task assignment UI
- [x] Reminder scheduler (EventBridge ‚Üí SQS ‚Üí notification)
- [x] Organization reporting dashboard ("What's due")
- [x] Admin reporting dashboard ("Who's behind")
- [x] Review workflow (approve/request changes)
- [x] Resubmission tracking with history

**Acceptance Criteria:**

- [x] Admins can create reporting cycles and tasks
- [x] Tasks can target specific orgs or org types
- [x] Organizations see their assigned tasks with due dates
- [x] Automated reminders sent at configured intervals
- [x] Status tracked through full workflow
- [x] Resubmissions maintain history with diffs
- [x] Dashboard shows progress across all orgs
- [x] Overdue tasks highlighted and tracked

---

### Phase 4: Analytics & Export (3-4 weeks)

#### R-002: Reporting & Export

**Priority:** P2
**Effort:** 3-4 weeks
**Requirement:** RP-AGG-005

**Layered Approach:**

| Layer   | Scope                                | Effort                            |
| ------- | ------------------------------------ | --------------------------------- |
| Layer 1 | Curated exports with field-level ACL | 2 weeks                           |
| Layer 2 | Saved reports with filters           | 1-2 weeks                         |
| Layer 3 | Self-service chart builder           | 3-4 weeks (defer unless required) |

**Database Schema:**

```sql
-- Saved reports
CREATE TABLE saved_reports (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID REFERENCES organizations(id),

  name TEXT NOT NULL,
  description TEXT,

  -- Report definition
  data_source TEXT NOT NULL, -- 'submissions', 'memberships', 'organizations'
  filters JSONB NOT NULL DEFAULT '{}',
  columns JSONB NOT NULL DEFAULT '[]', -- Which fields to include
  sort JSONB DEFAULT '{}',

  -- Access control
  owner_id TEXT NOT NULL REFERENCES "user"(id),
  shared_with JSONB DEFAULT '[]', -- user IDs or roles
  is_org_wide BOOLEAN NOT NULL DEFAULT false,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Export history (for audit)
CREATE TABLE export_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  user_id TEXT NOT NULL REFERENCES "user"(id),
  organization_id UUID REFERENCES organizations(id),

  report_id UUID REFERENCES saved_reports(id),

  export_type TEXT NOT NULL, -- 'csv', 'excel', 'pdf'
  data_source TEXT NOT NULL,
  filters_used JSONB NOT NULL,
  row_count INTEGER NOT NULL,

  file_key TEXT, -- S3 key (temporary)

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Field-Level Access Control:**

```typescript
interface FieldAccessPolicy {
  field: string;
  requiredRoles: string[]; // Empty = visible to all
  redactForRoles?: string[]; // Show as "***"
}

// Applied at export time, not query time
function applyFieldAccess(data: any[], userRoles: string[], policy: FieldAccessPolicy[]) {
  // Redact or remove fields based on policy
}
```

**Implementation:**

- [x] Create `src/db/schema/reports.schema.ts`
- [x] Create `src/features/reports/` module
- [x] Curated export endpoints (CSV, Excel)
- [x] Field-level access control middleware
- [x] Export audit logging
- [x] Saved report CRUD
- [x] Report builder UI (filters, columns)
- [x] Report sharing

**Acceptance Criteria:**

- [x] Authorized users can export datasets
- [x] Exports respect field-level access rules
- [x] Every export is audit logged
- [x] Reports can be saved with filters
- [x] Saved reports can be shared within org

---

## Part 4: Deferred Features (Phase 5+)

> These are not required for SIN MVP. Build only if explicitly requested.

| Feature                      | Reason to Defer              |
| ---------------------------- | ---------------------------- |
| Website builder              | Not a SIN requirement        |
| Mobile native app            | PWA sufficient               |
| Live scoring                 | Not a data warehouse feature |
| Competition management       | Not a SIN requirement        |
| LMS / training modules       | Can use external tool        |
| Full chart builder (Layer 3) | Layer 1-2 likely sufficient  |
| Multi-currency               | CAD only for viaSport        |
| Ticket sales                 | Not a SIN requirement        |

---

## Part 5: Migration Strategy (20M+ Rows)

### Pre-Migration Checklist

- [x] Legacy data inventory (tables, row counts, relationships) (synthetic placeholders in `docs/sin-rfp/phase-0/migration-strategy.md`)
- [x] Data quality assessment (nulls, duplicates, invalid formats) (synthetic placeholders in `docs/sin-rfp/phase-0/migration-strategy.md`)
- [x] Field mapping document (legacy ‚Üí SIN) (synthesized in `docs/sin-rfp/phase-0/migration-strategy.md`)
- [x] Transformation rules (date formats, phone normalization, enum mappings) (synthesized in `docs/sin-rfp/phase-0/migration-strategy.md`)
- [x] Rollback plan (keep legacy system read-only during transition) (documented in `docs/sin-rfp/phase-0/migration-strategy.md`)

### Migration Phases

| Phase | Scope                  | Approach                             |
| ----- | ---------------------- | ------------------------------------ |
| 1     | Schema creation        | Run in empty environment             |
| 2     | Organization hierarchy | Manual or scripted setup             |
| 3     | User migration         | Batch import with email notification |
| 4     | Historical submissions | Lane 2 batch import                  |
| 5     | Document migration     | S3 bulk copy with metadata sync      |
| 6     | Validation             | Reconciliation reports               |
| 7     | Cutover                | DNS switch, legacy read-only         |

### Batch Import Configuration for 20M Rows

```yaml
# ECS Task Definition
resources:
  cpu: 2048
  memory: 4096

# Processing settings
chunk_size: 5000
checkpoint_interval: 10000
max_retries: 3
connection_pool: unpooled # Direct connection, not pooled

# Error handling
max_errors_before_abort: 10000
error_report_format: csv
error_report_destination: s3://bucket/imports/{job_id}/errors.csv
```

---

## Part 6: RFP Submission Checklist

### Documentation Deliverables

- [x] Reference architecture document (with diagram)
- [x] Data residency statement
- [x] Security controls overview
- [x] Backup & DR plan with RPO/RTO
- [x] Audit & retention policy
- [x] Sub-processor inventory
- [x] Data classification guide
- [x] Migration strategy document
- [x] Phased delivery plan

### Technical Demonstration

- [x] Organization hierarchy with multi-level access (hierarchy visualization pending)
- [x] Audit log with filtering and export
- [x] MFA enrollment and challenge
- [x] Dynamic form creation and submission
- [x] Bulk import with validation and rollback
- [x] Reporting cycle with reminders
- [x] DSAR workflow (export, erasure)

### Compliance Evidence

- [x] AWS Canada region configuration
- [x] Encryption at rest (KMS)
- [x] Encryption in transit (TLS 1.3)
- [x] Immutable audit logs (trigger-enforced)
- [x] Session security controls
- [x] PII redaction in logs
- [ ] Backup restore test results (template only; needs execution)

---

## Appendix A: Existing Code to Leverage

| Existing Code                                    | Use For                            |
| ------------------------------------------------ | ---------------------------------- |
| `src/db/schema/roles.schema.ts`                  | Extend for org-scoped roles        |
| `src/components/form-fields/*`                   | Form builder field types           |
| `src/lib/email/sendgrid.ts`                      | Migrate to SES, keep patterns      |
| `src/components/ui/data-table.tsx`               | Admin dashboards                   |
| `src/lib/pacer/*`                                | Rate limiting foundation           |
| `src/features/membership/membership.finalize.ts` | Pattern for atomic multi-table ops |
| `src/lib/auth/*`                                 | Extend with MFA and org context    |

---

## Appendix B: Technology Stack Updates

| Current            | SIN Production                    |
| ------------------ | --------------------------------- |
| Neon PostgreSQL    | AWS RDS PostgreSQL (ca-central-1) |
| Netlify            | AWS via SST (production)          |
| SendGrid           | AWS SES (ca-central-1)            |
| Local file storage | S3 with SSE-KMS                   |
| No queue           | SQS for notifications             |
| No scheduler       | EventBridge Scheduler             |
| Console logging    | CloudWatch Logs (PII redacted)    |

---

## Appendix C: Better Auth 2FA Configuration

```typescript
// src/lib/auth/index.ts
import { betterAuth } from "better-auth";
import { twoFactor } from "better-auth/plugins/2fa";

export const auth = betterAuth({
  // ... existing config
  plugins: [
    twoFactor({
      issuer: "viaSport SIN",
      // TOTP settings
      totpOptions: {
        digits: 6,
        period: 30,
      },
      // Backup codes
      backupCodes: {
        enabled: true,
        count: 10,
        length: 8,
      },
    }),
  ],
});
```

---

## Document History

| Version | Date       | Changes                                                      |
| ------- | ---------- | ------------------------------------------------------------ |
| v1.0    | 2024-12    | Initial backlog                                              |
| v2.0    | 2024-12    | Complete rewrite incorporating architecture review feedback  |
| v2.1    | 2025-12-24 | Added Implementation Progress Tracker with codebase analysis |
</file>

<file path="src/lib/auth/types.ts">
import type { User as BetterAuthUser } from "better-auth";
import type { Tag } from "~/db/schema";

// User role with full role information
export interface UserRole {
  id: string;
  userId: string;
  roleId: string;
  role: {
    id: string;
    name: string;
    description: string | null;
    permissions: Record<string, boolean>;
  };
  teamId?: string | null;
  eventId?: string | null;
  assignedBy: string;
  assignedAt: Date;
  expiresAt?: Date | null;
  notes?: string | null;
}

// User tag (for future implementation)
export interface UserTag {
  id: string;
  userId: string;
  tagId: string;
  tag: Tag;
  assignedBy?: string | null;
  assignedAt: Date;
  expiresAt?: Date | null;
  notes?: string | null;
}

// Extended user type that includes our custom fields
export interface User extends BetterAuthUser {
  // Profile completion tracking
  profileComplete: boolean;

  // Required profile fields
  dateOfBirth?: Date | null;
  emergencyContact?: string | null; // JSON string

  // Optional profile fields
  gender?: string | null;
  pronouns?: string | null;
  phone?: string | null;

  // Privacy and preferences
  privacySettings?: string | null; // JSON string

  // Audit and versioning
  profileVersion: number;
  profileUpdatedAt?: Date | null;

  // MFA status
  mfaRequired: boolean;
  mfaEnrolledAt?: Date | null;
  twoFactorEnabled: boolean;

  // Roles and permissions
  roles?: UserRole[];

  // Tags (for future implementation)
  tags?: UserTag[];
}

// Type definitions that can be safely imported on both client and server
export type AuthUser = User | null;
</file>

<file path="src/features/auth/__tests__/login.test.tsx">
import userEvent from "@testing-library/user-event";
import { beforeEach, describe, expect, it, vi } from "vitest";

// Setup mocks before imports
const mockNavigate = vi.fn();
const mockInvalidateQueries = vi.fn();

// Mock auth client
vi.mock("~/lib/auth-client", () => ({
  auth: {
    signIn: {
      email: vi.fn(),
    },
    signUp: {
      email: vi.fn(),
    },
    signInWithOAuth: vi.fn(),
    signOut: vi.fn(),
    getSession: vi.fn(),
  },
  default: {
    signIn: {
      email: vi.fn(),
      social: vi.fn(),
    },
    signUp: {
      email: vi.fn(),
    },
    signOut: vi.fn(),
    getSession: vi.fn(),
  },
}));

// Mock TanStack Router
vi.mock("@tanstack/react-router", () => ({
  // eslint-disable-next-line @eslint-react/hooks-extra/no-unnecessary-use-prefix
  useNavigate: () => mockNavigate,
  // eslint-disable-next-line @eslint-react/hooks-extra/no-unnecessary-use-prefix
  useRouteContext: () => ({ redirectUrl: "/dashboard" }),
  // eslint-disable-next-line @eslint-react/hooks-extra/no-unnecessary-use-prefix
  useRouterState: () => ({ location: { pathname: "/auth/login" } }),
  // eslint-disable-next-line @eslint-react/hooks-extra/no-unnecessary-use-prefix
  useRouter: () => ({ invalidate: vi.fn() }),
  Link: ({
    to,
    children,
    ...props
  }: {
    to: string;
    children: React.ReactNode;
  } & React.AnchorHTMLAttributes<HTMLAnchorElement>) => (
    <a href={to} {...props}>
      {children}
    </a>
  ),
}));

// Mock SafeLink
vi.mock("~/components/ui/SafeLink", () => ({
  SafeLink: ({
    to,
    children,
    ...props
  }: {
    to: string;
    children: React.ReactNode;
  } & React.AnchorHTMLAttributes<HTMLAnchorElement>) => (
    <a href={to} {...props}>
      {children}
    </a>
  ),
}));

vi.mock("~/features/security/security.mutations", () => ({
  recordSecurityEvent: vi.fn(),
}));

vi.mock("~/features/security/security.queries", () => ({
  getAccountLockStatus: vi.fn().mockResolvedValue(null),
}));

vi.mock("@tanstack/react-query", async (importOriginal) => {
  const actual = await importOriginal<typeof import("@tanstack/react-query")>();
  return {
    ...actual,
    // eslint-disable-next-line @eslint-react/hooks-extra/no-unnecessary-use-prefix
    useQueryClient: () => ({ invalidateQueries: mockInvalidateQueries }),
  };
});

import { auth } from "~/lib/auth-client";
import { createAuthMocks } from "~/tests/mocks/auth";
import { render, screen, waitFor } from "~/tests/utils";
import LoginForm from "../components/login";

describe("LoginForm", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("renders login form with all elements", () => {
    render(<LoginForm />);

    // Check for form elements
    expect(screen.getByLabelText("Email")).toBeInTheDocument();
    expect(screen.getByLabelText("Password")).toBeInTheDocument();
    expect(screen.getByRole("button", { name: "Login" })).toBeInTheDocument();

    // Check for social login button
    expect(screen.getByRole("button", { name: "Login with Google" })).toBeInTheDocument();

    // Check for signup link
    expect(screen.getByText("Don't have an account?")).toBeInTheDocument();
    expect(screen.getByRole("link", { name: "Sign up" })).toHaveAttribute(
      "href",
      "/auth/signup",
    );
  });

  it("handles successful email login", async () => {
    const user = userEvent.setup();
    const { mockUser, mockSession } = createAuthMocks();

    // Setup successful login response
    vi.mocked(auth.signIn.email).mockResolvedValueOnce({
      data: { user: mockUser, session: mockSession },
      error: null,
    });

    render(<LoginForm />);

    // Fill in form
    await user.type(screen.getByLabelText("Email"), "test@example.com");
    await user.type(screen.getByLabelText("Password"), "password123");

    // Submit form
    await user.click(screen.getByRole("button", { name: "Login" }));

    await waitFor(() => {
      // Verify auth client was called
      expect(auth.signIn.email).toHaveBeenCalledWith({
        email: "test@example.com",
        password: "password123",
      });

      // Verify queries were invalidated
      expect(mockInvalidateQueries).toHaveBeenCalledWith({ queryKey: ["user"] });

      // Verify navigation
      expect(mockNavigate).toHaveBeenCalledWith({ to: "/dashboard" });
    });
  });

  it("displays error message on failed login", async () => {
    const user = userEvent.setup();
    const errorMessage = "Invalid email or password";

    // Setup failed login response
    vi.mocked(auth.signIn.email).mockResolvedValueOnce({
      data: null,
      error: {
        message: errorMessage,
      },
    });

    render(<LoginForm />);

    // Fill in form
    await user.type(screen.getByLabelText("Email"), "test@example.com");
    await user.type(screen.getByLabelText("Password"), "wrongpassword");

    // Submit form
    await user.click(screen.getByRole("button", { name: "Login" }));

    await waitFor(() => {
      // Verify error message is displayed
      expect(screen.getByText(errorMessage)).toBeInTheDocument();
    });
  });

  it("disables form during submission", async () => {
    const user = userEvent.setup();

    // Setup delayed login response
    vi.mocked(auth.signIn.email).mockImplementationOnce(() => {
      return new Promise(() => {}); // Never resolves
    });

    render(<LoginForm />);

    // Fill in form
    await user.type(screen.getByLabelText("Email"), "test@example.com");
    await user.type(screen.getByLabelText("Password"), "password123");

    // Submit form
    await user.click(screen.getByRole("button", { name: "Login" }));

    // Check loading state
    expect(screen.getByRole("button", { name: "Logging in..." })).toBeDisabled();
    expect(screen.getByLabelText("Email")).toBeDisabled();
    expect(screen.getByLabelText("Password")).toBeDisabled();

    // Social login button should also be disabled
    expect(screen.getByRole("button", { name: "Login with Google" })).toBeDisabled();
  });

  it("handles Google social login", async () => {
    const user = userEvent.setup();
    const { mockUser } = createAuthMocks();

    vi.mocked(auth.signInWithOAuth).mockResolvedValueOnce({
      redirect: true,
      token: "mock-token",
      url: undefined,
      user: mockUser,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } as any);

    render(<LoginForm />);

    await user.click(screen.getByRole("button", { name: "Login with Google" }));

    expect(auth.signInWithOAuth).toHaveBeenCalledWith(
      {
        provider: "google",
        callbackURL: "/dashboard",
      },
      expect.objectContaining({
        onRequest: expect.any(Function),
        onError: expect.any(Function),
      }),
    );
  });

  it("validates required fields", async () => {
    const user = userEvent.setup();

    render(<LoginForm />);

    // Try to submit empty form
    await user.click(screen.getByRole("button", { name: "Login" }));

    // Auth client should not be called
    expect(auth.signIn.email).not.toHaveBeenCalled();
  });
});
</file>

<file path="src/lib/auth/middleware/role-guard.ts">
import { redirect } from "@tanstack/react-router";
import { userHasRole } from "~/features/roles/permission.service";
import type { User } from "~/lib/auth/types";
import { isAdminClient } from "~/lib/auth/utils/admin-check";

interface RoleGuardOptions {
  user: User | null;
  requiredRoles?: string[];
  teamId?: string;
  eventId?: string;
  redirectTo?: string;
}

/**
 * Role-based access control guard for routes
 * Use this in route beforeLoad to protect pages based on user roles
 */
export async function requireRole({
  user,
  requiredRoles,
  teamId,
  eventId,
  redirectTo = "/dashboard",
}: RoleGuardOptions) {
  if (!user) {
    throw redirect({ to: "/auth/login" });
  }

  if (!requiredRoles || requiredRoles.length === 0) {
    return;
  }

  const hasAccess = requiredRoles.some((roleName) => {
    if (roleName === "Team Admin" && teamId) {
      return userHasRole(user, roleName, { teamId });
    }

    if (roleName === "Event Admin" && eventId) {
      return userHasRole(user, roleName, { eventId });
    }

    return userHasRole(user, roleName);
  });

  if (!hasAccess) {
    throw redirect({ to: redirectTo });
  }
}

/**
 * Convenience function for requiring global admin access
 */
export async function requireGlobalAdmin(user: User | null, redirectTo = "/dashboard") {
  if (!user) {
    throw redirect({ to: "/auth/login" });
  }

  if (!isAdminClient(user)) {
    throw redirect({ to: redirectTo });
  }
}
</file>

<file path="src/routes/api/auth/$action/$provider.ts">
import { createFileRoute } from "@tanstack/react-router";
import { getAuth } from "~/lib/auth/server-helpers";

export const Route = createFileRoute("/api/auth/$action/$provider")({
  server: {
    handlers: {
      GET: async ({ request }) => {
        const auth = await getAuth();
        return await auth.handler(request);
      },
      POST: async ({ request }) => {
        const auth = await getAuth();
        return await auth.handler(request);
      },
    },
  },
});
</file>

<file path="src/routes/api/auth/$.ts">
import { createFileRoute } from "@tanstack/react-router";
import { getAuth } from "~/lib/auth/server-helpers";

export const Route = createFileRoute("/api/auth/$")({
  server: {
    handlers: {
      GET: async ({ request }) => {
        const auth = await getAuth();
        return await auth.handler(request);
      },
      POST: async ({ request }) => {
        const auth = await getAuth();
        return await auth.handler(request);
      },
      OPTIONS: async ({ request }) => {
        const auth = await getAuth();
        return await auth.handler(request);
      },
    },
  },
});
</file>

<file path="src/features/auth/auth.schemas.ts">
import { z } from "zod";

/**
 * Login form validation schema
 */
export const loginFormSchema = z.object({
  email: z.email("Please enter a valid email").min(1, "Email is required"),
  password: z.string().min(1, "Password is required"),
});

export type LoginFormData = z.infer<typeof loginFormSchema>;

/**
 * Base signup form field schemas
 */
export const signupFormFieldSchemas = {
  name: z
    .string()
    .min(1, "Name is required")
    .min(2, "Name must be at least 2 characters"),
  email: z.email("Please enter a valid email").min(1, "Email is required"),
  password: z
    .string()
    .min(1, "Password is required")
    .min(8, "Password must be at least 8 characters"),
  confirmPassword: z.string().min(1, "Please confirm your password"),
};

/**
 * Signup form field validators for TanStack Form
 */
export const signupFormFields = {
  name: ({ value }: { value: string }) => {
    try {
      signupFormFieldSchemas.name.parse(value);
      return undefined;
    } catch (error) {
      if (error instanceof z.ZodError) {
        return error.issues[0]?.message || "Invalid name";
      }
      return "Invalid name";
    }
  },
  email: ({ value }: { value: string }) => {
    try {
      signupFormFieldSchemas.email.parse(value);
      return undefined;
    } catch (error) {
      if (error instanceof z.ZodError) {
        return error.issues[0]?.message || "Invalid email";
      }
      return "Invalid email";
    }
  },
  password: ({ value }: { value: string }) => {
    try {
      signupFormFieldSchemas.password.parse(value);
      return undefined;
    } catch (error) {
      if (error instanceof z.ZodError) {
        return error.issues[0]?.message || "Invalid password";
      }
      return "Invalid password";
    }
  },
  confirmPassword: ({ value }: { value: string }) => {
    try {
      signupFormFieldSchemas.confirmPassword.parse(value);
      return undefined;
    } catch (error) {
      if (error instanceof z.ZodError) {
        return error.issues[0]?.message || "Please confirm your password";
      }
      return "Please confirm your password";
    }
  },
};

/**
 * Signup form validation schema
 */
export const signupFormSchema = z
  .object(signupFormFieldSchemas)
  .refine((data) => data.password === data.confirmPassword, {
    path: ["confirmPassword"],
    error: "Passwords do not match",
  });

export type SignupFormData = z.infer<typeof signupFormSchema>;
</file>

<file path="src/lib/auth/middleware/auth-guard.ts">
import { createMiddleware } from "@tanstack/react-start";
import type { AuthUser } from "~/lib/auth/types";
import { resolveRequestId } from "~/lib/server/request-id";

export type AuthedRequestContext = {
  user: NonNullable<AuthUser>;
  requestId: string;
  organizationId?: string | null;
  organizationRole?: string | null;
};

const getCookieValue = (headers: Headers, name: string) => {
  const cookieHeader = headers.get("cookie");
  if (!cookieHeader) return null;
  const cookies = cookieHeader.split(";").map((entry) => entry.trim());
  const prefix = `${name}=`;
  for (const cookie of cookies) {
    if (cookie.startsWith(prefix)) {
      return decodeURIComponent(cookie.slice(prefix.length));
    }
  }
  return null;
};

/**
 * Middleware to force authentication on a server function, and add the user to the context.
 */
export const authMiddleware = createMiddleware({ type: "function" }).server(
  async ({ next, context }) => {
    const { getRequest, setResponseHeader, setResponseStatus } =
      await import("@tanstack/react-start/server");
    const { getAuth } = await import("~/lib/auth/server-helpers");
    const auth = await getAuth();
    const request = getRequest();
    const headers = request.headers;

    const requestId =
      (context as { requestId?: string } | undefined)?.requestId ??
      resolveRequestId(headers);
    setResponseHeader("x-request-id", requestId);

    const session = await auth.api.getSession({
      headers,
      query: {
        disableCookieCache: true,
      },
    });

    const user = session?.user;

    if (!user) {
      setResponseStatus(401);
      const { unauthorized } = await import("~/lib/server/errors");
      throw unauthorized();
    }

    const { isAccountLocked } = await import("~/lib/security/lockout");
    const lock = await isAccountLocked(user.id);
    if (lock) {
      setResponseStatus(423);
      const { forbidden } = await import("~/lib/server/errors");
      throw forbidden("Account locked");
    }

    const authed: AuthedRequestContext = {
      user: user as NonNullable<AuthUser>,
      requestId,
    };

    const contextOrgId =
      (context as { organizationId?: string | null } | undefined)?.organizationId ??
      null;
    const contextOrgRole =
      (context as { organizationRole?: string | null } | undefined)?.organizationRole ??
      null;
    const headerOrgId = headers.get("x-organization-id");
    const cookieOrgId = getCookieValue(headers, "active_org_id");
    const requestedOrgId = headerOrgId ?? contextOrgId ?? cookieOrgId ?? null;

    if (requestedOrgId) {
      if (contextOrgId === requestedOrgId && contextOrgRole) {
        authed.organizationId = contextOrgId;
        authed.organizationRole = contextOrgRole;
      } else {
        const { resolveOrganizationAccess } = await import(
          "~/features/organizations/organizations.access"
        );
        const access = await resolveOrganizationAccess({
          userId: user.id,
          organizationId: requestedOrgId,
        });

        if (access) {
          authed.organizationId = access.organizationId;
          authed.organizationRole = access.role;
        }
      }
    }

    const mergedContext = {
      ...(context as Record<string, unknown> | undefined),
      ...authed,
    } as AuthedRequestContext;

    return next({ context: mergedContext });
  },
);
</file>

<file path="src/lib/auth/utils/admin-check.ts">
import { createServerOnlyFn } from "@tanstack/react-start";
import type { AuthUser } from "~/lib/auth/types";
import { getTenantConfig } from "~/tenant";

const GLOBAL_ADMIN_ROLE_NAMES = getTenantConfig().admin.globalRoleNames;

const getPermissionService = createServerOnlyFn(async () => {
  const { PermissionService } = await import("~/features/roles/permission.service");
  return PermissionService;
});

function hasGlobalAdminRole(user: AuthUser): boolean {
  if (!user?.roles || user.roles.length === 0) {
    return false;
  }

  return user.roles.some(({ role }) => GLOBAL_ADMIN_ROLE_NAMES.includes(role.name));
}

export async function isAdmin(userId: string | undefined | null): Promise<boolean> {
  if (!userId) return false;
  const PermissionService = await getPermissionService();
  return PermissionService.isGlobalAdmin(userId);
}

export async function requireAdmin(userId: string | undefined | null): Promise<void> {
  if (!(await isAdmin(userId))) {
    throw new Error("Unauthorized: Admin access required");
  }

  if (!userId) {
    throw new Error("Unauthorized: Admin access required");
  }

  const { getDb } = await import("~/db/server-helpers");
  const { user } = await import("~/db/schema");
  const { eq } = await import("drizzle-orm");
  const db = await getDb();
  const [record] = await db
    .select({ mfaRequired: user.mfaRequired, twoFactorEnabled: user.twoFactorEnabled })
    .from(user)
    .where(eq(user.id, userId))
    .limit(1);

  if (record?.mfaRequired && !record.twoFactorEnabled) {
    throw new Error("Multi-factor authentication required");
  }
}

export function isAdminClient(user: AuthUser): boolean {
  return hasGlobalAdminRole(user);
}

export { GLOBAL_ADMIN_ROLE_NAMES };
</file>

<file path="src/features/auth/components/signup.tsx">
import { useQueryClient } from "@tanstack/react-query";
import { useNavigate, useRouter } from "@tanstack/react-router";
import { useState } from "react";
import { FormSubmitButton } from "~/components/form-fields/FormSubmitButton";
import { ValidatedInput } from "~/components/form-fields/ValidatedInput";
import { Button } from "~/components/ui/button";
import { GoogleIcon, LogoIcon } from "~/components/ui/icons";
import { SafeLink as Link } from "~/components/ui/SafeLink";
import { auth } from "~/lib/auth-client";
import { useAppForm } from "~/lib/hooks/useAppForm";
import { getBrand } from "~/tenant";
import { authQueryKey } from "../auth.queries";
import { signupFormFields } from "../auth.schemas";

export default function SignupForm() {
  const brand = getBrand();
  const queryClient = useQueryClient();
  const navigate = useNavigate();
  const router = useRouter();
  const redirectUrl = "/dashboard"; // Default redirect after signup

  const [isLoading, setIsLoading] = useState(false);
  const [errorMessage, setErrorMessage] = useState("");

  const form = useAppForm({
    defaultValues: {
      name: "",
      email: "",
      password: "",
      confirmPassword: "",
    },
    onSubmit: async ({ value }) => {
      setIsLoading(true);
      setErrorMessage("");

      try {
        const result = await auth.signUp.email({
          name: value.name,
          email: value.email,
          password: value.password,
          callbackURL: redirectUrl,
        });

        if (result?.error) {
          throw new Error(result.error.message || "Signup failed");
        }

        // Success path
        await queryClient.invalidateQueries({ queryKey: authQueryKey });
        await router.invalidate();
        await navigate({ to: redirectUrl });
      } catch (error) {
        // Error handling
        setErrorMessage((error as Error)?.message || "Signup failed");
        // Keep form values but reset submitting state by resetting with current values
        form.reset({
          name: value.name,
          email: value.email,
          password: value.password,
          confirmPassword: value.confirmPassword,
        });
      } finally {
        // Always reset loading state
        setIsLoading(false);
      }
    },
  });

  return (
    <div className="flex flex-col gap-6">
      <form
        onSubmit={async (e) => {
          e.preventDefault();
          e.stopPropagation();
          await form.handleSubmit();
        }}
      >
        <div className="flex flex-col gap-6">
          <div className="flex flex-col items-center gap-2">
            <a href="#" className="flex flex-col items-center gap-2 font-medium">
              <div className="flex h-8 w-8 items-center justify-center rounded-md">
                <LogoIcon className="size-6" />
              </div>
              <span className="sr-only">{brand.name}</span>
            </a>
            <h1 className="text-xl font-bold">Sign up for {brand.name}</h1>
          </div>
          <div className="flex flex-col gap-5">
            <form.Field
              name="name"
              validators={{
                onChange: signupFormFields.name,
              }}
            >
              {(field) => (
                <ValidatedInput
                  field={field}
                  label="Name"
                  type="text"
                  placeholder="John Doe"
                  autoComplete="name"
                  autoFocus
                />
              )}
            </form.Field>
            <form.Field
              name="email"
              validators={{
                onChange: signupFormFields.email,
              }}
            >
              {(field) => (
                <ValidatedInput
                  field={field}
                  label="Email"
                  type="email"
                  placeholder="hello@example.com"
                  autoComplete="email"
                />
              )}
            </form.Field>
            <form.Field
              name="password"
              validators={{
                onChange: signupFormFields.password,
              }}
            >
              {(field) => (
                <ValidatedInput
                  field={field}
                  label="Password"
                  type="password"
                  placeholder="Password"
                  autoComplete="new-password"
                />
              )}
            </form.Field>
            <form.Field
              name="confirmPassword"
              validators={{
                onChangeListenTo: ["password"],
                onChange: ({ value, fieldApi }) => {
                  const password = fieldApi.form.getFieldValue("password");
                  // Only validate if both fields have values
                  if (value && password && value !== password) {
                    return "Passwords do not match";
                  }
                  return undefined;
                },
              }}
            >
              {(field) => (
                <ValidatedInput
                  field={field}
                  label="Confirm Password"
                  type="password"
                  placeholder="Confirm Password"
                  autoComplete="new-password"
                />
              )}
            </form.Field>
            <FormSubmitButton
              isSubmitting={form.state.isSubmitting || isLoading}
              className="mt-2 w-full"
              size="lg"
              loadingText="Signing up..."
            >
              Sign up
            </FormSubmitButton>
          </div>
          {errorMessage && (
            <span className="text-destructive text-center text-sm">{errorMessage}</span>
          )}
          <div className="after:border-border relative text-center text-sm after:absolute after:inset-0 after:top-1/2 after:z-0 after:flex after:items-center after:border-t">
            <span className="bg-background text-muted-foreground relative z-10 px-2">
              Or
            </span>
          </div>
          <Button
            variant="outline"
            className="w-full"
            type="button"
            disabled={isLoading || form.state.isSubmitting}
            onClick={() =>
              auth.signInWithOAuth(
                {
                  provider: "google",
                  callbackURL: redirectUrl,
                },
                {
                  onRequest: () => {
                    setIsLoading(true);
                    setErrorMessage("");
                  },
                  // eslint-disable-next-line @typescript-eslint/no-explicit-any
                  onError: (ctx: any) => {
                    setIsLoading(false);
                    setErrorMessage(ctx.error?.message || "OAuth signup failed");
                  },
                },
              )
            }
          >
            <GoogleIcon />
            Sign up with Google
          </Button>
        </div>
      </form>

      <div className="text-center text-sm">
        Already have an account?{" "}
        <Link to="/auth/login" className="underline underline-offset-4">
          Login
        </Link>
      </div>
    </div>
  );
}
</file>

<file path="src/features/auth/auth.queries.ts">
import { queryOptions } from "@tanstack/react-query";
import { createServerFn } from "@tanstack/react-start";
import type { User } from "~/lib/auth/types";

/**
 * Server function to get the current user with all custom fields
 */
export const getCurrentUser = createServerFn({ method: "GET" }).handler(
  async (): Promise<User | null> => {
    // Import server-only modules inside the handler
    const { getDb } = await import("~/db/server-helpers");
    const { getAuth } = await import("~/lib/auth/server-helpers");
    const auth = await getAuth();
    const { getRequest } = await import("@tanstack/react-start/server");
    const { headers } = getRequest();

    const session = await auth.api.getSession({ headers });

    if (!session?.user) {
      return null;
    }

    // Import schema and ORM inside the handler
    const { eq } = await import("drizzle-orm");
    const { user } = await import("~/db/schema");

    // Fetch the full user data from the database
    const db = await getDb();
    const dbUser = await db
      .select()
      .from(user)
      .where(eq(user.id, session.user.id))
      .limit(1);

    if (!dbUser[0]) {
      return null;
    }

    // Fetch user roles
    const { PermissionService } = await import("~/features/roles/permission.service");
    const userRoles = await PermissionService.getUserRoles(session.user.id);

    // Map the database user to our extended User type
    return {
      ...session.user,
      profileComplete: dbUser[0].profileComplete,
      dateOfBirth: dbUser[0].dateOfBirth,
      emergencyContact: dbUser[0].emergencyContact,
      gender: dbUser[0].gender,
      pronouns: dbUser[0].pronouns,
      phone: dbUser[0].phone,
      privacySettings: dbUser[0].privacySettings,
      profileVersion: dbUser[0].profileVersion,
      profileUpdatedAt: dbUser[0].profileUpdatedAt,
      mfaRequired: dbUser[0].mfaRequired,
      mfaEnrolledAt: dbUser[0].mfaEnrolledAt,
      twoFactorEnabled: dbUser[0].twoFactorEnabled,
      roles: userRoles,
    };
  },
);

export type AuthQueryResult = Awaited<ReturnType<typeof getCurrentUser>>;

export const authQueryKey = ["user"] as const;

export const authQueryOptions = () =>
  queryOptions({
    queryKey: authQueryKey,
    queryFn: ({ signal }) => getCurrentUser({ signal }),
  });
</file>

<file path="src/lib/auth/server-helpers.ts">
/**
 * Server-only auth helpers
 * This module contains auth configuration that requires server-side environment variables
 */
import { APIError, betterAuth } from "better-auth";
import { drizzleAdapter } from "better-auth/adapters/drizzle";
import { twoFactor } from "better-auth/plugins";
import { tanstackStartCookies } from "better-auth/tanstack-start";
import { getBrand } from "~/tenant";

// Lazy-loaded auth instance
let authInstance: ReturnType<typeof betterAuth> | undefined;
let authInitPromise: Promise<ReturnType<typeof betterAuth>> | undefined;

const assertServerOnly = () => {
  if (typeof window !== "undefined") {
    throw new Error("Auth helpers can only be used on the server.");
  }
};

// Create and export the auth instance with server configuration
const createAuth = async (): Promise<ReturnType<typeof betterAuth>> => {
  assertServerOnly();
  // Import server modules when auth is created
  const { db } = await import("~/db");
  const schema = await import("~/db/schema");
  const { env, getAuthSecret, getBaseUrl, isProduction } =
    await import("~/lib/env.server");
  const brand = getBrand();

  const baseUrl = getBaseUrl();
  const isHttpsDeployment = baseUrl?.startsWith("https://") ?? false;
  const cookieDomain = env.COOKIE_DOMAIN;
  const allowedOAuthDomains = Array.isArray(env.OAUTH_ALLOWED_DOMAINS)
    ? env.OAUTH_ALLOWED_DOMAINS
    : [];
  const googleClientId = env.GOOGLE_CLIENT_ID || "";
  const googleClientSecret = env.GOOGLE_CLIENT_SECRET || "";

  if (process.env["NODE_ENV"] !== "production") {
    console.log("Auth config loading...");
    console.log("Base URL:", baseUrl);

    console.log(
      "Google Client ID:",
      googleClientId ? `Set (${googleClientId.substring(0, 10)}...)` : "Missing",
    );
    console.log("Google Client Secret:", googleClientSecret ? "Set" : "Missing");
    if (allowedOAuthDomains.length > 0) {
      console.log("OAuth allowed domains:", allowedOAuthDomains.join(", "));
    }
  }

  // Get database connection
  const dbConnection = await db();

  return betterAuth({
    appName: brand.name,
    baseURL: baseUrl,
    secret: getAuthSecret(),
    trustedOrigins: isProduction()
      ? [baseUrl]
      : [
          baseUrl,
          "http://localhost:3001",
          "http://localhost:5173",
          "http://localhost:5174",
          "http://localhost:8888",
        ],
    database: drizzleAdapter(dbConnection, {
      provider: "pg",
      schema: {
        user: schema.user,
        session: schema.session,
        account: schema.account,
        verification: schema.verification,
        twoFactor: schema.twoFactor,
      },
    }),

    // Session configuration with security settings
    session: {
      expiresIn: 60 * 60 * 8, // 8 hours
      updateAge: 60 * 30, // 30 minutes
      // NOTE: cookieCache is disabled due to a known bug with tanstackStartCookies
      // that prevents session_token cookie from being set. See:
      // https://github.com/better-auth/better-auth/issues/5639
      // Re-enable once the upstream fix is released.
    },

    // Secure cookie configuration
    advanced: {
      cookiePrefix: "solstice",
      useSecureCookies: isHttpsDeployment,
      defaultCookieAttributes: cookieDomain
        ? {
            secure: isHttpsDeployment,
            sameSite: "lax",
            httpOnly: true,
            path: "/",
            domain: cookieDomain,
          }
        : {
            secure: isHttpsDeployment,
            sameSite: "lax",
            httpOnly: true,
            path: "/",
          },
    },

    // OAuth providers configuration
    socialProviders: {
      google: {
        clientId: googleClientId,
        clientSecret: googleClientSecret,
        ...(allowedOAuthDomains.length > 0
          ? {
              mapProfileToUser: (profile: {
                email?: string | null | undefined;
                hd?: string | undefined;
              }) => {
                const email = profile.email?.toLowerCase();
                const domain = email?.split("@")[1];
                const hostedDomain = profile.hd?.toLowerCase();

                const isAllowed = [domain, hostedDomain]
                  .filter((value): value is string => Boolean(value))
                  .some((value) => allowedOAuthDomains.includes(value));

                if (!isAllowed) {
                  const allowedList =
                    allowedOAuthDomains.length === 1
                      ? allowedOAuthDomains[0]
                      : allowedOAuthDomains.join(", ");
                  throw new APIError("UNAUTHORIZED", {
                    message: `Access restricted. Please sign in with an approved domain (${allowedList}).`,
                  });
                }

                return {};
              },
            }
          : {}),
      },
    },

    // Email and password authentication
    emailAndPassword: {
      enabled: true,
      requireEmailVerification: isProduction(),
    },

    // Account linking configuration
    account: {
      accountLinking: {
        enabled: true,
        trustedProviders: ["google"], // Auto-link these providers
      },
    },

    // https://www.better-auth.com/docs/integrations/tanstack#usage-tips
    plugins: [
      twoFactor({
        issuer: brand.name,
        totpOptions: {
          digits: 6,
          period: 30,
        },
        backupCodeOptions: {
          amount: 10,
          length: 8,
        },
      }),
      tanstackStartCookies(), // MUST be the last plugin
    ],
  });
};

// Export auth as a getter that creates instance on first use
export const auth = new Proxy({} as ReturnType<typeof betterAuth>, {
  get(target, prop) {
    if (!authInstance) {
      throw new Error("Auth must be initialized asynchronously. Use getAuth() instead.");
    }
    return authInstance[prop as keyof typeof authInstance];
  },
});

// Export async getter for auth
export const getAuth = async (): Promise<ReturnType<typeof betterAuth>> => {
  assertServerOnly();

  if (authInstance) {
    return authInstance;
  }

  if (!authInitPromise) {
    authInitPromise = createAuth().then((instance) => {
      authInstance = instance;
      return instance;
    });
  }

  return authInitPromise;
};
</file>

<file path="src/features/auth/components/login.tsx">
import { useQueryClient } from "@tanstack/react-query";
import { useNavigate, useRouter } from "@tanstack/react-router";
import { useEffect, useState } from "react";
import { z } from "zod";
import { FormSubmitButton } from "~/components/form-fields/FormSubmitButton";
import { ValidatedInput } from "~/components/form-fields/ValidatedInput";
import { Button } from "~/components/ui/button";
import { GoogleIcon, LogoIcon } from "~/components/ui/icons";
import { Input } from "~/components/ui/input";
import { SafeLink as Link } from "~/components/ui/SafeLink";
import { recordSecurityEvent } from "~/features/security/security.mutations";
import { getAccountLockStatus } from "~/features/security/security.queries";
import { auth } from "~/lib/auth-client";
import { useAppForm } from "~/lib/hooks/useAppForm";
import { getBrand } from "~/tenant";
import { authQueryKey } from "../auth.queries";
import { loginFormSchema } from "../auth.schemas";

type LoginFormProps = {
  redirectPath?: string | undefined;
};

export default function LoginForm(props?: LoginFormProps) {
  const brand = getBrand();
  const queryClient = useQueryClient();
  const navigate = useNavigate();
  const router = useRouter();

  const safeRedirectPath = props?.redirectPath?.startsWith("/")
    ? props.redirectPath
    : "/dashboard";

  const [isHydrated, setIsHydrated] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [errorMessage, setErrorMessage] = useState("");
  const [twoFactorRequired, setTwoFactorRequired] = useState(false);
  const [twoFactorMethod, setTwoFactorMethod] = useState<"totp" | "backup">("totp");
  const [twoFactorCode, setTwoFactorCode] = useState("");
  const [twoFactorError, setTwoFactorError] = useState("");
  const [twoFactorLoading, setTwoFactorLoading] = useState(false);

  useEffect(() => {
    // Form handlers need to wait for hydration; setting state here is intentional.
    // eslint-disable-next-line @eslint-react/hooks-extra/no-direct-set-state-in-use-effect
    setIsHydrated(true);
  }, []);

  const form = useAppForm({
    defaultValues: {
      email: "",
      password: "",
    },
    onSubmit: async ({ value }) => {
      setIsLoading(true);
      setErrorMessage("");

      try {
        const result = await auth.signIn.email(value);

        if (result?.error) {
          void recordSecurityEvent({
            data: { eventType: "login_fail", identifier: value.email },
          });
          throw new Error(result.error.message || "Invalid email or password");
        }

        if (
          result?.data &&
          "twoFactorRedirect" in result.data &&
          result.data.twoFactorRedirect
        ) {
          setTwoFactorRequired(true);
          setIsLoading(false);
          return;
        }

        // Success path
        if (result?.data && "user" in result.data && result.data.user?.id) {
          const userId = result.data.user.id;
          void recordSecurityEvent({
            data: { eventType: "login_success", userId: result.data.user.id },
          });
          const lock = await getAccountLockStatus({ data: { userId } });
          if (lock) {
            await auth.signOut();
            setErrorMessage("Account locked. Contact an administrator for access.");
            return;
          }
        }
        await queryClient.invalidateQueries({ queryKey: authQueryKey });
        await router.invalidate();
        await navigate({ to: safeRedirectPath });
      } catch (error) {
        // Error handling
        setErrorMessage((error as Error)?.message || "Invalid email or password");
        // Keep form values but reset submitting state by resetting with current values
        form.reset(value);
      } finally {
        // Always reset loading state
        setIsLoading(false);
      }
    },
  });

  if (twoFactorRequired) {
    return (
      <div className="flex flex-col gap-6">
        <form
          data-testid="login-2fa-form"
          onSubmit={async (event) => {
            event.preventDefault();
            event.stopPropagation();
            setTwoFactorLoading(true);
            setTwoFactorError("");

            try {
              const result =
                twoFactorMethod === "backup"
                  ? await auth.twoFactor.verifyBackupCode({ code: twoFactorCode })
                  : await auth.twoFactor.verifyTotp({ code: twoFactorCode });

              if (result?.error) {
                void recordSecurityEvent({
                  data: { eventType: "mfa_fail" },
                });
                throw new Error(result.error.message || "Invalid authentication code");
              }

              if (result?.data?.user?.id) {
                void recordSecurityEvent({
                  data: { eventType: "mfa_success", userId: result.data.user.id },
                });
              }

              await queryClient.invalidateQueries({ queryKey: authQueryKey });
              await router.invalidate();
              await navigate({ to: safeRedirectPath });
            } catch (error) {
              setTwoFactorError(
                (error as Error)?.message || "Invalid authentication code",
              );
            } finally {
              setTwoFactorLoading(false);
            }
          }}
        >
          <div className="flex flex-col gap-6">
            <div className="flex flex-col items-center gap-2">
              <a href="#" className="flex flex-col items-center gap-2 font-medium">
                <div className="flex h-8 w-8 items-center justify-center rounded-md">
                  <LogoIcon className="size-6" />
                </div>
                <span className="sr-only">{brand.name}</span>
              </a>
              <h1 className="text-xl font-bold">Confirm your sign-in</h1>
              <p className="text-muted-foreground text-sm">
                {twoFactorMethod === "backup"
                  ? "Enter one of your backup codes."
                  : "Enter the code from your authenticator app."}
              </p>
            </div>

            <div className="flex flex-col gap-4">
              <div className="flex flex-wrap gap-2">
                <Button
                  type="button"
                  variant={twoFactorMethod === "totp" ? "default" : "outline"}
                  size="sm"
                  onClick={() => setTwoFactorMethod("totp")}
                  disabled={twoFactorLoading}
                >
                  Authenticator code
                </Button>
                <Button
                  type="button"
                  variant={twoFactorMethod === "backup" ? "default" : "outline"}
                  size="sm"
                  onClick={() => setTwoFactorMethod("backup")}
                  disabled={twoFactorLoading}
                >
                  Backup code
                </Button>
              </div>
              <div className="grid gap-2">
                <label className="text-sm font-medium" htmlFor="two-factor-code">
                  {twoFactorMethod === "backup" ? "Backup code" : "Authentication code"}
                </label>
                <Input
                  id="two-factor-code"
                  autoComplete={
                    twoFactorMethod === "backup" ? "one-time-code" : "one-time-code"
                  }
                  inputMode="numeric"
                  placeholder={twoFactorMethod === "backup" ? "backup-xxxxxx" : "123456"}
                  value={twoFactorCode}
                  onChange={(event) => setTwoFactorCode(event.target.value.trim())}
                />
              </div>

              <FormSubmitButton
                isSubmitting={twoFactorLoading}
                className="mt-2 w-full"
                size="lg"
                loadingText="Verifying..."
              >
                Verify code
              </FormSubmitButton>

              <Button
                type="button"
                variant="ghost"
                className="w-full"
                disabled={twoFactorLoading}
                onClick={() => {
                  setTwoFactorRequired(false);
                  setTwoFactorMethod("totp");
                  setTwoFactorCode("");
                  setTwoFactorError("");
                }}
              >
                Back to login
              </Button>
            </div>

            {twoFactorError && (
              <span className="text-destructive text-center text-sm">
                {twoFactorError}
              </span>
            )}
          </div>
        </form>
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-6">
      <form
        data-testid="login-form"
        data-hydrated={isHydrated ? "true" : "false"}
        onSubmit={async (e) => {
          e.preventDefault();
          e.stopPropagation();
          await form.handleSubmit();
        }}
      >
        <div className="flex flex-col gap-6">
          <div className="flex flex-col items-center gap-2">
            <a href="#" className="flex flex-col items-center gap-2 font-medium">
              <div className="flex h-8 w-8 items-center justify-center rounded-md">
                <LogoIcon className="size-6" />
              </div>
              <span className="sr-only">{brand.name}</span>
            </a>
            <h1 className="text-xl font-bold">Welcome back to {brand.name}</h1>
          </div>
          <div className="flex flex-col gap-5">
            <form.Field
              name="email"
              validators={{
                onChange: ({ value }) => {
                  try {
                    loginFormSchema.shape.email.parse(value);
                    return undefined;
                  } catch (error) {
                    if (error instanceof z.ZodError) {
                      return error.issues[0]?.message || "Invalid email";
                    }
                    return "Invalid email";
                  }
                },
              }}
            >
              {(field) => (
                <ValidatedInput
                  field={field}
                  label="Email"
                  type="email"
                  placeholder="hello@example.com"
                  autoComplete="email"
                  autoFocus
                />
              )}
            </form.Field>
            <form.Field
              name="password"
              validators={{
                onChange: ({ value }) => {
                  try {
                    loginFormSchema.shape.password.parse(value);
                    return undefined;
                  } catch (error) {
                    if (error instanceof z.ZodError) {
                      return error.issues[0]?.message || "Password is required";
                    }
                    return "Password is required";
                  }
                },
              }}
            >
              {(field) => (
                <ValidatedInput
                  field={field}
                  label="Password"
                  type="password"
                  placeholder="Password"
                  autoComplete="current-password"
                />
              )}
            </form.Field>
            <FormSubmitButton
              isSubmitting={form.state.isSubmitting || isLoading}
              className="mt-2 w-full"
              size="lg"
              loadingText="Logging in..."
            >
              Login
            </FormSubmitButton>
          </div>
          {errorMessage && (
            <span className="text-destructive text-center text-sm">{errorMessage}</span>
          )}
          <div className="after:border-border relative text-center text-sm after:absolute after:inset-0 after:top-1/2 after:z-0 after:flex after:items-center after:border-t">
            <span className="bg-background text-muted-foreground relative z-10 px-2">
              Or
            </span>
          </div>
          <Button
            variant="outline"
            className="w-full"
            type="button"
            disabled={isLoading || form.state.isSubmitting}
            onClick={() =>
              auth.signInWithOAuth(
                {
                  provider: "google",
                  callbackURL: safeRedirectPath,
                },
                {
                  onRequest: () => {
                    setIsLoading(true);
                    setErrorMessage("");
                  },
                  // eslint-disable-next-line @typescript-eslint/no-explicit-any
                  onError: (ctx: any) => {
                    setIsLoading(false);
                    setErrorMessage(ctx.error?.message || "OAuth login failed");
                  },
                },
              )
            }
          >
            <GoogleIcon />
            Login with Google
          </Button>
        </div>
      </form>

      <div className="text-center text-sm">
        Don&apos;t have an account?{" "}
        <Link to="/auth/signup" className="underline underline-offset-4">
          Sign up
        </Link>
      </div>
    </div>
  );
}
</file>

</files>
