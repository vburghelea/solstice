
<directory_structure>
docs/
  sin-rfp/
    hosting-compliance.md
    REQUIREMENTS-BUNDLE-1.md
    REQUIREMENTS-BUNDLE-2.md
    REQUIREMENTS-BUNDLE-3.md
    SIN-IMPLEMENTATION-BACKLOG.md
    SIN-REQUIREMENTS.md
src/
  components/
    form-fields/
      ValidatedCheckbox.tsx
      ValidatedCombobox.tsx
      ValidatedDatePicker.tsx
      ValidatedFileUpload.tsx
      ValidatedInput.tsx
      ValidatedSelect.tsx
  db/
    schema/
      auth.schema.ts
      events.schema.ts
      index.ts
      membership.schema.ts
      roles.schema.ts
      teams.schema.ts
    connections.ts
  features/
    auth/
      auth.schemas.ts
    dashboard/
      MemberDashboard.tsx
    events/
      events.schemas.ts
      events.types.ts
    membership/
      membership.finalize.ts
      membership.mutations.ts
      membership.queries.ts
      membership.types.ts
    roles/
      permission.server.ts
      permission.service.ts
      roles.mutations.ts
      roles.queries.ts
    teams/
      teams.mutations.ts
      teams.schemas.ts
  lib/
    auth/
      guards/
        route-guards.ts
      middleware/
        auth-guard.ts
        role-guard.ts
      server-helpers.ts
      types.ts
    email/
      sendgrid.ts
    security/
      utils/
        password-validator.ts
      config.ts
      index.ts
      password-config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/sin-rfp/hosting-compliance.md">
# Hosting and Compliance Approach (Netlify vs SST on AWS)

This section is written to align with the RFP criteria for hosting, data residency, backup and recovery, encryption, monitoring, and service delivery. It compares the current Netlify-based approach with an SST-on-AWS approach and recommends a baseline for the SIN program.

## RFP Alignment Snapshot

- Cloud hosted, modular, scalable: both Netlify and AWS can satisfy this.
- Data residency and tenancy model: AWS allows explicit region selection (for example, ca-central-1) and clearer controls; Netlify has limited region control for compute and relies on external data stores for residency.
- Backup and disaster recovery: AWS provides native snapshots and multi-AZ patterns; Netlify relies on the storage vendor and custom processes.
- Security and compliance: Both can support TLS and encryption at rest, but AWS provides deeper controls (KMS, IAM, CloudTrail, WAF, VPC).
- Monitoring and audit: AWS offers full-stack observability and audit trails; Netlify has platform logs but less granular control.

## Option A: SST on AWS (Recommended for SIN)

**Hosting model**
- SST provides infrastructure-as-code on AWS for frontend, API, and background workloads.
- Supports a managed-service delivery model with clear environment promotion (dev, test, prod).

**Data residency**
- Data and compute can be pinned to a Canadian region (ca-central-1).
- Residency posture is explicit and defensible in RFP responses.

**Backup and disaster recovery**
- Native snapshots for databases, S3 versioning, and lifecycle policies.
- Clear RTO/RPO definitions using AWS-native mechanisms.

**Encryption and access controls**
- TLS in transit; KMS-backed encryption at rest for data stores and object storage.
- IAM-based least privilege, with audit trails via CloudTrail.

**Monitoring and audit**
- CloudWatch metrics, logs, and alarms for system health and security.
- Centralized retention policy for audit logs (aligns with SEC-AGG-004).

**Scaling and data migration**
- Suitable for large imports and batch processing (Step Functions, ECS, Batch).
- Easier to guarantee throughput and resumable workflows for 20M+ rows.

## Option B: Netlify (Current)

**Hosting model**
- Managed frontend hosting with serverless functions and edge capabilities.
- Very strong developer experience and preview deploys.

**Data residency**
- Compute runs on a global edge network with limited region control.
- Residency is primarily determined by the chosen database and storage vendor.

**Backup and disaster recovery**
- Netlify does not provide data storage for primary data; DR depends on the DB vendor.
- Requires a documented backup and recovery process outside the platform.

**Encryption and access controls**
- TLS in transit is standard; encryption at rest depends on the data vendor.
- IAM-style controls are not part of the platform.

**Monitoring and audit**
- Platform logs exist, but deeper system audit requires external services.
- More effort to meet audit and retention requirements at scale.

**Scaling and data migration**
- Serverless functions can scale for request workloads but are less suitable for long-running imports.
- Large migration and data quality workflows must run outside Netlify.

## Recommendation

For RFP and compliance defensibility, use **SST on AWS** as the production base. This gives clear answers to data residency, backup and DR, encryption, audit logging, and large-scale data migration. Netlify can remain useful for rapid UI prototyping, but the production system should anchor on AWS.

## Open Items to Confirm for the RFP

- Data residency requirement (Canada-only vs best-effort).
- Database selection and region (managed Postgres in ca-central-1).
- RTO and RPO targets.
- Log retention periods and audit export requirements.
- Expected uptime and support SLAs.
</file>


<file path="docs/sin-rfp/SIN-IMPLEMENTATION-BACKLOG.md">
# viaSport SIN Implementation Backlog

> Prioritized implementation plan for the Strength in Numbers (SIN) system requirements.
> Based on analysis of existing Solstice codebase against 25 SIN requirements.

---

## Executive Summary

**Current Progress:** ~40% of SIN requirements have partial implementation
**Total Requirements:** 25 across 5 categories
**Estimated New Tables:** ~25 database entities
**Critical Path:** Organization Model → Audit Logging → Notifications → Forms → Reporting

---

## Priority Levels

| Priority | Meaning | Timeline Guidance |
|----------|---------|-------------------|
| **P0** | Foundation - blocks everything else | Phase 1 |
| **P1** | Core SIN functionality | Phase 2 |
| **P2** | Required for compliance/RFP | Phase 3 |
| **P3** | Enhanced UX/polish | Phase 4 |
| **P4** | Nice-to-have | Future |

---

## Phase 1: Foundation (P0)

These items are **blocking dependencies** for most other features.

### F-001: Organization & Affiliation Model
**Priority:** P0
**Blocks:** SEC-AGG-001, DM-AGG-003, RP-AGG-002, UI-AGG-002, all reporting features
**Effort:** Large

**Description:**
Extend the existing team model to support a hierarchical organization structure (viaSport → PSO → Club/Team). This is the multi-tenant foundation for SIN.

**Database Schema:**
```sql
-- Organizations (PSOs, clubs, affiliates)
CREATE TABLE organizations (
  id UUID PRIMARY KEY,
  name TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL,
  type TEXT NOT NULL, -- 'pso', 'club', 'affiliate'
  parent_org_id UUID REFERENCES organizations(id),
  status TEXT DEFAULT 'active',
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- User membership in organizations
CREATE TABLE organization_members (
  id UUID PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES "user"(id),
  organization_id UUID NOT NULL REFERENCES organizations(id),
  role TEXT NOT NULL, -- 'owner', 'admin', 'reporter', 'member'
  status TEXT DEFAULT 'pending', -- 'pending', 'active', 'rejected', 'suspended'
  invited_by TEXT REFERENCES "user"(id),
  joined_at TIMESTAMPTZ,
  approved_by TEXT REFERENCES "user"(id),
  approved_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, organization_id)
);

-- Delegated access for reporting
CREATE TABLE delegated_access (
  id UUID PRIMARY KEY,
  delegate_user_id TEXT NOT NULL REFERENCES "user"(id),
  organization_id UUID NOT NULL REFERENCES organizations(id),
  scope TEXT NOT NULL, -- 'reporting', 'analytics', 'admin'
  granted_by TEXT NOT NULL REFERENCES "user"(id),
  granted_at TIMESTAMPTZ DEFAULT NOW(),
  expires_at TIMESTAMPTZ,
  revoked_at TIMESTAMPTZ,
  UNIQUE(delegate_user_id, organization_id, scope)
);
```

**Acceptance Criteria:**
- [ ] Organizations can be created with parent/child relationships
- [ ] Users can be invited to organizations with specific roles
- [ ] Organization admins can approve/deny membership requests
- [ ] Delegated access can be granted for specific scopes
- [ ] All organization data is scoped - users only see their org's data

**Files to Create/Modify:**
- `src/db/schema/organizations.schema.ts` (new)
- `src/features/organizations/` (new feature module)
- `src/lib/auth/guards/org-guard.ts` (new)

---

### F-002: Immutable Audit Logging System
**Priority:** P0
**Blocks:** SEC-AGG-004, DM-AGG-002, RP-AGG-003, compliance
**Effort:** Medium

**Description:**
Create an append-only audit log that captures all significant system events with tamper-evident hashing. Required for PIPEDA compliance and regulatory reporting.

**Database Schema:**
```sql
CREATE TABLE audit_logs (
  id UUID PRIMARY KEY,
  occurred_at TIMESTAMPTZ DEFAULT NOW(),
  actor_user_id TEXT REFERENCES "user"(id), -- null for system actions
  actor_ip INET,
  actor_user_agent TEXT,

  action TEXT NOT NULL, -- 'AUTH.LOGIN', 'DATA.CREATE', 'ADMIN.ROLE_ASSIGN', etc.
  target_type TEXT, -- 'user', 'organization', 'submission', etc.
  target_id TEXT,

  before_state JSONB,
  after_state JSONB,
  metadata JSONB DEFAULT '{}',

  request_id TEXT, -- correlation ID
  prev_hash TEXT, -- hash of previous entry (tamper evidence)
  entry_hash TEXT NOT NULL -- hash of this entry
);

-- Enforce append-only via trigger
CREATE OR REPLACE FUNCTION prevent_audit_modification()
RETURNS TRIGGER AS $$
BEGIN
  RAISE EXCEPTION 'Audit logs are immutable';
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER audit_logs_immutable
BEFORE UPDATE OR DELETE ON audit_logs
FOR EACH ROW EXECUTE FUNCTION prevent_audit_modification();

-- Index for common queries
CREATE INDEX idx_audit_logs_actor ON audit_logs(actor_user_id, occurred_at DESC);
CREATE INDEX idx_audit_logs_target ON audit_logs(target_type, target_id, occurred_at DESC);
CREATE INDEX idx_audit_logs_action ON audit_logs(action, occurred_at DESC);
```

**Acceptance Criteria:**
- [ ] All auth events are logged (login, logout, failed attempts, MFA)
- [ ] All data mutations are logged with before/after state
- [ ] All admin actions are logged (role changes, org management)
- [ ] Logs cannot be modified or deleted (DB-enforced)
- [ ] Hash chain can be verified for integrity
- [ ] Admin UI can filter by user, target, action, date range
- [ ] Logs can be exported to CSV

**Files to Create/Modify:**
- `src/db/schema/audit.schema.ts` (new)
- `src/lib/audit/` (new module)
- `src/lib/audit/log.ts` - logging functions
- `src/lib/audit/verify.ts` - hash chain verification
- `src/features/admin/audit-viewer.tsx` (new)

---

### F-003: Notification Engine
**Priority:** P0
**Blocks:** RP-AGG-003, UI-AGG-004, SEC-AGG-002, TO-AGG-002
**Effort:** Medium

**Description:**
Build a unified notification system supporting in-app notifications, email delivery, user preferences, and scheduled reminders.

**Database Schema:**
```sql
CREATE TABLE notifications (
  id UUID PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES "user"(id),
  type TEXT NOT NULL, -- 'reporting_reminder', 'ticket_update', 'security_alert', etc.
  title TEXT NOT NULL,
  body TEXT NOT NULL,
  link TEXT, -- deep link to relevant page

  read_at TIMESTAMPTZ,
  dismissed_at TIMESTAMPTZ,

  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE notification_preferences (
  id UUID PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES "user"(id),
  category TEXT NOT NULL, -- 'reporting', 'security', 'support', 'system'
  channel_email BOOLEAN DEFAULT true,
  channel_in_app BOOLEAN DEFAULT true,
  frequency TEXT DEFAULT 'immediate', -- 'immediate', 'daily_digest', 'weekly_digest'
  UNIQUE(user_id, category)
);

CREATE TABLE notification_templates (
  id UUID PRIMARY KEY,
  key TEXT UNIQUE NOT NULL, -- 'reporting_reminder_7day', 'ticket_response', etc.
  subject TEXT NOT NULL,
  body_template TEXT NOT NULL, -- supports {{variable}} substitution
  category TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE scheduled_notifications (
  id UUID PRIMARY KEY,
  template_key TEXT NOT NULL REFERENCES notification_templates(key),
  user_id TEXT REFERENCES "user"(id), -- null for broadcast
  organization_id UUID REFERENCES organizations(id),
  scheduled_for TIMESTAMPTZ NOT NULL,
  sent_at TIMESTAMPTZ,
  failed_at TIMESTAMPTZ,
  error_message TEXT,
  variables JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_notifications_user ON notifications(user_id, read_at, created_at DESC);
CREATE INDEX idx_scheduled_pending ON scheduled_notifications(scheduled_for) WHERE sent_at IS NULL;
```

**Acceptance Criteria:**
- [ ] Users see notification bell with unread count in header
- [ ] Clicking bell shows notification panel with recent items
- [ ] Users can mark notifications as read/unread
- [ ] Users can configure preferences per category
- [ ] Email notifications respect user preferences
- [ ] Scheduled notifications are sent at configured times
- [ ] Admins can manage notification templates

**Files to Create/Modify:**
- `src/db/schema/notifications.schema.ts` (new)
- `src/features/notifications/` (new feature module)
- `src/components/ui/notification-bell.tsx` (new)
- `src/lib/notifications/send.ts` (new)
- `src/lib/notifications/scheduler.ts` (new)
- Modify `src/routes/__root.tsx` to include notification bell

---

## Phase 2: Core SIN Functionality (P1)

### S-001: Multi-Factor Authentication (MFA)
**Priority:** P1
**Requirement:** SEC-AGG-001
**Effort:** Medium

**Description:**
Add TOTP-based MFA with backup codes. Optional SMS can be added later.

**Database Schema:**
```sql
CREATE TABLE mfa_factors (
  id UUID PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES "user"(id),
  type TEXT NOT NULL, -- 'totp', 'sms' (future)
  secret_encrypted TEXT, -- for TOTP
  phone_e164 TEXT, -- for SMS
  is_active BOOLEAN DEFAULT false,
  verified_at TIMESTAMPTZ,
  last_used_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE mfa_backup_codes (
  id UUID PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES "user"(id),
  code_hash TEXT NOT NULL,
  used_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add to user table
ALTER TABLE "user" ADD COLUMN mfa_required BOOLEAN DEFAULT false;
ALTER TABLE "user" ADD COLUMN mfa_enrolled BOOLEAN DEFAULT false;
```

**Acceptance Criteria:**
- [ ] Users can enroll in TOTP MFA via QR code
- [ ] Users receive and can save backup codes
- [ ] Login requires MFA code when enrolled
- [ ] Backup codes work for recovery (single use)
- [ ] Admins can require MFA for specific roles
- [ ] All MFA events are audit logged

**Files to Create:**
- `src/features/auth/mfa/` (new)
- `src/features/auth/components/mfa-enrollment.tsx`
- `src/features/auth/components/mfa-challenge.tsx`
- `src/lib/auth/mfa.ts`

---

### S-002: Security Event Monitoring & Account Lockout
**Priority:** P1
**Requirement:** SEC-AGG-002
**Effort:** Medium

**Description:**
Track security events, detect anomalies, and auto-lock accounts after suspicious activity.

**Database Schema:**
```sql
CREATE TABLE security_events (
  id UUID PRIMARY KEY,
  user_id TEXT REFERENCES "user"(id),
  event_type TEXT NOT NULL, -- 'login_success', 'login_fail', 'mfa_fail', 'password_reset', etc.
  ip_address INET,
  user_agent TEXT,
  geo_country TEXT,
  geo_city TEXT,
  risk_score INTEGER DEFAULT 0,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE account_locks (
  id UUID PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES "user"(id),
  reason TEXT NOT NULL, -- 'failed_logins', 'suspicious_activity', 'admin_action'
  locked_at TIMESTAMPTZ DEFAULT NOW(),
  unlock_at TIMESTAMPTZ, -- auto-unlock time
  unlocked_by TEXT REFERENCES "user"(id),
  unlocked_at TIMESTAMPTZ,
  notes TEXT
);

CREATE INDEX idx_security_events_user ON security_events(user_id, created_at DESC);
CREATE INDEX idx_security_events_ip ON security_events(ip_address, created_at DESC);
```

**Detection Rules (configurable):**
- 5 failed logins in 15 minutes → lock for 30 minutes
- 10 failed logins in 1 hour → lock until admin unlock
- Login from new country → require MFA step-up
- Unusual time of day + new device → flag for review

**Acceptance Criteria:**
- [ ] All auth events are captured with IP/UA/geo
- [ ] Failed login threshold triggers auto-lock
- [ ] Locked accounts cannot authenticate
- [ ] Admins receive alerts for lockouts
- [ ] Admins can manually lock/unlock accounts
- [ ] Security dashboard shows recent events and anomalies

---

### D-001: Dynamic Form Builder
**Priority:** P1
**Requirement:** DM-AGG-001, RP-AGG-004
**Effort:** Large

**Description:**
Admin UI to create custom forms without code. Forms are versioned and submissions are tracked.

**Database Schema:**
```sql
CREATE TABLE forms (
  id UUID PRIMARY KEY,
  name TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL,
  description TEXT,
  organization_id UUID REFERENCES organizations(id), -- null for system-wide
  status TEXT DEFAULT 'draft', -- 'draft', 'published', 'archived'
  created_by TEXT REFERENCES "user"(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE form_versions (
  id UUID PRIMARY KEY,
  form_id UUID NOT NULL REFERENCES forms(id),
  version_number INTEGER NOT NULL,
  definition JSONB NOT NULL, -- field configs, layout, validation rules
  published_at TIMESTAMPTZ,
  published_by TEXT REFERENCES "user"(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(form_id, version_number)
);

CREATE TABLE form_submissions (
  id UUID PRIMARY KEY,
  form_id UUID NOT NULL REFERENCES forms(id),
  form_version_id UUID NOT NULL REFERENCES form_versions(id),
  organization_id UUID REFERENCES organizations(id),
  submitter_id TEXT REFERENCES "user"(id),

  status TEXT DEFAULT 'draft', -- 'draft', 'submitted', 'under_review', 'changes_requested', 'approved', 'rejected'
  payload JSONB NOT NULL,

  completeness_score INTEGER,
  missing_fields JSONB DEFAULT '[]',
  validation_errors JSONB DEFAULT '[]',

  submitted_at TIMESTAMPTZ,
  reviewed_by TEXT REFERENCES "user"(id),
  reviewed_at TIMESTAMPTZ,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE form_submission_versions (
  id UUID PRIMARY KEY,
  submission_id UUID NOT NULL REFERENCES form_submissions(id),
  version_number INTEGER NOT NULL,
  payload_snapshot JSONB NOT NULL,
  changed_by TEXT REFERENCES "user"(id),
  change_reason TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(submission_id, version_number)
);

CREATE TABLE submission_files (
  id UUID PRIMARY KEY,
  submission_id UUID NOT NULL REFERENCES form_submissions(id),
  field_key TEXT NOT NULL,
  file_name TEXT NOT NULL,
  mime_type TEXT NOT NULL,
  size_bytes INTEGER NOT NULL,
  checksum TEXT NOT NULL,
  storage_key TEXT NOT NULL,
  uploaded_by TEXT REFERENCES "user"(id),
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

**Form Definition Schema (JSONB):**
```typescript
interface FormDefinition {
  fields: FormField[];
  layout?: LayoutConfig;
  settings: {
    allowDraft: boolean;
    requireApproval: boolean;
    notifyOnSubmit: string[]; // user IDs or roles
  };
}

interface FormField {
  key: string;
  type: 'text' | 'number' | 'email' | 'phone' | 'date' | 'select' | 'multiselect' | 'checkbox' | 'file' | 'textarea';
  label: string;
  description?: string;
  required: boolean;
  validation?: ValidationRule[];
  options?: { value: string; label: string }[]; // for select/multiselect
  conditional?: ConditionalRule; // show/hide based on other fields
  fileConfig?: { allowedTypes: string[]; maxSize: number };
}
```

**Acceptance Criteria:**
- [ ] Admins can create forms with drag-and-drop field builder
- [ ] Forms support all standard field types
- [ ] Validation rules are enforced server-side
- [ ] Forms can be published (creates immutable version)
- [ ] Users can save drafts and submit
- [ ] Submissions track version history
- [ ] Files can be attached and downloaded

**Files to Create:**
- `src/db/schema/forms.schema.ts` (new)
- `src/features/forms/` (new feature module)
- `src/features/forms/components/form-builder.tsx`
- `src/features/forms/components/form-renderer.tsx`
- `src/features/forms/components/submission-viewer.tsx`

---

### D-002: Bulk Import & Data Migration
**Priority:** P1
**Requirement:** DM-AGG-006
**Effort:** Large

**Description:**
Import CSV/Excel files with field mapping, validation, preview, and rollback capability. Must support 20M+ row initial migration.

**Database Schema:**
```sql
CREATE TABLE import_jobs (
  id UUID PRIMARY KEY,
  type TEXT NOT NULL, -- 'csv', 'excel', 'api'
  target_form_id UUID REFERENCES forms(id),
  target_table TEXT, -- for direct table imports

  source_file_key TEXT,
  source_file_hash TEXT,
  mapping_template_id UUID REFERENCES import_mapping_templates(id),

  status TEXT DEFAULT 'pending', -- 'pending', 'validating', 'validated', 'importing', 'completed', 'failed', 'rolled_back'

  stats JSONB DEFAULT '{}', -- rows_total, rows_processed, rows_succeeded, rows_failed
  error_summary JSONB DEFAULT '{}',

  created_by TEXT REFERENCES "user"(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  started_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ
);

CREATE TABLE import_job_rows (
  id UUID PRIMARY KEY,
  job_id UUID NOT NULL REFERENCES import_jobs(id),
  row_number INTEGER NOT NULL,
  status TEXT DEFAULT 'pending', -- 'pending', 'valid', 'invalid', 'imported', 'failed'
  source_data JSONB NOT NULL,
  transformed_data JSONB,
  errors JSONB DEFAULT '[]',
  target_record_id TEXT, -- ID of created record
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE import_mapping_templates (
  id UUID PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  target_form_id UUID REFERENCES forms(id),
  target_table TEXT,
  mappings JSONB NOT NULL, -- source_column -> target_field + transform
  created_by TEXT REFERENCES "user"(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE transformation_logs (
  id UUID PRIMARY KEY,
  job_id UUID REFERENCES import_jobs(id),
  submission_id UUID REFERENCES form_submissions(id),
  field_key TEXT NOT NULL,
  original_value TEXT,
  transformed_value TEXT,
  transformation_type TEXT, -- 'normalize_phone', 'parse_date', 'map_enum', etc.
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_import_job_rows_job ON import_job_rows(job_id, row_number);
```

**Two-Lane Architecture:**
1. **Interactive UI Import** - for admin uploads < 10K rows
2. **Batch Pipeline** - for migration/large imports, uses unpooled connection, chunked processing, resumable

**Acceptance Criteria:**
- [ ] Admin can upload CSV/Excel and preview columns
- [ ] Auto-suggest mappings based on column names
- [ ] Preview shows first N rows with validation results
- [ ] Validation errors shown per-row with clear messages
- [ ] Import can be executed after validation passes
- [ ] Import can be rolled back (deletes imported records)
- [ ] Mapping templates can be saved and reused
- [ ] All imports are audit logged
- [ ] Large imports use batch pipeline (not UI)

**Files to Create:**
- `src/features/imports/` (new feature module)
- `src/features/imports/components/import-wizard.tsx`
- `src/features/imports/components/field-mapper.tsx`
- `scripts/batch-import.ts` (CLI for large migrations)

---

### R-001: Reporting Cycles & Workflow
**Priority:** P1
**Requirement:** RP-AGG-003
**Effort:** Medium

**Description:**
Define reporting cycles with deadlines, track submission status, send automated reminders, and enable resubmission workflows.

**Database Schema:**
```sql
CREATE TABLE reporting_cycles (
  id UUID PRIMARY KEY,
  name TEXT NOT NULL, -- 'FY2025 Q1', 'Annual Report 2025'
  description TEXT,
  start_date DATE NOT NULL,
  end_date DATE NOT NULL,
  status TEXT DEFAULT 'upcoming', -- 'upcoming', 'active', 'closed', 'archived'
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE reporting_tasks (
  id UUID PRIMARY KEY,
  cycle_id UUID NOT NULL REFERENCES reporting_cycles(id),
  form_id UUID NOT NULL REFERENCES forms(id),
  organization_id UUID REFERENCES organizations(id), -- null = all orgs

  title TEXT NOT NULL,
  description TEXT,
  due_date DATE NOT NULL,

  reminder_config JSONB DEFAULT '{}', -- days_before: [14, 7, 3, 1], overdue_frequency: 'daily'

  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE reporting_submissions (
  id UUID PRIMARY KEY,
  task_id UUID NOT NULL REFERENCES reporting_tasks(id),
  organization_id UUID NOT NULL REFERENCES organizations(id),
  form_submission_id UUID REFERENCES form_submissions(id),

  status TEXT DEFAULT 'not_started', -- 'not_started', 'in_progress', 'submitted', 'under_review', 'changes_requested', 'approved', 'overdue'

  submitted_at TIMESTAMPTZ,
  submitted_by TEXT REFERENCES "user"(id),

  reviewed_at TIMESTAMPTZ,
  reviewed_by TEXT REFERENCES "user"(id),
  review_notes TEXT,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  UNIQUE(task_id, organization_id)
);

CREATE TABLE reporting_submission_history (
  id UUID PRIMARY KEY,
  reporting_submission_id UUID NOT NULL REFERENCES reporting_submissions(id),
  action TEXT NOT NULL, -- 'submitted', 'changes_requested', 'resubmitted', 'approved'
  actor_id TEXT REFERENCES "user"(id),
  notes TEXT,
  form_submission_version_id UUID REFERENCES form_submission_versions(id),
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

**Acceptance Criteria:**
- [ ] Admins can create reporting cycles and assign tasks
- [ ] Organizations see their assigned tasks with due dates
- [ ] Automated reminders sent at configured intervals
- [ ] Submission status is tracked through workflow
- [ ] Resubmissions maintain full history
- [ ] Dashboard shows reporting progress across all orgs
- [ ] Overdue tasks are highlighted and tracked

---

## Phase 3: Compliance & Reporting (P2)

### C-001: Privacy Compliance (PIPEDA)
**Priority:** P2
**Requirement:** SEC-AGG-003
**Effort:** Medium

**Database Schema:**
```sql
CREATE TABLE policy_documents (
  id UUID PRIMARY KEY,
  type TEXT NOT NULL, -- 'privacy_policy', 'terms_of_service'
  version TEXT NOT NULL,
  content_url TEXT,
  content_hash TEXT,
  published_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE user_policy_acceptances (
  id UUID PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES "user"(id),
  policy_id UUID NOT NULL REFERENCES policy_documents(id),
  accepted_at TIMESTAMPTZ DEFAULT NOW(),
  ip_address INET,
  user_agent TEXT,
  UNIQUE(user_id, policy_id)
);

CREATE TABLE privacy_requests (
  id UUID PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES "user"(id),
  type TEXT NOT NULL, -- 'export', 'erasure', 'correction'
  status TEXT DEFAULT 'pending', -- 'pending', 'processing', 'completed', 'rejected'
  requested_at TIMESTAMPTZ DEFAULT NOW(),
  processed_by TEXT REFERENCES "user"(id),
  processed_at TIMESTAMPTZ,
  notes TEXT
);

CREATE TABLE retention_policies (
  id UUID PRIMARY KEY,
  data_type TEXT NOT NULL, -- 'submissions', 'audit_logs', 'sessions', etc.
  retention_days INTEGER NOT NULL,
  archive_after_days INTEGER,
  purge_after_days INTEGER,
  legal_hold BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

**Acceptance Criteria:**
- [ ] Users must accept current privacy policy to proceed
- [ ] Policy acceptance is recorded with timestamp/IP
- [ ] Users can request data export (DSAR)
- [ ] Users can request account deletion
- [ ] Retention policies can be configured per data type
- [ ] Scheduled jobs enforce retention policies

---

### C-002: Data Quality Dashboard
**Priority:** P2
**Requirement:** DM-AGG-004
**Effort:** Medium

**Database Schema:**
```sql
CREATE TABLE data_quality_issues (
  id UUID PRIMARY KEY,
  submission_id UUID REFERENCES form_submissions(id),
  organization_id UUID REFERENCES organizations(id),

  issue_type TEXT NOT NULL, -- 'missing_required', 'invalid_format', 'out_of_range', 'duplicate'
  field_key TEXT,
  severity TEXT DEFAULT 'warning', -- 'info', 'warning', 'error'
  message TEXT NOT NULL,

  detected_at TIMESTAMPTZ DEFAULT NOW(),
  resolved_at TIMESTAMPTZ,
  resolved_by TEXT REFERENCES "user"(id)
);

CREATE TABLE data_quality_runs (
  id UUID PRIMARY KEY,
  run_type TEXT NOT NULL, -- 'scheduled', 'manual'
  started_at TIMESTAMPTZ DEFAULT NOW(),
  completed_at TIMESTAMPTZ,
  stats JSONB DEFAULT '{}', -- records_checked, issues_found, etc.
  triggered_by TEXT REFERENCES "user"(id)
);
```

**Acceptance Criteria:**
- [ ] Dashboard shows data quality metrics by org/form
- [ ] Issues are categorized by type and severity
- [ ] Drill-down shows specific records with issues
- [ ] Scheduled quality checks run nightly
- [ ] Issues can be marked as resolved

---

### R-002: Self-Service Analytics & Export
**Priority:** P2
**Requirement:** RP-AGG-005
**Effort:** Large

**Database Schema:**
```sql
CREATE TABLE analytics_reports (
  id UUID PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,

  data_source TEXT NOT NULL, -- 'submissions', 'memberships', 'organizations', etc.
  filters JSONB DEFAULT '{}',
  dimensions JSONB DEFAULT '[]', -- group by fields
  measures JSONB DEFAULT '[]', -- aggregations
  chart_type TEXT, -- 'bar', 'line', 'pie', 'table', null for raw

  owner_id TEXT REFERENCES "user"(id),
  organization_id UUID REFERENCES organizations(id),
  is_public BOOLEAN DEFAULT false,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE analytics_report_shares (
  id UUID PRIMARY KEY,
  report_id UUID NOT NULL REFERENCES analytics_reports(id),
  shared_with_user_id TEXT REFERENCES "user"(id),
  shared_with_role TEXT,
  shared_at TIMESTAMPTZ DEFAULT NOW()
);
```

**Acceptance Criteria:**
- [ ] Users can select data source and build queries
- [ ] Support for filtering, grouping, aggregation
- [ ] Visualizations: bar, line, pie charts + pivot table
- [ ] Export to CSV, Excel, JSON
- [ ] Field-level access control on exports
- [ ] Reports can be saved and shared

---

## Phase 4: UX Enhancements (P3)

### U-001: Personalized Dashboard
**Priority:** P3
**Requirement:** UI-AGG-002
**Effort:** Medium

**Database Schema:**
```sql
CREATE TABLE dashboard_layouts (
  id UUID PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES "user"(id),
  widgets JSONB NOT NULL, -- ordered list of widget configs
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id)
);

CREATE TABLE dashboard_widget_defaults (
  id UUID PRIMARY KEY,
  role TEXT NOT NULL, -- 'org_admin', 'reporter', 'viasport_admin'
  widgets JSONB NOT NULL,
  UNIQUE(role)
);
```

**Acceptance Criteria:**
- [ ] Users can add/remove/reorder dashboard widgets
- [ ] Layout persists across sessions
- [ ] Different roles have different default layouts
- [ ] Reporting progress widget shows task status

---

### U-002: Global Search
**Priority:** P3
**Requirement:** UI-AGG-005
**Effort:** Medium

**Acceptance Criteria:**
- [ ] Search bar in header searches across entities
- [ ] Results grouped by type (orgs, users, submissions, forms)
- [ ] Results respect user permissions
- [ ] Search terms highlighted in results
- [ ] Recent searches saved per user

---

### U-003: Accessibility Enhancements
**Priority:** P3
**Requirement:** UI-AGG-003
**Effort:** Medium

**Acceptance Criteria:**
- [ ] WCAG 2.1 AA audit completed
- [ ] All critical issues remediated
- [ ] High contrast mode toggle available
- [ ] Full keyboard navigation support
- [ ] Screen reader compatibility verified

---

### U-004: Support Ticket System
**Priority:** P3
**Requirement:** UI-AGG-006
**Effort:** Medium

**Database Schema:**
```sql
CREATE TABLE support_tickets (
  id UUID PRIMARY KEY,
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  category TEXT NOT NULL, -- 'technical', 'reporting', 'access', 'other'
  priority TEXT DEFAULT 'normal', -- 'low', 'normal', 'high', 'urgent'
  status TEXT DEFAULT 'open', -- 'open', 'in_progress', 'waiting_response', 'resolved', 'closed'

  submitter_id TEXT NOT NULL REFERENCES "user"(id),
  organization_id UUID REFERENCES organizations(id),
  assigned_to TEXT REFERENCES "user"(id),

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  resolved_at TIMESTAMPTZ
);

CREATE TABLE ticket_messages (
  id UUID PRIMARY KEY,
  ticket_id UUID NOT NULL REFERENCES support_tickets(id),
  author_id TEXT NOT NULL REFERENCES "user"(id),
  body TEXT NOT NULL,
  is_internal BOOLEAN DEFAULT false, -- admin-only notes
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE ticket_ratings (
  id UUID PRIMARY KEY,
  ticket_id UUID NOT NULL REFERENCES support_tickets(id),
  rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
  feedback TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

**Acceptance Criteria:**
- [ ] Users can submit support tickets
- [ ] Ticket status tracked through workflow
- [ ] Admins can respond and manage tickets
- [ ] Email notifications on ticket updates
- [ ] Resolution triggers feedback prompt

---

## Phase 5: Training & Help (P4)

### T-001: Template Library
**Priority:** P4
**Requirement:** TO-AGG-001
**Effort:** Small

**Database Schema:**
```sql
CREATE TABLE templates (
  id UUID PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  category_id UUID REFERENCES template_categories(id),
  file_key TEXT NOT NULL,
  file_name TEXT NOT NULL,
  mime_type TEXT NOT NULL,
  download_count INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE template_categories (
  id UUID PRIMARY KEY,
  name TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL,
  description TEXT,
  sort_order INTEGER DEFAULT 0
);

CREATE TABLE template_form_links (
  id UUID PRIMARY KEY,
  template_id UUID NOT NULL REFERENCES templates(id),
  form_id UUID REFERENCES forms(id),
  field_key TEXT, -- optional: link to specific field
  UNIQUE(template_id, form_id, field_key)
);
```

**Acceptance Criteria:**
- [ ] Templates library page with categories
- [ ] Template preview and download
- [ ] Contextual template links in forms

---

### T-002: Guided Walkthroughs
**Priority:** P4
**Requirement:** TO-AGG-002
**Effort:** Medium

**Database Schema:**
```sql
CREATE TABLE user_onboarding_state (
  id UUID PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES "user"(id),
  completed_tours JSONB DEFAULT '[]', -- list of tour keys
  skipped_tours JSONB DEFAULT '[]',
  last_tour_at TIMESTAMPTZ,
  UNIQUE(user_id)
);
```

**Acceptance Criteria:**
- [ ] New users see onboarding tour automatically
- [ ] Tours can be skipped and replayed
- [ ] Completion is tracked per user

---

### T-003: Help Center & FAQ
**Priority:** P4
**Requirement:** TO-AGG-003
**Effort:** Small

**Acceptance Criteria:**
- [ ] Help center with categorized articles
- [ ] FAQ section with search
- [ ] Contextual help links from UI

---

## Summary: Implementation Phases

| Phase | Items | Focus |
|-------|-------|-------|
| **Phase 1** | F-001, F-002, F-003 | Foundation (Orgs, Audit, Notifications) |
| **Phase 2** | S-001, S-002, D-001, D-002, R-001 | Core SIN (MFA, Security, Forms, Import, Reporting) |
| **Phase 3** | C-001, C-002, R-002 | Compliance (Privacy, Quality, Analytics) |
| **Phase 4** | U-001, U-002, U-003, U-004 | UX (Dashboard, Search, A11y, Support) |
| **Phase 5** | T-001, T-002, T-003 | Training (Templates, Tours, Help) |

---

## Appendix: Existing Code to Leverage

| Existing Code | Use For |
|---------------|---------|
| `src/features/roles/` | Extend for org-scoped roles |
| `src/components/form-fields/` | Form builder field types |
| `src/lib/email/sendgrid.ts` | Notification emails |
| `src/components/ui/data-table.tsx` | Admin dashboards |
| `src/lib/utils/csv-export.ts` | Export functionality |
| `src/lib/pacer/` | Rate limiting for security |
| `src/features/membership/` | Pattern for org membership |
| `src/routes/onboarding/` | Pattern for guided flows |
</file>

<file path="docs/sin-rfp/SIN-REQUIREMENTS.md">
# viaSport Strength in Numbers (SIN) System Requirements

> Source: viaSport BC RFP - B.C. Amateur Sport Information Management System Replacement (December 2025)

## Overview

viaSport BC is seeking a technology partner to design, implement, and support a modern, secure, and scalable information management system that will replace legacy systems (BC Activity Reporter and BC Sport Information System).

**Key Context:**
- Historical data: 20+ million rows, growing ~1M rows/year
- Object storage: Hundreds of documents per year
- Target: Cloud-hosted, modular, scalable SaaS/platform solution
- Compliance: Canadian privacy statutes (PIPA/PIPEDA), SOC II / ISO 27001

---

## 2.1 DATA MANAGEMENT

| Req. ID | Title | Description | Acceptance Criteria |
|---------|-------|-------------|---------------------|
| **DM-AGG-001** | Data Collection & Submission | The system shall enable customizable form building, support flexible data entry through variable formats (forms, file uploads), with capabilities for real-time submission tracking, editing, and historical data migration. | Users and System Admin can successfully submit, track, and edit data |
| **DM-AGG-002** | Data Processing & Integration | The system shall enable standardization of data formatting, logging of transformation processes, and integration with external platforms through API (optional), and data import/export mechanisms. | Incoming data is processed uniformly, logged for traceability, and exchanged with external platforms |
| **DM-AGG-003** | Data Governance & Access Control | The system shall enforce role-based access to data and provide administrators with secure database access, along with data cataloging and indexing capabilities for discoverability. | Users can only access data based on permission |
| **DM-AGG-004** | Data Quality & Integrity | The system shall ensure relational integrity and continuously monitor data quality using validation rules and automated checks. | Submitted data meets validation rules |
| **DM-AGG-005** | Data Storage & Retention | The system shall support regular backups, disaster recovery mechanisms, data archiving, and secure cloud hosting aligned with retention policies. | Data is backed up, archived as scheduled, and securely hosted in the cloud |
| **DM-AGG-006** | Legacy Data Migration & Bulk Import | The system shall provide tooling and configurable mapping templates to import historical data from CSV/Excel, legacy databases, or APIs, including validation, error-handling, and rollback. | Administrators can map legacy fields to system fields, preview results, and execute import; import logs stored for audit |

---

## 2.2 REPORTING

| Req. ID | Title | Description | Acceptance Criteria |
|---------|-------|-------------|---------------------|
| **RP-AGG-001** | Data Validation & Submission Rules | The system shall validate submissions to ensure they are complete, clean, use the correct file types, and contain valid data fields such as dates and contact information. | Submissions that fail validation are rejected with appropriate error messages |
| **RP-AGG-002** | Reporting Information Management | The system shall manage metadata related to reporting including but not limited to contribution agreements, NCCP, contact details, fiscal periods, organization profiles, and delegated access rights. | Users can update relevant metadata and access reporting features accordingly |
| **RP-AGG-003** | Reporting Flow & Support | The system shall support automated reporting reminders, allow users to track data resubmissions, and visualize submitted data through dashboards. | Users are reminded, track changes, and view data in a dashboard format |
| **RP-AGG-004** | Reporting Configuration & Collection | The system shall allow system administrators to configure customizable reporting forms, define required fields, display files for users to read, edit, delete, and download. | System admin can configure reporting information and forms |
| **RP-AGG-005** | Self-Service Analytics & Data Export | Enable authorized users to build ad-hoc charts, pivot tables, and export raw or aggregated datasets in CSV, Excel, or JSON (optional) without developer intervention. | User builds a custom chart and exports underlying dataset to CSVs; export respects field-level access rules |

---

## 2.3 SECURITY

| Req. ID | Title | Description | Acceptance Criteria |
|---------|-------|-------------|---------------------|
| **SEC-AGG-001** | Authentication & Access Control | The system shall enforce multi-factor authentication, support secure password recovery, restrict access based on user roles and affiliations, and allow organizational leaders to manage user admission. | Users log in securely; only authorized individuals gain access based on role and affiliation |
| **SEC-AGG-002** | Monitoring & Threat Detection | The system shall detect and flag suspicious activities such as unusual login patterns or behavior anomalies and automatically lock accounts where appropriate. | Security anomalies are flagged, logged, and result in appropriate account safeguards |
| **SEC-AGG-003** | Privacy & Regulatory Compliance | The system shall comply with relevant data protection laws (e.g., PIPEDA) to ensure secure handling, storage, and access to personal information. | All sensitive data is encrypted and stored securely |
| **SEC-AGG-004** | Audit Trail & Data Lineage | The system shall maintain an immutable audit log of user actions, data changes, authentication events, and administrative configurations, supporting forensic review and regulatory reporting. | Auditors can filter logs by user or record ID and export results; tamper-evident hashing verifies integrity of log entries |

---

## 2.4 TRAINING & ONBOARDING

| Req. ID | Title | Description | Acceptance Criteria |
|---------|-------|-------------|---------------------|
| **TO-AGG-001** | Template Support & Integration | The system shall provide a centralized templates tab and offer contextual template access directly from each data entry item to guide users through required formats. | Users can easily locate and access the correct template when needed |
| **TO-AGG-002** | Guided Learning & Walkthroughs | The system shall offer onboarding and data upload tutorials to help users navigate key processes, especially during their first-time use. | Users can complete tasks independently with support from walkthroughs |
| **TO-AGG-003** | Reference Materials & Support | The system shall provide categorized guides and a frequently asked questions (FAQ) section to help users resolve issues and understand system functionality. | Users can find accurate answers and instructional material without needing direct support |

---

## 2.5 USER INTERFACE

| Req. ID | Title | Description | Acceptance Criteria |
|---------|-------|-------------|---------------------|
| **UI-AGG-001** | User Access & Account Control | The system shall support secure login/logout (MFA), individual and organizational account registration, account recovery, and system administrator account management with role-based access. | Users and system admin can perform account-related tasks securely |
| **UI-AGG-002** | Personalized Dashboard | The system shall provide the capability to create personalized dashboard for each user role, summarizing relevant data, actions, and reporting progress. | Users can view personalized dashboards based on their roles |
| **UI-AGG-003** | Responsive and Inclusive Design | The system shall provide a responsive interface across devices and include accessibility features such as screen reader compatibility, color contrast tools, and etc. | System is functional on all devices and meets accessibility compliance |
| **UI-AGG-004** | Communication: Task & Notification Management | The system shall enable automated and customizable notification messages and task reminders that alert users of pending actions and updates, both on the platform and via email. | Users receive timely and relevant notifications and reminders |
| **UI-AGG-005** | Content Navigation & Interaction | The system shall allow users to efficiently locate and interact with information using robust categorization, search and filtering capabilities. | Users can retrieve accurate results through search and filter functions |
| **UI-AGG-006** | User Support & Feedback Mechanism | The system shall enable users to submit support inquiries and feedback and allow administrators to respond through a managed interface. | Users can submit and receive responses to inquiries within the system |
| **UI-AGG-007** | Consistent Visual Language & Branding | The system shall maintain a consistent design style, color scheme, and branding across all modules. | All UI components follow a standardized visual style |

---

## Scope of Services

The selected vendor will perform the following services:

1. **Data Submission and Reporting Web Portal** - Develop, configure and implement a secure, robust and UX-driven reporting and data submission website portal.

2. **Data Warehousing** - Provide data storage/warehousing for viaSport's historical and ongoing data collection, reporting and analytics efforts.

3. **Data Migration** - Map, import, and validate historical data from legacy systems.

4. **Platform Design and Customization** - Provision cloud environment, security and access model, system architecture, and process automations.

5. **Testing & Quality Assurance** - Conduct system security and user acceptance testing; resolve defects.

6. **Training and Onboarding** - Deliver training and onboarding resources to the sector and administrator operational hand-off.

---

## Expertise Required

- Demonstrated delivery of large-scale SaaS information management platforms
- Proven security and technical expertise in alignment with Canadian privacy statutes (PIPA/PIPEDA and SOC II / ISO 27001 or equivalent)
- Experience migrating legacy data sets and implementing role-based governance
- Experience providing services to B.C. amateur sport sector, Provincial Sport Organizations, or similar non-profit or public organizations
- Familiarity with amateur-sport, non-profit, or public-sector reporting environments (desirable)
</file>

<file path="src/db/schema/auth.schema.ts">
import { boolean, integer, pgTable, text, timestamp } from "drizzle-orm/pg-core";

export const user = pgTable("user", {
  id: text("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  emailVerified: boolean("email_verified")
    .$defaultFn(() => false)
    .notNull(),
  image: text("image"),
  createdAt: timestamp("created_at")
    .$defaultFn(() => /* @__PURE__ */ new Date())
    .notNull(),
  updatedAt: timestamp("updated_at")
    .$defaultFn(() => /* @__PURE__ */ new Date())
    .notNull(),
  // Profile completion tracking
  profileComplete: boolean("profile_complete")
    .$defaultFn(() => false)
    .notNull(),

  // Required profile fields
  dateOfBirth: timestamp("date_of_birth"),
  emergencyContact: text("emergency_contact"), // JSON string

  // Optional profile fields
  gender: text("gender"),
  pronouns: text("pronouns"),
  phone: text("phone"),

  // Privacy and preferences
  privacySettings: text("privacy_settings"), // JSON string

  // Audit and versioning
  profileVersion: integer("profile_version")
    .$defaultFn(() => 1)
    .notNull(),
  profileUpdatedAt: timestamp("profile_updated_at").$defaultFn(() => new Date()),
});

export const session = pgTable("session", {
  id: text("id").primaryKey(),
  expiresAt: timestamp("expires_at").notNull(),
  token: text("token").notNull().unique(),
  createdAt: timestamp("created_at").notNull(),
  updatedAt: timestamp("updated_at").notNull(),
  ipAddress: text("ip_address"),
  userAgent: text("user_agent"),
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
});

export const account = pgTable("account", {
  id: text("id").primaryKey(),
  accountId: text("account_id").notNull(),
  providerId: text("provider_id").notNull(),
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  accessToken: text("access_token"),
  refreshToken: text("refresh_token"),
  idToken: text("id_token"),
  accessTokenExpiresAt: timestamp("access_token_expires_at"),
  refreshTokenExpiresAt: timestamp("refresh_token_expires_at"),
  scope: text("scope"),
  password: text("password"),
  createdAt: timestamp("created_at").notNull(),
  updatedAt: timestamp("updated_at").notNull(),
});

export const verification = pgTable("verification", {
  id: text("id").primaryKey(),
  identifier: text("identifier").notNull(),
  value: text("value").notNull(),
  expiresAt: timestamp("expires_at").notNull(),
  createdAt: timestamp("created_at").$defaultFn(() => /* @__PURE__ */ new Date()),
  updatedAt: timestamp("updated_at").$defaultFn(() => /* @__PURE__ */ new Date()),
});
</file>

<file path="src/lib/security/utils/password-validator.ts">
import { PASSWORD_CONFIG } from "../password-config";

interface PasswordValidationResult {
  isValid: boolean;
  errors: string[];
}

/**
 * Validates a password against security requirements
 * Works in both client and server environments
 */
export function validatePassword(password: string): PasswordValidationResult {
  const errors: string[] = [];
  const config = PASSWORD_CONFIG;

  // Check minimum length
  if (password.length < config.minLength) {
    errors.push(`Password must be at least ${config.minLength} characters long`);
  }

  // Check uppercase requirement
  if (config.requireUppercase && !/[A-Z]/.test(password)) {
    errors.push("Password must contain at least one uppercase letter");
  }

  // Check lowercase requirement
  if (config.requireLowercase && !/[a-z]/.test(password)) {
    errors.push("Password must contain at least one lowercase letter");
  }

  // Check numbers requirement
  if (config.requireNumbers && !/\d/.test(password)) {
    errors.push("Password must contain at least one number");
  }

  // Check special characters requirement
  if (config.requireSpecialChars && !/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
    errors.push("Password must contain at least one special character");
  }

  return {
    isValid: errors.length === 0,
    errors,
  };
}

/**
 * Generates a password strength score (0-5)
 */
export function getPasswordStrength(password: string): number {
  let strength = 0;

  // Length bonuses
  if (password.length >= 8) strength++;
  if (password.length >= 12) strength++;
  if (password.length >= 16) strength++;

  // Complexity bonuses
  if (/[a-z]/.test(password) && /[A-Z]/.test(password)) strength++;
  if (/\d/.test(password)) strength++;
  if (/[!@#$%^&*(),.?":{}|<>]/.test(password)) strength++;

  // Cap at 5
  return Math.min(strength, 5);
}

/**
 * Get a human-readable password strength label
 */
export function getPasswordStrengthLabel(strength: number): string {
  switch (strength) {
    case 0:
    case 1:
      return "Very Weak";
    case 2:
      return "Weak";
    case 3:
      return "Fair";
    case 4:
      return "Strong";
    case 5:
      return "Very Strong";
    default:
      return "Unknown";
  }
}
</file>

<file path="src/lib/security/password-config.ts">
/**
 * Password configuration constants
 * Shared between client and server - no environment dependencies
 */

export const PASSWORD_CONFIG = {
  minLength: 8,
  requireUppercase: true,
  requireLowercase: true,
  requireNumbers: true,
  requireSpecialChars: true,
} as const;

// Export type for use in other modules
export type PasswordConfig = typeof PASSWORD_CONFIG;
</file>

<file path="src/components/form-fields/ValidatedCombobox.tsx">
import React, { useState } from "react";
import { Button } from "~/components/ui/button";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "~/components/ui/command";
import { CheckIcon, ChevronsUpDownIcon } from "~/components/ui/icons";
import { Label } from "~/components/ui/label";
import { Popover, PopoverContent, PopoverTrigger } from "~/components/ui/popover";
import { FieldComponentProps, isFieldApi } from "~/lib/form";
import { cn } from "~/shared/lib/utils";

interface ValidatedComboboxProps extends FieldComponentProps {
  options: Array<{ value: string; label: string }>;
  searchPlaceholder?: string;
  emptyText?: string;
}

export const ValidatedCombobox: React.FC<ValidatedComboboxProps> = (props) => {
  const {
    field,
    label,
    placeholder = "Select an option...",
    className,
    options,
    searchPlaceholder = "Search...",
    emptyText = "No option found.",
  } = props;

  const [open, setOpen] = useState(false);

  if (!isFieldApi(field)) {
    console.error("ValidatedCombobox requires a valid field prop.", { field, props });
    return null;
  }

  const inputId = `${field.name}-combobox`;
  const meta = field.state.meta;
  const selectedOption = options.find((option) => option.value === field.state.value);

  return (
    <div className={cn("space-y-2", className)}>
      <Label htmlFor={inputId}>{label}</Label>
      <Popover open={open} onOpenChange={setOpen}>
        <PopoverTrigger asChild>
          <Button
            id={inputId}
            variant="outline"
            role="combobox"
            aria-expanded={open}
            aria-invalid={!!meta.errors.length}
            aria-describedby={meta.errors.length ? `${inputId}-errors` : undefined}
            className={cn(
              "w-full justify-between",
              !selectedOption && "text-muted-foreground",
            )}
            disabled={field.form.state.isSubmitting}
          >
            {selectedOption ? selectedOption.label : placeholder}
            <ChevronsUpDownIcon className="ml-2 h-4 w-4 shrink-0 opacity-50" />
          </Button>
        </PopoverTrigger>
        <PopoverContent className="w-[--radix-popover-trigger-width] p-0" align="start">
          <Command>
            <CommandInput placeholder={searchPlaceholder} />
            <CommandList>
              <CommandEmpty>{emptyText}</CommandEmpty>
              <CommandGroup>
                {options.map((option) => (
                  <CommandItem
                    key={option.value}
                    value={option.label}
                    onSelect={() => {
                      field.handleChange(option.value);
                      setOpen(false);
                    }}
                  >
                    <CheckIcon
                      className={cn(
                        "mr-2 h-4 w-4",
                        field.state.value === option.value ? "opacity-100" : "opacity-0",
                      )}
                    />
                    {option.label}
                  </CommandItem>
                ))}
              </CommandGroup>
            </CommandList>
          </Command>
        </PopoverContent>
      </Popover>
      {meta.isTouched && meta.errors.length > 0 && (
        <div id={`${inputId}-errors`} className="text-destructive text-sm font-medium">
          {meta.errors.join(", ")}
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/components/form-fields/ValidatedFileUpload.tsx">
import { useEffect, useMemo, useState } from "react";
import { Button } from "~/components/ui/button";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";
import { FieldComponentProps } from "~/lib/form";
import { cn } from "~/shared/lib/utils";

interface ValidatedFileUploadProps extends FieldComponentProps {
  accept?: string;
  maxSizeMb?: number;
  description?: string;
  helperText?: string;
  previewAlt?: string;
}

export function ValidatedFileUpload(props: ValidatedFileUploadProps) {
  const {
    field,
    label,
    placeholder,
    className,
    accept = "image/*",
    maxSizeMb = 5,
    description,
    helperText,
    previewAlt = "Uploaded file preview",
  } = props;

  const inputId = `${field.name}-file-input`;
  const meta = field.state.meta;
  const currentValue = field.state.value as File | string | null | undefined;

  const [sizeError, setSizeError] = useState<string | null>(null);

  const objectUrl = useMemo(() => {
    if (currentValue instanceof File) {
      return URL.createObjectURL(currentValue);
    }
    if (typeof currentValue === "string" && currentValue.length > 0) {
      return currentValue;
    }
    return null;
  }, [currentValue]);

  useEffect(() => {
    if (currentValue instanceof File && objectUrl) {
      const revoke =
        typeof URL.revokeObjectURL === "function" ? URL.revokeObjectURL.bind(URL) : null;
      if (revoke) {
        return () => revoke(objectUrl);
      }
    }
    return undefined;
  }, [currentValue, objectUrl]);

  const humanReadableSize = useMemo(() => {
    if (currentValue instanceof File) {
      return formatFileSize(currentValue.size);
    }
    return null;
  }, [currentValue]);

  return (
    <div className={cn("space-y-3", className)}>
      <Label htmlFor={inputId}>{label}</Label>
      <div className="flex flex-col gap-3">
        <Input
          id={inputId}
          type="file"
          accept={accept}
          placeholder={placeholder}
          onBlur={field.handleBlur}
          disabled={field.form.state.isSubmitting}
          onChange={(event) => {
            const file = event.target.files?.[0];
            if (!file) {
              field.handleChange(null);
              setSizeError(null);
              return;
            }

            if (maxSizeMb && file.size > maxSizeMb * 1024 * 1024) {
              setSizeError(`File is too large. Maximum size is ${maxSizeMb}MB.`);
              event.target.value = "";
              return;
            }

            setSizeError(null);
            field.handleChange(file);
          }}
        />
        {helperText && <p className="text-xs text-gray-500">{helperText}</p>}
        {sizeError && <p className="text-destructive text-sm font-medium">{sizeError}</p>}

        {objectUrl && (
          <div className="rounded-lg border border-dashed border-gray-300 bg-gray-50 p-4">
            <p className="text-sm font-semibold text-gray-900">Selected file</p>
            <p className="text-xs text-gray-500">
              {currentValue instanceof File ? currentValue.name : "Existing upload"}
              {humanReadableSize ? ` · ${humanReadableSize}` : ""}
            </p>
            {accept.startsWith("image") && (
              <img
                src={objectUrl}
                alt={previewAlt}
                className="mt-3 max-h-48 w-full rounded-md object-cover"
                loading="lazy"
              />
            )}
            <div className="mt-3 flex justify-end">
              <Button
                type="button"
                variant="ghost"
                size="sm"
                onClick={() => {
                  field.handleChange(null);
                  setSizeError(null);
                }}
              >
                Remove file
              </Button>
            </div>
          </div>
        )}
      </div>
      {description && <p className="text-muted-foreground text-sm">{description}</p>}
      {meta.isTouched && meta.errors.length > 0 && (
        <div className="text-destructive text-sm font-medium">
          {meta.errors.join(", ")}
        </div>
      )}
    </div>
  );
}

function formatFileSize(bytes: number) {
  if (bytes < 1024) return `${bytes} bytes`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}
</file>

<file path="src/db/schema/index.ts">
export * from "./auth.schema";
export * from "./events.schema";
export * from "./membership.schema";
export * from "./roles.schema";
export * from "./teams.schema";
</file>

<file path="src/lib/auth/guards/route-guards.ts">
import { redirect } from "@tanstack/react-router";
import type { User } from "better-auth";
import { requireCompleteProfile } from "~/features/profile/profile-guard";
import type { User as ExtendedUser } from "~/lib/auth/types";

/**
 * Route guard that requires authentication
 * Redirects to login page if user is not authenticated
 *
 * @example
 * export const Route = createFileRoute("/protected")({
 *   beforeLoad: async ({ context, location }) => {
 *     requireAuth({ user: context.user, location });
 *   },
 * });
 */
export function requireAuth({
  user,
  location,
  redirectTo = "/auth/login",
}: {
  user: User | null;
  location: { pathname: string };
  redirectTo?: string;
}) {
  if (!user) {
    throw redirect({
      to: redirectTo,
      search: {
        redirect: location.pathname,
      },
    });
  }
}

/**
 * Route guard that redirects authenticated users
 * Useful for login/signup pages
 *
 * @example
 * export const Route = createFileRoute("/auth/login")({
 *   beforeLoad: async ({ context }) => {
 *     redirectIfAuthenticated({ user: context.user });
 *   },
 * });
 */
export function redirectIfAuthenticated({
  user,
  redirectTo = "/dashboard",
}: {
  user: User | null;
  redirectTo?: string;
}) {
  if (user) {
    throw redirect({
      to: redirectTo,
    });
  }
}

/**
 * Composite guard that checks both auth and profile completion
 * Note: This expects the ExtendedUser type from route context which includes profile fields
 *
 * @example
 * export const Route = createFileRoute("/app/feature")({
 *   beforeLoad: async ({ context, location }) => {
 *     requireAuthAndProfile({ user: context.user, location });
 *   },
 * });
 */
export function requireAuthAndProfile({
  user,
  location,
}: {
  user: ExtendedUser | null;
  location: { pathname: string };
}) {
  // First check auth (will throw if user is null)
  requireAuth({ user, location });

  // Then check profile completion
  // The type assertion is safe because requireAuth would have thrown if user was null
  requireCompleteProfile(user as ExtendedUser);
}
</file>

<file path="src/lib/auth/types.ts">
import type { User as BetterAuthUser } from "better-auth";
import type { Tag } from "~/db/schema";

// User role with full role information
export interface UserRole {
  id: string;
  userId: string;
  roleId: string;
  role: {
    id: string;
    name: string;
    description: string | null;
    permissions: Record<string, boolean>;
  };
  teamId?: string | null;
  eventId?: string | null;
  assignedBy: string;
  assignedAt: Date;
  expiresAt?: Date | null;
  notes?: string | null;
}

// User tag (for future implementation)
export interface UserTag {
  id: string;
  userId: string;
  tagId: string;
  tag: Tag;
  assignedBy?: string | null;
  assignedAt: Date;
  expiresAt?: Date | null;
  notes?: string | null;
}

// Extended user type that includes our custom fields
export interface User extends BetterAuthUser {
  // Profile completion tracking
  profileComplete: boolean;

  // Required profile fields
  dateOfBirth?: Date | null;
  emergencyContact?: string | null; // JSON string

  // Optional profile fields
  gender?: string | null;
  pronouns?: string | null;
  phone?: string | null;

  // Privacy and preferences
  privacySettings?: string | null; // JSON string

  // Audit and versioning
  profileVersion: number;
  profileUpdatedAt?: Date | null;

  // Roles and permissions
  roles?: UserRole[];

  // Tags (for future implementation)
  tags?: UserTag[];
}

// Type definitions that can be safely imported on both client and server
export type AuthUser = User | null;
</file>

<file path="src/lib/security/config.ts">
/**
 * Security configuration for the application
 * Centralizes all security-related settings
 */

import { env, getBaseUrl, isProduction } from "~/lib/env.server";
import { PASSWORD_CONFIG } from "./password-config";

// This module should only be imported in server-side code

export const securityConfig = {
  // Cookie security settings
  cookies: {
    httpOnly: true,
    sameSite: "lax" as const,
    // Force secure cookies in production or when base URL starts with https://
    // This ensures secure cookies even in preview deployments where NODE_ENV might be "test"
    secure: isProduction() || getBaseUrl().startsWith("https://"),
    path: "/",
    // Optional domain restriction for production
    // Set COOKIE_DOMAIN env var to restrict cookies to specific domain
    ...(isProduction() && env.COOKIE_DOMAIN ? { domain: env.COOKIE_DOMAIN } : {}),
  },

  // Session configuration
  session: {
    maxAge: 60 * 60 * 24 * 30, // 30 days
    updateAge: 60 * 60 * 24, // Update session if older than 1 day
    cookieCache: {
      enabled: true,
      maxAge: 60 * 5, // 5 minutes
    },
  },

  // CORS configuration
  cors: {
    credentials: true,
    origin: getBaseUrl(),
    methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allowedHeaders: ["Content-Type", "Authorization"],
  },

  // Rate limiting defaults
  rateLimit: {
    auth: {
      windowMs: 15 * 60 * 1000, // 15 minutes
      max: 5, // 5 requests per window
    },
    api: {
      windowMs: 15 * 60 * 1000, // 15 minutes
      max: 100, // 100 requests per window
    },
  },

  // Password requirements (using shared config)
  password: {
    ...PASSWORD_CONFIG,
    maxLength: 128, // Additional server-side constraint
  },

  // OAuth configuration
  oauth: {
    // Allowed email domains for OAuth sign-ups (comma-separated in env)
    // Example: OAUTH_ALLOWED_DOMAINS=company.com,partner.com
    allowedDomains: env.OAUTH_ALLOWED_DOMAINS,
  },
} as const;

// Type exports
export type SecurityConfig = typeof securityConfig;
export type CookieConfig = typeof securityConfig.cookies;
export type SessionConfig = typeof securityConfig.session;
</file>

<file path="src/lib/security/index.ts">
/**
 * Security module exports
 * Centralizes all security-related functionality
 */

// Server-only exports - only import these in server code
export { securityConfig } from "./config";
export type { CookieConfig, SecurityConfig, SessionConfig } from "./config";

// Shared exports - safe for both client and server
export { PASSWORD_CONFIG } from "./password-config";
export {
  getPasswordStrength,
  getPasswordStrengthLabel,
  validatePassword,
} from "./utils/password-validator";
</file>

<file path="src/components/form-fields/ValidatedCheckbox.tsx">
import React from "react";
import { Checkbox } from "~/components/ui/checkbox";
import { Label } from "~/components/ui/label";
import { FieldComponentProps, isFieldApi } from "~/lib/form";
import { cn } from "~/shared/lib/utils";

interface ValidatedCheckboxProps extends FieldComponentProps {
  description?: string;
  disabled?: boolean;
}

export const ValidatedCheckbox: React.FC<ValidatedCheckboxProps> = (props) => {
  const { field, label, description, className, disabled = false } = props;

  if (!isFieldApi(field)) {
    console.error("ValidatedCheckbox requires a valid field prop.");
    return null;
  }

  const inputId = `${field.name}-checkbox`;
  const meta = field.state.meta;

  return (
    <div className={cn("space-y-2", className)}>
      <div className="flex items-center space-x-2">
        <Checkbox
          id={inputId}
          checked={!!field.state.value}
          onCheckedChange={(checked) => field.handleChange(!!checked)}
          onBlur={field.handleBlur}
          disabled={disabled || field.form.state.isSubmitting}
          aria-invalid={!!meta.errors.length}
          aria-describedby={
            [
              description ? `${inputId}-description` : null,
              meta.isTouched && meta.errors.length ? `${inputId}-errors` : null,
            ]
              .filter(Boolean)
              .join(" ") || undefined
          }
        />
        <Label
          htmlFor={inputId}
          className="cursor-pointer text-sm leading-none font-normal peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
        >
          {label}
        </Label>
      </div>
      {description && (
        <p id={`${inputId}-description`} className="text-muted-foreground ml-6 text-sm">
          {description}
        </p>
      )}
      {meta.isTouched && meta.errors.length > 0 && (
        <div
          id={`${inputId}-errors`}
          className="text-destructive ml-6 text-sm font-medium"
        >
          {meta.errors.join(", ")}
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/components/form-fields/ValidatedDatePicker.tsx">
import React from "react";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";
import { FieldComponentProps, isFieldApi } from "~/lib/form";
import { cn } from "~/shared/lib/utils";

interface ValidatedDatePickerProps extends FieldComponentProps {
  minAge?: number;
  maxAge?: number;
}

export const ValidatedDatePicker: React.FC<ValidatedDatePickerProps> = (props) => {
  const { field, label, minAge = 13, maxAge = 120, className } = props;

  if (!isFieldApi(field)) {
    console.error("ValidatedDatePicker requires a valid field prop.");
    return null;
  }

  const inputId = `${field.name}-date`;
  const meta = field.state.meta;

  // Calculate min and max dates based on age restrictions, using UTC for consistency
  const today = new Date();
  const maxDate = new Date(
    Date.UTC(today.getUTCFullYear() - minAge, today.getUTCMonth(), today.getUTCDate()),
  );
  const minDate = new Date(
    Date.UTC(today.getUTCFullYear() - maxAge, today.getUTCMonth(), today.getUTCDate()),
  );

  // Format date for input value using UTC components
  const formatDate = (date: Date | string | undefined): string => {
    if (!date) return "";
    const d = typeof date === "string" ? new Date(date) : date;
    if (isNaN(d.getTime())) return "";
    const year = d.getUTCFullYear();
    const month = String(d.getUTCMonth() + 1).padStart(2, "0");
    const day = String(d.getUTCDate()).padStart(2, "0");
    return `${year}-${month}-${day}`;
  };

  return (
    <div className={cn("space-y-2", className)}>
      <Label htmlFor={inputId}>{label}</Label>
      <Input
        id={inputId}
        type="date"
        value={formatDate(field.state.value)}
        onChange={(e) => {
          const value = e.target.value;
          if (value) {
            // Parse the date string as UTC to prevent timezone shifts
            const [year, month, day] = value.split("-").map(Number);
            const date = new Date(Date.UTC(year, month - 1, day));
            // Always store a UTC midnight ISO string so client & server match
            field.handleChange(date.toISOString().split("T")[0]);
          } else {
            field.handleChange(undefined);
          }
        }}
        onBlur={field.handleBlur}
        min={formatDate(minDate)}
        max={formatDate(maxDate)}
        disabled={field.form.state.isSubmitting}
        aria-invalid={!!meta.errors.length}
        aria-describedby={meta.errors.length ? `${inputId}-errors` : undefined}
      />
      <p className="text-muted-foreground text-sm">
        You must be between {minAge} and {maxAge} years old
      </p>
      {meta.isTouched && meta.errors.length > 0 && (
        <div id={`${inputId}-errors`} className="text-destructive text-sm font-medium">
          {meta.errors.join(", ")}
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/db/schema/roles.schema.ts">
import { sql } from "drizzle-orm";
import { boolean, index, jsonb, pgTable, text, timestamp } from "drizzle-orm/pg-core";
import { user } from "./auth.schema";

/**
 * Roles table - defines available roles in the system
 */
export const roles = pgTable("roles", {
  id: text("id")
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  name: text("name").notNull().unique(),
  description: text("description"),
  permissions: jsonb("permissions")
    .$type<Record<string, boolean>>()
    .notNull()
    .default({}),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
});

/**
 * User roles assignment table - maps users to roles with optional scope
 */
export const userRoles = pgTable(
  "user_roles",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    roleId: text("role_id")
      .notNull()
      .references(() => roles.id, { onDelete: "cascade" }),
    // Scope fields (NULL for global roles)
    teamId: text("team_id"),
    eventId: text("event_id"),
    // Metadata
    assignedBy: text("assigned_by")
      .notNull()
      .references(() => user.id),
    assignedAt: timestamp("assigned_at", { withTimezone: true }).notNull().defaultNow(),
    expiresAt: timestamp("expires_at", { withTimezone: true }),
    notes: text("notes"),
  },
  (table) => [
    index("idx_user_roles_user_id").on(table.userId),
    index("idx_user_roles_team_id")
      .on(table.teamId)
      .where(sql`${table.teamId} IS NOT NULL`),
    index("idx_user_roles_event_id")
      .on(table.eventId)
      .where(sql`${table.eventId} IS NOT NULL`),
    index("idx_user_roles_unique").on(
      table.userId,
      table.roleId,
      table.teamId,
      table.eventId,
    ),
  ],
);

/**
 * Tags table - for user categorization (future implementation)
 */
export const tags = pgTable("tags", {
  id: text("id")
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  name: text("name").notNull().unique(),
  category: text("category").notNull(), // 'official', 'team', 'player', 'custom'
  description: text("description"),
  color: text("color"), // For UI display
  icon: text("icon"), // Icon identifier
  isActive: boolean("is_active").default(true),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
});

/**
 * User tags assignment table (future implementation)
 */
export const userTags = pgTable(
  "user_tags",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    tagId: text("tag_id")
      .notNull()
      .references(() => tags.id, { onDelete: "cascade" }),
    assignedBy: text("assigned_by").references(() => user.id),
    assignedAt: timestamp("assigned_at", { withTimezone: true }).notNull().defaultNow(),
    expiresAt: timestamp("expires_at", { withTimezone: true }),
    notes: text("notes"),
  },
  (table) => [
    index("idx_user_tags_user_id").on(table.userId),
    index("idx_user_tags_tag_id").on(table.tagId),
    index("idx_user_tags_expires_at")
      .on(table.expiresAt)
      .where(sql`${table.expiresAt} IS NOT NULL`),
    index("idx_user_tags_unique").on(table.userId, table.tagId),
  ],
);

// Type exports for TypeScript
export type Role = typeof roles.$inferSelect;
export type NewRole = typeof roles.$inferInsert;
export type UserRole = typeof userRoles.$inferSelect;
export type NewUserRole = typeof userRoles.$inferInsert;
export type Tag = typeof tags.$inferSelect;
export type NewTag = typeof tags.$inferInsert;
export type UserTag = typeof userTags.$inferSelect;
export type NewUserTag = typeof userTags.$inferInsert;
</file>

<file path="src/db/schema/teams.schema.ts">
import { createId } from "@paralleldrive/cuid2";
import { relations, sql } from "drizzle-orm";
import {
  index,
  integer,
  pgEnum,
  pgTable,
  text,
  timestamp,
  uniqueIndex,
  varchar,
} from "drizzle-orm/pg-core";
import { user } from "./auth.schema";

// Enum for team member roles
export const teamMemberRoleEnum = pgEnum("team_member_role", [
  "captain",
  "coach",
  "player",
  "substitute",
]);

// Enum for team member status
export const teamMemberStatusEnum = pgEnum("team_member_status", [
  "pending",
  "active",
  "inactive",
  "removed",
]);

/**
 * Teams table
 * Stores team information for Quadball teams
 */
export const teams = pgTable(
  "teams",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => createId()),
    name: varchar("name", { length: 255 }).notNull(),
    slug: varchar("slug", { length: 255 }).notNull().unique(),
    description: text("description"),
    city: varchar("city", { length: 255 }),
    province: varchar("province", { length: 2 }), // ON, BC, etc.
    logoUrl: text("logo_url"),
    primaryColor: varchar("primary_color", { length: 7 }), // Hex color
    secondaryColor: varchar("secondary_color", { length: 7 }), // Hex color
    foundedYear: varchar("founded_year", { length: 4 }),
    website: text("website"),
    socialLinks: text("social_links"), // JSON string of social media links
    isActive: text("is_active").default("true").notNull(),
    createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
    updatedAt: timestamp("updated_at", { withTimezone: true })
      .notNull()
      .defaultNow()
      .$onUpdate(() => new Date()),
    createdBy: text("created_by")
      .notNull()
      .references(() => user.id),
  },
  (table) => [
    uniqueIndex("teams_slug_idx").on(table.slug),
    index("teams_created_by_idx").on(table.createdBy),
    index("teams_is_active_idx").on(table.isActive),
  ],
);

/**
 * Team members junction table
 * Manages the many-to-many relationship between users and teams
 */
export const teamMembers = pgTable(
  "team_members",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => createId()),
    teamId: text("team_id")
      .notNull()
      .references(() => teams.id, { onDelete: "cascade" }),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    role: teamMemberRoleEnum("role").notNull().default("player"),
    status: teamMemberStatusEnum("status").notNull().default("pending"),
    jerseyNumber: varchar("jersey_number", { length: 3 }),
    position: varchar("position", { length: 50 }), // Chaser, Beater, Keeper, Seeker
    joinedAt: timestamp("joined_at", { withTimezone: true }).notNull().defaultNow(),
    leftAt: timestamp("left_at", { withTimezone: true }),
    invitedBy: text("invited_by").references(() => user.id),
    notes: text("notes"),
    invitedAt: timestamp("invited_at", { withTimezone: true }),
    lastInvitationReminderAt: timestamp("last_invitation_reminder_at", {
      withTimezone: true,
    }),
    invitationReminderCount: integer("invitation_reminder_count").notNull().default(0),
    requestedAt: timestamp("requested_at", { withTimezone: true }),
  },
  (table) => [
    uniqueIndex("team_members_team_user_idx").on(table.teamId, table.userId),
    index("team_members_team_status_idx").on(table.teamId, table.status),
    index("team_members_user_status_idx").on(table.userId, table.status),
    uniqueIndex("team_members_active_user_idx")
      .on(table.userId)
      .where(sql`status = 'active'`),
  ],
);

// Relations
export const teamsRelations = relations(teams, ({ many, one }) => ({
  members: many(teamMembers),
  creator: one(user, {
    fields: [teams.createdBy],
    references: [user.id],
  }),
}));

export const teamMembersRelations = relations(teamMembers, ({ one }) => ({
  team: one(teams, {
    fields: [teamMembers.teamId],
    references: [teams.id],
  }),
  user: one(user, {
    fields: [teamMembers.userId],
    references: [user.id],
  }),
  inviter: one(user, {
    fields: [teamMembers.invitedBy],
    references: [user.id],
  }),
}));

// Types
export type Team = typeof teams.$inferSelect;
export type NewTeam = typeof teams.$inferInsert;
export type TeamMember = typeof teamMembers.$inferSelect;
export type NewTeamMember = typeof teamMembers.$inferInsert;
export type TeamMemberRole = (typeof teamMemberRoleEnum.enumValues)[number];
export type TeamMemberStatus = (typeof teamMemberStatusEnum.enumValues)[number];
</file>

<file path="src/features/membership/membership.finalize.ts">
import { eq } from "drizzle-orm";
import type {
  Membership,
  MembershipPaymentSession,
  MembershipType,
} from "~/db/schema/membership.schema";
import { membershipPaymentSessions, memberships } from "~/db/schema/membership.schema";
import type { getDb } from "~/db/server-helpers";
import { atomicJsonbMerge } from "~/lib/db/jsonb-utils";

export type MembershipPaymentSessionRow = MembershipPaymentSession;
export type MembershipTypeRow = MembershipType;
export type MembershipRow = Membership;

export type MembershipDbClient = Awaited<ReturnType<typeof getDb>>;

export interface FinalizeMembershipParams {
  db: MembershipDbClient;
  paymentSession: MembershipPaymentSessionRow;
  membershipType: MembershipTypeRow;
  paymentId: string;
  orderId?: string | null;
  sessionId: string;
  now: Date;
}

export interface FinalizeMembershipResult {
  membership: MembershipRow;
  wasCreated: boolean;
}

export async function finalizeMembershipForSession({
  db,
  paymentSession,
  membershipType,
  paymentId,
  orderId,
  sessionId,
  now,
}: FinalizeMembershipParams): Promise<FinalizeMembershipResult> {
  const nowIso = now.toISOString();
  const resolvedOrderId = orderId ?? paymentSession.squareOrderId ?? null;

  return db.transaction(async (tx) => {
    const [existingMembershipByPayment] = await tx
      .select()
      .from(memberships)
      .where(eq(memberships.paymentId, paymentId))
      .limit(1);

    if (existingMembershipByPayment) {
      await tx
        .update(membershipPaymentSessions)
        .set({
          status: "completed",
          squarePaymentId: paymentId,
          squareOrderId: resolvedOrderId,
          metadata: atomicJsonbMerge(membershipPaymentSessions.metadata, {
            membershipId: existingMembershipByPayment.id,
            paymentConfirmedAt: nowIso,
            squareOrderId: resolvedOrderId,
            squareTransactionId: paymentId,
          }),
          updatedAt: now,
        })
        .where(eq(membershipPaymentSessions.id, paymentSession.id));

      return {
        membership: existingMembershipByPayment,
        wasCreated: false,
      } satisfies FinalizeMembershipResult;
    }

    const startDate = new Date(now);
    const endDate = new Date(now);
    endDate.setMonth(endDate.getMonth() + membershipType.durationMonths);

    const membershipMetadata: Record<string, unknown> = {
      ...(paymentSession.metadata ?? {}),
      sessionId,
      purchasedAt: nowIso,
      squareTransactionId: paymentId,
    };

    if (resolvedOrderId) {
      membershipMetadata["squareOrderId"] = resolvedOrderId;
    }

    const [newMembership] = await tx
      .insert(memberships)
      .values({
        userId: paymentSession.userId,
        membershipTypeId: membershipType.id,
        startDate: startDate.toISOString().split("T")[0],
        endDate: endDate.toISOString().split("T")[0],
        status: "active",
        paymentProvider: "square",
        paymentId,
        metadata: membershipMetadata,
      })
      .returning();

    await tx
      .update(membershipPaymentSessions)
      .set({
        status: "completed",
        squarePaymentId: paymentId,
        squareOrderId: resolvedOrderId,
        metadata: atomicJsonbMerge(membershipPaymentSessions.metadata, {
          membershipId: newMembership.id,
          paymentConfirmedAt: nowIso,
          squareOrderId: resolvedOrderId,
          squareTransactionId: paymentId,
        }),
        updatedAt: now,
      })
      .where(eq(membershipPaymentSessions.id, paymentSession.id));

    return {
      membership: newMembership,
      wasCreated: true,
    } satisfies FinalizeMembershipResult;
  });
}
</file>

<file path="src/features/membership/membership.types.ts">
// Define types manually since we can't import from schema at top level
import type { MembershipMetadata } from "./membership.db-types";
export interface MembershipType {
  id: string;
  name: string;
  description: string | null;
  priceCents: number;
  durationMonths: number;
  status: "active" | "inactive";
  metadata: MembershipMetadata | null;
  createdAt: Date;
  updatedAt: Date;
}

export interface Membership {
  id: string;
  userId: string;
  membershipTypeId: string;
  /** ISO date string (YYYY-MM-DD) from database date column */
  startDate: string;
  /** ISO date string (YYYY-MM-DD) from database date column */
  endDate: string;
  status: "active" | "cancelled" | "expired";
  paymentId: string | null;
  metadata: MembershipMetadata | null;
  createdAt: Date;
  updatedAt: Date;
}

export interface MembershipOperationResult<T = unknown> {
  success: boolean;
  data?: T;
  errors?: Array<{
    code: "VALIDATION_ERROR" | "DATABASE_ERROR" | "PAYMENT_ERROR" | "NOT_FOUND";
    field?: string;
    message: string;
  }>;
}

export interface CheckoutSessionResult {
  checkoutUrl: string;
  sessionId: string;
}

export interface MembershipPurchaseInput {
  membershipTypeId: string;
  sessionId: string;
  paymentId?: string;
}

export interface UserMembership extends Membership {
  membershipType: MembershipType;
}

export interface MembershipStatus {
  hasMembership: boolean;
  currentMembership?: UserMembership;
  expiresAt?: Date;
  daysRemaining?: number;
}
</file>

<file path="src/features/roles/permission.server.ts">
import { createServerOnlyFn } from "@tanstack/react-start";
import { and, eq, inArray } from "drizzle-orm";
import { roles, userRoles } from "~/db/schema";

/**
 * Server-side permission service
 * All methods here use database queries and should only be called on the server
 */
export class PermissionService {
  /**
   * Check if a user has global admin permissions
   */
  static isGlobalAdmin = createServerOnlyFn(async (userId: string): Promise<boolean> => {
    const { getDb } = await import("~/db/server-helpers");
    const db = await getDb();

    const [row] = await db
      .select()
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(
        and(
          eq(userRoles.userId, userId),
          inArray(roles.name, ["Solstice Admin", "Quadball Canada Admin"]),
        ),
      )
      .limit(1);

    return !!row;
  });

  /**
   * Check if a user can manage a specific team
   */
  static canManageTeam = createServerOnlyFn(
    async (userId: string, teamId: string): Promise<boolean> => {
      // Global admins can manage any team
      if (await PermissionService.isGlobalAdmin(userId)) return true;

      const { getDb } = await import("~/db/server-helpers");
      const db = await getDb();

      // Check for team-specific admin role
      const [row] = await db
        .select()
        .from(userRoles)
        .innerJoin(roles, eq(userRoles.roleId, roles.id))
        .where(
          and(
            eq(userRoles.userId, userId),
            eq(roles.name, "Team Admin"),
            eq(userRoles.teamId, teamId),
          ),
        )
        .limit(1);

      return !!row;
    },
  );

  /**
   * Check if a user can manage a specific event
   */
  static canManageEvent = createServerOnlyFn(
    async (userId: string, eventId: string): Promise<boolean> => {
      // Global admins can manage any event
      if (await PermissionService.isGlobalAdmin(userId)) return true;

      const { getDb } = await import("~/db/server-helpers");
      const db = await getDb();

      // Check for event-specific admin role
      const [row] = await db
        .select()
        .from(userRoles)
        .innerJoin(roles, eq(userRoles.roleId, roles.id))
        .where(
          and(
            eq(userRoles.userId, userId),
            eq(roles.name, "Event Admin"),
            eq(userRoles.eventId, eventId),
          ),
        )
        .limit(1);

      return !!row;
    },
  );

  /**
   * Get all roles for a user including scope information
   */
  static getUserRoles = createServerOnlyFn(async (userId: string) => {
    const { getDb } = await import("~/db/server-helpers");
    const db = await getDb();

    const userRolesList = await db
      .select({
        id: userRoles.id,
        userId: userRoles.userId,
        roleId: userRoles.roleId,
        teamId: userRoles.teamId,
        eventId: userRoles.eventId,
        assignedBy: userRoles.assignedBy,
        assignedAt: userRoles.assignedAt,
        expiresAt: userRoles.expiresAt,
        notes: userRoles.notes,
        role: {
          id: roles.id,
          name: roles.name,
          description: roles.description,
          permissions: roles.permissions,
        },
      })
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(eq(userRoles.userId, userId));

    return userRolesList;
  });
}
</file>

<file path="src/features/roles/permission.service.ts">
import { and, eq, inArray } from "drizzle-orm";
import { roles, userRoles } from "~/db/schema";

export class PermissionService {
  /**
   * Check if a user has global admin permissions
   */
  static async isGlobalAdmin(userId: string): Promise<boolean> {
    const { db } = await import("~/db");
    const database = await db();
    const [row] = await database
      .select()
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(
        and(
          eq(userRoles.userId, userId),
          inArray(roles.name, ["Solstice Admin", "Quadball Canada Admin"]),
        ),
      )
      .limit(1);

    return !!row;
  }

  /**
   * Check if a user can manage a specific team
   */
  static async canManageTeam(userId: string, teamId: string): Promise<boolean> {
    // Global admins can manage any team
    if (await this.isGlobalAdmin(userId)) return true;

    // Check for team-specific admin role
    const { db } = await import("~/db");
    const database = await db();
    const [row] = await database
      .select()
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(
        and(
          eq(userRoles.userId, userId),
          eq(roles.name, "Team Admin"),
          eq(userRoles.teamId, teamId),
        ),
      )
      .limit(1);

    return !!row;
  }

  /**
   * Check if a user can manage a specific event
   */
  static async canManageEvent(userId: string, eventId: string): Promise<boolean> {
    // Global admins can manage any event
    if (await this.isGlobalAdmin(userId)) return true;

    // Check for event-specific admin role
    const { db } = await import("~/db");
    const database = await db();
    const [row] = await database
      .select()
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(
        and(
          eq(userRoles.userId, userId),
          eq(roles.name, "Event Admin"),
          eq(userRoles.eventId, eventId),
        ),
      )
      .limit(1);

    return !!row;
  }

  /**
   * Get all roles for a user including scope information
   */
  static async getUserRoles(userId: string) {
    const { db } = await import("~/db");
    const database = await db();
    const userRolesList = await database
      .select({
        id: userRoles.id,
        userId: userRoles.userId,
        roleId: userRoles.roleId,
        teamId: userRoles.teamId,
        eventId: userRoles.eventId,
        assignedBy: userRoles.assignedBy,
        assignedAt: userRoles.assignedAt,
        expiresAt: userRoles.expiresAt,
        notes: userRoles.notes,
        role: {
          id: roles.id,
          name: roles.name,
          description: roles.description,
          permissions: roles.permissions,
        },
      })
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(eq(userRoles.userId, userId));

    return userRolesList;
  }
}

/**
 * Client-side helper to check if a user has a specific role
 * This is for UI display purposes only - actual authorization happens server-side
 */
export function userHasRole(
  user: {
    roles?: Array<{
      role: { name: string };
      teamId?: string | null;
      eventId?: string | null;
    }>;
  },
  roleName: string,
  options?: { teamId?: string; eventId?: string },
): boolean {
  if (!user.roles) return false;

  return user.roles.some((userRole) => {
    if (userRole.role.name !== roleName) return false;

    // For global roles
    if (!options?.teamId && !options?.eventId) {
      return !userRole.teamId && !userRole.eventId;
    }

    // For team-specific roles
    if (options.teamId) {
      return userRole.teamId === options.teamId;
    }

    // For event-specific roles
    if (options.eventId) {
      return userRole.eventId === options.eventId;
    }

    return false;
  });
}

/**
 * Client-side helper to check if user is any kind of admin
 */
export function isAnyAdmin(user: { roles?: Array<{ role: { name: string } }> }): boolean {
  if (!user.roles) return false;

  return user.roles.some((userRole) =>
    ["Solstice Admin", "Quadball Canada Admin", "Team Admin", "Event Admin"].includes(
      userRole.role.name,
    ),
  );
}
</file>

<file path="src/components/form-fields/ValidatedSelect.tsx">
import React from "react";
import { Label } from "~/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";
import { FieldComponentProps, isFieldApi } from "~/lib/form";
import { cn } from "~/shared/lib/utils";

interface ValidatedSelectProps extends FieldComponentProps {
  options: Array<{ value: string; label: string }>;
  placeholderText?: string;
  required?: boolean;
}

export const ValidatedSelect: React.FC<ValidatedSelectProps> = (props) => {
  const {
    field,
    label,
    options,
    placeholderText = "Select an option",
    className,
    required,
  } = props;

  if (!isFieldApi(field)) {
    console.error("ValidatedSelect requires a valid field prop.");
    return null;
  }

  const selectId = `${field.name}-select`;
  const meta = field.state.meta;
  const EMPTY_OPTION_VALUE = "__empty_option__";
  const placeholderOption = options.find((option) => option.value === "");
  const normalizedOptions = options.map((option) =>
    option.value === "" ? { ...option, value: EMPTY_OPTION_VALUE } : option,
  );
  const selectValue = placeholderOption
    ? field.state.value === "" || field.state.value === undefined
      ? EMPTY_OPTION_VALUE
      : (field.state.value as string)
    : ((field.state.value as string | undefined) ?? undefined);

  return (
    <div className={cn("space-y-2", className)}>
      <Label htmlFor={selectId}>{label}</Label>
      <Select
        {...(selectValue !== undefined ? { value: selectValue } : {})}
        onValueChange={(value) => {
          const normalizedValue =
            placeholderOption && value === EMPTY_OPTION_VALUE ? "" : value;
          field.handleChange(normalizedValue);
        }}
        disabled={field.form.state.isSubmitting}
      >
        <SelectTrigger
          id={selectId}
          aria-invalid={!!meta.errors.length}
          aria-required={required}
          aria-describedby={meta.errors.length ? `${selectId}-errors` : undefined}
        >
          <SelectValue placeholder={placeholderOption?.label ?? placeholderText} />
        </SelectTrigger>
        <SelectContent>
          {normalizedOptions.map((option) => (
            <SelectItem key={option.value} value={option.value}>
              {option.label}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
      {meta.isTouched && meta.errors.length > 0 && (
        <div id={`${selectId}-errors`} className="text-destructive text-sm font-medium">
          {meta.errors.join(", ")}
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/db/schema/membership.schema.ts">
import { createId } from "@paralleldrive/cuid2";
import { sql } from "drizzle-orm";
import {
  date,
  index,
  integer,
  jsonb,
  pgTable,
  timestamp,
  uniqueIndex,
  varchar,
} from "drizzle-orm/pg-core";
import { user } from "./auth.schema";

export const membershipTypes = pgTable(
  "membership_types",
  {
    id: varchar("id", { length: 255 })
      .$defaultFn(() => createId())
      .primaryKey(),
    name: varchar("name", { length: 255 }).notNull(),
    description: varchar("description", { length: 1000 }),
    priceCents: integer("price_cents").notNull(),
    durationMonths: integer("duration_months").notNull(),
    status: varchar("status", { length: 50 })
      .$type<"active" | "inactive">()
      .notNull()
      .default("active"),
    metadata: jsonb("metadata").$type<Record<string, unknown>>(),
    createdAt: timestamp("created_at").notNull().defaultNow(),
    updatedAt: timestamp("updated_at").notNull().defaultNow(),
  },
  (table) => [index("membership_types_status_idx").on(table.status)],
);

export const memberships = pgTable(
  "memberships",
  {
    id: varchar("id", { length: 255 })
      .$defaultFn(() => createId())
      .primaryKey(),
    userId: varchar("user_id", { length: 255 })
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    membershipTypeId: varchar("membership_type_id", { length: 255 })
      .notNull()
      .references(() => membershipTypes.id),
    startDate: date("start_date").notNull(),
    endDate: date("end_date").notNull(),
    status: varchar("status", { length: 50 })
      .$type<"active" | "expired" | "cancelled">()
      .notNull()
      .default("active"),
    paymentProvider: varchar("payment_provider", { length: 100 }),
    paymentId: varchar("payment_id", { length: 255 }),
    metadata: jsonb("metadata").$type<{
      paymentDetails?: Record<string, unknown>;
      notes?: string;
      [key: string]: unknown;
    }>(),
    createdAt: timestamp("created_at").notNull().defaultNow(),
    updatedAt: timestamp("updated_at").notNull().defaultNow(),
  },
  (table) => [
    index("memberships_user_id_idx").on(table.userId),
    index("memberships_status_idx").on(table.status),
    index("memberships_end_date_idx").on(table.endDate),
    index("memberships_payment_id_idx").on(table.paymentId),
    // Prevent duplicate payments - unique on (provider, paymentId) when paymentId exists
    // This allows multiple NULL paymentIds but prevents replay attacks
    uniqueIndex("memberships_payment_provider_id_unique")
      .on(table.paymentProvider, table.paymentId)
      .where(sql`${table.paymentId} IS NOT NULL`),
  ],
);

export const membershipPaymentSessions = pgTable(
  "membership_payment_sessions",
  {
    id: varchar("id", { length: 255 })
      .$defaultFn(() => createId())
      .primaryKey(),
    userId: varchar("user_id", { length: 255 })
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    membershipTypeId: varchar("membership_type_id", { length: 255 })
      .notNull()
      .references(() => membershipTypes.id),
    squareCheckoutId: varchar("square_checkout_id", { length: 255 }).notNull(),
    squarePaymentLinkUrl: varchar("square_payment_link_url", { length: 2048 }).notNull(),
    squareOrderId: varchar("square_order_id", { length: 255 }),
    squarePaymentId: varchar("square_payment_id", { length: 255 }),
    status: varchar("status", { length: 50 })
      .$type<"pending" | "completed" | "cancelled" | "failed">()
      .notNull()
      .default("pending"),
    amountCents: integer("amount_cents").notNull(),
    currency: varchar("currency", { length: 10 }).notNull().default("CAD"),
    expiresAt: timestamp("expires_at"),
    metadata: jsonb("metadata").$type<Record<string, unknown>>(),
    createdAt: timestamp("created_at").notNull().defaultNow(),
    updatedAt: timestamp("updated_at").notNull().defaultNow(),
  },
  (table) => [
    index("membership_payment_sessions_user_idx").on(table.userId),
    uniqueIndex("membership_payment_sessions_checkout_idx").on(table.squareCheckoutId),
    index("membership_payment_sessions_order_idx").on(table.squareOrderId),
    index("membership_payment_sessions_payment_idx").on(table.squarePaymentId),
    index("membership_payment_sessions_type_idx").on(table.membershipTypeId),
  ],
);

// Export inferred types
export type MembershipType = typeof membershipTypes.$inferSelect;
export type NewMembershipType = typeof membershipTypes.$inferInsert;
export type Membership = typeof memberships.$inferSelect;
export type NewMembership = typeof memberships.$inferInsert;
export type MembershipPaymentSession = typeof membershipPaymentSessions.$inferSelect;
export type NewMembershipPaymentSession = typeof membershipPaymentSessions.$inferInsert;
</file>

<file path="src/db/connections.ts">
import { Pool, neonConfig } from "@neondatabase/serverless";
import { createServerOnlyFn } from "@tanstack/react-start";
import { drizzle as drizzleNeon } from "drizzle-orm/neon-serverless";
import { drizzle as drizzlePostgres } from "drizzle-orm/postgres-js";
import postgres from "postgres";
import * as schema from "./schema";

// Singleton instances
let pooledInstance: ReturnType<typeof drizzleNeon> | null = null;
let unpooledInstance: ReturnType<typeof drizzlePostgres> | null = null;
let poolInstance: Pool | null = null;
let sqlInstance: ReturnType<typeof postgres> | null = null;

/**
 * Pooled database connection using Neon's serverless driver.
 *
 * Uses DATABASE_URL (pooled) or NETLIFY_DATABASE_URL for serverless functions.
 * This connection goes through Neon's connection pooler for efficient
 * concurrent request handling.
 *
 * Use this for:
 * - API routes and serverless functions
 * - Short-lived queries
 * - High-concurrency scenarios
 */
export const pooledDb = createServerOnlyFn(async () => {
  // Return existing instance if available
  if (pooledInstance) {
    return pooledInstance;
  }

  const { getPooledDbUrl, isServerless } = await import("../lib/env.server");

  // Configure Neon for serverless environments
  if (isServerless()) {
    neonConfig.useSecureWebSocket = true;
    neonConfig.poolQueryViaFetch = true;
  }

  const connectionString = getPooledDbUrl();

  poolInstance = new Pool({ connectionString });
  pooledInstance = drizzleNeon({
    client: poolInstance,
    schema,
    casing: "snake_case",
  });

  return pooledInstance;
});

/**
 * Unpooled (direct) database connection using standard postgres driver.
 *
 * Uses DATABASE_URL_UNPOOLED or NETLIFY_DATABASE_URL_UNPOOLED for
 * migrations and long operations. This creates a direct connection
 * to the database without going through the pooler.
 *
 * Use this for:
 * - Database migrations
 * - Long-running operations
 * - Batch imports/exports
 * - Operations requiring session-level features
 */
export const unpooledDb = createServerOnlyFn(async () => {
  // Return existing instance if available
  if (unpooledInstance) {
    return unpooledInstance;
  }

  const { getUnpooledDbUrl } = await import("../lib/env.server");
  const connectionString = getUnpooledDbUrl();

  // Set a reasonable connection pool size
  sqlInstance = postgres(connectionString, {
    max: 10, // Maximum number of connections in the pool
    idle_timeout: 20, // Close idle connections after 20 seconds
    connect_timeout: 10, // Connection timeout
  });

  unpooledInstance = drizzlePostgres({
    client: sqlInstance,
    schema,
    casing: "snake_case",
  });

  return unpooledInstance;
});

/**
 * Returns the appropriate database connection based on the environment.
 *
 * - In serverless environments (Netlify/Vercel): Uses pooled connection
 * - In development or traditional servers: Uses unpooled connection
 *
 * This is the recommended export for most use cases as it automatically
 * selects the optimal connection type.
 */
export const getDb = createServerOnlyFn(async () => {
  const { isServerless } = await import("../lib/env.server");
  if (isServerless()) {
    console.log("Using pooled connection for serverless environment");
    return await pooledDb();
  } else {
    console.log("Using unpooled connection for traditional environment");
    return await unpooledDb();
  }
});

/**
 * Cleanup function to close all database connections
 * Should be called when shutting down the server
 */
export const closeConnections = createServerOnlyFn(async () => {
  const promises: Promise<void>[] = [];

  if (poolInstance) {
    promises.push(poolInstance.end());
    poolInstance = null;
    pooledInstance = null;
  }

  if (sqlInstance) {
    promises.push(sqlInstance.end({ timeout: 3 }));
    sqlInstance = null;
    unpooledInstance = null;
  }

  await Promise.all(promises);
  console.log("Database connections closed");
});
</file>

<file path="src/features/dashboard/MemberDashboard.tsx">
import { Link } from "@tanstack/react-router";
import {
  AlertCircle,
  Calendar,
  CheckCircle2,
  Clock,
  CreditCard,
  Settings,
  Shield,
  UserCircle,
  Users,
  XCircle,
} from "lucide-react";
import { Button } from "~/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";
import type { MembershipStatus } from "~/features/membership/membership.types";
import { isAnyAdmin } from "~/features/roles/permission.service";

// Types for the dashboard data
interface ProfileStatus {
  complete: boolean;
  missingFields: string[];
}

interface UserTeam {
  team: {
    id: string;
    name: string;
    slug: string;
    city: string | null;
    province: string | null;
  };
  membership: {
    role: string;
    status: string;
  };
  memberCount: number;
}

interface PendingInvite {
  team: {
    id: string;
    name: string;
    slug: string;
  };
  membership: {
    id: string;
    role: string;
  };
  inviter: {
    id: string;
    name: string | null;
    email: string;
  } | null;
}

interface UpcomingEvent {
  id: string;
  name: string;
  slug: string;
  startDate: Date | string;
  city: string | null;
  province: string | null;
  status: string;
}

interface User {
  id: string;
  name: string | null;
  email: string;
  roles?: Array<{ role: { name: string } }>;
}

export interface MemberDashboardProps {
  user: User;
  membershipStatus: MembershipStatus | null;
  profileStatus: ProfileStatus;
  userTeams: UserTeam[];
  pendingInvites: PendingInvite[];
  upcomingEvents: UpcomingEvent[];
}

export function MemberDashboard({
  user,
  membershipStatus,
  profileStatus,
  userTeams,
  pendingInvites,
  upcomingEvents,
}: MemberDashboardProps) {
  const isAdmin = isAnyAdmin(user);

  return (
    <div className="container mx-auto space-y-8 p-6">
      {/* Header */}
      <header>
        <h1 className="text-3xl font-bold tracking-tight">
          Welcome back, {user.name || "Member"}!
        </h1>
        <div className="mt-2 flex flex-wrap items-center gap-2">
          {membershipStatus?.hasMembership ? (
            <span className="inline-flex items-center rounded-full bg-green-100 px-2.5 py-0.5 text-xs font-medium text-green-800">
              <CheckCircle2 className="mr-1 h-3 w-3" />
              Active Member
            </span>
          ) : (
            <span className="inline-flex items-center rounded-full bg-yellow-100 px-2.5 py-0.5 text-xs font-medium text-yellow-800">
              <AlertCircle className="mr-1 h-3 w-3" />
              Membership Required
            </span>
          )}
          {isAdmin && (
            <span className="inline-flex items-center rounded-full bg-purple-100 px-2.5 py-0.5 text-xs font-medium text-purple-800">
              <Shield className="mr-1 h-3 w-3" />
              Admin
            </span>
          )}
        </div>
      </header>

      {/* Action Cards - Your Next Steps */}
      <ActionCards
        profileStatus={profileStatus}
        membershipStatus={membershipStatus}
        pendingInvites={pendingInvites}
      />

      {/* Main Content Grid */}
      <div className="grid gap-6 lg:grid-cols-2">
        {/* Teams Section */}
        <TeamsCard teams={userTeams} invites={pendingInvites} />

        {/* Membership Card */}
        <MembershipCard status={membershipStatus} />
      </div>

      {/* Upcoming Events */}
      <UpcomingEventsCard events={upcomingEvents} />

      {/* Admin Tools (conditional) */}
      {isAdmin && <AdminToolsCard />}

      {/* Quick Links */}
      <QuickLinksCard />
    </div>
  );
}

// Action Cards Component
function ActionCards({
  profileStatus,
  membershipStatus,
  pendingInvites,
}: {
  profileStatus: ProfileStatus;
  membershipStatus: MembershipStatus | null;
  pendingInvites: PendingInvite[];
}) {
  const actions: Array<{
    show: boolean;
    title: string;
    description: string;
    href: string;
    icon: typeof UserCircle;
    variant: "default" | "warning" | "info";
  }> = [];

  // Profile incomplete
  if (!profileStatus.complete) {
    actions.push({
      show: true,
      title: "Complete your profile",
      description: `Missing: ${profileStatus.missingFields.slice(0, 2).join(", ")}${profileStatus.missingFields.length > 2 ? "..." : ""}`,
      href: "/dashboard/profile",
      icon: UserCircle,
      variant: "warning",
    });
  }

  // No membership
  if (!membershipStatus?.hasMembership) {
    actions.push({
      show: true,
      title: "Activate membership",
      description: "Get your annual player membership to compete",
      href: "/dashboard/membership",
      icon: CreditCard,
      variant: "warning",
    });
  }

  // Membership expiring soon
  if (
    membershipStatus?.hasMembership &&
    membershipStatus.daysRemaining &&
    membershipStatus.daysRemaining < 30
  ) {
    actions.push({
      show: true,
      title: "Renew membership",
      description: `Expires in ${membershipStatus.daysRemaining} days`,
      href: "/dashboard/membership",
      icon: Clock,
      variant: "warning",
    });
  }

  // Pending team invites
  if (pendingInvites.length > 0) {
    actions.push({
      show: true,
      title: "Team invitations",
      description: `${pendingInvites.length} pending invite${pendingInvites.length !== 1 ? "s" : ""}`,
      href: "/dashboard/teams",
      icon: Users,
      variant: "info",
    });
  }

  if (actions.length === 0) {
    return null;
  }

  return (
    <section>
      <h2 className="mb-4 text-lg font-semibold">Your Next Steps</h2>
      <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
        {actions.map((action) => (
          <Link key={action.href + action.title} to={action.href}>
            <Card className="transition-shadow hover:shadow-md">
              <CardContent className="flex items-center gap-4 pt-6">
                <div
                  className={`rounded-full p-2 ${
                    action.variant === "warning"
                      ? "bg-yellow-100 text-yellow-700"
                      : "bg-blue-100 text-blue-700"
                  }`}
                >
                  <action.icon className="h-5 w-5" />
                </div>
                <div>
                  <p className="font-medium">{action.title}</p>
                  <p className="text-muted-foreground text-sm">{action.description}</p>
                </div>
              </CardContent>
            </Card>
          </Link>
        ))}
      </div>
    </section>
  );
}

// Teams Card
function TeamsCard({ teams, invites }: { teams: UserTeam[]; invites: PendingInvite[] }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Users className="h-5 w-5" />
          Your Teams
        </CardTitle>
        <CardDescription>
          {teams.length === 0
            ? "You're not on any teams yet"
            : `${teams.length} active team${teams.length !== 1 ? "s" : ""}`}
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        {teams.length === 0 ? (
          <div className="py-4 text-center">
            <p className="text-muted-foreground mb-4 text-sm">
              Join a team to compete in tournaments and events
            </p>
            <Button asChild variant="outline">
              <Link to="/dashboard/teams/browse">Browse Teams</Link>
            </Button>
          </div>
        ) : (
          <ul className="space-y-3">
            {teams.map(({ team, membership, memberCount }) => (
              <li key={team.id}>
                <Link
                  to="/dashboard/teams/$teamId"
                  params={{ teamId: team.slug }}
                  className="hover:bg-muted/50 flex items-center justify-between rounded-lg border p-3 transition-colors"
                >
                  <div>
                    <p className="font-medium">{team.name}</p>
                    <p className="text-muted-foreground text-sm">
                      {team.city}
                      {team.province ? `, ${team.province}` : ""} &middot; {memberCount}{" "}
                      member{memberCount !== 1 ? "s" : ""}
                    </p>
                  </div>
                  <span className="bg-muted rounded-full px-2 py-1 text-xs capitalize">
                    {membership.role}
                  </span>
                </Link>
              </li>
            ))}
          </ul>
        )}

        {/* Pending Invites */}
        {invites.length > 0 && (
          <div className="border-t pt-4">
            <p className="mb-2 text-sm font-medium">Pending Invitations</p>
            <ul className="space-y-2">
              {invites.map(({ team, membership, inviter }) => (
                <li
                  key={membership.id}
                  className="flex items-center justify-between rounded-lg border border-dashed p-3"
                >
                  <div>
                    <p className="font-medium">{team.name}</p>
                    <p className="text-muted-foreground text-sm">
                      Invited as {membership.role}
                      {inviter?.name ? ` by ${inviter.name}` : ""}
                    </p>
                  </div>
                  <div className="flex gap-2">
                    <Button size="sm" variant="outline">
                      Decline
                    </Button>
                    <Button size="sm">Accept</Button>
                  </div>
                </li>
              ))}
            </ul>
          </div>
        )}
      </CardContent>
    </Card>
  );
}

// Membership Card
function MembershipCard({ status }: { status: MembershipStatus | null }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <CreditCard className="h-5 w-5" />
          Membership Status
        </CardTitle>
      </CardHeader>
      <CardContent>
        {status?.hasMembership ? (
          <div className="space-y-4">
            <div className="flex items-center gap-3">
              <CheckCircle2 className="h-8 w-8 text-green-600" />
              <div>
                <p className="text-2xl font-bold">Active</p>
                <p className="text-muted-foreground text-sm">
                  {status.currentMembership?.membershipType.name}
                </p>
              </div>
            </div>
            {status.expiresAt && (
              <div className="bg-muted rounded-lg p-3">
                <p className="text-sm">
                  <Clock className="mr-1 inline h-4 w-4" />
                  Valid until{" "}
                  {new Date(status.expiresAt).toLocaleDateString("en-CA", {
                    year: "numeric",
                    month: "long",
                    day: "numeric",
                  })}
                </p>
                {typeof status.daysRemaining === "number" &&
                  status.daysRemaining < 60 && (
                    <p className="mt-1 text-sm text-yellow-700">
                      {status.daysRemaining <= 0
                        ? "Expires today"
                        : `${status.daysRemaining} days remaining`}
                    </p>
                  )}
              </div>
            )}
            <Button asChild variant="outline" className="w-full">
              <Link to="/dashboard/membership">
                {typeof status.daysRemaining === "number" && status.daysRemaining < 30
                  ? "Renew Now"
                  : "View Details"}
              </Link>
            </Button>
          </div>
        ) : (
          <div className="space-y-4 text-center">
            <XCircle className="text-muted-foreground mx-auto h-12 w-12" />
            <div>
              <p className="font-medium">No Active Membership</p>
              <p className="text-muted-foreground text-sm">
                Get your membership to compete in official events
              </p>
            </div>
            <Button asChild className="w-full">
              <Link to="/dashboard/membership">View Membership Options</Link>
            </Button>
          </div>
        )}
      </CardContent>
    </Card>
  );
}

// Upcoming Events Card
function UpcomingEventsCard({ events }: { events: UpcomingEvent[] }) {
  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <CardTitle className="flex items-center gap-2">
            <Calendar className="h-5 w-5" />
            Upcoming Events
          </CardTitle>
          <Button asChild variant="ghost" size="sm">
            <Link to="/dashboard/events">View all</Link>
          </Button>
        </div>
      </CardHeader>
      <CardContent>
        {events.length === 0 ? (
          <p className="text-muted-foreground py-4 text-center text-sm">
            No upcoming events scheduled
          </p>
        ) : (
          <ul className="space-y-3">
            {events.slice(0, 5).map((event) => (
              <li key={event.id}>
                <Link
                  to="/dashboard/events/$slug"
                  params={{ slug: event.slug }}
                  className="hover:bg-muted/50 flex items-center justify-between rounded-lg border p-3 transition-colors"
                >
                  <div>
                    <p className="font-medium">{event.name}</p>
                    <p className="text-muted-foreground text-sm">
                      {new Date(event.startDate).toLocaleDateString("en-CA", {
                        month: "short",
                        day: "numeric",
                        year: "numeric",
                      })}{" "}
                      &middot; {event.city}
                      {event.province ? `, ${event.province}` : ""}
                    </p>
                  </div>
                  <span
                    className={`rounded-full px-2 py-1 text-xs ${
                      event.status === "registration_open"
                        ? "bg-green-100 text-green-800"
                        : "bg-muted text-muted-foreground"
                    }`}
                  >
                    {event.status === "registration_open" ? "Open" : event.status}
                  </span>
                </Link>
              </li>
            ))}
          </ul>
        )}
      </CardContent>
    </Card>
  );
}

// Admin Tools Card
function AdminToolsCard() {
  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Shield className="h-5 w-5" />
          Admin Tools
        </CardTitle>
        <CardDescription>Manage organization settings and data</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="grid gap-3 sm:grid-cols-2 lg:grid-cols-4">
          <Button asChild variant="outline">
            <Link to="/dashboard/members">Members</Link>
          </Button>
          <Button asChild variant="outline">
            <Link to="/dashboard/admin/roles">Roles</Link>
          </Button>
          <Button asChild variant="outline">
            <Link to="/dashboard/events">Events</Link>
          </Button>
          <Button asChild variant="outline">
            <Link to="/dashboard/reports">Reports</Link>
          </Button>
        </div>
      </CardContent>
    </Card>
  );
}

// Quick Links Card
function QuickLinksCard() {
  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Settings className="h-5 w-5" />
          Quick Links
        </CardTitle>
      </CardHeader>
      <CardContent>
        <div className="grid gap-3 sm:grid-cols-3">
          <Button asChild variant="ghost" className="justify-start">
            <Link to="/dashboard/profile">
              <UserCircle className="mr-2 h-4 w-4" />
              Edit Profile
            </Link>
          </Button>
          <Button asChild variant="ghost" className="justify-start">
            <Link to="/dashboard/settings">
              <Settings className="mr-2 h-4 w-4" />
              Settings
            </Link>
          </Button>
          <Button asChild variant="ghost" className="justify-start">
            <a href="https://quadballcanada.ca" target="_blank" rel="noopener noreferrer">
              <Calendar className="mr-2 h-4 w-4" />
              News & Updates
            </a>
          </Button>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/lib/auth/middleware/auth-guard.ts">
import { createMiddleware } from "@tanstack/react-start";
import { getRequest, setResponseStatus } from "@tanstack/react-start/server";

import type { AuthUser } from "~/lib/auth/types";

export type AuthedRequestContext = {
  user: NonNullable<AuthUser>;
};

/**
 * Middleware to force authentication on a server function, and add the user to the context.
 */
export const authMiddleware = createMiddleware({ type: "function" }).server(
  async ({ next }) => {
    const { getAuth } = await import("~/lib/auth/server-helpers");
    const auth = await getAuth();
    const headers = getRequest().headers;

    const session = await auth.api.getSession({
      headers,
      query: {
        disableCookieCache: true,
      },
    });

    const user = session?.user;

    if (!user) {
      setResponseStatus(401);
      const { unauthorized } = await import("~/lib/server/errors");
      throw unauthorized();
    }

    const context: AuthedRequestContext = { user: user as NonNullable<AuthUser> };

    return next({ context });
  },
);
</file>

<file path="src/lib/auth/middleware/role-guard.ts">
import { redirect } from "@tanstack/react-router";
import { userHasRole } from "~/features/roles/permission.service";
import type { User } from "~/lib/auth/types";
import { isAdminClient } from "~/lib/auth/utils/admin-check";

interface RoleGuardOptions {
  user: User | null;
  requiredRoles?: string[];
  teamId?: string;
  eventId?: string;
  redirectTo?: string;
}

/**
 * Role-based access control guard for routes
 * Use this in route beforeLoad to protect pages based on user roles
 */
export async function requireRole({
  user,
  requiredRoles,
  teamId,
  eventId,
  redirectTo = "/dashboard",
}: RoleGuardOptions) {
  if (!user) {
    throw redirect({ to: "/auth/login" });
  }

  if (!requiredRoles || requiredRoles.length === 0) {
    return;
  }

  const hasAccess = requiredRoles.some((roleName) => {
    if (roleName === "Team Admin" && teamId) {
      return userHasRole(user, roleName, { teamId });
    }

    if (roleName === "Event Admin" && eventId) {
      return userHasRole(user, roleName, { eventId });
    }

    return userHasRole(user, roleName);
  });

  if (!hasAccess) {
    throw redirect({ to: redirectTo });
  }
}

/**
 * Convenience function for requiring global admin access
 */
export async function requireGlobalAdmin(user: User | null, redirectTo = "/dashboard") {
  if (!user) {
    throw redirect({ to: "/auth/login" });
  }

  if (!isAdminClient(user)) {
    throw redirect({ to: redirectTo });
  }
}
</file>

<file path="src/lib/email/sendgrid.ts">
/**
 * SendGrid email service wrapper
 * Provides type-safe methods for sending transactional emails
 */

import { z } from "zod";

// Email configuration schemas
export const EmailRecipientSchema = z.object({
  email: z.email(),
  name: z.string().optional(),
});

export const EmailDataSchema = z.object({
  to: z.union([EmailRecipientSchema, z.array(EmailRecipientSchema)]),
  from: EmailRecipientSchema,
  subject: z.string(),
  text: z.string().optional(),
  html: z.string().optional(),
  templateId: z.string().optional(),
  dynamicTemplateData: z.record(z.string(), z.unknown()).optional(),
  replyTo: EmailRecipientSchema.optional(),
  attachments: z
    .array(
      z.object({
        content: z.string(),
        filename: z.string(),
        type: z.string().optional(),
        disposition: z.string().optional(),
      }),
    )
    .optional(),
});

export type EmailRecipient = z.infer<typeof EmailRecipientSchema>;
export type EmailData = z.infer<typeof EmailDataSchema>;

// Response types
export interface SendEmailResult {
  success: boolean;
  messageId?: string;
  error?: string;
}

// Email template IDs (to be populated with actual SendGrid template IDs)
export const EMAIL_TEMPLATES = {
  MEMBERSHIP_PURCHASE_RECEIPT: "membership_purchase_receipt",
  WELCOME: "welcome",
  PASSWORD_RESET: "password_reset",
  TEAM_INVITATION: "team_invitation",
  EVENT_REGISTRATION_CONFIRMATION: "event_registration_confirmation",
} as const;

export type EmailTemplateId = (typeof EMAIL_TEMPLATES)[keyof typeof EMAIL_TEMPLATES];

// Mock email service for development
class MockEmailService {
  async send(data: EmailData): Promise<SendEmailResult> {
    console.log("📧 Mock Email Service - Sending email:", {
      to: data.to,
      subject: data.subject,
      templateId: data.templateId,
      dynamicTemplateData: data.dynamicTemplateData,
    });

    // Simulate network delay
    await new Promise((resolve) => setTimeout(resolve, 1000));

    // Simulate success
    return {
      success: true,
      messageId: `mock-${Date.now()}`,
    };
  }

  setApiKey(_key: string): void {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const key = _key;
    console.log("📧 Mock Email Service - API key set");
  }
}

// Real SendGrid service
class SendGridEmailService {
  private client: unknown;
  private initialized = false;

  async initialize(): Promise<void> {
    if (this.initialized) return;

    try {
      const sgMail = await import("@sendgrid/mail");
      this.client = sgMail.default;

      const apiKey = process.env["SENDGRID_API_KEY"];
      if (!apiKey) {
        throw new Error("SENDGRID_API_KEY environment variable is not set");
      }

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (this.client as any).setApiKey(apiKey);
      this.initialized = true;
    } catch (error) {
      console.error("Failed to initialize SendGrid:", error);
      throw error;
    }
  }

  async send(data: EmailData): Promise<SendEmailResult> {
    try {
      await this.initialize();

      // Validate email data
      const validatedData = EmailDataSchema.parse(data);

      // Convert to SendGrid format
      const msg = {
        to: validatedData.to,
        from: validatedData.from,
        subject: validatedData.subject,
        text: validatedData.text,
        html: validatedData.html,
        templateId: validatedData.templateId,
        dynamicTemplateData: validatedData.dynamicTemplateData,
        replyTo: validatedData.replyTo,
        attachments: validatedData.attachments,
      };

      // Send email
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const [response] = await (this.client as any).send(msg);

      return {
        success: true,
        messageId: response.headers["x-message-id"],
      };
    } catch (error) {
      console.error("SendGrid error:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to send email",
      };
    }
  }
}

// Factory function to get the appropriate email service
type EmailService = MockEmailService | SendGridEmailService;

let cachedEmailService: EmailService | null = null;

const resolveEmailService = async (): Promise<EmailService> => {
  if (cachedEmailService) {
    return cachedEmailService;
  }

  const useSendGrid =
    process.env["SENDGRID_API_KEY"] && process.env["NODE_ENV"] !== "test";

  cachedEmailService = useSendGrid ? new SendGridEmailService() : new MockEmailService();
  return cachedEmailService;
};

export const getEmailService = async (): Promise<EmailService> => resolveEmailService();

// Convenience function for sending membership purchase receipts
export const sendMembershipPurchaseReceipt = async (params: {
  to: EmailRecipient;
  membershipType: string;
  amount: number;
  paymentId: string;
  expiresAt: Date;
}) => {
  const service = await getEmailService();

  const fromEmail = process.env["SENDGRID_FROM_EMAIL"] || "noreply@quadballcanada.com";
  const fromName = process.env["SENDGRID_FROM_NAME"] || "Quadball Canada";

  return service.send({
    to: params.to,
    from: {
      email: fromEmail,
      name: fromName,
    },
    subject: "Membership Purchase Confirmation - Quadball Canada",
    templateId: EMAIL_TEMPLATES.MEMBERSHIP_PURCHASE_RECEIPT,
    dynamicTemplateData: {
      memberName: params.to.name || "Member",
      membershipType: params.membershipType,
      amount: `$${(params.amount / 100).toFixed(2)}`,
      paymentId: params.paymentId,
      expiresAt: params.expiresAt.toLocaleDateString("en-CA"),
      year: new Date().getFullYear(),
    },
    // Fallback plain text version
    text: `Thank you for purchasing a ${params.membershipType} membership!

Amount paid: $${(params.amount / 100).toFixed(2)}
Payment ID: ${params.paymentId}
Expires: ${params.expiresAt.toLocaleDateString("en-CA")}

You can view your membership status at any time by logging into your dashboard.

If you have any questions, please contact us at support@quadballcanada.com.

Best regards,
Quadball Canada Team`,
    // HTML version (used if no template ID is configured)
    html: `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Membership Purchase Confirmation</title>
</head>
<body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
  <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
    <h1 style="color: #0ea5e9;">Membership Purchase Confirmation</h1>
    
    <p>Hello ${params.to.name || "Member"},</p>
    
    <p>Thank you for purchasing a <strong>${params.membershipType}</strong> membership!</p>
    
    <div style="background-color: #f3f4f6; padding: 20px; border-radius: 8px; margin: 20px 0;">
      <h2 style="margin-top: 0;">Purchase Details</h2>
      <p><strong>Amount paid:</strong> $${(params.amount / 100).toFixed(2)}</p>
      <p><strong>Payment ID:</strong> ${params.paymentId}</p>
      <p><strong>Expires:</strong> ${params.expiresAt.toLocaleDateString("en-CA")}</p>
    </div>
    
    <p>You can view your membership status at any time by logging into your dashboard.</p>
    
    <p>If you have any questions, please contact us at <a href="mailto:support@quadballcanada.com">support@quadballcanada.com</a>.</p>
    
    <hr style="margin: 30px 0; border: none; border-top: 1px solid #e5e7eb;">
    
    <p style="color: #6b7280; font-size: 14px;">
      Best regards,<br>
      Quadball Canada Team
    </p>
  </div>
</body>
</html>
    `,
  });
};

export const sendTeamInvitationEmail = async (params: {
  to: EmailRecipient;
  teamName: string;
  teamSlug: string;
  role: string;
  invitedByName?: string;
  invitedByEmail?: string;
}) => {
  const service = await getEmailService();

  const fromEmail = process.env["SENDGRID_FROM_EMAIL"] || "noreply@quadballcanada.com";
  const fromName = process.env["SENDGRID_FROM_NAME"] || "Quadball Canada";

  const siteUrl =
    process.env["SITE_URL"] ||
    process.env["URL"] ||
    process.env["VITE_BASE_URL"] ||
    "http://localhost:5173";
  const normalizedSiteUrl = siteUrl.endsWith("/") ? siteUrl.slice(0, -1) : siteUrl;
  const dashboardUrl = `${normalizedSiteUrl}/dashboard/teams`;
  const invitationUrl = `${dashboardUrl}/${params.teamSlug}`;

  const inviterDisplay =
    params.invitedByName ||
    params.invitedByEmail ||
    "a Quadball Canada team representative";

  const textBody = `You've been invited to join ${params.teamName} as a ${params.role}.

Accept or decline your invitation here: ${dashboardUrl}

If the link above doesn't work, copy and paste this URL into your browser: ${invitationUrl}

Invitation sent by ${inviterDisplay}.`;

  return service.send({
    to: params.to,
    from: {
      email: fromEmail,
      name: fromName,
    },
    subject: `${params.teamName} team invitation`,
    templateId: EMAIL_TEMPLATES.TEAM_INVITATION,
    dynamicTemplateData: {
      teamName: params.teamName,
      role: params.role,
      inviterName: inviterDisplay,
      dashboardUrl,
      invitationUrl,
    },
    text: textBody,
  });
};

// Convenience function for sending welcome emails
export const sendWelcomeEmail = async (params: {
  to: EmailRecipient;
  profileUrl: string;
}) => {
  const service = await getEmailService();

  const fromEmail = process.env["SENDGRID_FROM_EMAIL"] || "noreply@quadballcanada.com";
  const fromName = process.env["SENDGRID_FROM_NAME"] || "Quadball Canada";

  return service.send({
    to: params.to,
    from: {
      email: fromEmail,
      name: fromName,
    },
    subject: "Welcome to Quadball Canada!",
    templateId: EMAIL_TEMPLATES.WELCOME,
    dynamicTemplateData: {
      memberName: params.to.name || "New Member",
      profileUrl: params.profileUrl,
      year: new Date().getFullYear(),
    },
    text: `Welcome to Quadball Canada!

We're thrilled to have you join our community.

To get started, please complete your profile: ${params.profileUrl}

If you have any questions, feel free to reach out to us at support@quadballcanada.com.

Best regards,
Quadball Canada Team`,
  });
};
</file>

<file path="src/db/schema/events.schema.ts">
import { createId } from "@paralleldrive/cuid2";
import { relations } from "drizzle-orm";
import {
  boolean,
  date,
  index,
  integer,
  jsonb,
  pgEnum,
  pgTable,
  text,
  timestamp,
  uniqueIndex,
  uuid,
  varchar,
} from "drizzle-orm/pg-core";
import { createInsertSchema, createSelectSchema } from "drizzle-zod";
import { z } from "zod";
import { user } from "./auth.schema";
import { teams } from "./teams.schema";

/**
 * Event status enum
 */
export const eventStatusEnum = pgEnum("event_status", [
  "draft", // Event is being planned, not visible in listings
  "published", // Event is visible but registration not open
  "registration_open", // Teams can register
  "registration_closed", // No more registrations
  "in_progress", // Event is currently happening
  "completed", // Event finished
  "cancelled", // Event was cancelled
]);

/**
 * Event type enum
 */
export const eventTypeEnum = pgEnum("event_type", [
  "tournament", // Competitive tournament
  "league", // League play
  "camp", // Training camp
  "clinic", // Skills clinic
  "social", // Social/fun event
  "other", // Other type
]);

/**
 * Registration type enum
 */
export const registrationTypeEnum = pgEnum("registration_type", [
  "team", // Teams register together
  "individual", // Individuals register and are assigned to teams
  "both", // Supports both team and individual registration
]);

/**
 * Main events table
 */
export const events = pgTable("events", {
  id: uuid("id").primaryKey().defaultRandom(),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),

  // Basic information
  name: varchar("name", { length: 255 }).notNull(),
  slug: varchar("slug", { length: 255 }).notNull().unique(), // URL-friendly identifier
  description: text("description"),
  shortDescription: varchar("short_description", { length: 500 }), // For cards/previews

  // Event details
  type: eventTypeEnum("type").notNull().default("tournament"),
  status: eventStatusEnum("status").notNull().default("draft"),

  // Location
  venueName: varchar("venue_name", { length: 255 }),
  venueAddress: text("venue_address"),
  city: varchar("city", { length: 100 }),
  province: varchar("province", { length: 50 }),
  postalCode: varchar("postal_code", { length: 10 }),
  locationNotes: text("location_notes"), // Parking info, directions, etc.

  // Dates and times
  startDate: date("start_date").notNull(),
  endDate: date("end_date").notNull(),
  registrationOpensAt: timestamp("registration_opens_at"),
  registrationClosesAt: timestamp("registration_closes_at"),

  // Registration settings
  registrationType: registrationTypeEnum("registration_type").notNull().default("team"),
  maxTeams: integer("max_teams"),
  maxParticipants: integer("max_participants"),
  minPlayersPerTeam: integer("min_players_per_team").default(7),
  maxPlayersPerTeam: integer("max_players_per_team").default(21),

  // Pricing (in cents)
  teamRegistrationFee: integer("team_registration_fee").default(0),
  individualRegistrationFee: integer("individual_registration_fee").default(0),
  earlyBirdDiscount: integer("early_bird_discount").default(0), // Percentage
  earlyBirdDeadline: timestamp("early_bird_deadline"),

  // Contact information
  organizerId: text("organizer_id")
    .notNull()
    .references(() => user.id),
  contactEmail: varchar("contact_email", { length: 255 }),
  contactPhone: varchar("contact_phone", { length: 20 }),

  // Additional data
  rules: jsonb("rules"), // Custom rules/modifications
  schedule: jsonb("schedule"), // Detailed schedule info
  divisions: jsonb("divisions"), // e.g. [{name: "Competitive", maxTeams: 8}, {name: "Recreational", maxTeams: 12}]
  amenities: jsonb("amenities"), // ["parking", "concessions", "livestream", etc.]
  requirements: jsonb("requirements"), // ["valid membership", "insurance", etc.]

  // Media
  logoUrl: text("logo_url"),
  bannerUrl: text("banner_url"),

  // Metadata
  metadata: jsonb("metadata"), // Flexible field for additional data
  allowEtransfer: boolean("allow_etransfer").notNull().default(false),
  etransferInstructions: text("etransfer_instructions"),
  etransferRecipient: varchar("etransfer_recipient", { length: 255 }),
});

/**
 * Event registrations table - tracks team/individual registrations for events
 */
export const eventRegistrations = pgTable("event_registrations", {
  id: uuid("id").primaryKey().defaultRandom(),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),

  // References
  eventId: uuid("event_id")
    .notNull()
    .references(() => events.id),
  teamId: text("team_id").references(() => teams.id), // Null for individual registrations
  userId: text("user_id")
    .notNull()
    .references(() => user.id), // Who registered

  // Registration details
  registrationType: registrationTypeEnum("registration_type").notNull(),
  division: varchar("division", { length: 100 }), // Which division they're in

  // Status
  status: varchar("status", { length: 50 }).notNull().default("pending"), // pending, confirmed, waitlisted, cancelled
  paymentStatus: varchar("payment_status", { length: 50 }).notNull().default("pending"), // pending, paid, refunded
  paymentId: text("payment_id"), // Reference to payment record
  paymentMethod: varchar("payment_method", { length: 50 }).notNull().default("square"),
  amountDueCents: integer("amount_due_cents").notNull().default(0),
  amountPaidCents: integer("amount_paid_cents"),
  paymentCompletedAt: timestamp("payment_completed_at"),
  paymentMetadata: jsonb("payment_metadata"),

  // Team roster (for team registrations)
  roster: jsonb("roster"), // Array of player IDs and roles

  // Notes
  notes: text("notes"), // Any special requirements/notes
  internalNotes: text("internal_notes"), // Admin notes

  // Timestamps
  confirmedAt: timestamp("confirmed_at"),
  cancelledAt: timestamp("cancelled_at"),
});

export const eventPaymentSessions = pgTable(
  "event_payment_sessions",
  {
    id: varchar("id", { length: 255 })
      .$defaultFn(() => createId())
      .primaryKey(),
    registrationId: uuid("registration_id")
      .notNull()
      .references(() => eventRegistrations.id, { onDelete: "cascade" }),
    eventId: uuid("event_id")
      .notNull()
      .references(() => events.id, { onDelete: "cascade" }),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    squareCheckoutId: varchar("square_checkout_id", { length: 255 }).notNull(),
    squarePaymentLinkUrl: varchar("square_payment_link_url", { length: 2048 }).notNull(),
    squareOrderId: varchar("square_order_id", { length: 255 }),
    squarePaymentId: varchar("square_payment_id", { length: 255 }),
    status: varchar("status", { length: 50 }).notNull().default("pending"),
    amountCents: integer("amount_cents").notNull(),
    currency: varchar("currency", { length: 10 }).notNull().default("CAD"),
    expiresAt: timestamp("expires_at"),
    metadata: jsonb("metadata"),
    createdAt: timestamp("created_at").notNull().defaultNow(),
    updatedAt: timestamp("updated_at").notNull().defaultNow(),
  },
  (table) => [
    uniqueIndex("event_payment_sessions_checkout_idx").on(table.squareCheckoutId),
    index("event_payment_sessions_payment_idx").on(table.squarePaymentId),
    index("event_payment_sessions_registration_idx").on(table.registrationId),
    index("event_payment_sessions_event_idx").on(table.eventId),
    index("event_payment_sessions_user_idx").on(table.userId),
  ],
);

/**
 * Event announcements/updates
 */
export const eventAnnouncements = pgTable("event_announcements", {
  id: uuid("id").primaryKey().defaultRandom(),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),

  eventId: uuid("event_id")
    .notNull()
    .references(() => events.id),
  authorId: text("author_id")
    .notNull()
    .references(() => user.id),

  title: varchar("title", { length: 255 }).notNull(),
  content: text("content").notNull(),

  isPinned: boolean("is_pinned").notNull().default(false),
  isPublished: boolean("is_published").notNull().default(true),

  // Who should see this
  visibility: varchar("visibility", { length: 50 }).notNull().default("all"), // all, registered, organizers
});

// Relations
export const eventsRelations = relations(events, ({ one, many }) => ({
  organizer: one(user, {
    fields: [events.organizerId],
    references: [user.id],
  }),
  registrations: many(eventRegistrations),
  paymentSessions: many(eventPaymentSessions),
  announcements: many(eventAnnouncements),
}));

export const eventRegistrationsRelations = relations(
  eventRegistrations,
  ({ one, many }) => ({
    event: one(events, {
      fields: [eventRegistrations.eventId],
      references: [events.id],
    }),
    team: one(teams, {
      fields: [eventRegistrations.teamId],
      references: [teams.id],
    }),
    user: one(user, {
      fields: [eventRegistrations.userId],
      references: [user.id],
    }),
    paymentSessions: many(eventPaymentSessions),
  }),
);

export const eventAnnouncementsRelations = relations(eventAnnouncements, ({ one }) => ({
  event: one(events, {
    fields: [eventAnnouncements.eventId],
    references: [events.id],
  }),
  author: one(user, {
    fields: [eventAnnouncements.authorId],
    references: [user.id],
  }),
}));

export const eventPaymentSessionsRelations = relations(
  eventPaymentSessions,
  ({ one }) => ({
    event: one(events, {
      fields: [eventPaymentSessions.eventId],
      references: [events.id],
    }),
    registration: one(eventRegistrations, {
      fields: [eventPaymentSessions.registrationId],
      references: [eventRegistrations.id],
    }),
    user: one(user, {
      fields: [eventPaymentSessions.userId],
      references: [user.id],
    }),
  }),
);

// Zod schemas
export const insertEventSchema = createInsertSchema(events);
export const selectEventSchema = createSelectSchema(events);
export const insertEventRegistrationSchema = createInsertSchema(eventRegistrations);
export const selectEventRegistrationSchema = createSelectSchema(eventRegistrations);
export const insertEventAnnouncementSchema = createInsertSchema(eventAnnouncements);
export const selectEventAnnouncementSchema = createSelectSchema(eventAnnouncements);
export const insertEventPaymentSessionSchema = createInsertSchema(eventPaymentSessions);
export const selectEventPaymentSessionSchema = createSelectSchema(eventPaymentSessions);

// Inferred types
export type EventPaymentSession = typeof eventPaymentSessions.$inferSelect;
export type NewEventPaymentSession = typeof eventPaymentSessions.$inferInsert;

// Custom validation schemas
export const baseCreateEventSchema = z.object({
  name: z.string().min(3).max(255),
  slug: z
    .string()
    .min(3)
    .max(255)
    .regex(/^[a-z0-9-]+$/, "Slug must be lowercase with hyphens only"),
  description: z.string().optional(),
  shortDescription: z.string().max(500).optional(),
  type: z.enum(["tournament", "league", "camp", "clinic", "social", "other"]),
  venueName: z.string().optional(),
  venueAddress: z.string().optional(),
  city: z.string().optional(),
  province: z.string().optional(),
  postalCode: z.string().optional(),
  startDate: z.string(), // Will be converted to Date
  endDate: z.string(), // Will be converted to Date
  registrationType: z.enum(["team", "individual", "both"]),
  maxTeams: z.int().positive().optional(),
  maxParticipants: z.int().positive().optional(),
  teamRegistrationFee: z.int().min(0).optional(),
  individualRegistrationFee: z.int().min(0).optional(),
  contactEmail: z.email().optional(),
  contactPhone: z.string().optional(),
  allowWaitlist: z.boolean().optional(),
  requireMembership: z.boolean().optional(),
  allowEtransfer: z.boolean().optional(),
  etransferRecipient: z
    .email("Enter a valid e-transfer email")
    .optional()
    .or(z.literal("")),
  etransferInstructions: z.string().max(2000).optional(),
});

export const createEventInputSchema = baseCreateEventSchema.superRefine((values, ctx) => {
  if (values.allowEtransfer) {
    const recipient = values.etransferRecipient?.trim() ?? "";
    if (!recipient) {
      ctx.addIssue({
        path: ["etransferRecipient"],
        code: "custom",
        message: "E-transfer recipient email is required when e-transfer is enabled",
      });
    }
  }
});

export type Event = typeof events.$inferSelect;
export type NewEvent = typeof events.$inferInsert;
export type EventRegistration = typeof eventRegistrations.$inferSelect;
export type NewEventRegistration = typeof eventRegistrations.$inferInsert;
export type EventAnnouncement = typeof eventAnnouncements.$inferSelect;
export type NewEventAnnouncement = typeof eventAnnouncements.$inferInsert;
</file>

<file path="src/features/auth/auth.schemas.ts">
import { z } from "zod";

/**
 * Login form validation schema
 */
export const loginFormSchema = z.object({
  email: z.email("Please enter a valid email").min(1, "Email is required"),
  password: z.string().min(1, "Password is required"),
});

export type LoginFormData = z.infer<typeof loginFormSchema>;

/**
 * Base signup form field schemas
 */
export const signupFormFieldSchemas = {
  name: z
    .string()
    .min(1, "Name is required")
    .min(2, "Name must be at least 2 characters"),
  email: z.email("Please enter a valid email").min(1, "Email is required"),
  password: z
    .string()
    .min(1, "Password is required")
    .min(8, "Password must be at least 8 characters"),
  confirmPassword: z.string().min(1, "Please confirm your password"),
};

/**
 * Signup form field validators for TanStack Form
 */
export const signupFormFields = {
  name: ({ value }: { value: string }) => {
    try {
      signupFormFieldSchemas.name.parse(value);
      return undefined;
    } catch (error) {
      if (error instanceof z.ZodError) {
        return error.issues[0]?.message || "Invalid name";
      }
      return "Invalid name";
    }
  },
  email: ({ value }: { value: string }) => {
    try {
      signupFormFieldSchemas.email.parse(value);
      return undefined;
    } catch (error) {
      if (error instanceof z.ZodError) {
        return error.issues[0]?.message || "Invalid email";
      }
      return "Invalid email";
    }
  },
  password: ({ value }: { value: string }) => {
    try {
      signupFormFieldSchemas.password.parse(value);
      return undefined;
    } catch (error) {
      if (error instanceof z.ZodError) {
        return error.issues[0]?.message || "Invalid password";
      }
      return "Invalid password";
    }
  },
  confirmPassword: ({ value }: { value: string }) => {
    try {
      signupFormFieldSchemas.confirmPassword.parse(value);
      return undefined;
    } catch (error) {
      if (error instanceof z.ZodError) {
        return error.issues[0]?.message || "Please confirm your password";
      }
      return "Please confirm your password";
    }
  },
};

/**
 * Signup form validation schema
 */
export const signupFormSchema = z
  .object(signupFormFieldSchemas)
  .refine((data) => data.password === data.confirmPassword, {
    path: ["confirmPassword"],
    error: "Passwords do not match",
  });

export type SignupFormData = z.infer<typeof signupFormSchema>;
</file>

<file path="src/features/membership/membership.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { zod$ } from "~/lib/server/fn-utils";
import { getMembershipTypeSchema } from "./membership.schemas";
import type {
  MembershipOperationResult,
  MembershipStatus,
  UserMembership,
} from "./membership.types";

/**
 * List all active membership types available for purchase
 */
export const listMembershipTypes = createServerFn({ method: "GET" }).handler(
  async (): Promise<
    MembershipOperationResult<import("./membership.types").MembershipType[]>
  > => {
    try {
      // Import server-only modules inside the handler
      const { getDb } = await import("~/db/server-helpers");

      // Import database dependencies inside handler
      const { eq } = await import("drizzle-orm");
      const { membershipTypes } = await import("~/db/schema");

      const db = await getDb();

      const activeTypes = await db
        .select()
        .from(membershipTypes)
        .where(eq(membershipTypes.status, "active"))
        .orderBy(membershipTypes.priceCents);

      return {
        success: true,
        data: activeTypes,
      };
    } catch (error) {
      console.error("Error fetching membership types:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to fetch membership types",
          },
        ],
      };
    }
  },
);

/**
 * Get a specific membership type by ID
 */
export const getMembershipType = createServerFn({ method: "GET" })
  .inputValidator(zod$(getMembershipTypeSchema))
  .handler(
    async ({
      data,
    }): Promise<
      MembershipOperationResult<import("./membership.types").MembershipType>
    > => {
      try {
        // Import server-only modules inside the handler
        const { getDb } = await import("~/db/server-helpers");

        // Import database dependencies inside handler
        const { eq } = await import("drizzle-orm");
        const { membershipTypes } = await import("~/db/schema");

        const db = await getDb();

        const [membershipType] = await db
          .select()
          .from(membershipTypes)
          .where(eq(membershipTypes.id, data.membershipTypeId))
          .limit(1);

        if (!membershipType) {
          return {
            success: false,
            errors: [
              {
                code: "NOT_FOUND",
                message: "Membership type not found",
              },
            ],
          };
        }

        return {
          success: true,
          data: membershipType,
        };
      } catch (error) {
        console.error("Error fetching membership type:", error);
        return {
          success: false,
          errors: [
            {
              code: "DATABASE_ERROR",
              message: "Failed to fetch membership type",
            },
          ],
        };
      }
    },
  );

/**
 * Get current user's membership status
 */
export const getUserMembershipStatus = createServerFn({ method: "GET" }).handler(
  async (): Promise<MembershipOperationResult<MembershipStatus>> => {
    try {
      // Import server-only modules inside the handler
      const [{ getDb }, { getAuth }] = await Promise.all([
        import("~/db/server-helpers"),
        import("~/lib/auth/server-helpers"),
      ]);

      const auth = await getAuth();
      const { getRequest } = await import("@tanstack/react-start/server");
      const { headers } = getRequest();
      const session = await auth.api.getSession({ headers });

      if (!session?.user?.id) {
        return {
          success: false,
          errors: [
            {
              code: "VALIDATION_ERROR",
              message: "User not authenticated",
            },
          ],
        };
      }

      // Import database dependencies inside handler
      const { and, eq, gte, sql } = await import("drizzle-orm");
      const { membershipTypes, memberships } = await import("~/db/schema");

      // Get active membership for the user
      const db = await getDb();

      const [currentMembership] = await db
        .select({
          membership: memberships,
          membershipType: membershipTypes,
        })
        .from(memberships)
        .innerJoin(membershipTypes, eq(memberships.membershipTypeId, membershipTypes.id))
        .where(
          and(
            eq(memberships.userId, session.user.id),
            eq(memberships.status, "active"),
            gte(memberships.endDate, sql`CURRENT_DATE`),
          ),
        )
        .orderBy(sql`${memberships.endDate} DESC`)
        .limit(1);

      if (!currentMembership) {
        return {
          success: true,
          data: {
            hasMembership: false,
          },
        };
      }

      const endDate = new Date(currentMembership.membership.endDate);
      const daysRemaining = Math.ceil(
        (endDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24),
      );

      const userMembership: UserMembership = {
        ...currentMembership.membership,
        membershipType: currentMembership.membershipType,
      };

      return {
        success: true,
        data: {
          hasMembership: true,
          currentMembership: userMembership,
          expiresAt: endDate,
          daysRemaining,
        },
      };
    } catch (error) {
      console.error("Error fetching membership status:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to fetch membership status",
          },
        ],
      };
    }
  },
);
</file>

<file path="src/features/roles/roles.mutations.ts">
import { createServerFn } from "@tanstack/react-start";
import { z } from "zod";
import { zod$ } from "~/lib/server/fn-utils";
import type { RoleAssignmentRow, RoleOperationResult } from "./roles.types";

const assignRoleSchema = z
  .object({
    userId: z.string().min(1, "User is required"),
    roleId: z.string().min(1, "Role is required"),
    teamId: z.string().min(1).optional().nullable(),
    eventId: z.string().min(1).optional().nullable(),
    notes: z.string().trim().max(500, "Notes must be 500 characters or fewer").optional(),
    expiresAt: z.iso.datetime().optional(),
  })
  .superRefine((data, ctx) => {
    if (data.teamId && data.eventId) {
      ctx.addIssue({
        code: "custom",
        message: "Choose either a team scope or an event scope—not both.",
        path: ["teamId"],
      });
    }
  });

const removeRoleSchema = z.object({
  assignmentId: z.string().min(1, "Assignment id is required"),
});

function normalizeNotes(notes?: string) {
  if (!notes) return null;
  const trimmed = notes.trim();
  return trimmed.length > 0 ? trimmed : null;
}

export const assignRoleToUser = createServerFn({ method: "POST" })
  .inputValidator(zod$(assignRoleSchema))
  .handler(async ({ data }): Promise<RoleOperationResult<RoleAssignmentRow>> => {
    try {
      const [{ getDb }, { getAuth }] = await Promise.all([
        import("~/db/server-helpers"),
        import("~/lib/auth/server-helpers"),
      ]);

      const auth = await getAuth();
      const { getRequest } = await import("@tanstack/react-start/server");
      const { headers } = getRequest();
      const session = await auth.api.getSession({ headers });

      if (!session?.user?.id) {
        return {
          success: false,
          errors: [
            {
              code: "UNAUTHORIZED",
              message: "User not authenticated",
            },
          ],
        };
      }

      const { requireAdmin, GLOBAL_ADMIN_ROLE_NAMES } = await import(
        "~/lib/auth/utils/admin-check"
      );
      await requireAdmin(session.user.id);

      const db = await getDb();
      const { roles, user, userRoles } = await import("~/db/schema");
      const { alias } = await import("drizzle-orm/pg-core");
      const { and, eq, isNull } = await import("drizzle-orm");

      const assignerUser = alias(user, "assigner_user");

      const [targetUser] = await db
        .select({ id: user.id, email: user.email, name: user.name })
        .from(user)
        .where(eq(user.id, data.userId))
        .limit(1);

      if (!targetUser) {
        return {
          success: false,
          errors: [
            {
              code: "NOT_FOUND",
              message: "User not found",
            },
          ],
        };
      }

      const [roleRecord] = await db
        .select({ id: roles.id, name: roles.name })
        .from(roles)
        .where(eq(roles.id, data.roleId))
        .limit(1);

      if (!roleRecord) {
        return {
          success: false,
          errors: [
            {
              code: "NOT_FOUND",
              message: "Role not found",
            },
          ],
        };
      }

      let teamId: string | null = data.teamId ?? null;
      let eventId: string | null = data.eventId ?? null;

      if (GLOBAL_ADMIN_ROLE_NAMES.includes(roleRecord.name)) {
        teamId = null;
        eventId = null;
      } else if (roleRecord.name === "Team Admin") {
        if (!teamId) {
          return {
            success: false,
            errors: [
              {
                code: "VALIDATION_ERROR",
                message: "Team Admin roles must be scoped to a specific team.",
              },
            ],
          };
        }
        eventId = null;
      } else if (roleRecord.name === "Event Admin") {
        if (!eventId) {
          return {
            success: false,
            errors: [
              {
                code: "VALIDATION_ERROR",
                message: "Event Admin roles must be scoped to a specific event.",
              },
            ],
          };
        }
        teamId = null;
      } else {
        teamId = teamId ?? null;
        eventId = eventId ?? null;
      }

      const expiresAt = data.expiresAt ? new Date(data.expiresAt) : null;
      if (expiresAt && Number.isNaN(expiresAt.getTime())) {
        return {
          success: false,
          errors: [
            {
              code: "VALIDATION_ERROR",
              message: "Invalid expiration date provided.",
            },
          ],
        };
      }

      const scopeConditions = [
        eq(userRoles.userId, targetUser.id),
        eq(userRoles.roleId, roleRecord.id),
        teamId ? eq(userRoles.teamId, teamId) : isNull(userRoles.teamId),
        eventId ? eq(userRoles.eventId, eventId) : isNull(userRoles.eventId),
      ];

      const [existingAssignment] = await db
        .select({ id: userRoles.id })
        .from(userRoles)
        .where(and(...scopeConditions))
        .limit(1);

      const fetchAssignment = async (assignmentId: string) => {
        const [assignment] = await db
          .select({
            id: userRoles.id,
            roleId: userRoles.roleId,
            roleName: roles.name,
            roleDescription: roles.description,
            userId: user.id,
            userName: user.name,
            userEmail: user.email,
            teamId: userRoles.teamId,
            eventId: userRoles.eventId,
            assignedBy: userRoles.assignedBy,
            assignedByName: assignerUser.name,
            assignedByEmail: assignerUser.email,
            assignedAt: userRoles.assignedAt,
            expiresAt: userRoles.expiresAt,
            notes: userRoles.notes,
          })
          .from(userRoles)
          .innerJoin(user, eq(userRoles.userId, user.id))
          .innerJoin(roles, eq(userRoles.roleId, roles.id))
          .leftJoin(assignerUser, eq(assignerUser.id, userRoles.assignedBy))
          .where(eq(userRoles.id, assignmentId))
          .limit(1);

        return assignment ?? null;
      };

      if (existingAssignment) {
        const existing = await fetchAssignment(existingAssignment.id);
        if (!existing) {
          return {
            success: false,
            errors: [
              {
                code: "DATABASE_ERROR",
                message: "Existing role assignment could not be loaded.",
              },
            ],
          };
        }

        return {
          success: true,
          data: existing,
        };
      }

      const [inserted] = await db
        .insert(userRoles)
        .values({
          userId: targetUser.id,
          roleId: roleRecord.id,
          teamId,
          eventId,
          assignedBy: session.user.id,
          notes: normalizeNotes(data.notes),
          expiresAt,
        })
        .returning();

      const created = await fetchAssignment(inserted.id);
      if (!created) {
        return {
          success: false,
          errors: [
            {
              code: "DATABASE_ERROR",
              message: "Role assignment was created but could not be loaded.",
            },
          ],
        };
      }

      return {
        success: true,
        data: created,
      };
    } catch (error) {
      console.error("Error assigning role:", error);

      if (error instanceof Error && error.message.includes("Admin access required")) {
        return {
          success: false,
          errors: [
            {
              code: "UNAUTHORIZED",
              message: "Admin access required",
            },
          ],
        };
      }

      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to assign role",
          },
        ],
      };
    }
  });

export const removeRoleAssignment = createServerFn({ method: "POST" })
  .inputValidator(zod$(removeRoleSchema))
  .handler(async ({ data }): Promise<RoleOperationResult<RoleAssignmentRow>> => {
    try {
      const [{ getDb }, { getAuth }] = await Promise.all([
        import("~/db/server-helpers"),
        import("~/lib/auth/server-helpers"),
      ]);

      const auth = await getAuth();
      const { getRequest } = await import("@tanstack/react-start/server");
      const { headers } = getRequest();
      const session = await auth.api.getSession({ headers });

      if (!session?.user?.id) {
        return {
          success: false,
          errors: [
            {
              code: "UNAUTHORIZED",
              message: "User not authenticated",
            },
          ],
        };
      }

      const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
      await requireAdmin(session.user.id);

      const db = await getDb();
      const { roles, userRoles, user } = await import("~/db/schema");
      const { alias } = await import("drizzle-orm/pg-core");
      const { eq } = await import("drizzle-orm");

      const assignerUser = alias(user, "assigner_user");

      const [existingAssignment] = await db
        .select({
          id: userRoles.id,
          roleId: userRoles.roleId,
          roleName: roles.name,
          roleDescription: roles.description,
          userId: user.id,
          userName: user.name,
          userEmail: user.email,
          teamId: userRoles.teamId,
          eventId: userRoles.eventId,
          assignedBy: userRoles.assignedBy,
          assignedByName: assignerUser.name,
          assignedByEmail: assignerUser.email,
          assignedAt: userRoles.assignedAt,
          expiresAt: userRoles.expiresAt,
          notes: userRoles.notes,
        })
        .from(userRoles)
        .innerJoin(user, eq(userRoles.userId, user.id))
        .innerJoin(roles, eq(userRoles.roleId, roles.id))
        .leftJoin(assignerUser, eq(assignerUser.id, userRoles.assignedBy))
        .where(eq(userRoles.id, data.assignmentId))
        .limit(1);

      if (!existingAssignment) {
        return {
          success: false,
          errors: [
            {
              code: "NOT_FOUND",
              message: "Role assignment not found",
            },
          ],
        };
      }

      await db.delete(userRoles).where(eq(userRoles.id, data.assignmentId));

      return {
        success: true,
        data: existingAssignment,
      };
    } catch (error) {
      console.error("Error removing role assignment:", error);

      if (error instanceof Error && error.message.includes("Admin access required")) {
        return {
          success: false,
          errors: [
            {
              code: "UNAUTHORIZED",
              message: "Admin access required",
            },
          ],
        };
      }

      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to remove role assignment",
          },
        ],
      };
    }
  });
</file>

<file path="src/components/form-fields/ValidatedInput.tsx">
import React from "react";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";
import { FieldComponentProps, isFieldApi } from "~/lib/form";
import { cn } from "~/shared/lib/utils";

// Type specifically for ValidatedInput, extending the base props
interface ValidatedInputProps extends FieldComponentProps {
  type?: React.HTMLInputTypeAttribute; // Allow passing input type (text, password, email, etc.)
  maxLength?: number;
  min?: string | number;
  max?: string | number;
  step?: string | number;
  autoComplete?: string;
  autoFocus?: boolean;
  pattern?: string;
  required?: boolean;
  readOnly?: boolean;
  disabled?: boolean;
  description?: string;
  onValueChange?: (value: string, event: React.ChangeEvent<HTMLInputElement>) => void;
}

// Correctly define the component receiving props
export const ValidatedInput: React.FC<ValidatedInputProps> = (props) => {
  const {
    field,
    label,
    type = "text",
    placeholder,
    className,
    description,
    onValueChange,
    ...rest // Collect rest of props here
  } = props;

  // Ensure field is correctly passed
  if (!isFieldApi(field)) {
    console.error("ValidatedInput requires a valid field prop.", { field, props });
    return null;
  }

  const inputId = `${field.name}-input`;
  const meta = field.state.meta;

  return (
    <div className={cn("space-y-2", className)}>
      <Label htmlFor={inputId}>{label}</Label>
      <Input
        id={inputId}
        name={field.name}
        type={type}
        value={field.state.value ?? ""}
        onBlur={field.handleBlur}
        onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
          if (onValueChange) {
            onValueChange(event.target.value, event);
            return;
          }
          field.handleChange(event.target.value);
        }}
        placeholder={placeholder}
        disabled={field.form.state.isSubmitting || props.disabled}
        // Add aria-invalid for accessibility based on errors
        aria-invalid={!!meta.errors.length}
        aria-describedby={meta.errors.length ? `${inputId}-errors` : undefined}
        {...rest}
      />
      {description && <p className="text-muted-foreground text-sm">{description}</p>}
      {/* Show errors only if the field has been touched and has errors */}
      {meta.isTouched && meta.errors.length > 0 && (
        <div id={`${inputId}-errors`} className="text-destructive text-sm font-medium">
          {meta.errors.join(", ")}
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/features/roles/roles.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { z } from "zod";
import { zod$ } from "~/lib/server/fn-utils";
import type {
  RoleManagementData,
  RoleOperationResult,
  RoleUserSearchResult,
} from "./roles.types";

function escapeLike(term: string) {
  return term.replace(/\\/g, "\\\\").replace(/%/g, "\\%").replace(/_/g, "\\_");
}

const searchUsersSchema = z.object({
  query: z.string().min(2, "Enter at least 2 characters"),
  limit: z.int().positive().max(25).optional().prefault(10),
});

export const getRoleManagementData = createServerFn({ method: "GET" }).handler(
  async (): Promise<RoleOperationResult<RoleManagementData>> => {
    try {
      const [{ getDb }, { getAuth }] = await Promise.all([
        import("~/db/server-helpers"),
        import("~/lib/auth/server-helpers"),
      ]);

      const auth = await getAuth();
      const { getRequest } = await import("@tanstack/react-start/server");
      const { headers } = getRequest();
      const session = await auth.api.getSession({ headers });

      if (!session?.user?.id) {
        return {
          success: false,
          errors: [
            {
              code: "UNAUTHORIZED",
              message: "User not authenticated",
            },
          ],
        };
      }

      const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
      await requireAdmin(session.user.id);

      const db = await getDb();
      const { roles, userRoles, user } = await import("~/db/schema");
      const { asc, desc, sql, eq } = await import("drizzle-orm");
      const { alias } = await import("drizzle-orm/pg-core");

      const roleSummaries = await db
        .select({
          id: roles.id,
          name: roles.name,
          description: roles.description,
          permissions: roles.permissions,
          createdAt: roles.createdAt,
          updatedAt: roles.updatedAt,
          assignmentCount: sql<number>`count(${userRoles.id})`,
        })
        .from(roles)
        .leftJoin(userRoles, eq(userRoles.roleId, roles.id))
        .groupBy(
          roles.id,
          roles.name,
          roles.description,
          roles.permissions,
          roles.createdAt,
          roles.updatedAt,
        )
        .orderBy(asc(roles.name));

      const assignerUser = alias(user, "assigner_user");

      const assignments = await db
        .select({
          id: userRoles.id,
          roleId: userRoles.roleId,
          roleName: roles.name,
          roleDescription: roles.description,
          userId: user.id,
          userName: user.name,
          userEmail: user.email,
          teamId: userRoles.teamId,
          eventId: userRoles.eventId,
          assignedBy: userRoles.assignedBy,
          assignedByName: assignerUser.name,
          assignedByEmail: assignerUser.email,
          assignedAt: userRoles.assignedAt,
          expiresAt: userRoles.expiresAt,
          notes: userRoles.notes,
        })
        .from(userRoles)
        .innerJoin(user, eq(userRoles.userId, user.id))
        .innerJoin(roles, eq(userRoles.roleId, roles.id))
        .leftJoin(assignerUser, eq(assignerUser.id, userRoles.assignedBy))
        .orderBy(desc(userRoles.assignedAt));

      return {
        success: true,
        data: {
          roles: roleSummaries,
          assignments,
        },
      };
    } catch (error) {
      console.error("Error loading role management data:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to load role management data",
          },
        ],
      };
    }
  },
);

export const searchRoleEligibleUsers = createServerFn({ method: "GET" })
  .inputValidator(zod$(searchUsersSchema))
  .handler(async ({ data }): Promise<RoleOperationResult<RoleUserSearchResult[]>> => {
    try {
      const [{ getDb }, { getAuth }] = await Promise.all([
        import("~/db/server-helpers"),
        import("~/lib/auth/server-helpers"),
      ]);

      const auth = await getAuth();
      const { getRequest } = await import("@tanstack/react-start/server");
      const { headers } = getRequest();
      const session = await auth.api.getSession({ headers });

      if (!session?.user?.id) {
        return {
          success: false,
          errors: [
            {
              code: "UNAUTHORIZED",
              message: "User not authenticated",
            },
          ],
        };
      }

      const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
      await requireAdmin(session.user.id);

      const db = await getDb();
      const { user, userRoles, roles } = await import("~/db/schema");
      const { asc, ilike, or, sql, eq } = await import("drizzle-orm");

      const searchTerm = `%${escapeLike(data.query.trim())}%`;

      const matches = await db
        .select({
          id: user.id,
          name: user.name,
          email: user.email,
          roleNames: sql<string[]>`array_remove(array_agg(${roles.name}), NULL)`,
        })
        .from(user)
        .leftJoin(userRoles, eq(userRoles.userId, user.id))
        .leftJoin(roles, eq(userRoles.roleId, roles.id))
        .where(or(ilike(user.email, searchTerm), ilike(user.name, searchTerm)))
        .groupBy(user.id)
        .orderBy(asc(user.name))
        .limit(data.limit);

      const results: RoleUserSearchResult[] = matches.map((match) => ({
        id: match.id,
        name: match.name,
        email: match.email,
        roleNames: Array.isArray(match.roleNames) ? match.roleNames : [],
      }));

      return {
        success: true,
        data: results,
      };
    } catch (error) {
      console.error("Error searching users for roles:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to search users",
          },
        ],
      };
    }
  });
</file>

<file path="src/features/teams/teams.schemas.ts">
import { z } from "zod";

// Query schemas
export const getTeamSchema = z.object({
  teamId: z.string(),
});
export type GetTeamInput = z.infer<typeof getTeamSchema>;

export const getTeamBySlugSchema = z.object({
  slug: z.string(),
});
export type GetTeamBySlugInput = z.infer<typeof getTeamBySlugSchema>;

const listTeamsInputSchema = z.object({
  includeInactive: z.boolean().optional().prefault(false),
});

export const listTeamsSchema = listTeamsInputSchema
  .nullish()
  .transform((value) => value ?? { includeInactive: false });
export type ListTeamsInput = z.infer<typeof listTeamsSchema>;

export const getTeamMembersSchema = z.object({
  teamId: z.string(),
  includeInactive: z.boolean().optional(),
});
export type GetTeamMembersInput = z.infer<typeof getTeamMembersSchema>;

export const isTeamMemberSchema = z.object({
  teamId: z.string(),
  userId: z.string(),
});
export type IsTeamMemberInput = z.infer<typeof isTeamMemberSchema>;

export const searchTeamsSchema = z.object({
  query: z.string().trim().min(1),
});
export type SearchTeamsInput = z.infer<typeof searchTeamsSchema>;

// Mutation schemas
export const createTeamSchema = z.object({
  name: z.string().min(1, "Team name is required"),
  slug: z
    .string()
    .min(1, "A unique URL slug is required")
    .regex(
      /^[a-z0-9-]+$/,
      "Slug can only contain lowercase letters, numbers, and hyphens",
    ),
  description: z.string().optional(),
  city: z.string().optional(),
  province: z.string().optional(),
  primaryColor: z
    .string()
    .regex(/^#[0-9A-Fa-f]{6}$/)
    .optional(),
  secondaryColor: z
    .string()
    .regex(/^#[0-9A-Fa-f]{6}$/)
    .optional(),
  foundedYear: z.string().length(4).optional(),
  website: z.url().optional(),
  socialLinks: z.record(z.string(), z.string()).optional(),
});
export type CreateTeamInput = z.infer<typeof createTeamSchema>;

export const updateTeamSchema = z.object({
  teamId: z.string(),
  data: createTeamSchema.partial(),
});
export type UpdateTeamInput = z.infer<typeof updateTeamSchema>;

export const addTeamMemberSchema = z.object({
  teamId: z.string(),
  email: z.email("Please enter a valid email address"),
  role: z.enum(["captain", "coach", "player", "substitute"]),
  jerseyNumber: z.string().optional(),
  position: z.string().optional(),
});
export type AddTeamMemberInput = z.infer<typeof addTeamMemberSchema>;

export const updateTeamMemberSchema = z.object({
  teamId: z.string(),
  memberId: z.string(),
  role: z.enum(["captain", "coach", "player", "substitute"]).optional(),
  jerseyNumber: z.string().optional(),
  position: z.string().optional(),
  notes: z.string().optional(),
});
export type UpdateTeamMemberInput = z.infer<typeof updateTeamMemberSchema>;

export const removeTeamMemberSchema = z.object({
  teamId: z.string(),
  memberId: z.string(),
});
export type RemoveTeamMemberInput = z.infer<typeof removeTeamMemberSchema>;

export const teamInviteActionSchema = z.object({
  teamId: z.string(),
});
export type TeamInviteActionInput = z.infer<typeof teamInviteActionSchema>;

export const requestTeamMembershipSchema = z.object({
  teamId: z.string(),
});
export type RequestTeamMembershipInput = z.infer<typeof requestTeamMembershipSchema>;
</file>

<file path="src/features/events/events.types.ts">
import type { z } from "zod";
import type { Event, EventRegistration } from "~/db/schema";
import type { createEventInputSchema } from "~/db/schema/events.schema";
import type {
  EventAmenities,
  EventDivisions,
  EventMetadata,
  EventPaymentMetadata,
  EventRegistrationRoster,
  EventRequirements,
  EventRules,
  EventSchedule,
} from "./events.db-types";

// Input types
export type CreateEventInput = z.infer<typeof createEventInputSchema>;

export type UpdateEventInput = Partial<CreateEventInput> & {
  status?: EventStatus;
};

export type EventFilters = {
  status?: Event["status"] | Event["status"][];
  type?: Event["type"] | Event["type"][];
  organizerId?: string;
  startDateFrom?: Date;
  startDateTo?: Date;
  city?: string;
  province?: string;
};

export type EventRegistrationInput = {
  eventId: string;
  teamId?: string;
  division?: string;
  notes?: string;
  roster?: {
    userId: string;
    role: string;
  }[];
};

// Response types
export interface EventWithDetails
  extends Omit<
    Event,
    "rules" | "schedule" | "divisions" | "amenities" | "requirements" | "metadata"
  > {
  rules: EventRules;
  schedule: EventSchedule;
  divisions: EventDivisions;
  amenities: EventAmenities;
  requirements: EventRequirements;
  metadata: EventMetadata;
  organizer: {
    id: string;
    name: string;
    email: string;
  };
  registrationCount: number;
  isRegistrationOpen: boolean;
  availableSpots: number | undefined;
}

export interface EventRegistrationWithDetails
  extends Omit<EventRegistration, "roster" | "paymentMetadata"> {
  roster: EventRegistrationRoster;
  paymentMetadata: EventPaymentMetadata | null;
  event: EventWithDetails;
  team?: {
    id: string;
    name: string;
    slug: string;
  };
  user: {
    id: string;
    name: string;
    email: string;
  };
}

export type EventPaymentMethod = EventRegistration["paymentMethod"];
export type EventPaymentStatus = EventRegistration["paymentStatus"];

export type EventRegistrationPaymentInfo =
  | {
      method: "square";
      checkoutUrl: string;
      sessionId: string;
    }
  | {
      method: "etransfer";
      instructions?: string | null;
      recipient?: string | null;
    }
  | {
      method: "free";
    };

export interface EventRegistrationResultPayload {
  registration: EventRegistrationWithDetails;
  payment?: EventRegistrationPaymentInfo;
}

export type CancelEventErrorCode =
  | "REFUND_FAILED"
  | "NO_PAYMENT_SESSION"
  | "NOT_PAID"
  | "UNAUTHORIZED";

export interface CancelEventResult {
  eventId: string;
  affected: {
    totalRegistrations: number;
    cancelled: number;
    alreadyCancelled: number;
    squareRefunded: number;
    etransferMarkedForRefund: number;
    freeOrUnpaid: number;
  };
  errors: Array<{
    registrationId: string;
    code: CancelEventErrorCode;
    message: string;
    paymentId?: string;
  }>;
}

// Operation result types
export type EventOperationResult<T = Event> =
  | { success: true; data: T }
  | { success: false; errors: EventError[] };

export type EventError = {
  code: EventErrorCode;
  message: string;
  field?: string;
};

export type EventErrorCode =
  | "VALIDATION_ERROR"
  | "NOT_FOUND"
  | "DUPLICATE_SLUG"
  | "UNAUTHORIZED"
  | "FORBIDDEN"
  | "REGISTRATION_CLOSED"
  | "EVENT_FULL"
  | "ALREADY_REGISTERED"
  | "INVALID_DATES"
  | "DATABASE_ERROR";

// Utility types
export type EventStatus = Event["status"];
export type EventType = Event["type"];
export type RegistrationType = Event["registrationType"];

// Pagination
export type EventListResult = {
  events: EventWithDetails[];
  totalCount: number;
  pageInfo: {
    currentPage: number;
    pageSize: number;
    totalPages: number;
    hasNextPage: boolean;
    hasPreviousPage: boolean;
  };
};
</file>

<file path="src/lib/auth/server-helpers.ts">
/**
 * Server-only auth helpers
 * This module contains auth configuration that requires server-side environment variables
 */
import { APIError, betterAuth } from "better-auth";
import { drizzleAdapter } from "better-auth/adapters/drizzle";
import { tanstackStartCookies } from "better-auth/tanstack-start";

// Lazy-loaded auth instance
let authInstance: ReturnType<typeof betterAuth> | undefined;
let authInitPromise: Promise<ReturnType<typeof betterAuth>> | undefined;

const assertServerOnly = () => {
  if (typeof window !== "undefined") {
    throw new Error("Auth helpers can only be used on the server.");
  }
};

// Create and export the auth instance with server configuration
const createAuth = async (): Promise<ReturnType<typeof betterAuth>> => {
  assertServerOnly();
  // Import server modules when auth is created
  const { db } = await import("~/db");
  const schema = await import("~/db/schema");
  const { env, getAuthSecret, getBaseUrl, isProduction } = await import(
    "~/lib/env.server"
  );

  const baseUrl = getBaseUrl();
  const isHttpsDeployment = baseUrl?.startsWith("https://") ?? false;
  const cookieDomain = env.COOKIE_DOMAIN;
  const allowedOAuthDomains = Array.isArray(env.OAUTH_ALLOWED_DOMAINS)
    ? env.OAUTH_ALLOWED_DOMAINS
    : [];
  const googleClientId = env.GOOGLE_CLIENT_ID || "";
  const googleClientSecret = env.GOOGLE_CLIENT_SECRET || "";

  if (process.env["NODE_ENV"] !== "production") {
    console.log("Auth config loading...");
    console.log("Base URL:", baseUrl);

    console.log(
      "Google Client ID:",
      googleClientId ? `Set (${googleClientId.substring(0, 10)}...)` : "Missing",
    );
    console.log("Google Client Secret:", googleClientSecret ? "Set" : "Missing");
    if (allowedOAuthDomains.length > 0) {
      console.log("OAuth allowed domains:", allowedOAuthDomains.join(", "));
    }
  }

  // Get database connection
  const dbConnection = await db();

  return betterAuth({
    baseURL: baseUrl,
    secret: getAuthSecret(),
    trustedOrigins: isProduction()
      ? [baseUrl]
      : [
          baseUrl,
          "http://localhost:5173",
          "http://localhost:5174",
          "http://localhost:8888",
        ],
    database: drizzleAdapter(dbConnection, {
      provider: "pg",
      schema: {
        user: schema.user,
        session: schema.session,
        account: schema.account,
        verification: schema.verification,
      },
    }),

    // Session configuration with security settings
    session: {
      expiresIn: 60 * 60 * 24 * 30, // 30 days
      updateAge: 60 * 60 * 24, // 1 day
      // NOTE: cookieCache is disabled due to a known bug with tanstackStartCookies
      // that prevents session_token cookie from being set. See:
      // https://github.com/better-auth/better-auth/issues/5639
      // Re-enable once the upstream fix is released.
    },

    // Secure cookie configuration
    advanced: {
      cookiePrefix: "solstice",
      useSecureCookies: isHttpsDeployment,
      defaultCookieAttributes: cookieDomain
        ? {
            secure: isHttpsDeployment,
            sameSite: "lax",
            httpOnly: true,
            path: "/",
            domain: cookieDomain,
          }
        : {
            secure: isHttpsDeployment,
            sameSite: "lax",
            httpOnly: true,
            path: "/",
          },
    },

    // OAuth providers configuration
    socialProviders: {
      google: {
        clientId: googleClientId,
        clientSecret: googleClientSecret,
        ...(allowedOAuthDomains.length > 0
          ? {
              mapProfileToUser: (profile: {
                email?: string | null | undefined;
                hd?: string | undefined;
              }) => {
                const email = profile.email?.toLowerCase();
                const domain = email?.split("@")[1];
                const hostedDomain = profile.hd?.toLowerCase();

                const isAllowed = [domain, hostedDomain]
                  .filter((value): value is string => Boolean(value))
                  .some((value) => allowedOAuthDomains.includes(value));

                if (!isAllowed) {
                  const allowedList =
                    allowedOAuthDomains.length === 1
                      ? allowedOAuthDomains[0]
                      : allowedOAuthDomains.join(", ");
                  throw new APIError("UNAUTHORIZED", {
                    message: `Access restricted. Please sign in with an approved domain (${allowedList}).`,
                  });
                }

                return {};
              },
            }
          : {}),
      },
    },

    // Email and password authentication
    emailAndPassword: {
      enabled: true,
      requireEmailVerification: isProduction(),
    },

    // Account linking configuration
    account: {
      accountLinking: {
        enabled: true,
        trustedProviders: ["google"], // Auto-link these providers
      },
    },

    // https://www.better-auth.com/docs/integrations/tanstack#usage-tips
    plugins: [tanstackStartCookies()], // MUST be the last plugin
  });
};

// Export auth as a getter that creates instance on first use
export const auth = new Proxy({} as ReturnType<typeof betterAuth>, {
  get(target, prop) {
    if (!authInstance) {
      throw new Error("Auth must be initialized asynchronously. Use getAuth() instead.");
    }
    return authInstance[prop as keyof typeof authInstance];
  },
});

// Export async getter for auth
export const getAuth = async (): Promise<ReturnType<typeof betterAuth>> => {
  assertServerOnly();

  if (authInstance) {
    return authInstance;
  }

  if (!authInitPromise) {
    authInitPromise = createAuth().then((instance) => {
      authInstance = instance;
      return instance;
    });
  }

  return authInitPromise;
};
</file>

<file path="src/features/events/events.schemas.ts">
import { z } from "zod";
import { baseCreateEventSchema, createEventInputSchema } from "~/db/schema/events.schema";

// Query schemas
export const listEventsSchema = z
  .object({
    filters: z
      .object({
        status: z.union([z.string(), z.array(z.string())]).optional(),
        type: z.union([z.string(), z.array(z.string())]).optional(),
        organizerId: z.string().optional(),
        startDateFrom: z.date().optional(),
        startDateTo: z.date().optional(),
        city: z.string().optional(),
        province: z.string().optional(),
      })
      .optional(),
    page: z.int().positive().optional(),
    pageSize: z.int().positive().optional(),
    sortBy: z.enum(["startDate", "createdAt", "name"]).optional(),
    sortOrder: z.enum(["asc", "desc"]).optional(),
  })
  .optional()
  .prefault({});
export type ListEventsInput = z.infer<typeof listEventsSchema>;

export const getEventSchema = z.object({
  id: z.string().optional(),
  slug: z.string().optional(),
});
export type GetEventInput = z.infer<typeof getEventSchema>;

export const getUpcomingEventsSchema = z
  .object({
    limit: z.int().positive().max(10).optional(),
  })
  .optional()
  .prefault({});
export type GetUpcomingEventsInput = z.infer<typeof getUpcomingEventsSchema>;

export const checkEventRegistrationSchema = z.object({
  eventId: z.string(),
  // userId is now inferred from session - not passed from client
  teamId: z.string().optional(),
});
export type CheckEventRegistrationInput = z.infer<typeof checkEventRegistrationSchema>;

// Mutation schemas
export const createEventSchema = createEventInputSchema;
export type CreateEventInput = z.infer<typeof createEventSchema>;

export const updateEventSchema = z.object({
  eventId: z.string(),
  data: baseCreateEventSchema.partial().extend({
    status: z
      .enum([
        "draft",
        "published",
        "registration_open",
        "registration_closed",
        "in_progress",
        "completed",
        "cancelled",
      ])
      .optional(),
  }),
});
export type UpdateEventInput = z.infer<typeof updateEventSchema>;

const rosterPlayerSchema = z.object({
  userId: z.string(),
  role: z.string().optional(),
  name: z.string().optional(),
  jerseyNumber: z.string().optional(),
});

const rosterObjectSchema = z.looseObject({
  players: z.array(rosterPlayerSchema).optional(),
  emergencyContact: z
    .looseObject({
      name: z.string().optional(),
      phone: z.string().optional(),
      relationship: z.string().optional(),
    })
    .optional(),
});

export const registerForEventSchema = z.object({
  eventId: z.string(),
  teamId: z.string().optional(),
  division: z.string().optional(),
  notes: z.string().optional(),
  roster: z.union([z.array(rosterPlayerSchema), rosterObjectSchema]).optional(),
  paymentMethod: z.enum(["square", "etransfer"]).prefault("square"),
});
export type RegisterForEventInput = z.infer<typeof registerForEventSchema>;

export const cancelEventRegistrationSchema = z.object({
  registrationId: z.string(),
  reason: z.string().optional(),
});
export type CancelEventRegistrationInput = z.infer<typeof cancelEventRegistrationSchema>;

export const cancelEntireEventSchema = z.object({
  eventId: z.uuid(),
  reason: z.string().optional(),
  notify: z.boolean().optional().prefault(true),
  refundMode: z.enum(["auto", "manual", "none"]).optional().prefault("auto"),
});
export type CancelEntireEventInput = z.infer<typeof cancelEntireEventSchema>;

export const markEtransferPaidSchema = z.object({
  registrationId: z.string(),
});

export const markEtransferReminderSchema = z.object({
  registrationId: z.string(),
});
</file>

<file path="src/features/teams/teams.mutations.ts">
import { createServerFn } from "@tanstack/react-start";
import { z } from "zod";
import type { TeamMemberRole, TeamMemberStatus } from "~/db/schema";
import { getAuthMiddleware, requireUser } from "~/lib/server/auth";
import { forbidden, notFound, validationError } from "~/lib/server/errors";
import { zod$ } from "~/lib/server/fn-utils";
import {
  addTeamMemberSchema,
  createTeamSchema,
  removeTeamMemberSchema,
  requestTeamMembershipSchema,
  teamInviteActionSchema,
  updateTeamMemberSchema,
  updateTeamSchema,
} from "./teams.schemas";

/**
 * Create a new team
 */
const ACTIVE_TEAM_MEMBERSHIP_CONSTRAINT = "team_members_active_user_idx";

const isActiveMembershipConstraintError = (error: unknown): boolean => {
  if (!error || typeof error !== "object") return false;

  const constraint =
    (error as { constraint?: string }).constraint ??
    (error as { constraint_name?: string }).constraint_name;
  const code = (error as { code?: string }).code;

  if (constraint === ACTIVE_TEAM_MEMBERSHIP_CONSTRAINT && code === "23505") {
    return true;
  }

  if ("cause" in error) {
    return isActiveMembershipConstraintError((error as { cause?: unknown }).cause);
  }

  return false;
};

export const createTeam = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(createTeamSchema))
  .handler(async ({ data, context }) => {
    // Import server-only modules inside the handler
    const [{ getDb }, { createId }] = await Promise.all([
      import("~/db/server-helpers"),
      import("@paralleldrive/cuid2"),
    ]);
    const { teams, teamMembers } = await import("~/db/schema");

    const user = requireUser(context);

    // Debug logging for E2E tests
    if (process.env["NODE_ENV"] === "development") {
      console.log("Creating team with user ID:", user.id);
    }

    const db = await getDb();

    // Start a transaction
    return await db.transaction(async (tx) => {
      // Create the team
      const [newTeam] = await tx
        .insert(teams)
        .values({
          id: createId(),
          name: data.name,
          slug: data.slug.toLowerCase().replace(/[^a-z0-9-]/g, "-"),
          description: data.description,
          city: data.city,
          province: data.province,
          primaryColor: data.primaryColor,
          secondaryColor: data.secondaryColor,
          foundedYear: data.foundedYear,
          website: data.website,
          socialLinks: data.socialLinks ? JSON.stringify(data.socialLinks) : null,
          createdBy: user.id,
        })
        .returning();

      // Add the creator as captain
      try {
        await tx.insert(teamMembers).values({
          id: createId(),
          teamId: newTeam.id,
          userId: user.id,
          role: "captain" as TeamMemberRole,
          status: "active" as TeamMemberStatus,
          invitedBy: user.id,
        });
      } catch (error) {
        if (isActiveMembershipConstraintError(error)) {
          throw validationError(
            "You already have an active team membership. Leave or deactivate your existing team before creating a new one.",
          );
        }

        throw error;
      }

      return newTeam;
    });
  });

/**
 * Update team details
 */
export const updateTeam = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(
    zod$(
      updateTeamSchema.extend({
        data: updateTeamSchema.shape.data.extend({
          socialLinks: z.record(z.string(), z.string()).optional(),
          logoUrl: z.string().optional(),
        }),
      }),
    ),
  )
  .handler(async ({ data, context }) => {
    // Import server-only modules inside the handler
    const [{ getDb }, { and, eq }] = await Promise.all([
      import("~/db/server-helpers"),
      import("drizzle-orm"),
    ]);
    const { teams, teamMembers } = await import("~/db/schema");

    const user = requireUser(context);

    const db = await getDb();

    // Check if user is captain or coach
    const [memberCheck] = await db
      .select({ role: teamMembers.role })
      .from(teamMembers)
      .where(
        and(
          eq(teamMembers.teamId, data.teamId),
          eq(teamMembers.userId, user.id),
          eq(teamMembers.status, "active"),
        ),
      )
      .limit(1);

    if (!memberCheck || !["captain", "coach"].includes(memberCheck.role)) {
      throw forbidden("Only captains or coaches can update team details");
    }

    // Update team
    const [updatedTeam] = await db
      .update(teams)
      .set({
        name: data.data.name,
        description: data.data.description,
        city: data.data.city,
        province: data.data.province,
        primaryColor: data.data.primaryColor,
        secondaryColor: data.data.secondaryColor,
        foundedYear: data.data.foundedYear,
        website: data.data.website,
        socialLinks: data.data.socialLinks
          ? JSON.stringify(data.data.socialLinks)
          : undefined,
        logoUrl: data.data.logoUrl,
      })
      .where(eq(teams.id, data.teamId))
      .returning();

    return updatedTeam;
  });

/**
 * Deactivate a team (soft delete)
 */
export const deactivateTeam = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(z.object({ teamId: z.string() })))
  .handler(async ({ data, context }) => {
    // Import server-only modules inside the handler
    const [{ getDb }, { and, eq }] = await Promise.all([
      import("~/db/server-helpers"),
      import("drizzle-orm"),
    ]);
    const { teams, teamMembers } = await import("~/db/schema");

    const user = requireUser(context);

    const db = await getDb();

    return await db.transaction(async (tx) => {
      // Check if user is captain
      const [memberCheck] = await tx
        .select({ role: teamMembers.role })
        .from(teamMembers)
        .where(
          and(
            eq(teamMembers.teamId, data.teamId),
            eq(teamMembers.userId, user.id),
            eq(teamMembers.status, "active"),
          ),
        )
        .limit(1);

      if (!memberCheck || memberCheck.role !== "captain") {
        throw forbidden("Only team captains can deactivate teams");
      }

      const now = new Date();

      await tx
        .update(teamMembers)
        .set({ status: "inactive", leftAt: now })
        .where(
          and(eq(teamMembers.teamId, data.teamId), eq(teamMembers.status, "active")),
        );

      const [deactivatedTeam] = await tx
        .update(teams)
        .set({ isActive: "false" })
        .where(eq(teams.id, data.teamId))
        .returning();

      return deactivatedTeam;
    });
  });

/**
 * Add a member to a team
 */
export const addTeamMember = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(addTeamMemberSchema))
  .handler(async ({ data, context }) => {
    // Import server-only modules inside the handler
    const [{ getDb }, { and, eq }, { createId }] = await Promise.all([
      import("~/db/server-helpers"),
      import("drizzle-orm"),
      import("@paralleldrive/cuid2"),
    ]);
    const { teamMembers, teams, user } = await import("~/db/schema");

    const currentUser = requireUser(context);

    const db = await getDb();

    // Check if current user has permission to add members
    const [memberCheck] = await db
      .select({ role: teamMembers.role })
      .from(teamMembers)
      .where(
        and(
          eq(teamMembers.teamId, data.teamId),
          eq(teamMembers.userId, currentUser.id),
          eq(teamMembers.status, "active"),
        ),
      )
      .limit(1);

    if (!memberCheck || !["captain", "coach"].includes(memberCheck.role)) {
      throw forbidden("Only captains and coaches can add team members");
    }

    // Find user by email
    const [targetUser] = await db
      .select({ id: user.id, email: user.email, name: user.name })
      .from(user)
      .where(eq(user.email, data.email))
      .limit(1);

    if (!targetUser) {
      throw notFound("User not found with that email address");
    }

    // Check if user is already a member
    const [existingMember] = await db
      .select({ status: teamMembers.status })
      .from(teamMembers)
      .where(
        and(eq(teamMembers.teamId, data.teamId), eq(teamMembers.userId, targetUser.id)),
      )
      .limit(1);

    if (existingMember) {
      if (existingMember.status === "active") {
        throw validationError("User is already an active member of this team");
      }
      // Reactivate if they were previously removed
      const [reactivated] = await db
        .update(teamMembers)
        .set({
          status: "pending" as TeamMemberStatus,
          invitedBy: currentUser.id,
          role: data.role,
          jerseyNumber: data.jerseyNumber,
          position: data.position,
          leftAt: null,
          invitedAt: new Date(),
          invitationReminderCount: 0,
          lastInvitationReminderAt: null,
          requestedAt: null,
        })
        .where(
          and(eq(teamMembers.teamId, data.teamId), eq(teamMembers.userId, targetUser.id)),
        )
        .returning();
      return reactivated;
    }

    // Add new member
    const [newMember] = await db
      .insert(teamMembers)
      .values({
        id: createId(),
        teamId: data.teamId,
        userId: targetUser.id,
        role: data.role,
        status: "pending" as TeamMemberStatus,
        jerseyNumber: data.jerseyNumber,
        position: data.position,
        invitedBy: currentUser.id,
        invitedAt: new Date(),
        invitationReminderCount: 0,
        lastInvitationReminderAt: null,
        requestedAt: null,
      })
      .returning();

    // Send invitation email in the background; failure shouldn't block flow
    const { sendTeamInvitationEmail } = await import("~/lib/email/sendgrid");
    if (targetUser?.email) {
      try {
        const [teamInfo] = await db
          .select({ name: teams.name, slug: teams.slug })
          .from(teams)
          .where(eq(teams.id, data.teamId))
          .limit(1);

        await sendTeamInvitationEmail({
          to: {
            email: targetUser.email,
            name: targetUser.name ?? undefined,
          },
          teamName: teamInfo?.name ?? "Quadball Canada Team",
          teamSlug: teamInfo?.slug ?? data.teamId,
          role: data.role,
          invitedByName: currentUser.name ?? undefined,
          invitedByEmail: currentUser.email ?? undefined,
        });
      } catch (error) {
        console.error("Failed to send team invitation email", error);
      }
    }

    return newMember;
  });

/**
 * Update team member details
 */
export const updateTeamMember = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(updateTeamMemberSchema))
  .handler(async ({ data, context }) => {
    // Import server-only modules inside the handler
    const [{ getDb }, { and, eq, sql }] = await Promise.all([
      import("~/db/server-helpers"),
      import("drizzle-orm"),
    ]);
    const { teamMembers } = await import("~/db/schema");

    const currentUser = requireUser(context);

    const db = await getDb();

    // Check if current user has permission
    const [memberCheck] = await db
      .select({ role: teamMembers.role })
      .from(teamMembers)
      .where(
        and(
          eq(teamMembers.teamId, data.teamId),
          eq(teamMembers.userId, currentUser.id),
          eq(teamMembers.status, "active"),
        ),
      )
      .limit(1);

    if (!memberCheck || !["captain", "coach"].includes(memberCheck.role)) {
      throw forbidden("Only captains and coaches can update team members");
    }

    // Don't allow demoting the last captain
    if (data.role && data.role !== "captain") {
      const [targetMember] = await db
        .select({ role: teamMembers.role })
        .from(teamMembers)
        .where(eq(teamMembers.id, data.memberId))
        .limit(1);

      if (targetMember?.role === "captain") {
        const [captainCount] = await db
          .select({ count: sql<number>`count(*)::int` })
          .from(teamMembers)
          .where(
            and(
              eq(teamMembers.teamId, data.teamId),
              eq(teamMembers.role, "captain"),
              eq(teamMembers.status, "active"),
            ),
          );
        const totalCaptains = captainCount?.count ?? 0;
        if (totalCaptains <= 1) {
          throw validationError("Cannot demote the last captain");
        }
      }
    }

    // Update member
    const [updatedMember] = await db
      .update(teamMembers)
      .set({
        role: data.role,
        jerseyNumber: data.jerseyNumber,
        position: data.position,
        notes: data.notes,
      })
      .where(eq(teamMembers.id, data.memberId))
      .returning();

    return updatedMember;
  });

/**
 * Remove a member from team
 */
export const removeTeamMember = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(removeTeamMemberSchema))
  .handler(async ({ data, context }) => {
    // Import server-only modules inside the handler
    const [{ getDb }, { and, eq, sql }] = await Promise.all([
      import("~/db/server-helpers"),
      import("drizzle-orm"),
    ]);
    const { teamMembers } = await import("~/db/schema");

    const currentUser = requireUser(context);

    const db = await getDb();

    // Check if current user has permission
    const [memberCheck] = await db
      .select({ role: teamMembers.role })
      .from(teamMembers)
      .where(
        and(
          eq(teamMembers.teamId, data.teamId),
          eq(teamMembers.userId, currentUser.id),
          eq(teamMembers.status, "active"),
        ),
      )
      .limit(1);

    if (!memberCheck || !["captain", "coach"].includes(memberCheck.role)) {
      throw forbidden("Only captains and coaches can remove team members");
    }

    // Don't allow removing the last captain
    const [targetMember] = await db
      .select({ role: teamMembers.role })
      .from(teamMembers)
      .where(eq(teamMembers.id, data.memberId))
      .limit(1);

    if (targetMember?.role === "captain") {
      const [captainCount] = await db
        .select({ count: sql<number>`count(*)::int` })
        .from(teamMembers)
        .where(
          and(
            eq(teamMembers.teamId, data.teamId),
            eq(teamMembers.role, "captain"),
            eq(teamMembers.status, "active"),
          ),
        );
      const totalCaptains = captainCount?.count ?? 0;
      if (totalCaptains <= 1) {
        throw validationError("Cannot remove the last captain");
      }
    }

    // Soft delete by updating status
    const [removedMember] = await db
      .update(teamMembers)
      .set({
        status: "inactive" as TeamMemberStatus,
        leftAt: new Date(),
      })
      .where(eq(teamMembers.id, data.memberId))
      .returning();

    return removedMember;
  });

/**
 * Accept a team invite
 */
export const acceptTeamInvite = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(teamInviteActionSchema))
  .handler(async ({ data, context }) => {
    // Import server-only modules inside the handler
    const [{ getDb }, { and, eq }] = await Promise.all([
      import("~/db/server-helpers"),
      import("drizzle-orm"),
    ]);
    const { teamMembers } = await import("~/db/schema");

    const currentUser = requireUser(context);

    const db = await getDb();

    // Update membership status
    const [updatedMember] = await db
      .update(teamMembers)
      .set({
        status: "active" as TeamMemberStatus,
        joinedAt: new Date(),
        requestedAt: null,
      })
      .where(
        and(
          eq(teamMembers.teamId, data.teamId),
          eq(teamMembers.userId, currentUser.id),
          eq(teamMembers.status, "pending"),
        ),
      )
      .returning();

    if (!updatedMember) {
      throw notFound("No pending invite found for this team");
    }

    return updatedMember;
  });

/**
 * Decline a team invite
 */
export const declineTeamInvite = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(teamInviteActionSchema))
  .handler(async ({ data, context }) => {
    // Import server-only modules inside the handler
    const [{ getDb }, { and, eq }] = await Promise.all([
      import("~/db/server-helpers"),
      import("drizzle-orm"),
    ]);
    const { teamMembers } = await import("~/db/schema");

    const currentUser = requireUser(context);

    const db = await getDb();

    // Update membership status
    const [declinedMember] = await db
      .update(teamMembers)
      .set({
        status: "inactive" as TeamMemberStatus,
        leftAt: new Date(),
        requestedAt: null,
      })
      .where(
        and(
          eq(teamMembers.teamId, data.teamId),
          eq(teamMembers.userId, currentUser.id),
          eq(teamMembers.status, "pending"),
        ),
      )
      .returning();

    if (!declinedMember) {
      throw notFound("No pending invite found for this team");
    }

    return declinedMember;
  });

export const requestTeamMembership = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(requestTeamMembershipSchema))
  .handler(async ({ data, context }) => {
    const [{ getDb }, { and, eq }, { createId }] = await Promise.all([
      import("~/db/server-helpers"),
      import("drizzle-orm"),
      import("@paralleldrive/cuid2"),
    ]);
    const { teamMembers } = await import("~/db/schema");

    const currentUser = requireUser(context);

    const db = await getDb();

    const [existingMember] = await db
      .select({
        id: teamMembers.id,
        status: teamMembers.status,
        invitedBy: teamMembers.invitedBy,
      })
      .from(teamMembers)
      .where(
        and(eq(teamMembers.teamId, data.teamId), eq(teamMembers.userId, currentUser.id)),
      )
      .limit(1);

    if (existingMember) {
      if (existingMember.status === "active") {
        throw validationError("You are already an active member of this team");
      }

      if (existingMember.status === "pending") {
        if (existingMember.invitedBy) {
          throw validationError("You already have a pending invitation for this team");
        }

        const [refreshedMember] = await db
          .update(teamMembers)
          .set({
            requestedAt: new Date(),
            invitationReminderCount: 0,
            lastInvitationReminderAt: null,
          })
          .where(eq(teamMembers.id, existingMember.id))
          .returning();

        return refreshedMember;
      }

      const [reactivatedMember] = await db
        .update(teamMembers)
        .set({
          status: "pending" as TeamMemberStatus,
          invitedBy: null,
          requestedAt: new Date(),
          invitedAt: null,
          invitationReminderCount: 0,
          lastInvitationReminderAt: null,
          leftAt: null,
        })
        .where(eq(teamMembers.id, existingMember.id))
        .returning();

      return reactivatedMember;
    }

    const [newRequest] = await db
      .insert(teamMembers)
      .values({
        id: createId(),
        teamId: data.teamId,
        userId: currentUser.id,
        role: "player" as TeamMemberRole,
        status: "pending" as TeamMemberStatus,
        invitedBy: null,
        requestedAt: new Date(),
        invitationReminderCount: 0,
        lastInvitationReminderAt: null,
      })
      .returning();

    return newRequest;
  });

/**
 * Leave a team voluntarily
 */
export const leaveTeam = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(z.object({ teamId: z.string() })))
  .handler(async ({ data, context }) => {
    // Import server-only modules inside the handler
    const [{ getDb }, { and, eq, sql }] = await Promise.all([
      import("~/db/server-helpers"),
      import("drizzle-orm"),
    ]);
    const { teamMembers } = await import("~/db/schema");

    const currentUser = requireUser(context);

    const db = await getDb();

    // Check membership
    const [member] = await db
      .select({ role: teamMembers.role })
      .from(teamMembers)
      .where(
        and(
          eq(teamMembers.teamId, data.teamId),
          eq(teamMembers.userId, currentUser.id),
          eq(teamMembers.status, "active"),
        ),
      )
      .limit(1);

    if (!member) {
      throw notFound("You are not an active member of this team");
    }

    // Don't allow the last captain to leave
    if (member.role === "captain") {
      const [captainCount] = await db
        .select({ count: sql<number>`count(*)::int` })
        .from(teamMembers)
        .where(
          and(
            eq(teamMembers.teamId, data.teamId),
            eq(teamMembers.role, "captain"),
            eq(teamMembers.status, "active"),
          ),
        );
      const totalCaptains = captainCount?.count ?? 0;
      if (totalCaptains <= 1) {
        throw validationError(
          "Cannot leave team as the last captain. Promote another member first.",
        );
      }
    }

    // Update membership status
    const [leftMember] = await db
      .update(teamMembers)
      .set({
        status: "inactive" as TeamMemberStatus,
        leftAt: new Date(),
      })
      .where(
        and(eq(teamMembers.teamId, data.teamId), eq(teamMembers.userId, currentUser.id)),
      )
      .returning();

    return leftMember;
  });
</file>

<file path="src/features/membership/membership.mutations.ts">
import { createServerFn } from "@tanstack/react-start";
import { and, eq, gte, sql } from "drizzle-orm";
import { membershipPaymentSessions, memberships, membershipTypes } from "~/db/schema";
import { atomicJsonbMerge } from "~/lib/db/jsonb-utils";
import { getAuthMiddleware, requireUser } from "~/lib/server/auth";
import { zod$ } from "~/lib/server/fn-utils";
import type { MembershipMetadata } from "./membership.db-types";
import {
  confirmMembershipPurchaseSchema,
  purchaseMembershipSchema,
} from "./membership.schemas";
import type {
  CheckoutSessionResult,
  Membership,
  MembershipOperationResult,
} from "./membership.types";

// Helper to cast membership jsonb fields
function castMembershipJsonbFields(
  membership: typeof memberships.$inferSelect,
): Membership {
  return {
    ...membership,
    metadata: (membership.metadata || {}) as MembershipMetadata,
  } as Membership;
}

const RETRYABLE_PAYMENT_ERROR_PATTERNS = [/pending/i, /not available/i, /processing/i];

function isRetryablePaymentError(message: string | undefined): boolean {
  if (!message) return false;
  return RETRYABLE_PAYMENT_ERROR_PATTERNS.some((pattern) => pattern.test(message));
}

async function wait(ms: number) {
  await new Promise((resolve) => setTimeout(resolve, ms));
}

const getSquarePaymentService = async () => {
  const { squarePaymentService } = await import("~/lib/payments/square");
  return squarePaymentService;
};

/**
 * Create a checkout session for membership purchase
 */
export const createCheckoutSession = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(purchaseMembershipSchema.omit({ autoRenew: true })))
  .handler(
    async ({
      data,
      context,
    }): Promise<MembershipOperationResult<CheckoutSessionResult>> => {
      try {
        // Import server-only modules inside the handler
        const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);

        const db = await getDb();
        const user = requireUser(context);

        // Verify membership type exists and is active

        const [membershipType] = await db
          .select()
          .from(membershipTypes)
          .where(
            and(
              eq(membershipTypes.id, data.membershipTypeId),
              eq(membershipTypes.status, "active"),
            ),
          )
          .limit(1);

        if (!membershipType) {
          return {
            success: false,
            errors: [
              {
                code: "NOT_FOUND",
                message: "Membership type not found or inactive",
              },
            ],
          };
        }

        // Check if user already has an active, unexpired membership
        // Must check both status AND date to allow renewal of expired memberships
        const [existingMembership] = await db
          .select()
          .from(memberships)
          .where(
            and(
              eq(memberships.userId, user.id),
              eq(memberships.status, "active"),
              gte(memberships.endDate, sql`CURRENT_DATE`),
            ),
          )
          .limit(1);

        if (existingMembership) {
          return {
            success: false,
            errors: [
              {
                code: "VALIDATION_ERROR",
                message: "User already has an active membership",
              },
            ],
          };
        }

        // Create checkout session with Square
        const squarePaymentService = await getSquarePaymentService();
        const checkoutSession = await squarePaymentService.createCheckoutSession(
          membershipType.id,
          user.id,
          membershipType.priceCents,
        );

        await db
          .insert(membershipPaymentSessions)
          .values({
            userId: user.id,
            membershipTypeId: membershipType.id,
            squareCheckoutId: checkoutSession.id,
            squarePaymentLinkUrl: checkoutSession.checkoutUrl,
            squareOrderId: checkoutSession.orderId || null,
            amountCents: membershipType.priceCents,
            currency: checkoutSession.currency,
            expiresAt: checkoutSession.expiresAt ?? null,
            metadata: {
              membershipName: membershipType.name,
              squareOrderId: checkoutSession.orderId || null,
            },
          })
          .onConflictDoUpdate({
            target: membershipPaymentSessions.squareCheckoutId,
            set: {
              membershipTypeId: membershipType.id,
              squarePaymentLinkUrl: checkoutSession.checkoutUrl,
              squareOrderId: checkoutSession.orderId || null,
              amountCents: membershipType.priceCents,
              currency: checkoutSession.currency,
              expiresAt: checkoutSession.expiresAt ?? null,
              metadata: {
                membershipName: membershipType.name,
                squareOrderId: checkoutSession.orderId || null,
              },
              updatedAt: new Date(),
            },
          });

        return {
          success: true,
          data: {
            checkoutUrl: checkoutSession.checkoutUrl,
            sessionId: checkoutSession.id,
          },
        };
      } catch (error) {
        console.error("Error creating checkout session:", error);
        return {
          success: false,
          errors: [
            {
              code: "PAYMENT_ERROR",
              message: "Failed to create checkout session",
            },
          ],
        };
      }
    },
  );

/**
 * Confirm membership purchase after payment
 */
export const confirmMembershipPurchase = createServerFn({ method: "POST" })
  .middleware(getAuthMiddleware())
  .inputValidator(zod$(confirmMembershipPurchaseSchema))
  .handler(async ({ data, context }): Promise<MembershipOperationResult<Membership>> => {
    try {
      // Import server-only modules inside the handler
      const [{ getDb }] = await Promise.all([import("~/db/server-helpers")]);

      const db = await getDb();
      const user = requireUser(context);

      // Look up the stored payment session
      const [paymentSession] = await db
        .select()
        .from(membershipPaymentSessions)
        .where(eq(membershipPaymentSessions.squareCheckoutId, data.sessionId))
        .limit(1);

      if (!paymentSession) {
        return {
          success: false,
          errors: [
            {
              code: "NOT_FOUND",
              message: "Checkout session not found",
            },
          ],
        };
      }

      if (paymentSession.userId !== user.id) {
        return {
          success: false,
          errors: [
            {
              code: "VALIDATION_ERROR",
              message: "Payment session does not belong to user",
            },
          ],
        };
      }

      if (data.membershipTypeId !== paymentSession.membershipTypeId) {
        return {
          success: false,
          errors: [
            {
              code: "VALIDATION_ERROR",
              message: "Membership type mismatch",
            },
          ],
        };
      }

      if (paymentSession.status === "completed" && paymentSession.squarePaymentId) {
        const [existingMembershipByPayment] = await db
          .select()
          .from(memberships)
          .where(eq(memberships.paymentId, paymentSession.squarePaymentId))
          .limit(1);

        if (existingMembershipByPayment) {
          return {
            success: true,
            data: castMembershipJsonbFields(existingMembershipByPayment),
          };
        }
      }

      // Verify payment with Square
      const squarePaymentService = await getSquarePaymentService();
      let paymentResult = await squarePaymentService.verifyPayment(
        paymentSession.squareCheckoutId,
        data.paymentId ?? paymentSession.squarePaymentId ?? undefined,
      );

      let retryAttempts = 0;
      const maxRetryAttempts = 2;

      while (
        !paymentResult.success &&
        retryAttempts < maxRetryAttempts &&
        isRetryablePaymentError(paymentResult.error)
      ) {
        retryAttempts += 1;
        await wait(750 * retryAttempts);

        const [latestSession] = await db
          .select()
          .from(membershipPaymentSessions)
          .where(eq(membershipPaymentSessions.id, paymentSession.id))
          .limit(1);

        if (
          latestSession &&
          latestSession.status === "completed" &&
          latestSession.squarePaymentId
        ) {
          paymentResult = {
            success: true,
            paymentId: latestSession.squarePaymentId,
            orderId: latestSession.squareOrderId,
            status: "COMPLETED",
            amount: latestSession.amountCents,
            currency: latestSession.currency,
          };
          break;
        }

        paymentResult = await squarePaymentService.verifyPayment(
          paymentSession.squareCheckoutId,
          data.paymentId ?? paymentSession.squarePaymentId ?? undefined,
        );
      }

      if (!paymentResult.success) {
        const now = new Date();
        await db
          .update(membershipPaymentSessions)
          .set({
            status: paymentSession.status === "completed" ? "completed" : "failed",
            metadata: atomicJsonbMerge(membershipPaymentSessions.metadata, {
              lastError: paymentResult.error || "Payment verification failed",
              lastErrorAt: now.toISOString(),
              retryAttempts,
            }),
            updatedAt: now,
          })
          .where(eq(membershipPaymentSessions.id, paymentSession.id));

        return {
          success: false,
          errors: [
            {
              code: "PAYMENT_ERROR",
              message: paymentResult.error || "Payment verification failed",
            },
          ],
        };
      }

      const squarePaymentId =
        paymentResult.paymentId ?? data.paymentId ?? paymentSession.squarePaymentId;

      if (!squarePaymentId) {
        return {
          success: false,
          errors: [
            {
              code: "PAYMENT_ERROR",
              message: "Missing payment identifier",
            },
          ],
        };
      }

      // Get membership type details

      const [membershipType] = await db
        .select()
        .from(membershipTypes)
        .where(eq(membershipTypes.id, data.membershipTypeId))
        .limit(1);

      if (!membershipType) {
        return {
          success: false,
          errors: [
            {
              code: "NOT_FOUND",
              message: "Membership type not found",
            },
          ],
        };
      }

      if (
        typeof paymentResult.amount === "number" &&
        paymentResult.amount !== membershipType.priceCents
      ) {
        return {
          success: false,
          errors: [
            {
              code: "PAYMENT_ERROR",
              message: "Payment amount does not match membership price",
            },
          ],
        };
      }

      if (paymentResult.currency && paymentResult.currency !== "CAD") {
        return {
          success: false,
          errors: [
            {
              code: "PAYMENT_ERROR",
              message: "Payment currency is not supported",
            },
          ],
        };
      }

      const now = new Date();
      const { finalizeMembershipForSession } = await import("./membership.finalize");
      const finalizeResult = await finalizeMembershipForSession({
        db,
        paymentSession,
        membershipType,
        paymentId: squarePaymentId,
        orderId: paymentResult.orderId ?? paymentSession.squareOrderId ?? null,
        sessionId: data.sessionId,
        now,
      });

      const confirmedMembership = finalizeResult.membership;
      const membershipWasCreated = finalizeResult.wasCreated;

      // Send confirmation email
      if (membershipWasCreated) {
        try {
          const { sendMembershipPurchaseReceipt } = await import("~/lib/email/sendgrid");

          await sendMembershipPurchaseReceipt({
            to: {
              email: user.email,
              name: user.name || undefined,
            },
            membershipType: membershipType.name,
            amount: membershipType.priceCents,
            paymentId: squarePaymentId,
            expiresAt: new Date(confirmedMembership.endDate),
          });
        } catch (emailError) {
          // Log error but don't fail the purchase
          console.error("Failed to send confirmation email:", emailError);
        }
      }

      return {
        success: true,
        data: castMembershipJsonbFields(
          confirmedMembership as typeof memberships.$inferSelect,
        ),
      };
    } catch (error) {
      console.error("Error confirming membership purchase:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to create membership record",
          },
        ],
      };
    }
  });
</file>

</files>
