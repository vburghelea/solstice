This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/lib/payments/**, src/features/membership/**, src/routes/api/payments/**, src/db/schema/membership.schema.ts, src/lib/env.server.ts, .env, SQUARE_INTEGRATION_STATUS.md, scripts/*square*.ts
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
- Git diffs from the worktree and staged changes are included
</notes>

</file_summary>

<user_provided_header>
Square Integration Debug - Checkout failing in production despite correct configuration
</user_provided_header>

<directory_structure>
scripts/
  get-square-location.ts
  test-square-sandbox.ts
src/
  db/
    schema/
      membership.schema.ts
  features/
    membership/
      __tests__/
        membership.schemas.test.ts
        membership.validation.test.ts
      components/
        admin-memberships-report.tsx
      hooks/
        usePaymentReturn.ts
      index.ts
      membership.admin-queries.ts
      membership.db-types.ts
      membership.mutations.ts
      membership.queries.ts
      membership.schemas.ts
      membership.types.ts
  lib/
    payments/
      square-real.ts
      square.ts
    env.server.ts
  routes/
    api/
      payments/
        square/
          callback.ts
SQUARE_INTEGRATION_STATUS.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="SQUARE_INTEGRATION_STATUS.md">
# Square Integration Testing Status

## Current Issue
The Square checkout integration is failing on the deployed Netlify site despite having correct configuration.

## What We've Done

### 1. Fixed Configuration
- ‚úÖ Updated `SQUARE_LOCATION_ID` from `test-location-id` to `LVDXQH3JBZ5EK`
- ‚úÖ Deployed to Netlify with correct environment variables
- ‚úÖ Verified configuration via test endpoint:
  ```json
  {
    "status": "Square Config Check",
    "hasAccessToken": true,
    "hasLocationId": true,
    "locationId": "LVDXQ...BZ5EK",
    "environment": "sandbox",
    "isValidLocationId": true
  }
  ```

### 2. Environment Variables (Confirmed in Netlify)
```
SQUARE_ACCESS_TOKEN=EAAAl7sNNDgjJXDRXFQT_tDsrJDpFZdb2OyqXGFfg5DjQLyRhblF8KB2ZwfiSp_S
SQUARE_APPLICATION_ID=sandbox-sq0idb-2rFEfy0tewRrL-80ecSSdg
SQUARE_ENV=sandbox
SQUARE_LOCATION_ID=LVDXQH3JBZ5EK
```

### 3. Test User Created
- Email: `squaretest@example.com`
- Password: `testpassword123`
- Status: No active membership (ready for purchase test)

### 4. Test Scripts Created
- `/scripts/get-square-location.ts` - Retrieves valid Square sandbox location IDs
- `/scripts/test-square-sandbox.ts` - Tests Square API connectivity
- `/src/routes/api/test-square.ts` - API endpoint to verify Square config in production

## Current Problem

When clicking "Purchase" on the membership page at https://snazzy-twilight-39e1e9.netlify.app/dashboard/membership:
- The checkout session creation fails with "Failed to create checkout session"
- The `/api/health` endpoint shows Square is configured
- The test endpoint confirms correct environment variables

## Files Involved

### Core Square Integration
- `/src/lib/payments/square.ts` - Main Square service wrapper
- `/src/lib/payments/square-real.ts` - Real Square API implementation
- `/src/features/membership/membership.mutations.ts` - Contains `createCheckoutSession` server function
- `/src/routes/api/payments/square/callback.ts` - Square payment callback handler

### Database Schema
- `/src/db/schema/membership.schema.ts` - Membership and payment session tables

### Environment Configuration
- `/.env` - Local environment variables
- `/src/lib/env.server.ts` - Server environment validation

## Testing Steps

1. **Local Testing** (Working)
   ```bash
   pnpm dev
   # Navigate to http://localhost:5173
   # Login as squaretest@example.com
   # Go to Dashboard > Membership
   # Click Purchase
   ```

2. **Production Testing** (Failing)
   ```
   # Navigate to https://snazzy-twilight-39e1e9.netlify.app
   # Login as squaretest@example.com
   # Go to Dashboard > Membership
   # Click Purchase
   # Error: "Failed to create checkout session"
   ```

## Square Sandbox Test Cards
- **Success**: `4111 1111 1111 1111` (any CVV, any future expiry)
- **Decline**: `4000 0000 0000 0002`
- **SCA Required**: `5333 3300 7777 0019`

## Debugging Needed

1. Check the actual error returned from Square API in production
2. Verify the Square SDK is correctly initializing with sandbox credentials
3. Check if there are any CORS or network issues in production
4. Verify the payment link creation request format

## API Endpoints

- Health Check: `GET /api/health`
- Test Square Config: `GET /api/test-square`
- Create Checkout: `POST /_serverFn/src_features_membership_membership_mutations_ts--createCheckoutSession_createServerFn_handler?createServerFn`
- Square Callback: `GET /api/payments/square/callback`

## Next Steps

1. Add more detailed error logging to the checkout creation
2. Test the Square API directly from the Netlify environment
3. Check Netlify function logs for the actual error
4. Verify the payment link creation parameters match Square's requirements
</file>

<file path="scripts/get-square-location.ts">
#!/usr/bin/env tsx
/**
 * Get valid Square Sandbox location ID
 */

import dotenv from "dotenv";
import type { Square } from "square";
import { SquareClient, SquareEnvironment, SquareError } from "square";

// Load environment variables
dotenv.config({ path: ".env" });

async function getLocations() {
  const accessToken = process.env["SQUARE_ACCESS_TOKEN"];

  if (!accessToken) {
    console.error("‚ùå SQUARE_ACCESS_TOKEN not found");
    process.exit(1);
  }

  const client = new SquareClient({
    token: accessToken,
    environment: SquareEnvironment.Sandbox,
  });

  try {
    // Try the same API call as in square-real.ts
    const testRequest: Square.checkout.CreatePaymentLinkRequest = {
      idempotencyKey: `test-${Date.now()}`,
      description: "Test",
      quickPay: {
        name: "Test Item",
        priceMoney: {
          amount: BigInt(100),
          currency: "CAD" as Square.Currency,
        },
        locationId: "test-location-id", // This will fail but show us the error
      },
    };

    console.log("Testing Square API with invalid location...");
    const result = await client.checkout.paymentLinks.create(testRequest);
    console.log("Result:", result);
  } catch (error: unknown) {
    if (error instanceof SquareError) {
      console.log("\n‚ùå Square API Error (expected):");
      for (const err of error.errors ?? []) {
        console.log(`  ${err.category}: ${err.code}`);
        console.log(`  ${err.detail}`);
        console.log(`  Field: ${err.field}`);
      }

      // Now try to get valid locations
      console.log("\nüìç Fetching valid locations...");
      try {
        const locationsApi = client.locations;
        const locations = await locationsApi.list();

        if (locations.locations && locations.locations.length > 0) {
          console.log(`\n‚úÖ Found ${locations.locations.length} location(s):\n`);

          for (const location of locations.locations) {
            console.log(`Location ID: ${location.id}`);
            console.log(`Name: ${location.name}`);
            console.log(`Status: ${location.status}`);
            console.log(`---`);
          }

          console.log(`\nüí° Update your .env file with:`);
          console.log(`SQUARE_LOCATION_ID="${locations.locations[0].id}"`);
        }
      } catch (locError: unknown) {
        console.error("Failed to fetch locations:", locError);
      }
    } else {
      console.error("Unknown error:", error);
    }
  }
}

getLocations();
</file>

<file path="scripts/test-square-sandbox.ts">
#!/usr/bin/env tsx
/**
 * Test Square Sandbox API connection and get valid location ID
 */

import dotenv from "dotenv";
import { SquareClient, SquareEnvironment, SquareError } from "square";

// Load environment variables
dotenv.config({ path: ".env" });

async function testSquareConnection() {
  console.log("üîß Testing Square Sandbox Connection...\n");

  const accessToken = process.env["SQUARE_ACCESS_TOKEN"];
  const environment = process.env["SQUARE_ENV"];

  if (!accessToken) {
    console.error("‚ùå SQUARE_ACCESS_TOKEN not found in .env");
    process.exit(1);
  }

  console.log(`Environment: ${environment}`);
  console.log(`Access Token: ${accessToken.substring(0, 20)}...`);
  console.log();

  const client = new SquareClient({
    token: accessToken,
    environment:
      environment === "production"
        ? SquareEnvironment.Production
        : SquareEnvironment.Sandbox,
  });

  try {
    // Test 1: List locations
    console.log("üìç Fetching locations...");
    const locationsResponse = await client.locations.list();
    const locationList = locationsResponse.locations ?? [];

    if (locationList.length > 0) {
      console.log(`‚úÖ Found ${locationList.length} location(s):\n`);

      locationList.forEach((location) => {
        console.log(`  Location ID: ${location.id}`);
        console.log(`  Name: ${location.name}`);
        console.log(`  Status: ${location.status}`);
        console.log(`  Currency: ${location.currency}`);
        console.log(`  Country: ${location.country}`);
        console.log(
          `  Address: ${location.address?.addressLine1}, ${location.address?.locality}`,
        );
        console.log("  ---");
      });

      // Set the first location as default
      const defaultLocation = locationList[0];
      console.log(`\nüí° To use this location, update your .env file:`);
      console.log(`   SQUARE_LOCATION_ID="${defaultLocation.id}"`);
    } else {
      console.log(
        "‚ö†Ô∏è  No locations found. You may need to create one in Square Dashboard.",
      );
    }

    // Test 2: Check catalog API
    console.log("\nüì¶ Testing Catalog API...");
    const catalogResponse = await client.catalog.list({
      types: "ITEM",
    });

    console.log(
      `‚úÖ Catalog API is accessible. Found ${catalogResponse.data.length} item(s).`,
    );

    // Test 3: Check payments API
    console.log("\nüí≥ Testing Payments API...");
    const paymentsResponse = await client.payments.list({
      limit: 1,
    });

    console.log(
      `‚úÖ Payments API is accessible. Found ${paymentsResponse.data.length} payment(s).`,
    );

    console.log("\n‚ú® Square Sandbox connection successful!");
  } catch (error: unknown) {
    console.error("\n‚ùå Square API Error:");

    if (error instanceof SquareError) {
      for (const err of error.errors ?? []) {
        console.error(`  - ${err.category}: ${err.code}`);
        console.error(`    ${err.detail}`);
      }
    } else {
      console.error(error);
    }

    process.exit(1);
  }
}

testSquareConnection();
</file>

<file path="src/features/membership/__tests__/membership.schemas.test.ts">
import { describe, expect, it } from "vitest";
import {
  cancelMembershipSchema,
  confirmMembershipPurchaseSchema,
  getMembershipTypeSchema,
  purchaseMembershipSchema,
} from "../membership.schemas";

describe("Membership Schemas", () => {
  describe("getMembershipTypeSchema", () => {
    it("validates valid membership type ID", () => {
      const validInput = {
        membershipTypeId: "membership-123",
      };

      const result = getMembershipTypeSchema.safeParse(validInput);
      expect(result.success).toBe(true);
    });

    it("fails without membership type ID", () => {
      const invalidInput = {};

      const result = getMembershipTypeSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });

    it("fails with non-string membership type ID", () => {
      const invalidInput = {
        membershipTypeId: 123,
      };

      const result = getMembershipTypeSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });
  });

  describe("purchaseMembershipSchema", () => {
    it("validates valid purchase input", () => {
      const validInput = {
        membershipTypeId: "membership-123",
        autoRenew: true,
      };

      const result = purchaseMembershipSchema.safeParse(validInput);
      expect(result.success).toBe(true);
      expect(result.data?.autoRenew).toBe(true);
    });

    it("validates purchase input without autoRenew (defaults to false)", () => {
      const validInput = {
        membershipTypeId: "membership-123",
      };

      const result = purchaseMembershipSchema.safeParse(validInput);
      expect(result.success).toBe(true);
      expect(result.data?.autoRenew).toBe(false);
    });

    it("fails without membership type ID", () => {
      const invalidInput = {
        autoRenew: true,
      };

      const result = purchaseMembershipSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });

    it("fails with invalid autoRenew type", () => {
      const invalidInput = {
        membershipTypeId: "membership-123",
        autoRenew: "yes", // Should be boolean
      };

      const result = purchaseMembershipSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });
  });

  describe("cancelMembershipSchema", () => {
    it("validates valid cancellation with all fields", () => {
      const validInput = {
        membershipId: "membership-123",
        reason: "Moving to another country",
        immediate: true,
      };

      const result = cancelMembershipSchema.safeParse(validInput);
      expect(result.success).toBe(true);
      expect(result.data?.reason).toBe("Moving to another country");
      expect(result.data?.immediate).toBe(true);
    });

    it("validates cancellation without optional fields", () => {
      const validInput = {
        membershipId: "membership-123",
      };

      const result = cancelMembershipSchema.safeParse(validInput);
      expect(result.success).toBe(true);
      expect(result.data?.reason).toBeUndefined();
      expect(result.data?.immediate).toBe(false);
    });

    it("validates cancellation with only reason", () => {
      const validInput = {
        membershipId: "membership-123",
        reason: "No longer playing",
      };

      const result = cancelMembershipSchema.safeParse(validInput);
      expect(result.success).toBe(true);
      expect(result.data?.reason).toBe("No longer playing");
      expect(result.data?.immediate).toBe(false);
    });

    it("fails without membership ID", () => {
      const invalidInput = {
        reason: "No longer playing",
        immediate: true,
      };

      const result = cancelMembershipSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });

    it("accepts empty string as reason", () => {
      const validInput = {
        membershipId: "membership-123",
        reason: "",
        immediate: false,
      };

      const result = cancelMembershipSchema.safeParse(validInput);
      expect(result.success).toBe(true);
      expect(result.data?.reason).toBe("");
    });
  });

  describe("confirmMembershipPurchaseSchema", () => {
    it("validates valid confirmation with all fields", () => {
      const validInput = {
        membershipTypeId: "membership-123",
        sessionId: "session-456",
        paymentId: "payment-789",
      };

      const result = confirmMembershipPurchaseSchema.safeParse(validInput);
      expect(result.success).toBe(true);
      expect(result.data?.paymentId).toBe("payment-789");
    });

    it("validates confirmation without optional payment ID", () => {
      const validInput = {
        membershipTypeId: "membership-123",
        sessionId: "session-456",
      };

      const result = confirmMembershipPurchaseSchema.safeParse(validInput);
      expect(result.success).toBe(true);
      expect(result.data?.paymentId).toBeUndefined();
    });

    it("fails without membership type ID", () => {
      const invalidInput = {
        sessionId: "session-456",
        paymentId: "payment-789",
      };

      const result = confirmMembershipPurchaseSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });

    it("fails without session ID", () => {
      const invalidInput = {
        membershipTypeId: "membership-123",
        paymentId: "payment-789",
      };

      const result = confirmMembershipPurchaseSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });

    it("fails with non-string IDs", () => {
      const invalidInput = {
        membershipTypeId: 123,
        sessionId: 456,
        paymentId: 789,
      };

      const result = confirmMembershipPurchaseSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });
  });
});
</file>

<file path="src/features/membership/__tests__/membership.validation.test.ts">
import { describe, expect, it } from "vitest";
import {
  confirmMembershipPurchaseSchema,
  purchaseMembershipSchema,
} from "../membership.schemas";

describe("Membership Server Function Validation", () => {
  describe("createCheckoutSession validation", () => {
    it("validates membership purchase input correctly", () => {
      // The actual server function uses omit({ autoRenew: true })
      const schema = purchaseMembershipSchema.omit({ autoRenew: true });

      const validInput = {
        data: {
          membershipTypeId: "membership-123",
        },
      };

      const result = schema.safeParse(validInput.data);
      expect(result.success).toBe(true);
    });

    it("fails without membership type ID", () => {
      const schema = purchaseMembershipSchema.omit({ autoRenew: true });

      const invalidInput = {
        data: {},
      };

      const result = schema.safeParse(invalidInput.data);
      expect(result.success).toBe(false);
    });
  });

  describe("confirmMembershipPurchase validation", () => {
    it("validates confirmation input correctly", () => {
      const validInput = {
        data: {
          membershipTypeId: "membership-123",
          sessionId: "session-456",
          paymentId: "payment-789",
        },
      };

      const result = confirmMembershipPurchaseSchema.safeParse(validInput.data);
      expect(result.success).toBe(true);
    });

    it("validates without optional payment ID", () => {
      const validInput = {
        data: {
          membershipTypeId: "membership-123",
          sessionId: "session-456",
        },
      };

      const result = confirmMembershipPurchaseSchema.safeParse(validInput.data);
      expect(result.success).toBe(true);
    });

    it("fails without required fields", () => {
      const invalidInput = {
        data: {
          membershipTypeId: "membership-123",
          // Missing sessionId
        },
      };

      const result = confirmMembershipPurchaseSchema.safeParse(invalidInput.data);
      expect(result.success).toBe(false);
    });
  });

  describe("Membership Types", () => {
    it("validates membership type structure", () => {
      // This is more of a type check than a runtime validation
      const membershipType = {
        id: "annual-player-2025",
        name: "Annual Player Membership 2025",
        description: "Full player membership for 2025 season",
        priceCents: 4500,
        currency: "CAD",
        durationMonths: 12,
        benefits: [
          "Tournament participation",
          "League play",
          "Insurance coverage",
          "Voting rights",
        ],
        status: "active" as const,
        maxPurchases: 1,
        validFrom: new Date("2025-01-01"),
        validUntil: new Date("2025-12-31"),
      };

      expect(membershipType).toMatchObject({
        id: expect.any(String),
        name: expect.any(String),
        priceCents: expect.any(Number),
        durationMonths: expect.any(Number),
        status: expect.stringMatching(/active|inactive|archived/),
      });
    });
  });

  describe("Membership Record", () => {
    it("validates membership record structure", () => {
      const membership = {
        id: "membership-123",
        userId: "user-456",
        membershipTypeId: "annual-player-2025",
        startDate: "2025-01-01",
        endDate: "2025-12-31",
        status: "active" as const,
        paymentProvider: "square" as const,
        paymentId: "payment-789",
        autoRenew: false,
        metadata: {
          sessionId: "session-123",
          purchasedAt: new Date().toISOString(),
        },
      };

      expect(membership).toMatchObject({
        id: expect.any(String),
        userId: expect.any(String),
        membershipTypeId: expect.any(String),
        startDate: expect.stringMatching(/^\d{4}-\d{2}-\d{2}$/),
        endDate: expect.stringMatching(/^\d{4}-\d{2}-\d{2}$/),
        status: expect.stringMatching(/active|expired|cancelled/),
        paymentProvider: expect.stringMatching(/square|etransfer|cash|other/),
      });
    });
  });
});
</file>

<file path="src/features/membership/components/admin-memberships-report.tsx">
import { useQuery } from "@tanstack/react-query";
import { type ColumnDef } from "@tanstack/react-table";
import { useState } from "react";
import { DataTable } from "~/components/ui/data-table";
import { exportToCSV, formatCurrency, formatDate } from "~/lib/utils/csv-export";
import { getAllMemberships, type MembershipReportRow } from "../membership.admin-queries";

const columns: ColumnDef<MembershipReportRow>[] = [
  {
    accessorKey: "userName",
    header: "User Name",
  },
  {
    accessorKey: "userEmail",
    header: "Email",
  },
  {
    accessorKey: "membershipType",
    header: "Membership Type",
  },
  {
    accessorKey: "startDate",
    header: "Start Date",
    cell: ({ row }) => formatDate(row.getValue("startDate")),
  },
  {
    accessorKey: "endDate",
    header: "End Date",
    cell: ({ row }) => formatDate(row.getValue("endDate")),
  },
  {
    accessorKey: "status",
    header: "Status",
    cell: ({ row }) => {
      const status = row.getValue("status") as string;
      return (
        <span
          className={`inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-medium ${
            status === "active"
              ? "bg-green-100 text-green-800"
              : status === "expired"
                ? "bg-gray-100 text-gray-800"
                : "bg-red-100 text-red-800"
          }`}
        >
          {status}
        </span>
      );
    },
  },
  {
    accessorKey: "priceCents",
    header: "Price",
    cell: ({ row }) => formatCurrency(row.getValue("priceCents")),
  },
  {
    accessorKey: "paymentId",
    header: "Payment ID",
    cell: ({ row }) => row.getValue("paymentId") || "-",
  },
  {
    accessorKey: "createdAt",
    header: "Created At",
    cell: ({ row }) => formatDate(row.getValue("createdAt")),
  },
];

export function AdminMembershipsReport() {
  const [statusFilter, setStatusFilter] = useState<
    "all" | "active" | "expired" | "cancelled"
  >("all");

  const { data, isLoading, error } = useQuery({
    queryKey: ["admin-memberships", statusFilter],
    queryFn: async () => {
      const result = await getAllMemberships({ data: { status: statusFilter } });
      return result;
    },
  });

  const handleExport = () => {
    if (data?.data) {
      const exportData = data.data.map((row) => ({
        "User Name": row.userName,
        Email: row.userEmail,
        "Membership Type": row.membershipType,
        "Start Date": formatDate(row.startDate),
        "End Date": formatDate(row.endDate),
        Status: row.status,
        Price: formatCurrency(row.priceCents),
        "Payment ID": row.paymentId || "-",
        "Created At": formatDate(row.createdAt),
      }));

      const filename = `memberships-report-${new Date().toISOString().split("T")[0]}.csv`;
      exportToCSV(exportData, filename);
    }
  };

  if (isLoading) {
    return (
      <div className="flex h-64 items-center justify-center">
        <div className="text-muted-foreground">Loading memberships...</div>
      </div>
    );
  }

  if (error || !data?.success) {
    const errorMessage = data?.errors?.[0]?.message || "Failed to load memberships";

    // Check if it's an admin access error
    if (errorMessage === "Admin access required") {
      return (
        <div className="border-destructive/50 bg-destructive/10 rounded-lg border p-6">
          <h3 className="text-destructive text-lg font-semibold">Access Denied</h3>
          <p className="text-muted-foreground mt-2">
            You do not have permission to view this report. Admin access is required.
          </p>
        </div>
      );
    }

    return (
      <div className="border-destructive/50 bg-destructive/10 rounded-lg border p-6">
        <h3 className="text-destructive text-lg font-semibold">Error Loading Report</h3>
        <p className="text-muted-foreground mt-2">{errorMessage}</p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-2xl font-bold tracking-tight">Memberships Report</h2>
          <p className="text-muted-foreground">
            View and export all membership data across the platform
          </p>
        </div>
        <div className="flex items-center gap-4">
          <select
            value={statusFilter}
            onChange={(e) =>
              setStatusFilter(
                e.target.value as "all" | "active" | "expired" | "cancelled",
              )
            }
            className="border-input bg-background ring-offset-background focus-visible:ring-ring rounded-md border px-3 py-2 text-sm focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:outline-none"
          >
            <option value="all">All Status</option>
            <option value="active">Active</option>
            <option value="expired">Expired</option>
            <option value="cancelled">Cancelled</option>
          </select>
        </div>
      </div>

      <DataTable
        columns={columns}
        data={data.data || []}
        pageSize={20}
        onExport={handleExport}
      />
    </div>
  );
}
</file>

<file path="src/features/membership/hooks/usePaymentReturn.ts">
import { useMemo } from "react";

export interface PaymentReturnParams {
  isMockCheckout: boolean;
  sessionId: string | null;
  success: boolean;
  error: string | null;
  paymentId: string | null;
  membershipTypeId: string | null;
}

/**
 * Parse payment return parameters from URL without using useEffect
 * This hook extracts payment-related query parameters for processing
 */
export function usePaymentReturn(): PaymentReturnParams {
  return useMemo(() => {
    if (typeof window === "undefined") {
      return {
        isMockCheckout: false,
        sessionId: null,
        success: false,
        error: null,
        paymentId: null,
        membershipTypeId: null,
      };
    }

    const searchParams = new URLSearchParams(window.location.search);

    return {
      isMockCheckout: searchParams.get("mock_checkout") === "true",
      sessionId: searchParams.get("session"),
      success: searchParams.get("success") === "true",
      error: searchParams.get("error"),
      paymentId: searchParams.get("payment_id"),
      membershipTypeId: searchParams.get("type"),
    };
  }, []); // Empty deps since URL doesn't change after mount
}

/**
 * Get appropriate error message for payment errors
 */
export function getPaymentErrorMessage(error: string | null): string | null {
  if (!error) return null;

  const errorMessages: Record<string, string> = {
    cancelled: "Payment was cancelled",
    verification_failed: "Payment verification failed",
    processing_error: "An error occurred while processing your payment",
  };

  return errorMessages[error] || "Payment failed";
}

/**
 * Clear payment-related query parameters from URL
 */
export function clearPaymentParams(): void {
  if (typeof window !== "undefined") {
    window.history.replaceState({}, document.title, window.location.pathname);
  }
}
</file>

<file path="src/features/membership/index.ts">
// Export queries
export {
  getMembershipType,
  getUserMembershipStatus,
  listMembershipTypes,
} from "./membership.queries";

// Export mutations
export { confirmMembershipPurchase, createCheckoutSession } from "./membership.mutations";

// Export types
export type {
  CheckoutSessionResult,
  MembershipOperationResult,
  MembershipPurchaseInput,
  MembershipStatus,
  UserMembership,
} from "./membership.types";
</file>

<file path="src/features/membership/membership.schemas.ts">
import { z } from "zod";

// Query schemas
export const getMembershipTypeSchema = z.object({
  membershipTypeId: z.string(),
});
export type GetMembershipTypeInput = z.infer<typeof getMembershipTypeSchema>;

// Mutation schemas
export const purchaseMembershipSchema = z.object({
  membershipTypeId: z.string(),
  autoRenew: z.boolean().default(false),
});
export type PurchaseMembershipInput = z.infer<typeof purchaseMembershipSchema>;

export const cancelMembershipSchema = z.object({
  membershipId: z.string(),
  reason: z.string().optional(),
  immediate: z.boolean().default(false),
});
export type CancelMembershipInput = z.infer<typeof cancelMembershipSchema>;

export const confirmMembershipPurchaseSchema = z.object({
  membershipTypeId: z.string(),
  sessionId: z.string(),
  paymentId: z.string().optional(),
});
export type ConfirmMembershipPurchaseInput = z.infer<
  typeof confirmMembershipPurchaseSchema
>;
</file>

<file path="src/db/schema/membership.schema.ts">
import { createId } from "@paralleldrive/cuid2";
import {
  date,
  index,
  integer,
  jsonb,
  pgTable,
  timestamp,
  uniqueIndex,
  varchar,
} from "drizzle-orm/pg-core";
import { user } from "./auth.schema";

export const membershipTypes = pgTable(
  "membership_types",
  {
    id: varchar("id", { length: 255 })
      .$defaultFn(() => createId())
      .primaryKey(),
    name: varchar("name", { length: 255 }).notNull(),
    description: varchar("description", { length: 1000 }),
    priceCents: integer("price_cents").notNull(),
    durationMonths: integer("duration_months").notNull(),
    status: varchar("status", { length: 50 })
      .$type<"active" | "inactive">()
      .notNull()
      .default("active"),
    metadata: jsonb("metadata").$type<Record<string, unknown>>(),
    createdAt: timestamp("created_at").notNull().defaultNow(),
    updatedAt: timestamp("updated_at").notNull().defaultNow(),
  },
  (table) => ({
    statusIdx: index("membership_types_status_idx").on(table.status),
  }),
);

export const memberships = pgTable(
  "memberships",
  {
    id: varchar("id", { length: 255 })
      .$defaultFn(() => createId())
      .primaryKey(),
    userId: varchar("user_id", { length: 255 })
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    membershipTypeId: varchar("membership_type_id", { length: 255 })
      .notNull()
      .references(() => membershipTypes.id),
    startDate: date("start_date").notNull(),
    endDate: date("end_date").notNull(),
    status: varchar("status", { length: 50 })
      .$type<"active" | "expired" | "cancelled">()
      .notNull()
      .default("active"),
    paymentProvider: varchar("payment_provider", { length: 100 }),
    paymentId: varchar("payment_id", { length: 255 }),
    metadata: jsonb("metadata").$type<{
      paymentDetails?: Record<string, unknown>;
      notes?: string;
      [key: string]: unknown;
    }>(),
    createdAt: timestamp("created_at").notNull().defaultNow(),
    updatedAt: timestamp("updated_at").notNull().defaultNow(),
  },
  (table) => ({
    userIdIdx: index("memberships_user_id_idx").on(table.userId),
    statusIdx: index("memberships_status_idx").on(table.status),
    endDateIdx: index("memberships_end_date_idx").on(table.endDate),
    paymentIdIdx: index("memberships_payment_id_idx").on(table.paymentId),
  }),
);

export const membershipPaymentSessions = pgTable(
  "membership_payment_sessions",
  {
    id: varchar("id", { length: 255 })
      .$defaultFn(() => createId())
      .primaryKey(),
    userId: varchar("user_id", { length: 255 })
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    membershipTypeId: varchar("membership_type_id", { length: 255 })
      .notNull()
      .references(() => membershipTypes.id),
    squareCheckoutId: varchar("square_checkout_id", { length: 255 }).notNull(),
    squarePaymentLinkUrl: varchar("square_payment_link_url", { length: 2048 }).notNull(),
    squareOrderId: varchar("square_order_id", { length: 255 }),
    squarePaymentId: varchar("square_payment_id", { length: 255 }),
    status: varchar("status", { length: 50 })
      .$type<"pending" | "completed" | "cancelled" | "failed">()
      .notNull()
      .default("pending"),
    amountCents: integer("amount_cents").notNull(),
    currency: varchar("currency", { length: 10 }).notNull().default("CAD"),
    expiresAt: timestamp("expires_at"),
    metadata: jsonb("metadata").$type<Record<string, unknown>>(),
    createdAt: timestamp("created_at").notNull().defaultNow(),
    updatedAt: timestamp("updated_at").notNull().defaultNow(),
  },
  (table) => ({
    userIdx: index("membership_payment_sessions_user_idx").on(table.userId),
    checkoutIdx: uniqueIndex("membership_payment_sessions_checkout_idx").on(
      table.squareCheckoutId,
    ),
    orderIdx: index("membership_payment_sessions_order_idx").on(table.squareOrderId),
    paymentIdx: index("membership_payment_sessions_payment_idx").on(
      table.squarePaymentId,
    ),
    membershipTypeIdx: index("membership_payment_sessions_type_idx").on(
      table.membershipTypeId,
    ),
  }),
);

// Export inferred types
export type MembershipType = typeof membershipTypes.$inferSelect;
export type NewMembershipType = typeof membershipTypes.$inferInsert;
export type Membership = typeof memberships.$inferSelect;
export type NewMembership = typeof memberships.$inferInsert;
export type MembershipPaymentSession = typeof membershipPaymentSessions.$inferSelect;
export type NewMembershipPaymentSession = typeof membershipPaymentSessions.$inferInsert;
</file>

<file path="src/features/membership/membership.db-types.ts">
/**
 * Type definitions for membership database jsonb fields
 */

/* eslint-disable @typescript-eslint/no-explicit-any */

export interface MembershipMetadata {
  [key: string]: any;
  paymentDetails?: Record<string, any>;
  notes?: string;
}
</file>

<file path="src/routes/api/payments/square/callback.ts">
import { redirect } from "@tanstack/react-router";
import { createServerFileRoute } from "@tanstack/react-start/server";
import { eq } from "drizzle-orm";
import { membershipPaymentSessions } from "~/db/schema";
import { getSquarePaymentService } from "~/lib/payments/square";

export const ServerRoute = createServerFileRoute("/api/payments/square/callback").methods(
  {
    GET: async ({ request }) => {
      try {
        const url = new URL(request.url);
        const params = url.searchParams;

        // Get checkout ID from Square
        const checkoutId = params.get("checkoutId");
        const transactionId = params.get("transactionId");

        if (!checkoutId) {
          return redirect({
            to: "/dashboard/membership",
            search: {
              error: "cancelled",
            },
          });
        }

        const { getDb } = await import("~/db/server-helpers");
        const db = await getDb();

        const [paymentSession] = await db
          .select()
          .from(membershipPaymentSessions)
          .where(eq(membershipPaymentSessions.squareCheckoutId, checkoutId))
          .limit(1);

        const nowIso = new Date().toISOString();

        // Check if payment was cancelled
        if (!transactionId) {
          if (paymentSession) {
            await db
              .update(membershipPaymentSessions)
              .set({
                status: "cancelled",
                metadata: {
                  ...(paymentSession.metadata ?? {}),
                  cancelledAt: nowIso,
                },
                updatedAt: new Date(),
              })
              .where(eq(membershipPaymentSessions.id, paymentSession.id));
          }

          return redirect({
            to: "/dashboard/membership",
            search: {
              error: "cancelled",
            },
          });
        }

        if (paymentSession) {
          await db
            .update(membershipPaymentSessions)
            .set({
              squarePaymentId: transactionId,
              metadata: {
                ...(paymentSession.metadata ?? {}),
                squareTransactionId: transactionId,
                callbackReceivedAt: nowIso,
              },
              updatedAt: new Date(),
            })
            .where(eq(membershipPaymentSessions.id, paymentSession.id));
        }

        // Get the payment service
        const paymentService = await getSquarePaymentService();

        // Verify the payment with Square
        const result = await paymentService.verifyPayment(checkoutId, transactionId);

        if (!result.success) {
          console.error("Payment verification failed:", result.error);

          if (paymentSession) {
            await db
              .update(membershipPaymentSessions)
              .set({
                status: "failed",
                metadata: {
                  ...(paymentSession.metadata ?? {}),
                  lastError: result.error || "Payment verification failed",
                  lastErrorAt: nowIso,
                  squareTransactionId: transactionId,
                },
                updatedAt: new Date(),
              })
              .where(eq(membershipPaymentSessions.id, paymentSession.id));
          }

          return redirect({
            to: "/dashboard/membership",
            search: {
              error: "verification_failed",
            },
          });
        }

        const paymentIdentifier = result.paymentId || transactionId;

        if (paymentSession) {
          await db
            .update(membershipPaymentSessions)
            .set({
              status: "completed",
              squarePaymentId: paymentIdentifier,
              metadata: {
                ...(paymentSession.metadata ?? {}),
                squareTransactionId: paymentIdentifier,
                paymentVerifiedAt: nowIso,
              },
              updatedAt: new Date(),
            })
            .where(eq(membershipPaymentSessions.id, paymentSession.id));
        }

        const searchParams: Record<string, string> = {
          success: "true",
          payment_id: paymentIdentifier,
          session: checkoutId,
        };

        if (paymentSession?.membershipTypeId) {
          searchParams["type"] = paymentSession.membershipTypeId;
        }

        return redirect({
          to: "/dashboard/membership",
          search: searchParams,
        });
      } catch (error) {
        console.error("Square callback error:", error);
        return redirect({
          to: "/dashboard/membership",
          search: {
            error: "processing_error",
          },
        });
      }
    },
  },
);
</file>

<file path="src/features/membership/membership.admin-queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { z } from "zod";
import type { MembershipOperationResult } from "./membership.types";

const getAllMembershipsSchema = z.object({
  status: z.enum(["all", "active", "expired", "cancelled"]).optional().default("all"),
  limit: z.number().optional().default(100),
  offset: z.number().optional().default(0),
});

export interface MembershipReportRow {
  id: string;
  userName: string;
  userEmail: string;
  membershipType: string;
  startDate: string;
  endDate: string;
  status: "active" | "expired" | "cancelled";
  priceCents: number;
  paymentId: string | null;
  createdAt: Date;
}

/**
 * Admin-only: Get all memberships with user information
 */
export const getAllMemberships = createServerFn({ method: "GET" })
  .validator(getAllMembershipsSchema.parse)
  .handler(
    async ({ data }): Promise<MembershipOperationResult<MembershipReportRow[]>> => {
      try {
        // Import server-only modules inside the handler
        const [{ getDb }, { getAuth }] = await Promise.all([
          import("~/db/server-helpers"),
          import("~/lib/auth/server-helpers"),
        ]);

        const auth = await getAuth();
        const { getWebRequest } = await import("@tanstack/react-start/server");
        const { headers } = getWebRequest();
        const session = await auth.api.getSession({ headers });

        if (!session?.user?.id) {
          return {
            success: false,
            errors: [
              {
                code: "VALIDATION_ERROR",
                message: "User not authenticated",
              },
            ],
          };
        }

        // Check admin access
        const { requireAdmin } = await import("~/lib/auth/utils/admin-check");
        await requireAdmin(session.user.id);

        // Import database dependencies inside handler
        const { and, eq, sql } = await import("drizzle-orm");
        const { memberships, membershipTypes, user } = await import("~/db/schema");

        const db = await getDb();

        // Build where conditions
        const conditions = [];
        if (data.status !== "all") {
          conditions.push(eq(memberships.status, data.status));
        }
        const query = db
          .select({
            id: memberships.id,
            userName: user.name,
            userEmail: user.email,
            membershipType: membershipTypes.name,
            startDate: memberships.startDate,
            endDate: memberships.endDate,
            status: memberships.status,
            priceCents: membershipTypes.priceCents,
            paymentId: memberships.paymentId,
            createdAt: memberships.createdAt,
          })
          .from(memberships)
          .innerJoin(user, eq(memberships.userId, user.id))
          .innerJoin(
            membershipTypes,
            eq(memberships.membershipTypeId, membershipTypes.id),
          )
          .orderBy(sql`${memberships.createdAt} DESC`)
          .limit(data.limit)
          .offset(data.offset);

        if (conditions.length > 0) {
          const results = await query.where(and(...conditions));
          return {
            success: true,
            data: results,
          };
        }

        const results = await query;
        return {
          success: true,
          data: results,
        };
      } catch (error) {
        console.error("Error fetching memberships:", error);

        if ((error as Error).message?.includes("Admin access required")) {
          return {
            success: false,
            errors: [
              {
                code: "VALIDATION_ERROR",
                message: "Admin access required",
              },
            ],
          };
        }

        return {
          success: false,
          errors: [
            {
              code: "DATABASE_ERROR",
              message: "Failed to fetch memberships",
            },
          ],
        };
      }
    },
  );
</file>

<file path="src/features/membership/membership.types.ts">
// Define types manually since we can't import from schema at top level
import type { MembershipMetadata } from "./membership.db-types";
export interface MembershipType {
  id: string;
  name: string;
  description: string | null;
  priceCents: number;
  durationMonths: number;
  status: "active" | "inactive";
  metadata: MembershipMetadata | null;
  createdAt: Date;
  updatedAt: Date;
}

export interface Membership {
  id: string;
  userId: string;
  membershipTypeId: string;
  startDate: string | Date;
  endDate: string | Date;
  status: "active" | "cancelled" | "expired";
  paymentId: string | null;
  metadata: MembershipMetadata | null;
  createdAt: Date;
  updatedAt: Date;
}

export interface MembershipOperationResult<T = unknown> {
  success: boolean;
  data?: T;
  errors?: Array<{
    code: "VALIDATION_ERROR" | "DATABASE_ERROR" | "PAYMENT_ERROR" | "NOT_FOUND";
    field?: string;
    message: string;
  }>;
}

export interface CheckoutSessionResult {
  checkoutUrl: string;
  sessionId: string;
}

export interface MembershipPurchaseInput {
  membershipTypeId: string;
  sessionId: string;
  paymentId?: string;
}

export interface UserMembership extends Membership {
  membershipType: MembershipType;
}

export interface MembershipStatus {
  hasMembership: boolean;
  currentMembership?: UserMembership;
  expiresAt?: Date;
  daysRemaining?: number;
}
</file>

<file path="src/lib/payments/square-real.ts">
/**
 * Square payment integration helper - REAL implementation
 * This module handles real Square API interactions
 */

import { createId } from "@paralleldrive/cuid2";
import { eq } from "drizzle-orm";
import type { Square } from "square";
import { SquareClient, SquareEnvironment, SquareError, WebhooksHelper } from "square";
import { membershipPaymentSessions, memberships } from "~/db/schema";

// This module should only be imported in server-side code

export interface CheckoutSession {
  id: string;
  checkoutUrl: string;
  membershipTypeId: string;
  userId: string;
  amount: number;
  currency: string;
  status: "pending" | "completed" | "cancelled";
  expiresAt: Date;
  orderId?: string | null;
}

export interface PaymentResult {
  success: boolean;
  paymentId?: string;
  error?: string;
  orderId?: string | null;
  status?: string | null;
  amount?: number | null;
  currency?: string | null;
}

/**
 * Real Square payment helper
 * Handles actual Square API interactions for production
 */
export class SquarePaymentService {
  private client: SquareClient;
  private locationId: string;

  constructor() {
    // Get environment variables
    const accessToken = process.env["SQUARE_ACCESS_TOKEN"];
    const locationId = process.env["SQUARE_LOCATION_ID"];
    const environment = process.env["SQUARE_ENV"] || "sandbox";

    if (!accessToken) {
      throw new Error("SQUARE_ACCESS_TOKEN is required");
    }

    if (!locationId) {
      throw new Error("SQUARE_LOCATION_ID is required");
    }

    // Initialize Square client
    this.client = new SquareClient({
      token: accessToken,
      environment:
        environment === "production"
          ? SquareEnvironment.Production
          : SquareEnvironment.Sandbox,
    });

    this.locationId = locationId;
  }

  /**
   * Create a checkout session for membership purchase
   * @param membershipTypeId - ID of the membership type to purchase
   * @param userId - ID of the user making the purchase
   * @param amount - Amount in cents
   * @returns Checkout session with URL to redirect user
   */
  async createCheckoutSession(
    membershipTypeId: string,
    userId: string,
    amount: number,
  ): Promise<CheckoutSession> {
    try {
      // Import the server env to get base URL
      const { getBaseUrl } = await import("~/lib/env.server");
      const baseUrl = getBaseUrl();

      // Create idempotency key for Square
      const idempotencyKey = createId();

      // Create checkout request

      // Create payment link with Square (recommended over Checkout API)
      const paymentLinkRequest: Square.checkout.CreatePaymentLinkRequest = {
        idempotencyKey,
        description: "Annual Player Membership",
        quickPay: {
          name: "Annual Player Membership",
          priceMoney: {
            amount: BigInt(amount),
            currency: "CAD",
          },
          locationId: this.locationId,
        },
        checkoutOptions: {
          allowTipping: false,
          redirectUrl: `${baseUrl}/api/payments/square/callback`,
          askForShippingAddress: false,
          merchantSupportEmail:
            process.env["SUPPORT_EMAIL"] || "support@quadballcanada.com",
        },
        prePopulatedData: {
          buyerEmail: null, // Will be set from user data in the future
        },
        paymentNote: `Membership purchase for user ${userId}`,
      };

      const result = await this.client.checkout.paymentLinks.create(paymentLinkRequest);

      if (!result.paymentLink?.id || !result.paymentLink?.url) {
        throw new Error("Failed to create payment link");
      }

      // Create our internal session object
      const checkoutSession: CheckoutSession = {
        id: result.paymentLink.id,
        checkoutUrl: result.paymentLink.url,
        membershipTypeId,
        userId,
        amount,
        currency: "CAD",
        status: "pending",
        expiresAt: new Date(Date.now() + 30 * 60 * 1000), // 30 minutes
        orderId: result.paymentLink.orderId || null,
      };

      // In a real implementation, we would store this session in the database
      // For now, we'll encode it in the state parameter
      return checkoutSession;
    } catch (error) {
      console.error("Square checkout error:", error);

      if (error instanceof SquareError) {
        const errorDetail = error.errors?.[0]?.detail || error.message || "Unknown error";
        throw new Error(`Square API error: ${errorDetail}`);
      }

      throw error;
    }
  }

  /**
   * Verify a payment after redirect from Square
   * @param checkoutId - The checkout ID from Square
   * @returns Payment verification result
   */
  async verifyPayment(checkoutId: string, paymentId?: string): Promise<PaymentResult> {
    try {
      if (!checkoutId) {
        return {
          success: false,
          error: "Missing checkout ID",
        };
      }

      const paymentLinkResponse = await this.client.checkout.paymentLinks.get({
        id: checkoutId,
      });
      const paymentLink = paymentLinkResponse.paymentLink;

      if (!paymentLink) {
        return {
          success: false,
          error: "Checkout session not found",
        };
      }

      let resolvedPaymentId = paymentId ?? null;
      const paymentLinkOrderId = paymentLink.orderId;

      let order: Square.Order | null = null;

      if (paymentLinkOrderId) {
        try {
          const orderResponse = await this.client.orders.get({
            orderId: paymentLinkOrderId,
          });
          order = orderResponse.order ?? null;
        } catch (orderError) {
          console.warn("Failed to fetch order for payment verification", orderError);
        }
      }

      if (!resolvedPaymentId && order) {
        resolvedPaymentId =
          order.tenders?.find((tender) => tender.paymentId)?.paymentId ?? null;
      }

      if (!resolvedPaymentId) {
        return {
          success: false,
          error: "Payment still pending or not available",
        };
      }

      let paymentResponse = await this.client.payments.get({
        paymentId: resolvedPaymentId,
      });
      let payment = paymentResponse.payment;

      if (!payment) {
        return {
          success: false,
          error: "Payment not found",
        };
      }

      if (
        payment.orderId &&
        paymentLinkOrderId &&
        payment.orderId !== paymentLinkOrderId
      ) {
        return {
          success: false,
          error: "Payment does not match checkout session",
        };
      }

      if (payment.status === "APPROVED") {
        try {
          await this.client.payments.complete({ paymentId: resolvedPaymentId });
          paymentResponse = await this.client.payments.get({
            paymentId: resolvedPaymentId,
          });
          payment = paymentResponse.payment;
        } catch (completeError) {
          console.warn("Failed to capture approved payment", completeError);
        }
      }

      if (!payment?.status || payment.status !== "COMPLETED") {
        return {
          success: false,
          error: `Payment status is ${payment?.status ?? "unknown"}`,
        };
      }

      const expectedAmount = order?.totalMoney?.amount ?? null;

      const actualAmount =
        payment.amountMoney?.amount ?? payment.totalMoney?.amount ?? null;

      if (
        expectedAmount !== null &&
        actualAmount !== null &&
        actualAmount !== expectedAmount
      ) {
        console.warn("Payment amount does not match checkout amount", {
          paymentAmount: actualAmount?.toString(),
          expectedAmount: expectedAmount.toString(),
          paymentId: payment.id,
          checkoutId,
        });
      }

      const amountBigint =
        payment.amountMoney?.amount ?? payment.totalMoney?.amount ?? null;
      const normalizedAmount = amountBigint !== null ? Number(amountBigint) : null;
      const currency =
        payment.amountMoney?.currency ?? payment.totalMoney?.currency ?? null;

      return {
        success: true,
        paymentId: payment.id ?? resolvedPaymentId,
        orderId: payment.orderId ?? paymentLinkOrderId ?? null,
        status: payment.status ?? null,
        amount: normalizedAmount,
        currency: currency ?? null,
      };
    } catch (error) {
      console.error("Payment verification error:", error);

      if (error instanceof SquareError) {
        const errorDetail = error.errors?.[0]?.detail || error.message || "Unknown error";
        return {
          success: false,
          error: `Square API error: ${errorDetail}`,
        };
      }

      return {
        success: false,
        error: error instanceof Error ? error.message : "Failed to verify payment",
      };
    }
  }

  /**
   * Process a webhook from Square
   * @param payload - Webhook payload
   * @param signature - Webhook signature for verification
   * @returns Processing result
   */
  async processWebhook(
    payload: unknown,
    signature: string,
  ): Promise<{ processed: boolean; error?: string }> {
    try {
      const webhookSignatureKey = process.env["SQUARE_WEBHOOK_SIGNATURE_KEY"];

      if (!webhookSignatureKey) {
        console.error("SQUARE_WEBHOOK_SIGNATURE_KEY not configured");
        return {
          processed: false,
          error: "Webhook signature key not configured",
        };
      }

      // Verify webhook signature using Square's WebhooksHelper
      const isValid = await WebhooksHelper.verifySignature({
        requestBody: JSON.stringify(payload),
        signatureHeader: signature,
        signatureKey: webhookSignatureKey,
        notificationUrl: process.env["SQUARE_WEBHOOK_URL"] || "",
      });

      if (!isValid && process.env["NODE_ENV"] !== "development") {
        return {
          processed: false,
          error: "Invalid webhook signature",
        };
      }

      // Process webhook based on type
      const event = payload as { type: string; data: unknown };
      const eventType = event.type;
      const eventTimestamp = new Date().toISOString();

      switch (eventType) {
        case "payment.created":
        case "payment.updated":
          // Handle payment events
          {
            const eventData = event.data as Record<string, unknown> | undefined;
            const paymentObj = eventData?.["object"] as
              | Record<string, unknown>
              | undefined;
            const payment = paymentObj?.["payment"] as
              | Record<string, unknown>
              | undefined;

            if (!payment) break;

            const paymentId = payment["id"] as string | undefined;
            const orderId = payment["order_id"] as string | undefined;
            const status = (payment["status"] as string | undefined)?.toUpperCase();

            try {
              const { getDb } = await import("~/db/server-helpers");
              const db = await getDb();

              let session: typeof membershipPaymentSessions.$inferSelect | null = null;

              if (paymentId) {
                const [foundByPayment] = await db
                  .select()
                  .from(membershipPaymentSessions)
                  .where(eq(membershipPaymentSessions.squarePaymentId, paymentId))
                  .limit(1);

                session = foundByPayment ?? null;
              }

              if (!session && orderId) {
                const [foundByOrder] = await db
                  .select()
                  .from(membershipPaymentSessions)
                  .where(eq(membershipPaymentSessions.squareOrderId, orderId))
                  .limit(1);

                session = foundByOrder ?? null;
              }

              if (session) {
                const statusMap: Record<string, typeof session.status> = {
                  COMPLETED: "completed",
                  APPROVED: "completed",
                  FAILED: "failed",
                  CANCELED: "cancelled",
                  CANCELED_BY_CUSTOMER: "cancelled",
                };

                const nextStatus = statusMap[status ?? ""] ?? session.status;
                const nextPaymentId = paymentId ?? session.squarePaymentId ?? undefined;

                await db
                  .update(membershipPaymentSessions)
                  .set({
                    status: nextStatus,
                    squarePaymentId: nextPaymentId ?? session.squarePaymentId,
                    squareOrderId: orderId ?? session.squareOrderId,
                    metadata: {
                      ...(session.metadata ?? {}),
                      lastWebhookEvent: eventType,
                      lastWebhookAt: eventTimestamp,
                      squarePaymentStatus: status,
                    },
                    updatedAt: new Date(),
                  })
                  .where(eq(membershipPaymentSessions.id, session.id));
              }
            } catch (dbError) {
              console.error("Failed to update payment session from webhook:", dbError);
            }
          }
          break;

        case "refund.created":
        case "refund.updated":
          // Handle refund events
          {
            const eventData = event.data as Record<string, unknown> | undefined;
            const refundObj = eventData?.["object"] as
              | Record<string, unknown>
              | undefined;
            const refund = refundObj?.["refund"] as Record<string, unknown> | undefined;
            if (!refund) break;

            const refundId = refund["id"] as string | undefined;
            const paymentId = refund["payment_id"] as string | undefined;
            const status = (refund["status"] as string | undefined)?.toUpperCase();

            if (!paymentId) break;

            try {
              const { getDb } = await import("~/db/server-helpers");
              const db = await getDb();

              const [session] = await db
                .select()
                .from(membershipPaymentSessions)
                .where(eq(membershipPaymentSessions.squarePaymentId, paymentId))
                .limit(1);

              if (session) {
                await db
                  .update(membershipPaymentSessions)
                  .set({
                    metadata: {
                      ...(session.metadata ?? {}),
                      lastRefundStatus: status,
                      lastRefundId: refundId,
                      lastRefundAt: eventTimestamp,
                    },
                    updatedAt: new Date(),
                  })
                  .where(eq(membershipPaymentSessions.id, session.id));
              }

              const [membershipRecord] = await db
                .select()
                .from(memberships)
                .where(eq(memberships.paymentId, paymentId))
                .limit(1);

              if (membershipRecord) {
                const targetStatus =
                  status === "COMPLETED" ? "cancelled" : membershipRecord.status;

                await db
                  .update(memberships)
                  .set({
                    status: targetStatus,
                    metadata: {
                      ...(membershipRecord.metadata ?? {}),
                      refundId,
                      refundStatus: status,
                      refundUpdatedAt: eventTimestamp,
                    },
                    updatedAt: new Date(),
                  })
                  .where(eq(memberships.id, membershipRecord.id));
              }
            } catch (dbError) {
              console.error("Failed to update records from refund webhook:", dbError);
            }
          }
          break;

        default:
          console.log("Unknown webhook event type:", eventType);
      }

      return {
        processed: true,
      };
    } catch (error) {
      console.error("Webhook processing error:", error);

      return {
        processed: false,
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }

  /**
   * Get payment details
   * @param paymentId - The payment ID to look up
   * @returns Payment details or null
   */
  async getPaymentDetails(paymentId: string): Promise<{
    id: string;
    status: string;
    amount: number;
    currency: string;
    createdAt: Date;
    receiptUrl?: string | undefined;
  } | null> {
    try {
      if (!paymentId) return null;

      const result = await this.client.payments.get({ paymentId });

      if (!result.payment) {
        return null;
      }

      return {
        id: result.payment.id!,
        status: result.payment.status || "unknown",
        amount: Number(result.payment.amountMoney?.amount || 0),
        currency: result.payment.amountMoney?.currency || "CAD",
        createdAt: new Date(result.payment.createdAt!),
        receiptUrl: result.payment.receiptUrl || undefined,
      };
    } catch (error) {
      console.error("Error fetching payment details:", error);
      return null;
    }
  }

  /**
   * Create a refund for a payment
   * @param paymentId - The payment ID to refund
   * @param amount - Amount to refund in cents (optional, defaults to full refund)
   * @param reason - Reason for the refund
   * @returns Refund result
   */
  async createRefund(
    paymentId: string,
    amount?: number,
    reason?: string,
  ): Promise<{ success: boolean; refundId?: string; error?: string }> {
    try {
      const idempotencyKey = createId();

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const request: any = {
        idempotencyKey,
        paymentId,
        reason: reason || "Customer requested refund",
      };

      if (amount) {
        request.amountMoney = {
          amount: BigInt(amount),
          currency: "CAD",
        };
      }

      const result = await this.client.refunds.refundPayment(request);

      if (!result.refund?.id) {
        return {
          success: false,
          error: "Failed to create refund",
        };
      }

      return {
        success: true,
        refundId: result.refund.id,
      };
    } catch (error) {
      console.error("Refund creation error:", error);

      if (error instanceof SquareError) {
        const errorDetail = error.errors?.[0]?.detail || error.message || "Unknown error";
        return {
          success: false,
          error: `Square API error: ${errorDetail}`,
        };
      }

      return {
        success: false,
        error: "Failed to create refund",
      };
    }
  }
}

// Export function to get the appropriate service based on environment
export function getSquarePaymentService() {
  const useRealSquare =
    process.env["SQUARE_ENV"] === "production" || process.env["SQUARE_ENV"] === "sandbox";

  if (useRealSquare && process.env["SQUARE_ACCESS_TOKEN"]) {
    return new SquarePaymentService();
  }

  // Fall back to mock service if not configured
  console.warn("Square not configured, using mock payment service");
  return null; // Will fall back to mock in the main square.ts file
}
</file>

<file path="src/lib/payments/square.ts">
/**
 * Square payment integration helper
 * Switches between mock and real implementation based on environment
 */

import { createId } from "@paralleldrive/cuid2";
import { serverOnly } from "@tanstack/react-start";

// This module should only be imported in server-side code

export interface CheckoutSession {
  id: string;
  checkoutUrl: string;
  membershipTypeId: string;
  userId: string;
  amount: number;
  currency: string;
  status: "pending" | "completed" | "cancelled";
  expiresAt: Date;
  orderId?: string | null;
}

export interface PaymentResult {
  success: boolean;
  paymentId?: string;
  error?: string;
  orderId?: string | null;
  status?: string | null;
  amount?: number | null;
  currency?: string | null;
}

/**
 * Mock Square payment helper
 * Returns fake checkout URLs and payment confirmations for development
 */
export class MockSquarePaymentService {
  constructor() {
    console.log("Using MOCK Square payment service");
  }

  /**
   * Create a checkout session for membership purchase
   * @param membershipTypeId - ID of the membership type to purchase
   * @param userId - ID of the user making the purchase
   * @param amount - Amount in cents
   * @returns Checkout session with URL to redirect user
   */
  async createCheckoutSession(
    membershipTypeId: string,
    userId: string,
    amount: number,
  ): Promise<CheckoutSession> {
    // Mock implementation - returns a fake checkout URL
    const sessionId = createId();
    // Import the server env to get base URL
    const { getBaseUrl } = await import("~/lib/env.server");
    const baseUrl = getBaseUrl();

    // In real implementation, this would call Square's Checkout API
    const checkoutSession: CheckoutSession = {
      id: sessionId,
      // Mock checkout URL - in production this would be a Square URL
      checkoutUrl: `${baseUrl}/dashboard/membership?mock_checkout=true&session=${sessionId}&type=${membershipTypeId}&amount=${amount}`,
      membershipTypeId,
      userId,
      amount,
      currency: "CAD",
      status: "pending",
      expiresAt: new Date(Date.now() + 30 * 60 * 1000), // 30 minutes
      orderId: null,
    };

    // In production, we would store this session in the database
    // For now, we'll just return it
    return checkoutSession;
  }

  /**
   * Verify a payment after redirect from Square
   * @param sessionId - The checkout session ID
   * @param paymentId - The payment ID from Square (optional in mock)
   * @returns Payment verification result
   */
  async verifyPayment(sessionId: string, paymentId?: string): Promise<PaymentResult> {
    // Mock implementation - always returns success
    // In real implementation, this would verify with Square API

    if (!sessionId) {
      return {
        success: false,
        error: "Missing session ID",
      };
    }

    // Simulate API delay
    await new Promise((resolve) => setTimeout(resolve, 500));

    return {
      success: true,
      paymentId: paymentId || `mock_payment_${createId()}`,
      orderId: sessionId,
      status: "COMPLETED",
      amount: null,
      currency: "CAD",
    };
  }

  /**
   * Process a webhook from Square
   * @param payload - Webhook payload
   * @param signature - Webhook signature for verification
   * @returns Processing result
   */
  async processWebhook(
    payload: unknown,
    signature: string,
  ): Promise<{ processed: boolean; error?: string }> {
    // Mock implementation - not used in development

    console.log("Mock webhook received:", { payload, signature });

    return {
      processed: true,
    };
  }

  /**
   * Get payment details
   * @param paymentId - The payment ID to look up
   * @returns Payment details or null
   */
  async getPaymentDetails(paymentId: string): Promise<{
    id: string;
    status: string;
    amount: number;
    currency: string;
    createdAt: Date;
    receiptUrl?: string | undefined;
  } | null> {
    // Mock implementation
    // In production, this would fetch from Square API

    if (!paymentId) return null;

    return {
      id: paymentId,
      status: "completed",
      amount: 4500, // $45.00 in cents
      currency: "CAD",
      createdAt: new Date(),
    };
  }

  /**
   * Create a refund for a payment (mock)
   * @param paymentId - The payment ID to refund
   * @param amount - Amount to refund in cents (optional, defaults to full refund)
   * @param reason - Reason for the refund
   * @returns Refund result
   */
  async createRefund(
    paymentId: string,
    amount?: number,
    reason?: string,
  ): Promise<{ success: boolean; refundId?: string; error?: string }> {
    // Mock implementation
    console.log("Mock refund created:", { paymentId, amount, reason });

    return {
      success: true,
      refundId: `mock_refund_${createId()}`,
    };
  }
}

// Type for the payment service interface
export type ISquarePaymentService = MockSquarePaymentService;

// Server-only function to get the appropriate payment service
const getSquarePaymentServiceInternal = serverOnly(async () => {
  const useRealSquare =
    process.env["SQUARE_ENV"] === "production" || process.env["SQUARE_ENV"] === "sandbox";

  if (useRealSquare && process.env["SQUARE_ACCESS_TOKEN"]) {
    try {
      const { getSquarePaymentService: getRealService } = await import("./square-real");
      const realService = getRealService();
      if (realService) {
        console.log("Using REAL Square payment service");
        return realService;
      }
    } catch (error) {
      console.error("Failed to load real Square service:", error);
    }
  }

  // Fall back to mock service
  return new MockSquarePaymentService();
});

// Export singleton instance getter
export const getSquarePaymentService = async (): Promise<ISquarePaymentService> => {
  return getSquarePaymentServiceInternal();
};

// For backward compatibility
export const squarePaymentService = {
  createCheckoutSession: async (
    ...args: Parameters<ISquarePaymentService["createCheckoutSession"]>
  ) => {
    const service = await getSquarePaymentService();
    return service.createCheckoutSession(...args);
  },
  verifyPayment: async (...args: Parameters<ISquarePaymentService["verifyPayment"]>) => {
    const service = await getSquarePaymentService();
    return service.verifyPayment(...args);
  },
  processWebhook: async (
    ...args: Parameters<ISquarePaymentService["processWebhook"]>
  ) => {
    const service = await getSquarePaymentService();
    return service.processWebhook(...args);
  },
  getPaymentDetails: async (
    ...args: Parameters<ISquarePaymentService["getPaymentDetails"]>
  ) => {
    const service = await getSquarePaymentService();
    return service.getPaymentDetails(...args);
  },
};
</file>

<file path="src/features/membership/membership.queries.ts">
import { createServerFn } from "@tanstack/react-start";
import { getMembershipTypeSchema } from "./membership.schemas";
import type {
  MembershipOperationResult,
  MembershipStatus,
  UserMembership,
} from "./membership.types";

/**
 * List all active membership types available for purchase
 */
export const listMembershipTypes = createServerFn({ method: "GET" }).handler(
  async (): Promise<
    MembershipOperationResult<import("./membership.types").MembershipType[]>
  > => {
    try {
      // Import server-only modules inside the handler
      const { getDb } = await import("~/db/server-helpers");

      // Import database dependencies inside handler
      const { eq } = await import("drizzle-orm");
      const { membershipTypes } = await import("~/db/schema");

      const db = await getDb();

      const activeTypes = await db
        .select()
        .from(membershipTypes)
        .where(eq(membershipTypes.status, "active"))
        .orderBy(membershipTypes.priceCents);

      return {
        success: true,
        data: activeTypes,
      };
    } catch (error) {
      console.error("Error fetching membership types:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to fetch membership types",
          },
        ],
      };
    }
  },
);

/**
 * Get a specific membership type by ID
 */
export const getMembershipType = createServerFn({ method: "GET" })
  .validator(getMembershipTypeSchema.parse)
  .handler(
    async ({
      data,
    }): Promise<
      MembershipOperationResult<import("./membership.types").MembershipType>
    > => {
      try {
        // Import server-only modules inside the handler
        const { getDb } = await import("~/db/server-helpers");

        // Import database dependencies inside handler
        const { eq } = await import("drizzle-orm");
        const { membershipTypes } = await import("~/db/schema");

        const db = await getDb();

        const [membershipType] = await db
          .select()
          .from(membershipTypes)
          .where(eq(membershipTypes.id, data.membershipTypeId))
          .limit(1);

        if (!membershipType) {
          return {
            success: false,
            errors: [
              {
                code: "NOT_FOUND",
                message: "Membership type not found",
              },
            ],
          };
        }

        return {
          success: true,
          data: membershipType,
        };
      } catch (error) {
        console.error("Error fetching membership type:", error);
        return {
          success: false,
          errors: [
            {
              code: "DATABASE_ERROR",
              message: "Failed to fetch membership type",
            },
          ],
        };
      }
    },
  );

/**
 * Get current user's membership status
 */
export const getUserMembershipStatus = createServerFn({ method: "GET" }).handler(
  async (): Promise<MembershipOperationResult<MembershipStatus>> => {
    try {
      // Import server-only modules inside the handler
      const [{ getDb }, { getAuth }] = await Promise.all([
        import("~/db/server-helpers"),
        import("~/lib/auth/server-helpers"),
      ]);

      const auth = await getAuth();
      const { getWebRequest } = await import("@tanstack/react-start/server");
      const { headers } = getWebRequest();
      const session = await auth.api.getSession({ headers });

      if (!session?.user?.id) {
        return {
          success: false,
          errors: [
            {
              code: "VALIDATION_ERROR",
              message: "User not authenticated",
            },
          ],
        };
      }

      // Import database dependencies inside handler
      const { and, eq, gte, sql } = await import("drizzle-orm");
      const { membershipTypes, memberships } = await import("~/db/schema");

      // Get active membership for the user
      const db = await getDb();

      const [currentMembership] = await db
        .select({
          membership: memberships,
          membershipType: membershipTypes,
        })
        .from(memberships)
        .innerJoin(membershipTypes, eq(memberships.membershipTypeId, membershipTypes.id))
        .where(
          and(
            eq(memberships.userId, session.user.id),
            eq(memberships.status, "active"),
            gte(memberships.endDate, sql`CURRENT_DATE`),
          ),
        )
        .orderBy(sql`${memberships.endDate} DESC`)
        .limit(1);

      if (!currentMembership) {
        return {
          success: true,
          data: {
            hasMembership: false,
          },
        };
      }

      const endDate = new Date(currentMembership.membership.endDate);
      const daysRemaining = Math.ceil(
        (endDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24),
      );

      const userMembership: UserMembership = {
        ...currentMembership.membership,
        membershipType: currentMembership.membershipType,
      };

      return {
        success: true,
        data: {
          hasMembership: true,
          currentMembership: userMembership,
          expiresAt: endDate,
          daysRemaining,
        },
      };
    } catch (error) {
      console.error("Error fetching membership status:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to fetch membership status",
          },
        ],
      };
    }
  },
);
</file>

<file path="src/lib/env.server.ts">
/**
 * Server-only environment configuration
 * This module should only be imported in server-side code
 */

// This module should only be imported in server-side code

// Load dotenv synchronously before createEnv is called
import dotenv from "dotenv";
if (import.meta.env.SSR && import.meta.env.DEV) {
  dotenv.config();
  dotenv.config({ path: ".env", override: true });
}

import { createEnv } from "@t3-oss/env-core";
import { z } from "zod";

export const env = createEnv({
  server: {
    // Database
    DATABASE_URL: z.string().url(),
    DATABASE_URL_UNPOOLED: z.string().url().optional(),
    DATABASE_POOLED_URL: z.string().url().optional(),
    DATABASE_UNPOOLED_URL: z.string().url().optional(),
    NETLIFY_DATABASE_URL: z.string().url().optional(),
    NETLIFY_DATABASE_URL_UNPOOLED: z.string().url().optional(),

    // Auth
    BETTER_AUTH_SECRET: z
      .string()
      .min(1, "BETTER_AUTH_SECRET must be set")
      .default("dev-secret-change-in-production"),
    GOOGLE_CLIENT_ID: z.string().optional(),
    GOOGLE_CLIENT_SECRET: z.string().optional(),

    // Square Payment Integration
    SQUARE_ENV: z.enum(["sandbox", "production"]).optional(),
    SQUARE_APPLICATION_ID: z.string().optional(),
    SQUARE_ACCESS_TOKEN: z.string().optional(),
    SQUARE_LOCATION_ID: z.string().optional(),
    SQUARE_WEBHOOK_SIGNATURE_KEY: z.string().optional(),
    SQUARE_WEBHOOK_URL: z.string().url().optional(),
    SUPPORT_EMAIL: z.string().email().optional(),

    // SendGrid Email Integration
    SENDGRID_API_KEY: z.string().optional(),
    SENDGRID_FROM_EMAIL: z.string().email().optional(),
    SENDGRID_FROM_NAME: z.string().optional(),

    // Other
    COOKIE_DOMAIN: z.string().optional(),
    NODE_ENV: z.enum(["development", "production", "test"]).default("development"),
    NETLIFY: z.string().optional(),
    VERCEL_ENV: z.string().optional(),

    // Client vars are also available on server
    // In production, Netlify provides URL env var
    VITE_BASE_URL: z.string().url().optional(),

    // Netlify automatically provides these
    URL: z.string().url().optional(), // The main URL of the site
    SITE_URL: z.string().url().optional(), // The site's URL
    DEPLOY_URL: z.string().url().optional(), // The specific deploy URL
    DEPLOY_PRIME_URL: z.string().url().optional(), // The prime URL for the deploy
  },
  // Use process.env since we've just loaded .env
  runtimeEnv: process.env,
  emptyStringAsUndefined: true,
});

// Helper functions
export const getDbUrl = () => env.DATABASE_URL;

export const getPooledDbUrl = () =>
  env.DATABASE_POOLED_URL || env.NETLIFY_DATABASE_URL || env.DATABASE_URL;

export const getUnpooledDbUrl = () =>
  env.DATABASE_UNPOOLED_URL ||
  env.DATABASE_URL_UNPOOLED ||
  env.NETLIFY_DATABASE_URL_UNPOOLED ||
  env.DATABASE_URL;

export const getBaseUrl = () => {
  // Check if we have any Netlify-provided URLs (indicates we're in Netlify environment)
  const netlifyUrl = env.URL || env.SITE_URL || env.DEPLOY_PRIME_URL || env.DEPLOY_URL;

  // Check if we're in a Netlify environment by looking for Netlify-specific env vars
  const isNetlifyEnv = !!(env.NETLIFY || env.NETLIFY_DATABASE_URL || netlifyUrl);

  // In production, Netlify environment, or when we have a URL, use it
  if (isProduction() || isNetlifyEnv) {
    // If we have a Netlify URL, use it; otherwise fall back to VITE_BASE_URL or a default
    return netlifyUrl || env.VITE_BASE_URL || "https://app.netlify.com";
  }

  // In development/test, require VITE_BASE_URL
  if (!env.VITE_BASE_URL) {
    throw new Error("VITE_BASE_URL is required in development");
  }
  return env.VITE_BASE_URL;
};
export const getAuthSecret = () => env.BETTER_AUTH_SECRET;

export const isProduction = () => env.NODE_ENV === "production";
export const isDevelopment = () => env.NODE_ENV === "development";
export const isTest = () => env.NODE_ENV === "test";
export const isServerless = () => !!(env.NETLIFY || env.VERCEL_ENV);
</file>

<file path="src/features/membership/membership.mutations.ts">
import { createServerFn, serverOnly } from "@tanstack/react-start";
import { and, eq } from "drizzle-orm";
import { membershipPaymentSessions, memberships, membershipTypes } from "~/db/schema";
import type { MembershipMetadata } from "./membership.db-types";
import {
  confirmMembershipPurchaseSchema,
  purchaseMembershipSchema,
} from "./membership.schemas";
import type {
  CheckoutSessionResult,
  Membership,
  MembershipOperationResult,
} from "./membership.types";

// Helper to cast membership jsonb fields
function castMembershipJsonbFields(
  membership: typeof memberships.$inferSelect,
): Membership {
  return {
    ...membership,
    metadata: (membership.metadata || {}) as MembershipMetadata,
  } as Membership;
}

/**
 * Server-only helper to get Square payment service
 * This ensures the Square module is never included in the client bundle
 */
const getSquarePaymentService = serverOnly(async () => {
  const { squarePaymentService } = await import("~/lib/payments/square");
  return squarePaymentService;
});

/**
 * Create a checkout session for membership purchase
 */
export const createCheckoutSession = createServerFn({ method: "POST" })
  .validator(purchaseMembershipSchema.omit({ autoRenew: true }).parse)
  .handler(
    async ({ data }): Promise<MembershipOperationResult<CheckoutSessionResult>> => {
      try {
        // Import server-only modules inside the handler
        const [{ getDb }, { getAuth }] = await Promise.all([
          import("~/db/server-helpers"),
          import("~/lib/auth/server-helpers"),
        ]);

        const db = await getDb();
        const auth = await getAuth();
        const { getWebRequest } = await import("@tanstack/react-start/server");
        const { headers } = getWebRequest();
        const session = await auth.api.getSession({ headers });

        if (!session?.user?.id) {
          return {
            success: false,
            errors: [
              {
                code: "VALIDATION_ERROR",
                message: "User not authenticated",
              },
            ],
          };
        }

        // Verify membership type exists and is active

        const [membershipType] = await db
          .select()
          .from(membershipTypes)
          .where(
            and(
              eq(membershipTypes.id, data.membershipTypeId),
              eq(membershipTypes.status, "active"),
            ),
          )
          .limit(1);

        if (!membershipType) {
          return {
            success: false,
            errors: [
              {
                code: "NOT_FOUND",
                message: "Membership type not found or inactive",
              },
            ],
          };
        }

        // Check if user already has an active membership
        const [existingMembership] = await db
          .select()
          .from(memberships)
          .where(
            and(
              eq(memberships.userId, session.user.id),
              eq(memberships.status, "active"),
            ),
          )
          .limit(1);

        if (existingMembership) {
          return {
            success: false,
            errors: [
              {
                code: "VALIDATION_ERROR",
                message: "User already has an active membership",
              },
            ],
          };
        }

        // Create checkout session with Square
        const squarePaymentService = await getSquarePaymentService();
        const checkoutSession = await squarePaymentService.createCheckoutSession(
          membershipType.id,
          session.user.id,
          membershipType.priceCents,
        );

        await db
          .insert(membershipPaymentSessions)
          .values({
            userId: session.user.id,
            membershipTypeId: membershipType.id,
            squareCheckoutId: checkoutSession.id,
            squarePaymentLinkUrl: checkoutSession.checkoutUrl,
            squareOrderId: checkoutSession.orderId || null,
            amountCents: membershipType.priceCents,
            currency: checkoutSession.currency,
            expiresAt: checkoutSession.expiresAt ?? null,
            metadata: {
              membershipName: membershipType.name,
              squareOrderId: checkoutSession.orderId || null,
            },
          })
          .onConflictDoUpdate({
            target: membershipPaymentSessions.squareCheckoutId,
            set: {
              membershipTypeId: membershipType.id,
              squarePaymentLinkUrl: checkoutSession.checkoutUrl,
              squareOrderId: checkoutSession.orderId || null,
              amountCents: membershipType.priceCents,
              currency: checkoutSession.currency,
              expiresAt: checkoutSession.expiresAt ?? null,
              metadata: {
                membershipName: membershipType.name,
                squareOrderId: checkoutSession.orderId || null,
              },
              updatedAt: new Date(),
            },
          });

        return {
          success: true,
          data: {
            checkoutUrl: checkoutSession.checkoutUrl,
            sessionId: checkoutSession.id,
          },
        };
      } catch (error) {
        console.error("Error creating checkout session:", error);
        return {
          success: false,
          errors: [
            {
              code: "PAYMENT_ERROR",
              message: "Failed to create checkout session",
            },
          ],
        };
      }
    },
  );

/**
 * Confirm membership purchase after payment
 */
export const confirmMembershipPurchase = createServerFn({ method: "POST" })
  .validator(confirmMembershipPurchaseSchema.parse)
  .handler(async ({ data }): Promise<MembershipOperationResult<Membership>> => {
    try {
      // Import server-only modules inside the handler
      const [{ getDb }, { getAuth }] = await Promise.all([
        import("~/db/server-helpers"),
        import("~/lib/auth/server-helpers"),
      ]);

      const db = await getDb();
      const auth = await getAuth();
      const { getWebRequest } = await import("@tanstack/react-start/server");
      const { headers } = getWebRequest();
      const session = await auth.api.getSession({ headers });

      if (!session?.user?.id) {
        return {
          success: false,
          errors: [
            {
              code: "VALIDATION_ERROR",
              message: "User not authenticated",
            },
          ],
        };
      }

      // Look up the stored payment session
      const [paymentSession] = await db
        .select()
        .from(membershipPaymentSessions)
        .where(eq(membershipPaymentSessions.squareCheckoutId, data.sessionId))
        .limit(1);

      if (!paymentSession) {
        return {
          success: false,
          errors: [
            {
              code: "NOT_FOUND",
              message: "Checkout session not found",
            },
          ],
        };
      }

      if (paymentSession.userId !== session.user.id) {
        return {
          success: false,
          errors: [
            {
              code: "VALIDATION_ERROR",
              message: "Payment session does not belong to user",
            },
          ],
        };
      }

      if (data.membershipTypeId !== paymentSession.membershipTypeId) {
        return {
          success: false,
          errors: [
            {
              code: "VALIDATION_ERROR",
              message: "Membership type mismatch",
            },
          ],
        };
      }

      if (paymentSession.status === "completed" && paymentSession.squarePaymentId) {
        const [existingMembershipByPayment] = await db
          .select()
          .from(memberships)
          .where(eq(memberships.paymentId, paymentSession.squarePaymentId))
          .limit(1);

        if (existingMembershipByPayment) {
          return {
            success: true,
            data: castMembershipJsonbFields(existingMembershipByPayment),
          };
        }
      }

      // Verify payment with Square
      const squarePaymentService = await getSquarePaymentService();
      const paymentResult = await squarePaymentService.verifyPayment(
        paymentSession.squareCheckoutId,
        data.paymentId ?? paymentSession.squarePaymentId ?? undefined,
      );

      if (!paymentResult.success) {
        await db
          .update(membershipPaymentSessions)
          .set({
            status: paymentSession.status === "completed" ? "completed" : "failed",
            metadata: {
              ...(paymentSession.metadata ?? {}),
              lastError: paymentResult.error || "Payment verification failed",
              lastErrorAt: new Date().toISOString(),
            },
            updatedAt: new Date(),
          })
          .where(eq(membershipPaymentSessions.id, paymentSession.id));

        return {
          success: false,
          errors: [
            {
              code: "PAYMENT_ERROR",
              message: paymentResult.error || "Payment verification failed",
            },
          ],
        };
      }

      const squarePaymentId =
        paymentResult.paymentId ?? data.paymentId ?? paymentSession.squarePaymentId;

      if (!squarePaymentId) {
        return {
          success: false,
          errors: [
            {
              code: "PAYMENT_ERROR",
              message: "Missing payment identifier",
            },
          ],
        };
      }

      // Get membership type details

      const [membershipType] = await db
        .select()
        .from(membershipTypes)
        .where(eq(membershipTypes.id, data.membershipTypeId))
        .limit(1);

      if (!membershipType) {
        return {
          success: false,
          errors: [
            {
              code: "NOT_FOUND",
              message: "Membership type not found",
            },
          ],
        };
      }

      if (
        typeof paymentResult.amount === "number" &&
        paymentResult.amount !== membershipType.priceCents
      ) {
        return {
          success: false,
          errors: [
            {
              code: "PAYMENT_ERROR",
              message: "Payment amount does not match membership price",
            },
          ],
        };
      }

      if (paymentResult.currency && paymentResult.currency !== "CAD") {
        return {
          success: false,
          errors: [
            {
              code: "PAYMENT_ERROR",
              message: "Payment currency is not supported",
            },
          ],
        };
      }

      const confirmedMembership = await db.transaction(async (tx) => {
        const [existingMembershipByPayment] = await tx
          .select()
          .from(memberships)
          .where(eq(memberships.paymentId, squarePaymentId))
          .limit(1);

        if (existingMembershipByPayment) {
          await tx
            .update(membershipPaymentSessions)
            .set({
              status: "completed",
              squarePaymentId,
              squareOrderId: paymentResult.orderId ?? paymentSession.squareOrderId,
              metadata: {
                ...(paymentSession.metadata ?? {}),
                membershipId: existingMembershipByPayment.id,
                paymentConfirmedAt: new Date().toISOString(),
                squareOrderId: paymentResult.orderId ?? paymentSession.squareOrderId,
              },
              updatedAt: new Date(),
            })
            .where(eq(membershipPaymentSessions.id, paymentSession.id));

          return existingMembershipByPayment;
        }

        // Calculate membership dates
        const startDate = new Date();
        const endDate = new Date();
        endDate.setMonth(endDate.getMonth() + membershipType.durationMonths);

        const [newMembership] = await tx
          .insert(memberships)
          .values({
            userId: session.user.id,
            membershipTypeId: membershipType.id,
            startDate: startDate.toISOString().split("T")[0],
            endDate: endDate.toISOString().split("T")[0],
            status: "active",
            paymentProvider: "square",
            paymentId: squarePaymentId,
            metadata: {
              ...(paymentSession.metadata ?? {}),
              sessionId: data.sessionId,
              purchasedAt: new Date().toISOString(),
            },
          })
          .returning();

        await tx
          .update(membershipPaymentSessions)
          .set({
            status: "completed",
            squarePaymentId,
            squareOrderId: paymentResult.orderId ?? paymentSession.squareOrderId,
            metadata: {
              ...(paymentSession.metadata ?? {}),
              membershipId: newMembership.id,
              paymentConfirmedAt: new Date().toISOString(),
              squareOrderId: paymentResult.orderId ?? paymentSession.squareOrderId,
            },
            updatedAt: new Date(),
          })
          .where(eq(membershipPaymentSessions.id, paymentSession.id));

        return newMembership;
      });

      // Send confirmation email
      try {
        const { sendMembershipPurchaseReceipt } = await import("~/lib/email/sendgrid");

        await sendMembershipPurchaseReceipt({
          to: {
            email: session.user.email,
            name: session.user.name || undefined,
          },
          membershipType: membershipType.name,
          amount: membershipType.priceCents,
          paymentId: squarePaymentId,
          expiresAt: new Date(confirmedMembership.endDate),
        });
      } catch (emailError) {
        // Log error but don't fail the purchase
        console.error("Failed to send confirmation email:", emailError);
      }

      return {
        success: true,
        data: castMembershipJsonbFields(
          confirmedMembership as typeof memberships.$inferSelect,
        ),
      };
    } catch (error) {
      console.error("Error confirming membership purchase:", error);
      return {
        success: false,
        errors: [
          {
            code: "DATABASE_ERROR",
            message: "Failed to create membership record",
          },
        ],
      };
    }
  });
</file>

</files>

<git_diffs>
<git_diff_work_tree>
diff --git a/src/routeTree.gen.ts b/src/routeTree.gen.ts
index 1ce86ee..1b6d0fc 100644
--- a/src/routeTree.gen.ts
+++ b/src/routeTree.gen.ts
@@ -39,6 +39,7 @@ import { Route as DashboardTeamsTeamIdIndexRouteImport } from "./routes/dashboar
 import { Route as DashboardTeamsTeamIdMembersRouteImport } from "./routes/dashboard/teams/$teamId.members";
 import { Route as DashboardTeamsTeamIdManageRouteImport } from "./routes/dashboard/teams/$teamId.manage";
 import { Route as DashboardEventsEventIdManageRouteImport } from "./routes/dashboard/events/$eventId.manage";
+import { ServerRoute as ApiTestSquareServerRouteImport } from "./routes/api/test-square";
 import { ServerRoute as ApiHealthServerRouteImport } from "./routes/api/health";
 import { ServerRoute as ApiWebhooksSquareServerRouteImport } from "./routes/api/webhooks/square";
 import { ServerRoute as ApiTestCleanupServerRouteImport } from "./routes/api/test/cleanup";
@@ -192,6 +193,11 @@ const DashboardEventsEventIdManageRoute =
     path: "/$eventId/manage",
     getParentRoute: () => DashboardEventsRoute,
   } as any);
+const ApiTestSquareServerRoute = ApiTestSquareServerRouteImport.update({
+  id: "/api/test-square",
+  path: "/api/test-square",
+  getParentRoute: () => rootServerRouteImport,
+} as any);
 const ApiHealthServerRoute = ApiHealthServerRouteImport.update({
   id: "/api/health",
   path: "/api/health",
@@ -409,6 +415,7 @@ export interface RootRouteChildren {
 }
 export interface FileServerRoutesByFullPath {
   "/api/health": typeof ApiHealthServerRoute;
+  "/api/test-square": typeof ApiTestSquareServerRoute;
   "/api/auth/$": typeof ApiAuthSplatServerRoute;
   "/api/test/cleanup": typeof ApiTestCleanupServerRoute;
   "/api/webhooks/square": typeof ApiWebhooksSquareServerRoute;
@@ -417,6 +424,7 @@ export interface FileServerRoutesByFullPath {
 }
 export interface FileServerRoutesByTo {
   "/api/health": typeof ApiHealthServerRoute;
+  "/api/test-square": typeof ApiTestSquareServerRoute;
   "/api/auth/$": typeof ApiAuthSplatServerRoute;
   "/api/test/cleanup": typeof ApiTestCleanupServerRoute;
   "/api/webhooks/square": typeof ApiWebhooksSquareServerRoute;
@@ -426,6 +434,7 @@ export interface FileServerRoutesByTo {
 export interface FileServerRoutesById {
   __root__: typeof rootServerRouteImport;
   "/api/health": typeof ApiHealthServerRoute;
+  "/api/test-square": typeof ApiTestSquareServerRoute;
   "/api/auth/$": typeof ApiAuthSplatServerRoute;
   "/api/test/cleanup": typeof ApiTestCleanupServerRoute;
   "/api/webhooks/square": typeof ApiWebhooksSquareServerRoute;
@@ -436,6 +445,7 @@ export interface FileServerRouteTypes {
   fileServerRoutesByFullPath: FileServerRoutesByFullPath;
   fullPaths:
     | "/api/health"
+    | "/api/test-square"
     | "/api/auth/$"
     | "/api/test/cleanup"
     | "/api/webhooks/square"
@@ -444,6 +454,7 @@ export interface FileServerRouteTypes {
   fileServerRoutesByTo: FileServerRoutesByTo;
   to:
     | "/api/health"
+    | "/api/test-square"
     | "/api/auth/$"
     | "/api/test/cleanup"
     | "/api/webhooks/square"
@@ -452,6 +463,7 @@ export interface FileServerRouteTypes {
   id:
     | "__root__"
     | "/api/health"
+    | "/api/test-square"
     | "/api/auth/$"
     | "/api/test/cleanup"
     | "/api/webhooks/square"
@@ -461,6 +473,7 @@ export interface FileServerRouteTypes {
 }
 export interface RootServerRouteChildren {
   ApiHealthServerRoute: typeof ApiHealthServerRoute;
+  ApiTestSquareServerRoute: typeof ApiTestSquareServerRoute;
   ApiAuthSplatServerRoute: typeof ApiAuthSplatServerRoute;
   ApiTestCleanupServerRoute: typeof ApiTestCleanupServerRoute;
   ApiWebhooksSquareServerRoute: typeof ApiWebhooksSquareServerRoute;
@@ -670,6 +683,13 @@ declare module "@tanstack/react-router" {
 }
 declare module "@tanstack/react-start/server" {
   interface ServerFileRoutesByPath {
+    "/api/test-square": {
+      id: "/api/test-square";
+      path: "/api/test-square";
+      fullPath: "/api/test-square";
+      preLoaderRoute: typeof ApiTestSquareServerRouteImport;
+      parentRoute: typeof rootServerRouteImport;
+    };
     "/api/health": {
       id: "/api/health";
       path: "/api/health";
@@ -841,6 +861,7 @@ export const routeTree = rootRouteImport
   ._addFileTypes<FileRouteTypes>();
 const rootServerRouteChildren: RootServerRouteChildren = {
   ApiHealthServerRoute: ApiHealthServerRoute,
+  ApiTestSquareServerRoute: ApiTestSquareServerRoute,
   ApiAuthSplatServerRoute: ApiAuthSplatServerRoute,
   ApiTestCleanupServerRoute: ApiTestCleanupServerRoute,
   ApiWebhooksSquareServerRoute: ApiWebhooksSquareServerRoute,

</git_diff_work_tree>
<git_diff_staged>

</git_diff_staged>
</git_diffs>
