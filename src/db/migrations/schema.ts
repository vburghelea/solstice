import { sql } from "drizzle-orm";
import {
  boolean,
  date,
  foreignKey,
  index,
  integer,
  jsonb,
  pgEnum,
  pgTable,
  primaryKey,
  real,
  serial,
  text,
  timestamp,
  unique,
  uniqueIndex,
  uuid,
  varchar,
} from "drizzle-orm/pg-core";

export const applicationStatus = pgEnum("application_status", [
  "pending",
  "approved",
  "rejected",
]);
export const campaignRecurrence = pgEnum("campaign_recurrence", [
  "weekly",
  "bi-weekly",
  "monthly",
]);
export const campaignStatus = pgEnum("campaign_status", [
  "active",
  "cancelled",
  "completed",
]);
export const eventStatus = pgEnum("event_status", [
  "draft",
  "published",
  "registration_open",
  "registration_closed",
  "in_progress",
  "completed",
  "cancelled",
]);
export const eventType = pgEnum("event_type", [
  "tournament",
  "league",
  "camp",
  "clinic",
  "social",
  "other",
]);
export const experienceLevel = pgEnum("experience_level", [
  "beginner",
  "intermediate",
  "advanced",
  "expert",
]);
export const gameStatus = pgEnum("game_status", ["scheduled", "canceled", "completed"]);
export const gmStrength = pgEnum("gm_strength", [
  "creativity",
  "world_builder",
  "inclusive",
  "rule_of_cool",
  "storytelling",
  "voices",
  "sets_the_mood",
  "teacher",
  "knows_the_rules",
  "visual_aid",
]);
export const participantRole = pgEnum("participant_role", [
  "owner",
  "player",
  "invited",
  "applicant",
]);
export const participantStatus = pgEnum("participant_status", [
  "approved",
  "rejected",
  "pending",
]);
export const registrationType = pgEnum("registration_type", [
  "team",
  "individual",
  "both",
]);
export const socialAction = pgEnum("social_action", [
  "follow",
  "unfollow",
  "block",
  "unblock",
]);
export const teamMemberRole = pgEnum("team_member_role", [
  "captain",
  "coach",
  "player",
  "substitute",
]);
export const teamMemberStatus = pgEnum("team_member_status", [
  "pending",
  "active",
  "inactive",
  "removed",
]);
export const visibility = pgEnum("visibility", ["public", "protected", "private"]);

export const campaigns = pgTable(
  "campaigns",
  {
    id: uuid().defaultRandom().primaryKey().notNull(),
    ownerId: text("owner_id").notNull(),
    gameSystemId: integer("game_system_id").notNull(),
    name: varchar({ length: 255 }).notNull(),
    description: text().notNull(),
    images: jsonb(),
    recurrence: campaignRecurrence().notNull(),
    timeOfDay: varchar("time_of_day", { length: 255 }).notNull(),
    sessionDuration: real("session_duration").notNull(),
    pricePerSession: real("price_per_session"),
    language: varchar({ length: 255 }).notNull(),
    location: jsonb(),
    status: campaignStatus().default("active").notNull(),
    minimumRequirements: jsonb("minimum_requirements"),
    visibility: visibility().default("public").notNull(),
    safetyRules: jsonb("safety_rules"),
    createdAt: timestamp("created_at", { mode: "string" }).defaultNow().notNull(),
    updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().notNull(),
    sessionZeroData: jsonb("session_zero_data"),
    campaignExpectations: jsonb("campaign_expectations"),
    tableExpectations: jsonb("table_expectations"),
    characterCreationOutcome: text("character_creation_outcome"),
  },
  (table) => [
    foreignKey({
      columns: [table.ownerId],
      foreignColumns: [user.id],
      name: "campaigns_owner_id_user_id_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [table.gameSystemId],
      foreignColumns: [gameSystems.id],
      name: "campaigns_game_system_id_game_systems_id_fk",
    }).onDelete("cascade"),
  ],
);

export const campaignApplications = pgTable(
  "campaign_applications",
  {
    id: uuid().defaultRandom().primaryKey().notNull(),
    campaignId: uuid("campaign_id").notNull(),
    userId: text("user_id").notNull(),
    status: applicationStatus().default("pending").notNull(),
    createdAt: timestamp("created_at", { mode: "string" }).defaultNow().notNull(),
    updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().notNull(),
  },
  (table) => [
    foreignKey({
      columns: [table.campaignId],
      foreignColumns: [campaigns.id],
      name: "campaign_applications_campaign_id_campaigns_id_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [table.userId],
      foreignColumns: [user.id],
      name: "campaign_applications_user_id_user_id_fk",
    }).onDelete("cascade"),
  ],
);

export const campaignParticipants = pgTable(
  "campaign_participants",
  {
    id: uuid().defaultRandom().primaryKey().notNull(),
    campaignId: uuid("campaign_id").notNull(),
    userId: text("user_id").notNull(),
    role: participantRole().notNull(),
    status: participantStatus().notNull(),
    createdAt: timestamp("created_at", { mode: "string" }).defaultNow().notNull(),
    updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().notNull(),
  },
  (table) => [
    foreignKey({
      columns: [table.campaignId],
      foreignColumns: [campaigns.id],
      name: "campaign_participants_campaign_id_campaigns_id_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [table.userId],
      foreignColumns: [user.id],
      name: "campaign_participants_user_id_user_id_fk",
    }).onDelete("cascade"),
  ],
);

export const games = pgTable(
  "games",
  {
    id: uuid().defaultRandom().primaryKey().notNull(),
    ownerId: text("owner_id").notNull(),
    campaignId: uuid("campaign_id"),
    gameSystemId: integer("game_system_id").notNull(),
    name: varchar({ length: 255 }).notNull(),
    dateTime: timestamp("date_time", { mode: "string" }).notNull(),
    description: text().notNull(),
    expectedDuration: real("expected_duration").notNull(),
    price: real(),
    language: varchar({ length: 50 }).notNull(),
    location: jsonb().notNull(),
    status: gameStatus().default("scheduled").notNull(),
    minimumRequirements: jsonb("minimum_requirements"),
    visibility: visibility().default("public").notNull(),
    safetyRules: jsonb("safety_rules"),
    createdAt: timestamp("created_at", { mode: "string" }).defaultNow().notNull(),
    updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().notNull(),
  },
  (table) => [
    foreignKey({
      columns: [table.ownerId],
      foreignColumns: [user.id],
      name: "games_owner_id_user_id_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [table.campaignId],
      foreignColumns: [campaigns.id],
      name: "games_campaign_id_campaigns_id_fk",
    }).onDelete("set null"),
    foreignKey({
      columns: [table.gameSystemId],
      foreignColumns: [gameSystems.id],
      name: "games_game_system_id_game_systems_id_fk",
    }).onDelete("cascade"),
  ],
);

export const gameApplications = pgTable(
  "game_applications",
  {
    id: uuid().defaultRandom().primaryKey().notNull(),
    gameId: uuid("game_id").notNull(),
    userId: text("user_id").notNull(),
    status: applicationStatus().default("pending").notNull(),
    createdAt: timestamp("created_at", { mode: "string" }).defaultNow().notNull(),
    updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().notNull(),
  },
  (table) => [
    foreignKey({
      columns: [table.gameId],
      foreignColumns: [games.id],
      name: "game_applications_game_id_games_id_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [table.userId],
      foreignColumns: [user.id],
      name: "game_applications_user_id_user_id_fk",
    }).onDelete("cascade"),
  ],
);

export const gameParticipants = pgTable(
  "game_participants",
  {
    id: uuid().defaultRandom().primaryKey().notNull(),
    gameId: uuid("game_id").notNull(),
    userId: text("user_id").notNull(),
    role: participantRole().default("player").notNull(),
    status: participantStatus().default("pending").notNull(),
    createdAt: timestamp("created_at", { mode: "string" }).defaultNow().notNull(),
    updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().notNull(),
  },
  (table) => [
    foreignKey({
      columns: [table.gameId],
      foreignColumns: [games.id],
      name: "game_participants_game_id_games_id_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [table.userId],
      foreignColumns: [user.id],
      name: "game_participants_user_id_user_id_fk",
    }).onDelete("cascade"),
  ],
);

export const gmReviews = pgTable(
  "gm_reviews",
  {
    id: text().primaryKey().notNull(),
    reviewerId: text("reviewer_id").notNull(),
    gmId: text("gm_id").notNull(),
    rating: integer().notNull(),
    selectedStrengths: jsonb("selected_strengths").default([]),
    comment: text(),
    createdAt: timestamp("created_at", { mode: "string" }).notNull(),
    updatedAt: timestamp("updated_at", { mode: "string" }).notNull(),
  },
  (table) => [
    foreignKey({
      columns: [table.reviewerId],
      foreignColumns: [user.id],
      name: "gm_reviews_reviewer_id_user_id_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [table.gmId],
      foreignColumns: [user.id],
      name: "gm_reviews_gm_id_user_id_fk",
    }).onDelete("cascade"),
  ],
);

export const userFollows = pgTable(
  "user_follows",
  {
    id: text().primaryKey().notNull(),
    followerId: text("follower_id").notNull(),
    followingId: text("following_id").notNull(),
    createdAt: timestamp("created_at", { mode: "string" }).notNull(),
  },
  (table) => [
    foreignKey({
      columns: [table.followerId],
      foreignColumns: [user.id],
      name: "user_follows_follower_id_user_id_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [table.followingId],
      foreignColumns: [user.id],
      name: "user_follows_following_id_user_id_fk",
    }).onDelete("cascade"),
  ],
);

export const socialAuditLogs = pgTable(
  "social_audit_logs",
  {
    id: text().primaryKey().notNull(),
    actorUserId: text("actor_user_id"),
    targetUserId: text("target_user_id"),
    action: socialAction().notNull(),
    metadata: jsonb(),
    createdAt: timestamp("created_at", { mode: "string" }).defaultNow().notNull(),
  },
  (table) => [
    index("social_audit_logs_action_idx").using(
      "btree",
      table.action.asc().nullsLast().op("enum_ops"),
    ),
    index("social_audit_logs_actor_idx").using(
      "btree",
      table.actorUserId.asc().nullsLast().op("text_ops"),
    ),
    index("social_audit_logs_target_idx").using(
      "btree",
      table.targetUserId.asc().nullsLast().op("text_ops"),
    ),
    foreignKey({
      columns: [table.actorUserId],
      foreignColumns: [user.id],
      name: "social_audit_logs_actor_user_id_user_id_fk",
    }).onDelete("set null"),
    foreignKey({
      columns: [table.targetUserId],
      foreignColumns: [user.id],
      name: "social_audit_logs_target_user_id_user_id_fk",
    }).onDelete("set null"),
  ],
);

export const userBlocks = pgTable(
  "user_blocks",
  {
    id: text().primaryKey().notNull(),
    blockerId: text("blocker_id").notNull(),
    blockeeId: text("blockee_id").notNull(),
    reason: text(),
    createdAt: timestamp("created_at", { mode: "string" }).defaultNow().notNull(),
  },
  (table) => [
    index("user_blocks_blockee_idx").using(
      "btree",
      table.blockeeId.asc().nullsLast().op("text_ops"),
    ),
    index("user_blocks_blocker_idx").using(
      "btree",
      table.blockerId.asc().nullsLast().op("text_ops"),
    ),
    foreignKey({
      columns: [table.blockerId],
      foreignColumns: [user.id],
      name: "user_blocks_blocker_id_user_id_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [table.blockeeId],
      foreignColumns: [user.id],
      name: "user_blocks_blockee_id_user_id_fk",
    }).onDelete("cascade"),
    unique("user_blocks_unique").on(table.blockerId, table.blockeeId),
  ],
);

export const user = pgTable(
  "user",
  {
    id: text().primaryKey().notNull(),
    name: text().notNull(),
    email: text().notNull(),
    emailVerified: boolean("email_verified").notNull(),
    image: text(),
    createdAt: timestamp("created_at", { mode: "string" }).notNull(),
    updatedAt: timestamp("updated_at", { mode: "string" }).notNull(),
    profileComplete: boolean("profile_complete").notNull(),
    gender: text(),
    pronouns: text(),
    phone: text(),
    privacySettings: text("privacy_settings"),
    profileVersion: integer("profile_version").notNull(),
    profileUpdatedAt: timestamp("profile_updated_at", { mode: "string" }),
    city: text(),
    country: text(),
    languages: jsonb().default([]),
    identityTags: jsonb("identity_tags").default([]),
    preferredGameThemes: jsonb("preferred_game_themes").default([]),
    overallExperienceLevel: experienceLevel("overall_experience_level"),
    isGm: boolean("is_gm").default(false),
    gamesHosted: integer("games_hosted").default(0),
    averageResponseTime: integer("average_response_time"),
    responseRate: integer("response_rate").default(0),
    gmStyle: text("gm_style"),
    gmRating: integer("gm_rating"),
    calendarAvailability: jsonb("calendar_availability").default({
      friday: [
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
      ],
      monday: [
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
      ],
      sunday: [
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
      ],
      tuesday: [
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
      ],
      saturday: [
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
      ],
      thursday: [
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
      ],
      wednesday: [
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
      ],
    }),
    uploadedAvatarPath: text("uploaded_avatar_path"),
  },
  (table) => [unique("user_email_unique").on(table.email)],
);

export const verification = pgTable("verification", {
  id: text().primaryKey().notNull(),
  identifier: text().notNull(),
  value: text().notNull(),
  expiresAt: timestamp("expires_at", { mode: "string" }).notNull(),
  createdAt: timestamp("created_at", { mode: "string" }),
  updatedAt: timestamp("updated_at", { mode: "string" }),
});

export const account = pgTable(
  "account",
  {
    id: text().primaryKey().notNull(),
    accountId: text("account_id").notNull(),
    providerId: text("provider_id").notNull(),
    userId: text("user_id").notNull(),
    accessToken: text("access_token"),
    refreshToken: text("refresh_token"),
    idToken: text("id_token"),
    accessTokenExpiresAt: timestamp("access_token_expires_at", { mode: "string" }),
    refreshTokenExpiresAt: timestamp("refresh_token_expires_at", { mode: "string" }),
    scope: text(),
    password: text(),
    createdAt: timestamp("created_at", { mode: "string" }).notNull(),
    updatedAt: timestamp("updated_at", { mode: "string" }).notNull(),
  },
  (table) => [
    foreignKey({
      columns: [table.userId],
      foreignColumns: [user.id],
      name: "account_user_id_user_id_fk",
    }).onDelete("cascade"),
  ],
);

export const session = pgTable(
  "session",
  {
    id: text().primaryKey().notNull(),
    expiresAt: timestamp("expires_at", { mode: "string" }).notNull(),
    token: text().notNull(),
    createdAt: timestamp("created_at", { mode: "string" }).notNull(),
    updatedAt: timestamp("updated_at", { mode: "string" }).notNull(),
    ipAddress: text("ip_address"),
    userAgent: text("user_agent"),
    userId: text("user_id").notNull(),
  },
  (table) => [
    foreignKey({
      columns: [table.userId],
      foreignColumns: [user.id],
      name: "session_user_id_user_id_fk",
    }).onDelete("cascade"),
    unique("session_token_unique").on(table.token),
  ],
);

export const gameSystems = pgTable(
  "game_systems",
  {
    id: serial().primaryKey().notNull(),
    name: varchar({ length: 255 }).notNull(),
    slug: varchar({ length: 255 }),
    description: text(),
    images: text().array(),
    minPlayers: integer("min_players"),
    maxPlayers: integer("max_players"),
    optimalPlayers: integer("optimal_players"),
    averagePlayTime: integer("average_play_time"),
    ageRating: varchar("age_rating", { length: 50 }),
    complexityRating: varchar("complexity_rating", { length: 50 }),
    yearReleased: integer("year_released"),
    createdAt: timestamp("created_at", { mode: "string" }).defaultNow().notNull(),
    updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().notNull(),
  },
  (table) => [
    unique("game_systems_name_unique").on(table.name),
    unique("game_systems_slug_unique").on(table.slug),
  ],
);

export const gameSystemCategories = pgTable(
  "game_system_categories",
  {
    id: serial().primaryKey().notNull(),
    name: varchar({ length: 255 }).notNull(),
    description: text(),
  },
  (table) => [unique("game_system_categories_name_unique").on(table.name)],
);

export const gameSystemMechanics = pgTable(
  "game_system_mechanics",
  {
    id: serial().primaryKey().notNull(),
    name: varchar({ length: 255 }).notNull(),
    description: text(),
  },
  (table) => [unique("game_system_mechanics_name_unique").on(table.name)],
);

export const events = pgTable(
  "events",
  {
    id: uuid().defaultRandom().primaryKey().notNull(),
    createdAt: timestamp("created_at", { mode: "string" }).defaultNow().notNull(),
    updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().notNull(),
    name: varchar({ length: 255 }).notNull(),
    slug: varchar({ length: 255 }).notNull(),
    description: text(),
    shortDescription: varchar("short_description", { length: 500 }),
    type: eventType().default("tournament").notNull(),
    status: eventStatus().default("draft").notNull(),
    venueName: varchar("venue_name", { length: 255 }),
    venueAddress: text("venue_address"),
    city: varchar({ length: 100 }),
    country: varchar({ length: 50 }),
    postalCode: varchar("postal_code", { length: 10 }),
    locationNotes: text("location_notes"),
    startDate: date("start_date").notNull(),
    endDate: date("end_date").notNull(),
    registrationOpensAt: timestamp("registration_opens_at", { mode: "string" }),
    registrationClosesAt: timestamp("registration_closes_at", { mode: "string" }),
    registrationType: registrationType("registration_type").default("team").notNull(),
    maxTeams: integer("max_teams"),
    maxParticipants: integer("max_participants"),
    minPlayersPerTeam: integer("min_players_per_team").default(7),
    maxPlayersPerTeam: integer("max_players_per_team").default(21),
    teamRegistrationFee: integer("team_registration_fee").default(0),
    individualRegistrationFee: integer("individual_registration_fee").default(0),
    earlyBirdDiscount: integer("early_bird_discount").default(0),
    earlyBirdDeadline: timestamp("early_bird_deadline", { mode: "string" }),
    organizerId: text("organizer_id").notNull(),
    contactEmail: varchar("contact_email", { length: 255 }),
    contactPhone: varchar("contact_phone", { length: 20 }),
    rules: jsonb(),
    schedule: jsonb(),
    divisions: jsonb(),
    amenities: jsonb(),
    requirements: jsonb(),
    logoUrl: text("logo_url"),
    bannerUrl: text("banner_url"),
    isPublic: boolean("is_public").default(false).notNull(),
    isFeatured: boolean("is_featured").default(false).notNull(),
    metadata: jsonb(),
  },
  (table) => [
    foreignKey({
      columns: [table.organizerId],
      foreignColumns: [user.id],
      name: "events_organizer_id_user_id_fk",
    }),
    unique("events_slug_unique").on(table.slug),
  ],
);

export const eventAnnouncements = pgTable(
  "event_announcements",
  {
    id: uuid().defaultRandom().primaryKey().notNull(),
    createdAt: timestamp("created_at", { mode: "string" }).defaultNow().notNull(),
    updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().notNull(),
    eventId: uuid("event_id").notNull(),
    authorId: text("author_id").notNull(),
    title: varchar({ length: 255 }).notNull(),
    content: text().notNull(),
    isPinned: boolean("is_pinned").default(false).notNull(),
    isPublished: boolean("is_published").default(true).notNull(),
    visibility: varchar({ length: 50 }).default("all").notNull(),
  },
  (table) => [
    foreignKey({
      columns: [table.eventId],
      foreignColumns: [events.id],
      name: "event_announcements_event_id_events_id_fk",
    }),
    foreignKey({
      columns: [table.authorId],
      foreignColumns: [user.id],
      name: "event_announcements_author_id_user_id_fk",
    }),
  ],
);

export const eventRegistrations = pgTable(
  "event_registrations",
  {
    id: uuid().defaultRandom().primaryKey().notNull(),
    createdAt: timestamp("created_at", { mode: "string" }).defaultNow().notNull(),
    updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().notNull(),
    eventId: uuid("event_id").notNull(),
    teamId: text("team_id"),
    userId: text("user_id").notNull(),
    registrationType: registrationType("registration_type").notNull(),
    division: varchar({ length: 100 }),
    status: varchar({ length: 50 }).default("pending").notNull(),
    paymentStatus: varchar("payment_status", { length: 50 }).default("pending").notNull(),
    paymentId: text("payment_id"),
    roster: jsonb(),
    notes: text(),
    internalNotes: text("internal_notes"),
    confirmedAt: timestamp("confirmed_at", { mode: "string" }),
    cancelledAt: timestamp("cancelled_at", { mode: "string" }),
  },
  (table) => [
    foreignKey({
      columns: [table.eventId],
      foreignColumns: [events.id],
      name: "event_registrations_event_id_events_id_fk",
    }),
    foreignKey({
      columns: [table.teamId],
      foreignColumns: [teams.id],
      name: "event_registrations_team_id_teams_id_fk",
    }),
    foreignKey({
      columns: [table.userId],
      foreignColumns: [user.id],
      name: "event_registrations_user_id_user_id_fk",
    }),
  ],
);

export const teams = pgTable(
  "teams",
  {
    id: text().primaryKey().notNull(),
    name: varchar({ length: 255 }).notNull(),
    slug: varchar({ length: 255 }).notNull(),
    description: text(),
    city: varchar({ length: 255 }),
    country: varchar({ length: 3 }),
    logoUrl: text("logo_url"),
    primaryColor: varchar("primary_color", { length: 7 }),
    secondaryColor: varchar("secondary_color", { length: 7 }),
    foundedYear: varchar("founded_year", { length: 4 }),
    website: text(),
    socialLinks: text("social_links"),
    isActive: text("is_active").default("true").notNull(),
    createdAt: timestamp("created_at", { withTimezone: true, mode: "string" })
      .defaultNow()
      .notNull(),
    updatedAt: timestamp("updated_at", { withTimezone: true, mode: "string" })
      .defaultNow()
      .notNull(),
    createdBy: text("created_by").notNull(),
  },
  (table) => [
    index("teams_created_by_idx").using(
      "btree",
      table.createdBy.asc().nullsLast().op("text_ops"),
    ),
    index("teams_is_active_idx").using(
      "btree",
      table.isActive.asc().nullsLast().op("text_ops"),
    ),
    uniqueIndex("teams_slug_idx").using(
      "btree",
      table.slug.asc().nullsLast().op("text_ops"),
    ),
    foreignKey({
      columns: [table.createdBy],
      foreignColumns: [user.id],
      name: "teams_created_by_user_id_fk",
    }),
    unique("teams_slug_unique").on(table.slug),
  ],
);

export const memberships = pgTable(
  "memberships",
  {
    id: varchar({ length: 255 }).primaryKey().notNull(),
    userId: varchar("user_id", { length: 255 }).notNull(),
    membershipTypeId: varchar("membership_type_id", { length: 255 }).notNull(),
    startDate: date("start_date").notNull(),
    endDate: date("end_date").notNull(),
    status: varchar({ length: 50 }).default("active").notNull(),
    paymentProvider: varchar("payment_provider", { length: 100 }),
    paymentId: varchar("payment_id", { length: 255 }),
    metadata: jsonb(),
    createdAt: timestamp("created_at", { mode: "string" }).defaultNow().notNull(),
    updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().notNull(),
  },
  (table) => [
    index("memberships_end_date_idx").using(
      "btree",
      table.endDate.asc().nullsLast().op("date_ops"),
    ),
    index("memberships_payment_id_idx").using(
      "btree",
      table.paymentId.asc().nullsLast().op("text_ops"),
    ),
    index("memberships_status_idx").using(
      "btree",
      table.status.asc().nullsLast().op("text_ops"),
    ),
    index("memberships_user_id_idx").using(
      "btree",
      table.userId.asc().nullsLast().op("text_ops"),
    ),
    foreignKey({
      columns: [table.userId],
      foreignColumns: [user.id],
      name: "memberships_user_id_user_id_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [table.membershipTypeId],
      foreignColumns: [membershipTypes.id],
      name: "memberships_membership_type_id_membership_types_id_fk",
    }),
  ],
);

export const membershipTypes = pgTable(
  "membership_types",
  {
    id: varchar({ length: 255 }).primaryKey().notNull(),
    name: varchar({ length: 255 }).notNull(),
    description: varchar({ length: 1000 }),
    priceCents: integer("price_cents").notNull(),
    durationMonths: integer("duration_months").notNull(),
    status: varchar({ length: 50 }).default("active").notNull(),
    metadata: jsonb(),
    createdAt: timestamp("created_at", { mode: "string" }).defaultNow().notNull(),
    updatedAt: timestamp("updated_at", { mode: "string" }).defaultNow().notNull(),
  },
  (table) => [
    index("membership_types_status_idx").using(
      "btree",
      table.status.asc().nullsLast().op("text_ops"),
    ),
  ],
);

export const teamMembers = pgTable(
  "team_members",
  {
    id: text().primaryKey().notNull(),
    teamId: text("team_id").notNull(),
    userId: text("user_id").notNull(),
    role: teamMemberRole().default("player").notNull(),
    status: teamMemberStatus().default("pending").notNull(),
    jerseyNumber: varchar("jersey_number", { length: 3 }),
    position: varchar({ length: 50 }),
    joinedAt: timestamp("joined_at", { withTimezone: true, mode: "string" })
      .defaultNow()
      .notNull(),
    leftAt: timestamp("left_at", { withTimezone: true, mode: "string" }),
    invitedBy: text("invited_by"),
    notes: text(),
  },
  (table) => [
    uniqueIndex("team_members_active_user_idx")
      .using("btree", table.userId.asc().nullsLast().op("text_ops"))
      .where(sql`(status = 'active'::team_member_status)`),
    index("team_members_team_status_idx").using(
      "btree",
      table.teamId.asc().nullsLast().op("text_ops"),
      table.status.asc().nullsLast().op("enum_ops"),
    ),
    uniqueIndex("team_members_team_user_idx").using(
      "btree",
      table.teamId.asc().nullsLast().op("text_ops"),
      table.userId.asc().nullsLast().op("text_ops"),
    ),
    index("team_members_user_status_idx").using(
      "btree",
      table.userId.asc().nullsLast().op("enum_ops"),
      table.status.asc().nullsLast().op("text_ops"),
    ),
    foreignKey({
      columns: [table.teamId],
      foreignColumns: [teams.id],
      name: "team_members_team_id_teams_id_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [table.userId],
      foreignColumns: [user.id],
      name: "team_members_user_id_user_id_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [table.invitedBy],
      foreignColumns: [user.id],
      name: "team_members_invited_by_user_id_fk",
    }),
  ],
);

export const userTags = pgTable(
  "user_tags",
  {
    id: text().primaryKey().notNull(),
    userId: text("user_id").notNull(),
    tagId: text("tag_id").notNull(),
    assignedBy: text("assigned_by"),
    assignedAt: timestamp("assigned_at", { withTimezone: true, mode: "string" })
      .defaultNow()
      .notNull(),
    expiresAt: timestamp("expires_at", { withTimezone: true, mode: "string" }),
    notes: text(),
  },
  (table) => [
    index("idx_user_tags_expires_at")
      .using("btree", table.expiresAt.asc().nullsLast().op("timestamptz_ops"))
      .where(sql`(expires_at IS NOT NULL)`),
    index("idx_user_tags_tag_id").using(
      "btree",
      table.tagId.asc().nullsLast().op("text_ops"),
    ),
    index("idx_user_tags_unique").using(
      "btree",
      table.userId.asc().nullsLast().op("text_ops"),
      table.tagId.asc().nullsLast().op("text_ops"),
    ),
    index("idx_user_tags_user_id").using(
      "btree",
      table.userId.asc().nullsLast().op("text_ops"),
    ),
    foreignKey({
      columns: [table.userId],
      foreignColumns: [user.id],
      name: "user_tags_user_id_user_id_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [table.tagId],
      foreignColumns: [tags.id],
      name: "user_tags_tag_id_tags_id_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [table.assignedBy],
      foreignColumns: [user.id],
      name: "user_tags_assigned_by_user_id_fk",
    }),
  ],
);

export const roles = pgTable(
  "roles",
  {
    id: text().primaryKey().notNull(),
    name: text().notNull(),
    description: text(),
    permissions: jsonb().default({}).notNull(),
    createdAt: timestamp("created_at", { withTimezone: true, mode: "string" })
      .defaultNow()
      .notNull(),
    updatedAt: timestamp("updated_at", { withTimezone: true, mode: "string" })
      .defaultNow()
      .notNull(),
  },
  (table) => [unique("roles_name_unique").on(table.name)],
);

export const tags = pgTable(
  "tags",
  {
    id: text().primaryKey().notNull(),
    name: text().notNull(),
    category: text().notNull(),
    description: text(),
    color: text(),
    icon: text(),
    isActive: boolean("is_active").default(true),
    createdAt: timestamp("created_at", { withTimezone: true, mode: "string" })
      .defaultNow()
      .notNull(),
    updatedAt: timestamp("updated_at", { withTimezone: true, mode: "string" })
      .defaultNow()
      .notNull(),
  },
  (table) => [unique("tags_name_unique").on(table.name)],
);

export const userRoles = pgTable(
  "user_roles",
  {
    id: text().primaryKey().notNull(),
    userId: text("user_id").notNull(),
    roleId: text("role_id").notNull(),
    teamId: text("team_id"),
    eventId: text("event_id"),
    assignedBy: text("assigned_by").notNull(),
    assignedAt: timestamp("assigned_at", { withTimezone: true, mode: "string" })
      .defaultNow()
      .notNull(),
    expiresAt: timestamp("expires_at", { withTimezone: true, mode: "string" }),
    notes: text(),
  },
  (table) => [
    index("idx_user_roles_event_id")
      .using("btree", table.eventId.asc().nullsLast().op("text_ops"))
      .where(sql`(event_id IS NOT NULL)`),
    index("idx_user_roles_team_id")
      .using("btree", table.teamId.asc().nullsLast().op("text_ops"))
      .where(sql`(team_id IS NOT NULL)`),
    index("idx_user_roles_unique").using(
      "btree",
      table.userId.asc().nullsLast().op("text_ops"),
      table.roleId.asc().nullsLast().op("text_ops"),
      table.teamId.asc().nullsLast().op("text_ops"),
      table.eventId.asc().nullsLast().op("text_ops"),
    ),
    index("idx_user_roles_user_id").using(
      "btree",
      table.userId.asc().nullsLast().op("text_ops"),
    ),
    foreignKey({
      columns: [table.userId],
      foreignColumns: [user.id],
      name: "user_roles_user_id_user_id_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [table.roleId],
      foreignColumns: [roles.id],
      name: "user_roles_role_id_roles_id_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [table.assignedBy],
      foreignColumns: [user.id],
      name: "user_roles_assigned_by_user_id_fk",
    }),
  ],
);

export const gameSystemToCategory = pgTable(
  "game_system_to_category",
  {
    gameSystemId: integer("game_system_id").notNull(),
    categoryId: integer("category_id").notNull(),
  },
  (table) => [
    foreignKey({
      columns: [table.gameSystemId],
      foreignColumns: [gameSystems.id],
      name: "game_system_to_category_game_system_id_game_systems_id_fk",
    }),
    foreignKey({
      columns: [table.categoryId],
      foreignColumns: [gameSystemCategories.id],
      name: "game_system_to_category_category_id_game_system_categories_id_f",
    }),
    primaryKey({
      columns: [table.gameSystemId, table.categoryId],
      name: "game_system_to_category_game_system_id_category_id_pk",
    }),
  ],
);

export const gameSystemToMechanics = pgTable(
  "game_system_to_mechanics",
  {
    gameSystemId: integer("game_system_id").notNull(),
    mechanicsId: integer("mechanics_id").notNull(),
  },
  (table) => [
    foreignKey({
      columns: [table.gameSystemId],
      foreignColumns: [gameSystems.id],
      name: "game_system_to_mechanics_game_system_id_game_systems_id_fk",
    }),
    foreignKey({
      columns: [table.mechanicsId],
      foreignColumns: [gameSystemMechanics.id],
      name: "game_system_to_mechanics_mechanics_id_game_system_mechanics_id_",
    }),
    primaryKey({
      columns: [table.gameSystemId, table.mechanicsId],
      name: "game_system_to_mechanics_game_system_id_mechanics_id_pk",
    }),
  ],
);

export const userGameSystemPreferences = pgTable(
  "user_game_system_preferences",
  {
    userId: text("user_id").notNull(),
    gameSystemId: integer("game_system_id").notNull(),
    preferenceType: text("preference_type").notNull(),
    createdAt: timestamp("created_at", { mode: "string" }).defaultNow().notNull(),
  },
  (table) => [
    foreignKey({
      columns: [table.userId],
      foreignColumns: [user.id],
      name: "user_game_system_preferences_user_id_user_id_fk",
    }),
    foreignKey({
      columns: [table.gameSystemId],
      foreignColumns: [gameSystems.id],
      name: "user_game_system_preferences_game_system_id_game_systems_id_fk",
    }),
    primaryKey({
      columns: [table.userId, table.gameSystemId],
      name: "user_game_system_preferences_user_id_game_system_id_pk",
    }),
  ],
);
